<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>33聊天室</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Long+Cang&display=swap" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap');
        /* --- 1. 全局与主题 --- */
        :root {
            --theme-color-1: #F4E8DD; /* 奶油杏 */
            --theme-color-2: #EDD4D8; /* 柔粉 */
            --theme-color-3: #CCD4CC; /* 灰绿 */
            --theme-color-4: #B5BFCF; /* 雾蓝 */
            /* --- 颜色修改 --- */
            --accent-color: #A7C7E7; /* 强调色-浅蓝 */
            --ui-button-color: var(--text-color-light); /* 按钮默认颜色 */
            --ui-button-active-color: var(--accent-color); /* 按钮激活颜色 */
            --accent-color-deep: #88A9D1; /* 深一点的浅蓝 */
            /* --- 颜色修改结束 --- */
            --text-color-dark: #5D534A; /* 深棕 */
            --text-color-medium: #7E746D;
            --text-color-light: #A39B94;
            --text-color-white: #FFFFFF;
            --bg-main: #F7F8FA; /* 改为柔和的浅灰色背景 */
            --bg-light: rgba(255, 255, 255, 0.7);
            --border-color: rgba(0, 0, 0, 0.08);
            --shadow-light: 0 4px 15px rgba(0, 0, 0, 0.05);
            --shadow-medium: 0 6px 20px rgba(0, 0, 0, 0.1);
            --font-main: "SimSun", "宋体", serif; /* 全局字体，默认楷体 */
            --font-title: "Kaiti", "楷体", serif;
            --font-bubble: "LXGW WenKai Screen", "Kaiti", "楷体", serif; /* 气泡字体，默认楷体 */
            --font-inner-voice: "Long Cang", cursive; /* 心声字体，默认龙藏体 */
            --font-essay: "Long Cang", cursive; /* 随笔字体，默认龙藏体 */
            --font-bubble-size: 0.95rem; /* 使用CSS变量 */
            --unread-bg: #ff4d4d;
            --red-packet-red: #DB5445;
            --red-packet-gold: #F8D69A;
            
            /* --- 气泡主题化变量 --- */
            --player-bubble-bg: var(--accent-color); /* 我的消息背景色 (A类气泡) */
            --friend-bubble-bg: var(--text-color-white);  /* 好友消息背景色 (A类气泡) */
            --player-bubble-text-color: var(--text-color-dark); /* 我的消息字体颜色 */
            --friend-bubble-text-color: var(--text-color-dark);  /* 好友消息字体颜色 */
        }
        :root {
            /* ... existing variables ... */
            --ui-bg-color: rgba(255, 255, 255, 0.5); /* 页面UI背景色 */
            --ui-texture-image: none; /* UI纹理图片 */
        }
        @keyframes paw-pulse { /* 新增 */
            0% { transform: scale(1); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1); }
        }
/* --- 开屏动画样式 (参考样式) --- */
#splash-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-main);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    transition: opacity 0.5s ease-out;
}
#splash-screen.hidden {
    opacity: 0;
    pointer-events: none;
}
.splash-logo {
    font-family: 'ZCOOL KuaiLe', cursive; /* 使用参考文件字体 */
    font-size: 36px; /* 参考文件字体大小 */
    color: var(--accent-color-2); /* 使用参考文件颜色风格，映射到当前主题 */
    margin-bottom: 20px;
}
.splash-loader {
    width: 50px;
    height: 50px;
    border: 3px solid var(--theme-color-2); /* 边框颜色映射 */
    border-top-color: var(--accent-color); /* 顶部颜色映射 */
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* 移除移动端点击高亮 */
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: var(--font-main);
            color: var(--text-color-dark);
        }

    body {
        background: var(--bg-main);
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: var(--font-main); /* 应用全局字体 */
    }

        #app-container {
            width: 100%;
            height: 100%;
            max-width: 500px;
            background-color: var(--bg-light);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: var(--shadow-medium);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #main-content {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            display: flex;
        }

        /* --- 2. 页面切换与布局 --- */
        .page {
            display: none;
            flex-grow: 1;
            flex-direction: column;
            overflow: hidden;
            animation: fadeIn 0.4s ease-in-out;
        }
        .page.active {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        .page-header {
            padding: 15px 10px;
            display: grid;
            grid-template-columns: 50px 1fr auto; /* 调整右侧为自适应宽度 */
            align-items: center;
            background-color: var(--ui-bg-color);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative;
            overflow: hidden; /* 隐藏溢出的噪点 */
        }
        .page-header h1 {
            font-family: var(--font-title);
            font-size: 1.3rem; /* 减小字体大小 */
            /* 移除绝对定位和变换，由父级wrapper控制 */
        }
        .page-header .header-icon {
            font-size: 1.3rem;
            cursor: pointer;
            color: var(--ui-button-color);
            z-index: 2;
        }

        .page-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            -webkit-overflow-scrolling: touch;
        }
        .page-content::-webkit-scrollbar {
            width: 4px;
        }
        .page-content::-webkit-scrollbar-thumb {
            background: var(--theme-color-4);
            border-radius: 2px;
        }
        
        /* --- 3. 底部导航栏 --- */
        #bottom-nav {
            display: flex;
            width: 100%;
            background-color: var(--ui-bg-color);
            border-top: 1px solid var(--border-color);
            padding: 8px 0;
            flex-shrink: 0;
            position: relative; /* 为噪点做准备 */
            overflow: hidden; /* 隐藏溢出的噪点 */
        }
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--ui-button-color);
            transition: color 0.3s, transform 0.3s;
        }
        .nav-item:hover {
            color: var(--accent-color);
        }
        .nav-item.active {
            color: var(--ui-button-active-color);
            transform: scale(1.1);
        }
        .nav-item i {
            font-size: 1.4rem;
            margin-bottom: 4px;
        }
        .nav-item span {
            font-size: 0.75rem;
        }

        /* --- 4. 消息列表页面 --- */
        #page-messages .page-header {
            padding: 10px 15px;
        }
        #my-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            cursor: pointer;
            border: 2px solid var(--text-color-white);
            box-shadow: var(--shadow-light);
        }
        .message-list {
            list-style: none;
            padding: 0;
        }
        .message-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-bottom: 1px solid var(--border-color);
        }
        .message-item:hover {
            background-color: rgba(0,0,0,0.03);
        }
        .item-avatar {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            margin-right: 15px;
            background-color: var(--theme-color-3);
            flex-shrink: 0;
        }
        .item-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .item-name {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 6px;
        }
        .item-last-msg {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .item-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-left: 10px;
            flex-shrink: 0;
        }
        .item-time {
            font-size: 0.75rem;
            color: var(--text-color-light);
            margin-bottom: 8px;
        }
        .unread-badge {
            background-color: var(--unread-bg);
            color: white;
            font-size: 0.7rem;
            min-width: 20px;
            height: 20px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 6px;
        }
        /* --- 4.1 页面头部图标调整 --- */
        #header-link-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.05);
            color: var(--text-color-medium);
            display: flex;
            justify-content: center;
            align-items: center;
            text-decoration: none;
            justify-self: end;
            margin-right: 15px;
            transition: all 0.2s;
        }
        #header-link-btn:hover {
            background-color: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }

        .page-header .header-icon {
            font-size: 1.2rem; /* 缩小图标 */
            padding: 0 10px; /* 调整点击区域 */
        }
        /* 将右侧图标推到最右边 */
        .page-header .header-icon:last-child {
            justify-self: end;
            padding-right: 15px; /* 增加右边距 */
        }
        .header-icon-group {
            display: flex;
            gap: 5px; /* 进一步减小间距 */
            align-items: center;
            justify-self: end;
            padding-right: 10px; /* 向左移动一点 */
        }
        #batch-delete-btn:hover i,
        #batch-delete-btn:active i,
        #page-contacts.selection-mode #batch-delete-btn i {
             color: #e74c3c;
        }
        /* --- 4.2. 底部上移样式 --- */
        #app-container.bottom-offset-active {
            padding-bottom: 30px; /* 为系统导航栏留出空间 */
            height: calc(100% - 30px); /* 相应地调整高度 */
        }
        /* --- 5. 通讯录页面 --- */
        .tabs {
            display: flex;
            justify-content: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-btn {
            padding: 8px 20px;
            cursor: pointer;
            border-radius: 20px;
            background-color: transparent;
            border: 1px solid transparent;
            color: var(--text-color-medium);
            transition: all 0.3s;
            font-family: var(--font-main);
        }
        .tab-btn.active {
            background-color: var(--text-color-white);
            border-color: var(--theme-color-2);
            color: var(--accent-color-deep);
            font-weight: bold;
            box-shadow: var(--shadow-light);
        }
        .contact-section {
            display: none;
        }
        .contact-section.active {
            display: block;
        }
        .contact-list-header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 5px;
            color: var(--text-color-light);
        }
        .sort-btn {
            cursor: pointer;
            font-size: 0.9rem;
        }
        .contact-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .contact-item-avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            object-fit: cover;
            margin-right: 15px;
            background-color: var(--theme-color-4);
        }
        .contact-item-name {
            flex-grow: 1;
            font-size: 1.1rem;
        }
        .contact-info-btn {
            font-size: 1.2rem;
            color: var(--text-color-light);
            cursor: pointer;
            padding: 5px;
        }
        .contact-list .contact-select-checkbox {
            display: none;
            margin-right: 15px;
            width: 20px;
            height: 20px;
            accent-color: var(--accent-color);
        }
        .contact-list.selection-mode .contact-select-checkbox {
            display: block;
        }
        .contact-list.selection-mode .contact-item {
            cursor: pointer;
        }
        .contact-list.selection-mode .contact-info-btn {
            display: none; /* 选择模式下隐藏详情按钮 */
        }

        #contacts-friend-folders .prompt-folder {
            margin-bottom: 8px; /* 减小分组间距 */
        }
        #contacts-friend-folders .prompt-folder-header h3 {
            font-weight: normal; /* 移除分组名称加粗 */
        }

        /* --- 6. 设置页面 --- */
        .settings-list {
            padding-top: 10px;
        }
        .setting-item {
            display: flex;
            align-items: center;
            padding: 18px 15px;
            background-color: var(--text-color-white);
            margin: 0 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .setting-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-light);
        }
        .setting-item i {
            font-size: 1.3rem;
            color: var(--accent-color);
            margin-right: 15px;
            width: 25px;
            text-align: center;
        }
        .setting-item span {
            font-size: 1.1rem;
            flex-grow: 1;
        }
        .setting-item .fa-chevron-right {
            color: var(--text-color-light);
            font-size: 1rem;
        }

        /* --- 7. 聊天页面 --- */
        #page-chat .page-header .header-title {
            max-width: 80%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 1.1rem; /* 缩小字体大小 */
        }
        .header-title-wrapper {
            grid-column: 2 / 3; /* 占据中间栏 */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* 防止内容溢出 */
        }
        .typing-indicator-container {
            font-size: 0.75rem; /* 进一步调小 */
            color: var(--text-color-medium);
            display: none; /* Initially hidden */
            margin-top: 1px; /* 微调与标题的间距 */
        }
        .chat-area {
            flex-grow: 1;
            padding: 20px 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            /* 关键让聊天区域拥有自己的背景，而不是透明 */
            background-color: var(--theme-color-1); 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        /* --- 聊天背景容器 --- */
        #app-container {
            /* ... (保留原有样式) */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed; /* 关键：使背景固定不滚动 */
        }
        
        /* --- 主题设置弹窗内样式 (参考 聊天背景上传.html) --- */
        .theme-settings-modal .form-group {
            margin-bottom: 25px;
        }

        .theme-settings-modal .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--form-label-color, #555);
        }

        .theme-settings-modal .background-upload-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 15px;
            border: 1px dashed var(--border-color);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.5);
        }

        .theme-settings-modal .background-preview {
            width: 150px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            background-color: #e9e9e9;
        }

        .theme-settings-modal .cover-preview {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            background-color: #e9e9e9;
        }
        
        .theme-settings-modal .color-input-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .theme-settings-modal .color-input-group input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .theme-settings-modal .color-input-group input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .theme-settings-modal .color-input-group input[type="color"]::-webkit-color-swatch { border: 2px solid var(--border-color); border-radius: 8px; }

        .message-row {
            display: flex;
            max-width: 80%;
            width: -webkit-fit-content;
            width: -moz-fit-content;
            width: fit-content;
        }
        .message-row.sent {
            align-self: flex-end;
            flex-direction: row-reverse;
        }
        .message-row.received {
            align-self: flex-start;
        }
        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            background-color: var(--theme-color-3);
            flex-shrink: 0;
        }
        .message-avatar.group-avatar-style {
            border-radius: 12px; /* 方形圆角 */
        }
        .message-row.sent .message-avatar {
            margin-left: 10px;
        }
        .message-row.received .message-avatar {
            margin-right: 10px;
        }
        .message-content {
            display: flex;
            flex-direction: column;
        }
        .message-row.sent .message-content {
            align-items: flex-end;
        }
        .message-row.received .message-content {
            align-items: flex-start;
        }
        .message-name {
            font-size: 0.8rem;
            color: var(--text-color-light);
            margin-bottom: 5px;
            padding: 0 5px;
        }
    .bubble {
        /* --- 核心修改：禁止用户选择文本 --- */
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        /* --- 修改结束 --- */

        padding: 8px 12px;
        border-radius: 16px;
        word-break: break-word;
        white-space: pre-wrap; /* 新增：让换行符生效 */
        font-family: var(--font-bubble); /* 应用气泡字体 */
        font-size: var(--font-bubble-size, 0.95rem); /* 使用CSS变量 */
        line-height: 1.4;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        border: none; /* 移除默认边框，由具体样式控制 */
    }
        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        /* --- 默认气泡样式 (A类, 边框变色) --- */
        #app-container.app-bubble-style-default .bubble {
            background: white; /* 固定背景为白色 */
            color: var(--text-color-dark); /* 固定文字颜色为深色 */
        }
        #app-container.app-bubble-style-default .bubble.received {
            border: 1px solid var(--friend-bubble-bg); /* 边框颜色由变量控制 */
            border-top-left-radius: 5px;
        }
        #app-container.app-bubble-style-default .bubble.sent {
            border: 1px solid var(--player-bubble-bg); /* 边框颜色由变量控制 */
            border-top-right-radius: 5px;
        }
        #app-container.app-bubble-style-default .message-row.sent .quote-block {
            background-color: rgba(0, 0, 0, 0.04);
            border-color: var(--player-bubble-bg); 
            color: var(--text-color-dark);
        }
        #app-container.app-bubble-style-default .message-row.received .quote-block {
            background-color: rgba(0, 0, 0, 0.04);
            border-color: var(--friend-bubble-bg);
            color: var(--text-color-dark);
        }
        #app-container.app-bubble-style-default .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        #app-container.app-bubble-style-default .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }


        /* --- 立体3D气泡样式 (A类) --- */
        #app-container.app-bubble-style-3d .bubble {
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            border-bottom-width: 3px;
            border-bottom-style: solid;
        }
        #app-container.app-bubble-style-3d .bubble.received {
            background: var(--friend-bubble-bg);
            color: var(--friend-bubble-text-color);
            border-color: rgba(0,0,0,0.1);
        }
        #app-container.app-bubble-style-3d .bubble.sent {
            background: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            border-color: rgba(0,0,0,0.2);
        }


        /* --- 可爱条纹 (B类) --- */
        #app-container.app-bubble-style-stripey .bubble {
            background: repeating-linear-gradient(45deg, #FFC0CB, #FFC0CB 10px, #F8C8D1 10px, #F8C8D1 20px);
            color: #a3505f;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #app-container.app-bubble-style-stripey .voice-wave-bar { background-color: #a3505f; }

        /* --- 渐变彩虹 (B类, 动画) --- */
        @keyframes gradientBG {
            0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; }
        }
        #app-container.app-bubble-style-gradient .bubble {
            background: linear-gradient(45deg, #ff9a9e, #fad0c4, #a1c4fd, #c2e9fb, #ff9a9e);
            background-size: 300% 300%;
            animation: gradientBG 8s ease infinite;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        #app-container.app-bubble-style-gradient .voice-wave-bar { background-color: white; }

        /* --- 手绘涂鸦 (B类) --- */
        #app-container.app-bubble-style-doodle .bubble {
            border: 2px solid #333;
            border-radius: 15px 10px 15px 12px;
            background: white;
            color: #333;
            box-shadow: 3px 3px 0px #ccc;
        }
        #app-container.app-bubble-style-doodle .bubble.sent {
            border-radius: 10px 15px 12px 15px;
        }
        #app-container.app-bubble-style-doodle .quote-block {
            border-left-width: 2px;
            border-left-style: dashed;
            background-color: #f7f7f7;
        }
        #app-container.app-bubble-style-doodle .voice-wave-bar { background-color: #333; }

        /* --- 手绘涂鸦2 (B类) --- */
        #app-container.app-bubble-style-hand-drawn .bubble {
            background: white; border: 3px solid #333; position: relative;
            box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.1); font-family: 'Comic Sans MS', cursive;
            color: #333;
        }
        #app-container.app-bubble-style-hand-drawn .bubble.received { border-radius: 0 20px 20px 20px; }
        #app-container.app-bubble-style-hand-drawn .bubble.sent { border-radius: 20px 0 20px 20px; }
        #app-container.app-bubble-style-hand-drawn .voice-wave-bar { background-color: #333; }

        /* --- 拟态 (A类) --- */
        #app-container.app-bubble-style-neumorphic .bubble {
            background: var(--friend-bubble-bg);
            border-radius: 20px;
            box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #fff;
            color: var(--friend-bubble-text-color);
            border: none;
        }
        #app-container.app-bubble-style-neumorphic .bubble.sent {
            background: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
        }
        #app-container.app-bubble-style-neumorphic .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        #app-container.app-bubble-style-neumorphic .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }

        /* --- 柔和条纹 (A类) --- */
        #app-container.app-bubble-style-stripes .bubble {
            background-color: var(--friend-bubble-bg);
            background-image: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.2),
                rgba(255, 255, 255, 0.2) 15px,
                rgba(255, 255, 255, 0.1) 15px,
                rgba(255, 255, 255, 0.1) 30px
            );
            color: var(--friend-bubble-text-color);
            border: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
         #app-container.app-bubble-style-stripes .bubble.sent {
            background-color: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
        }

        /* --- 网格 (A类) - 修复 --- */
        #app-container.app-bubble-style-grid .bubble {
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 15px 15px;
            background-color: color-mix(in srgb, var(--friend-bubble-bg) 80%, transparent); /* 增加透明度 */
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: var(--friend-bubble-text-color);
        }
         #app-container.app-bubble-style-grid .bubble.sent {
            background-color: color-mix(in srgb, var(--player-bubble-bg) 80%, transparent); /* 增加透明度 */
            color: var(--player-bubble-text-color);
        }

        /* --- 可爱风 (A类, 边框变色) --- */
        #app-container.app-bubble-style-cute .bubble {
            background: transparent;
            color: var(--friend-bubble-text-color);
        }
        #app-container.app-bubble-style-cute .bubble.received {
            border: 2px solid var(--friend-bubble-bg);
            border-radius: 25px 25px 25px 5px;
        }
        #app-container.app-bubble-style-cute .bubble.sent {
            border: 2px solid var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            border-radius: 25px 25px 5px 25px;
        }

        /* --- 简约os (A类) --- */
        #app-container.app-bubble-style-simple-os .bubble {
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        #app-container.app-bubble-style-simple-os .bubble.received {
            background-color: color-mix(in srgb, var(--friend-bubble-bg) 60%, transparent); /* 增加不透明度 */
            color: var(--friend-bubble-text-color);
        }
        #app-container.app-bubble-style-simple-os .bubble.sent {
            background-color: color-mix(in srgb, var(--player-bubble-bg) 60%, transparent); /* 增加不透明度 */
            color: var(--player-bubble-text-color);
        }

        /* --- 发光果冻 (B类) --- */
        #app-container.app-bubble-style-glow-jelly .bubble.received {
            background: linear-gradient(135deg, #00c9ff, #92fe9d);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 201, 255, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }
        #app-container.app-bubble-style-glow-jelly .bubble.sent {
            background: linear-gradient(135deg, #ff7e5f, #feb47b);
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 126, 95, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        #app-container.app-bubble-style-glow-jelly .voice-wave-bar { background-color: white; }
        #app-container.app-bubble-style-glow-jelly .bubble.received .voice-wave-bar { background-color: black; }

        /* --- 金属质感 (B类) --- */
        #app-container.app-bubble-style-metal .bubble {
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0); border: 1px solid #a0a0a0;
            color: #333; box-shadow: 0 2px 4px rgba(0,0,0,0.1), inset 0 1px 3px rgba(255,255,255,0.8);
            position: relative; overflow: hidden;
            border-radius: 16px; /* 基础圆角 */
        }
        #app-container.app-bubble-style-metal .bubble.received { border-top-left-radius: 5px; } /* 尖角 */
        #app-container.app-bubble-style-metal .bubble.sent { border-top-right-radius: 5px; } /* 尖角 */

        #app-container.app-bubble-style-metal .bubble::before {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(to bottom right, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 45%, rgba(255,255,255,0) 55%, rgba(255,255,255,0.2) 100%);
            transform: rotate(30deg);
        }
        #app-container.app-bubble-style-metal .voice-wave-bar { background-color: #333; }
        
        /* --- 海洋风 (B类, 带尖角) --- */
        #app-container.app-bubble-style-ocean .bubble {
            background: linear-gradient(160deg, #0077b6, #00b4d8);
            color: white;
            border: 2px solid transparent; /* 匹配可爱风尺寸，但透明 */
            border-radius: 16px;
            position: relative;
        }
        #app-container.app-bubble-style-ocean .bubble.received { border-bottom-left-radius: 5px; }
        #app-container.app-bubble-style-ocean .bubble.sent { border-bottom-right-radius: 5px; }

        /* --- 猫爪风 (B类) --- */
        #app-container.app-bubble-style-paw .bubble.received {
            background: #fce1cb;
            color: #8b5e34;
            border: none;
            border-radius: 20px 20px 20px 5px;
        }
        #app-container.app-bubble-style-paw .bubble.sent {
            background: #cbe7fc;
            color: #345c8b;
            border: none;
            border-radius: 20px 20px 5px 20px;
        }
        #app-container.app-bubble-style-paw .bubble::before {
            content: '🐾';
            position: absolute;
            bottom: -10px;
            font-size: 1.5rem;
            opacity: 0.2;
        }
        #app-container.app-bubble-style-paw .bubble.received::before { left: 10px; }
        #app-container.app-bubble-style-paw .bubble.sent::before { right: 10px; }
        #app-container.app-bubble-style-paw .voice-wave-bar { background-color: #8b5e34; }
        #app-container.app-bubble-style-paw .bubble.sent .voice-wave-bar { background-color: #345c8b; }
        
        /* --- 古风 (B类) --- */
        #app-container.app-bubble-style-ancient .bubble.received {
            background: #f5f0e1; color: #5d4037; border: 2px solid #8d6e63;
            font-family: 'SimSun', serif; box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.1);
        }
        #app-container.app-bubble-style-ancient .bubble.sent {
            background: #d7ccc8; color: #4e342e; border: 2px solid #795548;
            font-family: 'SimSun', serif; box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.1);
        }

        /* --- 国风 (B类) --- */
        #app-container.app-bubble-style-chinese .bubble {
            border-radius: 0;
            clip-path: polygon(0 10px, 10px 0, calc(100% - 10px) 0, 100% 10px, 100% calc(100% - 10px), calc(100% - 10px) 100%, 10px 100%, 0 calc(100% - 10px));
        }
        #app-container.app-bubble-style-chinese .bubble.received {
            background: white; border: 1px solid #c81e1e; color: #c81e1e;
        }
        #app-container.app-bubble-style-chinese .bubble.sent {
            background: #c81e1e; border: 1px solid #f9d56e; color: #f9d56e;
        }
        #app-container.app-bubble-style-chinese .voice-wave-bar { background-color: #f9d56e; }
        #app-container.app-bubble-style-chinese .bubble.received .voice-wave-bar { background-color: #c81e1e; }

        /* --- 拟态2 (B类, 效果固定) - 新增 --- */
        #app-container.app-bubble-style-neumorphic-2 .bubble {
            background: #F0F0F3;
            font-weight: 500;
            color: #888;
            text-shadow: 1px 1px 1px #fff;
            border: 1px solid rgba(0,0,0,0.05);
        }
        #app-container.app-bubble-style-neumorphic-2 .bubble.received {
            border-radius: 25px 25px 25px 5px; /* 应用尖角 */
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.9), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        #app-container.app-bubble-style-neumorphic-2 .bubble.sent {
            border-radius: 25px 25px 5px 25px; /* 应用尖角 */
             box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.9), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        /* --- 绿白 (B类) --- */
        #app-container.app-bubble-style-wechat .bubble {
            position: relative;
            border-radius: 8px;
            color: #000000;
        }
        #app-container.app-bubble-style-wechat .bubble::after {
            content: '';
            position: absolute;
            top: 10px;
            border-width: 6px;
            border-style: solid;
        }
        #app-container.app-bubble-style-wechat .bubble.received {
            background-color: #FFFFFF;
        }
        #app-container.app-bubble-style-wechat .bubble.received::after {
            left: -12px;
            border-color: transparent #FFFFFF transparent transparent;
        }
        #app-container.app-bubble-style-wechat .bubble.sent {
            background-color: #95EC6A;
        }
        #app-container.app-bubble-style-wechat .bubble.sent::after {
            right: -12px;
            border-color: transparent transparent transparent #95EC6A;
        }
        #app-container.app-bubble-style-wechat .voice-wave-bar {
            background-color: #000000;
        }


        /* --- 引用和语音消息的通用适配 --- */
        .quote-block {
            padding: 8px 12px;
            border-left: 3px solid; /* 颜色由父级样式决定 */
            background-color: rgba(0, 0, 0, 0.04); /* 浅灰色背景 */
            line-height: 1.4;
            font-size: 0.85em;
            border-radius: 8px;
            color: color-mix(in srgb, currentColor 80%, transparent); /* 修改：颜色比当前字体颜色稍浅 */
        }
        .quote-block .quoted-name { font-weight: bold; }

        .voice-duration {
            font-size: 0.8rem;
            color: currentColor;
            margin-right: 10px;
            font-weight: bold;
        }
        .voice-wave {
            display: flex;
            align-items: center;
            height: 20px;
            flex-grow: 1;
            justify-content: flex-end;
        }
        .voice-wave-bar {
            width: 3px;
            background-color: currentColor;
            margin: 0 2px;
            border-radius: 2px;
            animation: voiceWave 1.5s infinite ease-in-out;
            transform-origin: bottom;
        }
        @keyframes voiceWave {
            0%, 100% { transform: scaleY(0.4); }
            50% { transform: scaleY(1.0); }
        }
        .voice-wave-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .voice-wave-bar:nth-child(2) { height: 12px; animation-delay: 0.2s; }
        .voice-wave-bar:nth-child(3) { height: 16px; animation-delay: 0.4s; }
        .voice-wave-bar:nth-child(4) { height: 12px; animation-delay: 0.6s; }
        .voice-wave-bar:nth-child(5) { height: 8px; animation-delay: 0.8s; }

        .bubble-timestamp {
            font-size: 0.7rem;
            color: var(--text-color-light);
            margin-top: 4px; /* 气泡与时间戳之间的间距 */
            padding: 0 8px;  /* 水平对齐 */
            user-select: none;
        }

        /* --- 剩余基础样式保持不变 --- */
        .bubble-emoji {
            background: none !important; border: none !important; box-shadow: none !important; padding: 0;
            max-width: 120px; overflow: hidden;
        }
        .bubble-emoji img { max-width: 100%; display: block; border-radius: 12px; }
        .bubble.quote-message-bubble { display: flex; flex-direction: column; gap: 8px; }
        .bubble.image-with-desc-bubble { max-width: 160px; /* 稍微增大最大宽度以容纳长图 */ max-height: none; /* 移除固定的最大高度限制 */ padding: 5px; /* 增加一点内边距 */ display: flex; flex-direction: column; gap: 8px; }
        .bubble.image-with-desc-bubble img { max-width: 100%; height: auto; /* 关键：让高度自适应宽度 */ border-radius: 8px; display: block; background-color: var(--theme-color-1); }
        .bubble.image-with-desc-bubble img { max-width: 100%; border-radius: 8px; display: block; background-color: var(--theme-color-1); }
        .bubble.image-with-desc-bubble .description-text { display: none; padding: 0 4px; font-size: 0.9rem; line-height: 1.5; color: var(--text-color-dark); }
        .bubble.voice-message-bubble {
            display: flex;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            z-index: 1;
            min-width: 80px;
        }
        .bubble.vision-image-bubble {
            max-width: 240px; /* 让图片可以显示得更大一些 */
            max-height: none; /* 移除高度限制 */
            padding: 5px;
        }
        .bubble.vision-image-bubble .description-text {
            display: block; /* 总是显示附言 */
            padding-top: 5px;
        }
        .bubble-and-tag-wrapper { position: relative; display: flex; flex-direction: column; align-items: flex-start; }
        .message-row.sent .bubble-and-tag-wrapper { align-items: flex-end; }
        .voice-transcript { position: absolute; top: calc(100% + 5px); left: 0; width: max-content; max-width: 250px; background: #e6f7ff; border: 1px dashed #91d5ff; color: #03a9f4; border-radius: 10px; padding: 8px 12px; font-size: 0.85rem; z-index: 5; display: none; word-wrap: break-word; }
        .voice-transcript.show { display: block; }
        .message-row.sent .voice-transcript { left: auto; right: 0; }
        .bubble-retracted { background: #e0e0e0; font-style: italic; color: #888; animation: retract 0.5s ease-in-out forwards; }
        .retract-button-wrapper { position: absolute; bottom: calc(100% + 5px); z-index: 5; animation: popIn 0.2s ease-out; background: rgba(0, 0, 0, 0.7); border-radius: 15px; padding: 4px; gap: 4px; display: none; }
        .message-row.sent .retract-button-wrapper { right: 0; }
        .message-row.received .retract-button-wrapper { left: 0; }
        .retract-button-wrapper.show { display: flex; }
        .retract-btn { background: transparent; color: white; border: none; border-radius: 12px; padding: 6px 12px; font-size: 0.8rem; cursor: pointer; transition: background 0.2s; display: flex; align-items: center; gap: 5px; }
        .retract-btn:hover { background: rgba(255, 255, 255, 0.2); }
        @keyframes retract { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.8); opacity: 0; } }
        /* AI Typing Indicator Bubble */
        .bubble-typing { display: flex; gap: 5px; align-items: center; padding: 10px 15px; background: var(--text-color-white); border: 1px solid var(--theme-color-2); border-top-left-radius: 5px; }
        .typing-dot { width: 8px; height: 8px; background-color: var(--text-color-light); border-radius: 50%; animation: typing-pulse 1.4s infinite ease-in-out both; }
        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing-pulse { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }

        .time-divider, .retracted-notice, .system-notice {
            align-self: center;
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 10px;
            margin: 5px 0;
        }

        .chat-area::-webkit-scrollbar {
            width: 6px;
        }
        .chat-area::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.02);
        }
        .chat-area::-webkit-scrollbar-thumb {
            background-color: var(--theme-color-4);
            border-radius: 3px;
        }
        .chat-area::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-color);
        }

        #history-loader {
            text-align: center;
            padding: 10px;
            display: none; /* Initially hidden */
        }
        #history-loader.visible {
            display: block;
        }
        #history-loader .loader-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--theme-color-2);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
        }

        .retracted-notice {
            cursor: pointer;
            transition: background 0.3s;
        }
        .retracted-notice:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        /* --- 4.3. 消息列表长按弹窗 --- */
        .message-list-popover {
            position: absolute;
            z-index: 100;
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            padding: 5px;
            display: flex;
            gap: 5px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            opacity: 0;
            transform: scale(0.9);
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            color: white;
        }
        .message-list-popover-btn {
            background: transparent;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background-color 0.2s;
        }
        .message-list-popover-btn:hover {
            background-color: rgba(255,255,255,0.15);
        }
        .message-item .item-pin-icon {
            color: var(--accent-color);
            margin-right: 8px;
            font-size: 0.9rem;
        }

        .chat-input-area {
            display: flex;
            flex-direction: column; /* 改为纵向布局 */
            padding: 10px 15px;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative; /* 为表情面板定位 */
        }
        /* 聊天页面顶部*/
        #page-chat .page-header {
            background: white;
        }


        /* --- 功能：引用预览样式 --- */
        .quote-preview-area {
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-color-medium);
            margin-bottom: 8px; /* 和下方输入框的间距 */
            display: none; /* 默认隐藏 */
        }
        .quote-preview-content { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cancel-quote-btn { background: none; border: none; font-size: 1.2rem; color: #999; cursor: pointer; padding: 0 5px;}

        /* 输入和发送按钮的容器 */
        .input-top-row {
            display: flex;
            align-items: flex-end;
            width: 100%;
        }
        
        /* 包裹层，用于横向滚动 */
        .input-feature-row-wrapper {
            width: 100%;
            overflow-x: auto;
            padding-bottom: 5px; /* 为滚动条预留空间，如果可见 */
            margin-bottom: -5px; /* 补偿内边距，避免增加额外高度 */
        }
        .input-feature-row-wrapper::-webkit-scrollbar {
            display: none; /* 隐藏滚动条 (Chrome, Safari) */
        }
        .input-feature-row-wrapper {
            -ms-overflow-style: none;  /* 隐藏滚动条 (IE, Edge) */
            scrollbar-width: none;  /* 隐藏滚动条 (Firefox) */
        }

        /* 新增的功能按钮行 */
        .input-feature-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-top: 8px;
            width: max-content; /* 关键：让行内容不换行，从而可以滚动 */
        }
        .feature-btn {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            color: var(--text-color-medium);
            transition: all 0.2s;
        }
        .feature-btn:hover {
            background: white;
            color: var(--accent-color);
        }

        /* 表情包面板 */
        .emoji-card {
            position: absolute;
            bottom: 100%; /* 位于输入区域正上方 */
            left: 10px; right: 10px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
            padding: 15px;
            z-index: 100;
            display: none;
            max-height: 250px;
            overflow-y: auto;
        }
        .emoji-card.active { display: block; }

        .emoji-item-add {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px;
            height: 60px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-color-light);
            font-size: 24px;
        }
        .emoji-item-add:hover {
            background-color: rgba(0,0,0,0.05);
            color: var(--accent-color);
            border-color: var(--accent-color);
        }

.emoji-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 4列 */
    grid-template-rows: repeat(2, auto); /* 2行 */
    gap: 15px; /* 增大间距 */
    min-height: 140px; /* 调整最小高度以适应新布局 */
}
        .emoji-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        .emoji-nav button {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-color-light);
            cursor: pointer;
            padding: 5px 15px;
        }
        .emoji-nav button:hover {
            color: var(--accent-color);
        }
        #emoji-page-indicator {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            min-width: 30px;
            text-align: center;
        }
        
        .emoji-item { cursor: pointer; text-align: center; transition: transform 0.2s; }
        .emoji-item:hover { transform: scale(1.1); }
        .emoji-item img { width: 60px; height: 60px; object-fit: contain; }
        .emoji-item { position: relative; } /* 为绝对定位提供基准 */
        .favorite-emoji-toggle {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 22px;
            height: 22px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: #ccc;
            font-size: 0.8rem;
            transition: all 0.2s;
            opacity: 0.5; /* 降低默认透明度，避免视觉干扰 */
        }
        .favorite-emoji-toggle:hover {
            transform: scale(1.1);
            opacity: 1; /* 悬浮时完全不透明 */
        }
        .favorite-emoji-toggle.is-favorite {
            color: #ffc107; /* 黄色星星 */
            background-color: white;
            border-color: #ffc107;
        }
        #ai-request-btn {
            background: none; border: none; font-size: 1.8rem; cursor: pointer; padding: 5px 10px 5px 0; transition: transform 0.2s;
        }
        #ai-request-btn:hover {
             transform: scale(1.1);
        }
        #message-input {
            flex-grow: 1;
            border: none;
            background: var(--text-color-white);
            padding: 12px;
            border-radius: 18px;
            resize: none;
            font-size: 1rem;
            font-family: var(--font-main);
            max-height: 100px;
            outline: none;
            margin-left: 10px; /* 和左侧AI按钮的间距 */
        }
        #send-btn {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--theme-color-2) 100%);
            border: none;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 1.2rem;
            margin-left: 10px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            flex-shrink: 0; /* 防止被挤压 */
            box-shadow: 0 4px 10px rgba(167, 199, 231, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #send-btn:hover {
            background-color: var(--accent-color-deep);
            transform: scale(1.05);
        }
        #send-btn i {
            position: relative;
            top: 10px; /* 向下微调图标位置 */
        }
        
        /* --- 8. 模态框/弹窗 --- */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2500; /* 提升层级，高于侧边栏的 2000 */
        }
        #modal-overlay.visible {
            display: flex;
            animation: fadeIn 0.3s;
        }
        .modal-content {
            background: var(--bg-main);
            padding: 25px;
            border-radius: 20px;
            width: 90%;
            max-width: 450px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-medium);
            animation: slideInUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes slideInUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal-header {
            font-family: var(--font-title);
            font-size: 1.6rem;
            margin-bottom: 20px;
            text-align: center;
            color: var(--text-color-dark);
        }

        /* --- 详情页样式 (来自参考文件) --- */
        .details-card {
            background-color: var(--text-color-white);
            border-radius: 12px;
            padding: 20px;
            box-shadow: var(--shadow-light);
            margin-bottom: 20px;
        }
        .details-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            position: relative; /* 为绝对定位的子元素提供定位参考 */
        }
        .details-header-attribution {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 2;
            flex-shrink: 0; /* 防止被标题挤压 */
        }
        .details-header-attribution:hover {
            transform: scale(1.1);
            background-color: var(--accent-color);
        }
        .details-header .avatar {
            width: 64px;
            height: 64px;
            border-radius: 12px;
            margin-right: 20px;
            object-fit: cover;
        }
        .details-info .name {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-color-dark);
        }
        .details-info .id {
            font-size: 0.9rem;
            color: var(--text-color-light);
        }
        .details-section {
            margin-top: 20px;
        }
        .details-section-title {
            font-size: 1rem;
            color: var(--text-color-medium);
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .details-field {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 1rem;
        }
        .details-field .label { color: var(--text-color-medium); }
        .details-field .value { color: var(--text-color-dark); text-align: right; }
        .details-section p {
            white-space: pre-wrap; /* 关键：让换行符生效 */
            max-height: 150px;     /* 限制最大高度 */
            overflow-y: auto;      /* 内容超出时显示滚动条 */
            line-height: 1.6;
            color: var(--text-color-medium);
            background-color: rgba(0,0,0,0.02); /* 加一点淡淡的底色以区分 */
            padding: 10px;
            border-radius: 8px;
        }
        .details-section p::-webkit-scrollbar { width: 4px; }
        .details-section p::-webkit-scrollbar-thumb { background: var(--theme-color-4); border-radius: 2px; }
        .member-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
        }
        .member-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        .member-item .avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 0;
        }
        .member-item .name {
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .details-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .details-btn {
            width: 100%;
            padding: 14px;
            font-size: 1rem;
            font-weight: 500;
            border-radius: 8px; /* 调整圆角 */
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.2); /* 透明背景 */
            border: 1px dashed var(--text-color-light); /* 虚线边框 */
            color: var(--text-color-dark); /* 深色文字 */
        }
        .details-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            border-color: var(--accent-color);
            color: var(--accent-color-deep);
        }
        /* 移除特定的背景色，使其风格统一 */
        .btn-details-primary {
            /* 样式已由 .details-btn 统一处理 */
        }
        .btn-details-danger {
            /* 样式已由 .details-btn 统一处理 */
        }
        .btn-details-danger:hover {
            border-color: #e74c3c;
            color: #c0392b;
        }
        /* --- 结束：详情页样式 --- */

        .form-group {
            margin-bottom: 18px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-color-medium);
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            border-radius: 10px;
            font-size: 1rem;
            font-family: var(--font-main);
            outline-color: var(--accent-color);
        }
        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        .modal-content .form-group textarea {
    max-height: 25vh; /* 限制最大高度为视窗的25% */
    overflow-y: auto; /* 确保内容超出时可滚动 */
}
        .avatar-uploader {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            background-color: transparent; /* 改为透明 */
            border: 2px solid white;
        }
        .upload-btn {
            padding: 8px 15px;
            background: var(--theme-color-4);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 25px;
        }
        .modal-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: bold;
            transition: all 0.2s;
        }

        /* --- 颜色选择器样式 --- */
        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 4px;
            background-color: var(--text-color-white);
        }
        .color-picker-container input[type="color"] {
            width: 30px;
            height: 30px;
            border: none;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .color-picker-container input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .color-picker-container input[type="color"]::-webkit-color-swatch { border: 1px solid var(--border-color); border-radius: 6px; }

        .color-picker-container .color-hex-input {
            border: none;
            outline: none;
            width: 70px;
            font-family: monospace;
            font-size: 0.9rem;
            background-color: transparent;
            color: var(--text-color-dark);
            text-align: center;
        }
        /* --- 新增结束 --- */

        /* --- Neumorphic Modal Style --- */
        .modal-content.modal-neumorphic {
            background: #F0F0F3;
            border-radius: 20px;
            box-shadow: 
                -7px -7px 20px 0px #fff,
                7px 7px 20px 0px #d1d9e6;
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 25px;
        }
        .modal-neumorphic .modal-header {
            color: #555;
            font-family: var(--font-title);
            text-shadow: 1px 1px 1px #fff;
            text-align: center;
            margin-bottom: 25px;
        }
        .modal-neumorphic .form-group label {
            color: #888;
            font-weight: 500;
            text-shadow: 1px 1px 1px #fff;
        }
        .modal-neumorphic .form-group input,
        .modal-neumorphic .form-group select,
        .modal-neumorphic .form-group textarea {
            background: #F0F0F3;
            border: none;
            border-radius: 12px;
            padding: 12px 15px;
            box-shadow: 
                inset -5px -5px 9px rgba(255, 255, 255, 0.7),
                inset 5px 5px 9px rgba(174, 174, 192, 0.2);
            color: var(--text-color-dark);
            font-size: 1rem;
            outline: none;
        }
        .modal-neumorphic .modal-actions {
            display: flex;
            justify-content: space-around; /* Space them out */
            margin-top: 30px;
        }
        .modal-neumorphic .modal-btn {
            padding: 12px 0; /* Vertical padding, horizontal from flex */
            flex: 1; /* Take up equal space */
            margin: 0 10px; /* Spacing between buttons */
            border-radius: 12px;
            border: none;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-family: var(--font-main);
        }
        .modal-neumorphic .btn-primary {
            background: #5A8DEE;
            color: white;
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.7), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        .modal-neumorphic .btn-primary:hover {
            box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.7), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
            background: #4a7de0; /* Slightly darker on hover */
            color: #f0f0f0;
        }
        .modal-neumorphic .btn-secondary {
            background: #F0F0F3;
            color: #888;
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.7), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        .modal-neumorphic .btn-secondary:hover {
            box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.7), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--accent-color-deep);
            transform: translateY(-2px);
        }
        .btn-secondary {
            background-color: #ccc;
            color: #333;
        }
        .btn-secondary:hover {
            background-color: #bbb;
        }
        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .persona-modal-card {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: var(--shadow-light);
        }
        .persona-modal-card h4 {
            font-family: var(--font-title);
            color: var(--accent-color-deep);
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
    .persona-modal-card p {
        font-family: var(--font-inner-voice); /* 应用心声字体 */
        line-height: 1.6;
        color: var(--text-color-dark);
    }
    .persona-modal-card.note-paper p {
        font-family: var(--font-essay); /* 应用随笔字体 */
        white-space: pre-wrap; /* 让换行符生效 */
    }
    .note-paper {
        background-color: #fdf5d3;
        background-image:
            linear-gradient(90deg, rgba(200, 180, 140, 0.15) 1px, transparent 1px),
            linear-gradient(rgba(200, 180, 140, 0.15) 1px, transparent 1px);
        background-size: 20px 20px;
        border: 1px solid #e0d9c3;
        position: relative;
        padding-top: 30px; /* 为图钉留出空间 */
    }
        .note-paper::before {
            content: '';
            position: absolute;
            top: 5px;
            right: 15px;
            width: 20px;
            height: 20px;
            background: #ff7675;
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            border: 2px solid white;
        }
        .member-select-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 5px;
        }
        .member-select-item {
            display: flex;
            align-items: center; /* 垂直居中对齐 */
            padding: 8px;
            cursor: pointer; /* 让整行都可以点击 */
        }

        .member-select-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
        }

        /* --- 创建群聊弹窗样式 --- */
        .creation-mode-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .mode-btn {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            background-color: transparent;
            color: var(--text-color-medium);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .mode-btn.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        #group-creation-search {
            width: 100%;
            padding: 10px 15px;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            margin-bottom: 10px;
        }
        .selection-panel.hidden {
            display: none;
        }

        .group-info-modal-body .form-group {
            margin-bottom: 10px;
        }
        .group-info-modal-body .member-list-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 15px;
            max-height: 250px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0,0,0,0.02);
            border-radius: 8px;
        }
        .group-info-modal-body .member-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .group-info-modal-body .member-item img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid white;
        }
        .group-info-modal-body .member-item span {
            font-size: 0.8rem;
            color: var(--text-color-medium);
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* --- 8.5. 顶部浮窗通知 --- */
        #top-notification-container {
            position: absolute;
            top: 15px; /* 从顶部留出一些间距 */
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 480px; /* 匹配app-container的最大宽度 */
            z-index: 5000;
            pointer-events: none; /* 允许点击穿透容器本身 */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .notification-banner {
            pointer-events: auto; /* 仅banner可点击 */
            background-color: #FBFBFC; /* 柔和的灰白色 */
            border: 1px solid var(--border-color); /* 使用通用边框色 */
            border-radius: 16px; /* 圆角 */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1); /* 增强阴影效果 */
            padding: 12px 18px; /* 增大内边距 */
            display: flex;
            align-items: center;
            gap: 15px; /* 增大间距 */
            width: fit-content;
            max-width: 95%; /* 限制最大宽度 */
            min-width: 280px; /* 增大最小宽度 */
            cursor: pointer;
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            animation: notification-enter 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        
        @keyframes notification-enter {
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        @keyframes notification-exit {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        .notification-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }
        .notification-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 8px;
        }
        .notification-name {
            font-weight: bold;
            color: var(--text-color-dark);
            white-space: nowrap;
        }
        .notification-time {
            font-size: 0.7rem;
            color: var(--text-color-light);
            flex-shrink: 0;
        }
        .notification-message {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- 8.5.1 特殊：随笔更新浮窗 --- */
        .essay-notification-banner {
            pointer-events: auto;
            position: relative;
            width: 48px;
            height: 48px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            color: #fff;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: width 0.5s cubic-bezier(0.65, 0, 0.35, 1);
        }
        .essay-notification-banner.is-playing {
            animation: expand-toast 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        .essay-notification-banner .icon-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .essay-notification-banner.is-playing .icon-wrapper {
             animation: move-icon 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        .essay-notification-banner .text-content {
            opacity: 0;
            white-space: nowrap;
            padding-left: 52px; /* 给图标留出空间 */
        }
        .essay-notification-banner.is-playing .text-content {
            animation: show-text 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        @keyframes expand-toast {
            0% { width: 48px; }
            50%, 100% { width: 220px; }
        }

        @keyframes move-icon {
            0% {
                left: 50%;
                transform: translate(-50%, -50%) scale(1);
            }
            40% {
                left: 24px;
                transform: translate(-50%, -50%) scale(0.9);
            }
            50%, 100% {
                left: 24px;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes show-text {
            0%, 50% { opacity: 0; transform: translateX(-10px); }
            100% { opacity: 1; transform: translateX(0); }
        }



        /* --- 8.7. Toast 轻量提示 --- */
        .toast-notification {
            position: fixed; /* 使用fixed定位，相对于视口 */
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 10000; /* 确保高于所有其他元素 */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            animation: toast-in 0.3s forwards;
        }

        @keyframes toast-in {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .toast-notification.hiding {
            opacity: 0;
        }
        /* --- 8.8. Bottom Sheet --- */
        #bottom-sheet-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            z-index: 3000; /* 高于模态框 */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out; /* 只对 opacity 过渡 */
        }
        #bottom-sheet-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .bottom-sheet-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            max-height: 50vh;
            background: white;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            flex-direction: column;
        }
        #bottom-sheet-overlay.visible .bottom-sheet-content {
            transform: translateY(0);
        }
        .bottom-sheet-header {
            padding: 15px 20px;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .bottom-sheet-body {
            padding: 10px;
            overflow-y: auto;
            max-height: 40vh; /* 设置最大高度以启用滚动 */
        }
        .bottom-sheet-item {
            padding: 15px 20px;
            font-size: 1.1rem;
            cursor: pointer;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }
        .bottom-sheet-item:last-child {
            border-bottom: none;
        }
        .bottom-sheet-item:hover {
            background-color: rgba(0,0,0,0.03);
        }
        /* Neumorphic style for bottom sheet */
        .bottom-sheet-content.neumorphic {
            background: #F0F0F3;
            box-shadow: 
                -7px -7px 20px 0px #fff,
                7px 7px 20px 0px #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-header {
            color: #555;
            text-shadow: 1px 1px 1px #fff;
            border-bottom-color: #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-item {
            color: var(--text-color-dark);
            border-bottom-color: #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-item:hover {
            background: #e6e6e9;
        }
        .bottom-sheet-content.compact-list .bottom-sheet-item {
            padding: 10px 20px; /* Reduced vertical padding */
            font-size: 1rem; /* Slightly smaller font */
        }
/* --- 9. 点击特效 --- */
#click-effect-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;
    z-index: 9999;
}
.ripple {
    position: absolute;
    border-radius: 50%;
    background-color: var(--accent-color);
    transform: scale(0);
    animation: ripple-effect 0.6s ease-out;
    opacity: 0.5;
}
@keyframes ripple-effect {
    to {
        transform: scale(1);
        opacity: 0;
    }
}
.heart {
    position: absolute;
    color: var(--accent-color);
    animation: heart-fly 1.2s ease-out forwards;
    opacity: 1;
    font-size: 16px;
}
@keyframes heart-fly {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}
/* --- 10. 侧边栏 --- */
#sidebar-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(5px);
    z-index: 2000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
#sidebar-overlay.visible {
    opacity: 1;
    visibility: visible;
}
#sidebar-content {
    position: absolute;
    top: 0;
    right: 0; /* 改为 right */
    left: auto; /* 新增 */
    width: 80%;
    max-width: 350px;
    height: 100%;
    background: var(--bg-main);
    box-shadow: var(--shadow-medium);
    transform: translateX(100%); /* 改为正值 */
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
}
#sidebar-overlay.visible #sidebar-content {
    transform: translateX(0);
}
#sidebar-content .form-group {
    margin-bottom: 20px;
}

        /* --- 10.1. 左侧滑出侧边栏 --- */
        #sidebar-content.sidebar-from-left {
            left: 0;
            right: auto;
            transform: translateX(-100%);
        }
        #sidebar-overlay.visible #sidebar-content.sidebar-from-left {
            transform: translateX(0);
        }

        /* --- 10.2. 侧边栏样式调整 --- */
        #sidebar-content .modal-header {
            font-size: 1.4rem; /* 缩小标题字体 */
            padding-bottom: 15px; /* 为分割线留出空间 */
            margin-bottom: 15px; /* 调整与下方内容的间距 */
            border-bottom: 1px solid var(--border-color); /* 添加分割线 */
            position: relative;
        }
        /* 优美的分割线装饰 */
        #sidebar-content .modal-header::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 2px;
            background: var(--accent-color);
            border-radius: 1px;
        }
        #sidebar-content .setting-item span {
            font-size: 1rem; /* 缩小侧边栏内按钮文字大小 */
        }
        

        /* 侧边栏内的特定样式 */
        #sidebar-content .details-card {
             background-color: rgba(255,255,255,0.6);
             margin: 0 0 15px 0;
             padding: 15px;
        }
        #sidebar-content .details-header .avatar {
            width: 50px;
            height: 50px;
        }
        #sidebar-content .details-info .name {
            font-size: 1.3rem;
        }
        #sidebar-content .details-actions {
            margin-top: 20px;
        }
        
        /* 群成员列表弹窗样式 */
        .member-list-modal-body {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px; /* 为滚动条留出空间 */
        }
        .member-list-modal-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .member-list-modal-item:last-child {
            border-bottom: none;
        }
        .member-list-modal-item img {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            margin-right: 15px;
        }
        .member-list-modal-item .owner-tag {
            font-size: 0.7rem;
            background-color: #f1c40f;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 10px;
        }

        /* --- 10.3. Neumorphic Sidebar Style --- */
        #sidebar-content.neumorphic {
            background: #F0F0F3;
            box-shadow: 
                -7px 0px 20px 0px #fff,
                7px 0px 20px 0px #d1d9e6;
            border-left: 1px solid rgba(255, 255, 255, 0.5); /* For right sidebar */
        }
        #sidebar-content.neumorphic.sidebar-from-left {
            box-shadow: 
                -7px 0px 20px 0px #d1d9e6,
                7px 0px 20px 0px #fff;
            border-left: none;
            border-right: 1px solid rgba(255, 255, 255, 0.5);
        }
        #sidebar-content.neumorphic .modal-header {
            color: #555;
            text-shadow: 1px 1px 1px #fff;
            border-bottom-color: #d1d9e6;
        }
        #sidebar-content.neumorphic .modal-header::after {
            background: #888;
            box-shadow: 1px 1px 1px #fff;
        }
        #sidebar-content.neumorphic .setting-item {
            background: transparent;
            box-shadow: 
                -5px -5px 9px rgba(255, 255, 255, 0.9), 
                5px 5px 9px rgba(174, 174, 192, 0.4);
            margin: 0 0 15px; /* Adjust margin */
        }
        #sidebar-content.neumorphic .setting-item:hover {
            box-shadow: 
                inset -5px -5px 9px rgba(255, 255, 255, 0.9), 
                inset 5px 5px 9px rgba(174, 174, 192, 0.4);
            transform: none; /* Override hover transform */
        }

        /* --- 聊天页面顶部/底部 UI 颜色 --- */
        #page-chat .page-header,
        .chat-input-area {
            background-color: var(--chat-ui-bg-color, white);
        }

        /* --- 聊天页面功能按钮颜色 --- */
        .chat-input-area .feature-btn {
            color: var(--chat-feature-btn-color, var(--text-color-medium));
        }
        .chat-input-area .feature-btn:hover {
            color: var(--chat-feature-btn-active-color, var(--accent-color));
        }

        /* --- 聊天页面特殊按钮图标 (小羽毛和发送) --- */
        #ai-request-btn i,
        #send-btn i {
            display: inline-block; /* 确保 i 标签可以被背景图替换 */
            width: 100%;
            height: 100%;
            font-size: inherit; /* 继承父级字体大小 */
            line-height: inherit; /* 继承父级行高 */
        }
        #ai-request-btn i {
            color: var(--chat-feature-btn-active-color, var(--accent-color));
            }
        #send-btn i {color:white}
        #ai-request-btn img,
        #send-btn img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* 确保图片完整显示 */
        }
        #send-btn:has(img) {
            background: none;
            box-shadow: none;
        }

        /* --- 10.4. 洞察弹窗样式 (新增) --- */
        #chat-insight-btn i {
            background: linear-gradient(135deg, #87CEEB, #98FB98); /* 使用饱和度更低的天蓝色和淡绿色 */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }
        .insight-member-list {
            max-height: 40vh;
            overflow-y: auto;
            padding-right: 5px;
        }
        .insight-member-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .insight-member-item:last-child {
            border-bottom: none;
        }
        .insight-member-item img {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            margin-right: 15px;
        }
        .insight-member-item span {
            flex-grow: 1;
            white-space: nowrap;      /* 防止文字换行 */
            overflow: hidden;         /* 隐藏超出部分 */
            text-overflow: ellipsis;  /* 显示省略号 */
            max-width: 150px;         /* 设置一个最大宽度 */
        }
        .insight-view-btn {
            padding: 4px 12px;     /* 缩小内边距 */
            font-size: 0.6rem;     /* 缩小字体 */
            min-width: 50px;       /* 确保按钮不会过小 */
            max-width: 50px;       /* 确保按钮不会过小 */
            flex-shrink: 0;        /* 防止按钮被挤压 */
        }

        /* --- 11. 自定义提示词页面 --- */
        #prompts-page-content {
            padding: 15px;
        }
        #prompt-header-actions {
            gap: 10px; /* 减小图标间距 */
        }
        #prompt-header-actions .header-icon {
            font-size: 1.1rem; /* 减小图标大小 */
            padding: 0 5px; /* 减小图标的水平内边距，让其更紧凑 */
        }
        
        .prompt-folder {
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-light);
            transition: all 0.3s;
        }
        .prompt-folder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        .prompt-folder-header h3 {
            font-size: 1.1rem;
            color: var(--text-color-dark);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .prompt-folder-header h3 .folder-toggle-icon {
        transition: transform 0.3s ease-in-out;
         }
        .prompt-folder-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .prompt-folder-controls .folder-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-light);
            transition: color 0.2s;
        }
        .prompt-folder-controls .folder-action-btn:hover {
            color: var(--accent-color);
        }
        .prompt-folder-content {
            padding: 15px;
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }
        .prompt-folder-content.collapsed {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
    margin-top: -1px; /* 优化边框显示 */
    display: block; 
}
.prompt-folder-header.collapsed .folder-toggle-icon {
    transform: rotate(-90deg);
}
        .prompt-card {
            background-color: var(--text-color-white);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border-left: 5px solid var(--theme-color-4);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .prompt-card.inactive {
            border-left-color: #ccc;
            opacity: 0.7;
        }
        .prompt-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .prompt-card-name {
            font-weight: bold;
            font-size: 1rem;
            color: var(--text-color-dark);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .prompt-card-name .prompt-index {
            font-size: 0.8rem;
            background: var(--theme-color-4);
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
        }
        .prompt-card.inactive .prompt-card-name .prompt-index {
            background: #ccc;
        }
        .prompt-card-tags {
            display: flex;
            gap: 6px;
        }
        .prompt-tag {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 10px;
            color: white;
        }
        .tag-explicit { background-color: var(--accent-color); }
        .tag-implicit { background-color: var(--theme-color-4); }
        .tag-keywords {
            background-color: var(--theme-color-3);
            color: var(--text-color-dark);
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .prompt-card-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .prompt-card-actions .action-btn {
            background: rgba(0,0,0,0.05);
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .prompt-card-actions .action-btn:hover {
            background: var(--accent-color);
            color: white;
        }
        .font-delete-btn {
            padding: 8px 10px;
            font-size: 0.9rem;
            min-width: 40px;
        }
        
        /* --- 12. 绑定提示词弹窗样式 --- */
        .binding-modal-content {
            background: var(--bg-light) !important; /* 使用主页面的浅色背景 */
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
        }
        .binding-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .binding-modal-header h2 {
            margin: 0;
            font-size: 1.4rem;
            font-family: var(--font-title);
        }
        #open-folder-selection-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        #open-folder-selection-btn:hover {
            transform: scale(1.1) rotate(90deg);
            background: var(--accent-color-deep);
        }
        #bound-folders-list {
            min-height: 100px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .bound-folder-card {
            background: var(--text-color-white);
            padding: 15px;
            border-radius: 10px;
            box-shadow: var(--shadow-light);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .bound-folder-card i {
            font-size: 1.5rem;
            color: var(--theme-color-4);
        }
        .bound-folder-card span {
            font-size: 1.1rem;
            flex-grow: 1;
        }

        .folder-selection-list {
            max-height: 300px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .folder-selection-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background-color: rgba(255,255,255,0.5);
            border-radius: 8px;
            cursor: pointer;
        }
        .folder-selection-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 15px;
            accent-color: var(--accent-color);
        }
        .folder-selection-item i {
            margin-right: 10px;
            color: var(--text-color-medium);
        }
        
        /* --- 开关样式 (可复用) --- */
        .switch { position: relative; display: inline-block; width: 52px; height: 30px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 30px; }
        .slider:before { position: absolute; content: ""; height: 24px; width: 24px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(22px); }


        /* --- 13. 发现页面 --- */
        #page-discover .settings-list {
            padding-top: 10px;
        }
        #page-discover .setting-item {
            margin: 0 10px 1px; /* 紧凑列表 */
            border-radius: 0;
            padding: 18px 15px;
            background: var(--text-color-white);
        }
        #page-discover .setting-item:first-child {
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            margin-top: 10px;
        }
        #page-discover .setting-item:last-child {
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            margin-bottom: 10px;
        }
        #page-discover .setting-item:hover {
            transform: none;
            box-shadow: none;
            background-color: #f7f7f7;
        }

        /* --- 14. 朋友圈页面 --- */
        #page-moments {
            /* 关键1：让它成为一个剪裁和定位的容器 */
            overflow: hidden; 
            position: relative; /* 为子元素的绝对定位提供基准 */
        }

        #moments-wrapper {
            /* 关键2：使用绝对定位来确保尺寸和位置的精确性 */
            position: absolute;
            top: 0;
            left: 0;
            width: 125%; /* 100% / 0.8 = 125% */
            height: 125%;
            transform: scale(0.8);
            transform-origin: top left;
            
            /* 内部布局保持不变，依然使用flex来排列header和content */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 防止内部出现意外的滚动条 */
        }
        #page-moments .page-header {
            display: flex; /* 使用flex布局以适应按钮 */
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            position: absolute; /* 浮动在背景图上 */
            top: 0;
            left: 0;
            right: 0;
            background: transparent;
            border-bottom: none;
            z-index: 10;
        }
        #page-moments .page-header .header-icon {
            color: var(--text-color-white);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            font-size: 1.4rem;
        }
        #moments-actions-group {
            display: flex;
            gap: 10px;
        }
        #page-moments .page-header .header-icon {
            color: var(--text-color-white);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            font-size: 1.4rem;
            padding: 5px 8px; /* 调整内边距使按钮更紧凑 */
        }

        #page-moments .page-content {
            padding: 0; /* 移除内边距，让内容填满 */
            background-color: var(--theme-color-1);
        }

        .moments-header-container {
            position: relative;
        }
        #moments-bg {
            width: 100%;
            height: 250px;
            object-fit: cover;
            display: block;
        }
        .moments-profile-info {
            position: absolute;
            bottom: 0;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .moments-profile-info .name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--text-color-white);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .moments-profile-info .avatar {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            border: 3px solid white;
            box-shadow: var(--shadow-light);
        }

        #moments-list {
            list-style: none;
            padding: 0;
            background-color: var(--bg-light);
        }

        .moments-post {
            display: flex;
            gap: 15px;
            padding: 20px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        .post-avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
        }
        .post-main-content {
            flex-grow: 1;
        }
        .post-author-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent-color-deep);
            margin-bottom: 8px;
        }
        .post-text {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        .post-images-grid {
            display: grid;
            gap: 5px;
            margin-bottom: 10px;
        }
        .post-images-grid.grid-1 { grid-template-columns: minmax(0, 2fr); }
        .post-images-grid.grid-2, .post-images-grid.grid-4 { grid-template-columns: repeat(2, 1fr); }
        .post-images-grid.grid-3, .post-images-grid.grid-5, .post-images-grid.grid-6, .post-images-grid.grid-7, .post-images-grid.grid-8, .post-images-grid.grid-9 { grid-template-columns: repeat(3, 1fr); }

        .post-images-grid img {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 6px;
            background-color: var(--theme-color-1);
        }
        .post-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .post-timestamp {
            font-size: 0.8rem;
            color: var(--text-color-light);
        }
        .post-actions-btn {
            background: transparent; /* 去掉背景色 */
            border: none;
            width: 30px;
            height: 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-medium);
            transition: background-color 0.2s; /* 添加过渡效果 */
        }
        .post-actions-btn:hover, .post-action-icon-btn:hover {
            background-color: rgba(0, 0, 0, 0.05); /* 添加悬浮效果 */
        }

        .post-comments-section {
            background-color: #f7f7f7;
            border-radius: 8px;
            padding: 5px;
            font-size: 0.9rem;
        }
        .post-interactions {
            background-color: #f7f7f7;
            border-radius: 8px;
            padding: 5px;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        .post-likes {
            padding: 8px 10px;
            line-height: 1.5;
            color: var(--accent-color-deep);
            font-weight: 500;
            border-bottom: 1px solid #ededed;
        }
        .post-likes .fa-heart {
            margin-right: 8px;
        }
        .post-likes:empty {
            display: none;
        }
        .post-likes:empty + .post-comments-list {
            border-top: none; /* 如果没有点赞，评论区就不要有上边框 */
        }
        .post-footer .action-buttons-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .post-action-icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-medium);
        }
        .post-action-icon-btn.liked .fa-heart {
            color: var(--accent-color);
            font-weight: 900; /* 'fas' style */
        }
        .post-comment-item {
            padding: 8px 10px;
            line-height: 1.5;
        }
        .comment-author {
            color: var(--accent-color);
            font-weight: bold;
        }
        .comment-reply-to {
            color: var(--text-color-medium);
        }
        .post-comment-typing-indicator {
            padding: 8px 10px;
            color: var(--text-color-light);
            font-style: italic;
        }

        /* 评论输入框 */
        .comment-input-wrapper {
            display: none; /* 默认隐藏 */
            padding: 8px 10px;
            margin-top: 5px;
        }
        .comment-input-wrapper.active {
            display: flex; /* 点击评论按钮后显示 */
            gap: 8px;
        }
        .comment-input-wrapper input {
            flex-grow: 1;
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 8px 12px;
            font-size: 0.9rem;
            outline: none;
        }
        .comment-input-wrapper button {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 0 15px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* --- 15. 朋友圈转发卡片样式 --- */
        .bubble.forwarded-moment-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 250px;
            min-width: 220px;
        }
        .bubble.forwarded-moment-bubble:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        /* --- 核心针对所有主题，强制重置特殊消息的气泡样式 --- */
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.transfer-or-red-packet-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.card-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-moment-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.gift-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-history-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.bubble-emoji {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            margin: 0 !important;
            filter: none !important;
            white-space: normal !important; /* 新增：为特殊气泡重置换行行为 */
        }
        
        /* --- 核心专门禁用自定义CSS在特殊气泡上的伪元素 --- */
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.transfer-or-red-packet-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.transfer-or-red-packet-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.card-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.card-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-moment-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-moment-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.gift-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.gift-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-history-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-history-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.bubble-emoji::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.bubble-emoji::after {
            content: none !important;
        }
        

        /* --- 通用基础样式 --- */
        .bubble.transfer-or-red-packet-bubble,
        .bubble.card-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 280px;
        }
        .bubble.transfer-or-red-packet-bubble:not(.claimed):hover,
        .bubble.card-bubble:hover .card-message-wrapper {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        .bubble.card-bubble {
            max-width: 280px; /* 调整为 max-width */
        }

        .forwarded-moment-card-content {
            background-color: var(--text-color-white);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .forwarded-moment-card-content .card-title {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-color-dark) !important;
        }
        .forwarded-moment-card-content .card-preview {
            font-size: 0.8rem;
            color: var(--text-color-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .forwarded-moment-card-content .card-footer {
            font-size: 0.75rem;
            color: var(--text-color-light);
            border-top: 1px solid var(--border-color);
            padding-top: 8px;
            margin-top: 8px;
        }

        /* --- 朋友圈转发卡片详情弹窗样式 --- */
        .moment-detail-wrapper { padding: 20px 15px; }
        .moment-detail-wrapper .post-header { display: flex; align-items: center; gap: 15px; }
        .moment-detail-wrapper .post-avatar { width: 50px; height: 50px; border-radius: 8px; object-fit: cover; }
        .moment-detail-wrapper .post-author-info .name { font-size: 1.1rem; font-weight: 600; color: var(--accent-color-deep); }
        .moment-detail-wrapper .post-content-full { margin: 15px 0; font-size: 1rem; line-height: 1.7; white-space: pre-wrap; }
        .moment-detail-wrapper .post-image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 5px; margin: 15px 0; }
        .moment-detail-wrapper .post-image-grid img { width: 100%; height: 80px; object-fit: cover; border-radius: 6px; }
        .moment-detail-wrapper .post-footer-full { display: flex; justify-content: space-between; align-items: center; color: var(--text-color-light); font-size: 0.8rem; margin-bottom: 10px; }
        .moment-detail-wrapper .interactions-section { background-color: rgba(0,0,0,0.03); border-radius: 8px; font-size: 0.9rem; }
        .moment-detail-wrapper .likes-list { padding: 10px 12px; line-height: 1.5; color: var(--accent-color-deep); font-weight: 500; word-break: break-all; }
        .moment-detail-wrapper .likes-list .fa-heart { margin-right: 8px; }
        .moment-detail-wrapper .likes-list:empty + .comments-list { border-top: none; }
        .moment-detail-wrapper .comments-list { padding: 5px 0; border-top: 1px solid var(--border-color); }
        .moment-detail-wrapper .comment-item { padding: 8px 12px; line-height: 1.5; }
        .moment-detail-wrapper .comment-author { color: var(--accent-color); font-weight: bold; }
        .moment-detail-wrapper .comment-reply-to { color: var(--text-color-medium); }

        /* 
        =============================
        消息气泡样式 (来自参考文件)
        =============================
        */

        /* --- 通用基础样式 --- */
        .bubble.transfer-or-red-packet-bubble,
        .bubble.card-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 280px;
        }
        .bubble.transfer-or-red-packet-bubble:not(.claimed):hover,
        .bubble.card-bubble:hover .card-message-wrapper {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        .bubble.card-bubble {
            max-width: 280px; /* 调整为 max-width */
        }

        /* --- 卡片消息容器样式 --- */
        .card-message-wrapper {
            background-color: var(--text-color-white, white);
            border: 1px solid var(--border-color, #eee);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            color: var(--text-color-dark, #333);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card-message-wrapper h4,
        .card-message-wrapper p {
            margin: 0;
            padding: 0;
            line-height: 1.4;
        }
        .card-message-wrapper h4 {
            font-size: 1rem;
            font-weight: 600;
        }
        .card-message-wrapper p {
            font-size: 0.85rem;
            color: var(--text-color-light, #666);
        }

        /* --- 卡片详情展开样式 (修改后) --- */
        .bubble.card-bubble {
            position: relative; /* 为绝对定位的子元素提供参考 */
            overflow: visible;  /* 允许绝对定位的子元素溢出 */
            background: none; /* 卡片消息本身不需要背景 */
            padding: 0;       /* 移除内边距，由内部wrapper控制 */
            box-shadow: none; /* 移除阴影，由内部wrapper控制 */
        }
        .card-detail-content {
            position: absolute; /* 关键修改：脱离文档流 */
            top: 100%; /* 定位到可见卡片的正下方 */
            left: 0;
            width: 100%;
            z-index: 10; /* 确保在其他元素之上 */
            
            background-color: var(--text-color-white); /* 固定白色背景 */
            color: var(--text-color-dark); /* 固定深色字体 */
            border: 1px solid var(--border-color, #eee);
            border-radius: 12px; /* 给自己完整的圆角 */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); /* 独立的外阴影 */
            padding: 15px;

            max-height: 0; /* 默认隐藏 */
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.4s ease, padding-top 0.4s ease, padding-bottom 0.4s ease;
            box-sizing: border-box;
        }
        .card-detail-content.visible {
            max-height: 500px;
            opacity: 1;
        }
        /* 确保详情内的文字颜色不被外部气泡样式覆盖 */
        .card-detail-content h5, .card-detail-content p {
            color: var(--text-color-dark) !important;
        }

        /* --- 1. 新版转账样式 --- */
        .message-row.sent .transfer-content-v3 {
            background-color: #BEE3F8;
            color: #2A4365;
        }
        .message-row.received .transfer-content-v3 {
            background-color: #FFF0F5;
            color: var(--text-color-dark);
        }
        .transfer-content-v3 {
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            width: 100%;
            min-width: 200px; /* 设置最小宽度 */
            position: relative; /* 为伪元素定位 */
            overflow: hidden; /* 裁剪伪元素 */
            z-index: 1; /* 确保内容在背景之上 */
        }
        /* 确保内容在遮罩层之上 */
        .transfer-content-v3 > * {
            position: relative;
            z-index: 2;
        }
        /* 半透明白色遮罩，降低背景图饱和度 */
        .transfer-content-v3::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.65);
            z-index: 1;
        }
        .transfer-header-v3 {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 5px;
        }
        .transfer-icon-v3 {
            font-size: 22px;
        }
        .message-row.sent .transfer-icon-v3 { color: #3182CE; }
        .message-row.received .transfer-icon-v3 { color: #FF69B4; }

        .transfer-info-v3 h4 { margin: 0; font-size: 1em; font-weight: 500; }
        .transfer-info-v3 p { margin: 0; font-size: 1.2em; font-weight: 700; }
        .transfer-footer-v3 {
            border-top: 1px solid rgba(0,0,0,0.08);
            padding-top: 5px;
            margin-top: 5px;
            font-size: 0.75em;
            color: #777;
        }
        .bubble.claimed .transfer-content-v3 {
            background-color: #e0e0e0;
            opacity: 0.8;
        }

        /* --- 2. 新版红包样式 --- */
        .red-packet-v3-wrapper {
            width: 120px;
            height: 160px;
            position: relative;
        }
        .rp-cover-v3 {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            background-image: url('https://z.wiki/u/IDzEvp'); /* 已更换为新的默认封面 */
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* 让内容从底部开始对齐，为隐藏标题做准备 */
            padding: 10px;
            box-sizing: border-box;
        }
        .rp-title-v3 {
            display: none; /* 已隐藏红包封面上的标题 */
        }
        .open-button-v3 {
            width: 45px;
            height: 45px;
            background-color: var(--red-packet-gold);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            color: var(--red-packet-red);
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            animation: paw-pulse 2s infinite ease-in-out;
            align-self: center; /* 确保在 flex 布局中居中 */
            margin-bottom: 5px; /* 调整与底部距离 */
        }
        .claimed-overlay-v3 {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(2px);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--red-packet-red);
            font-weight: bold;
            font-size: 1rem;
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .bubble.claimed .claimed-overlay-v3 {
            opacity: 1;
        }
        .bubble.claimed .open-button-v3 {
            display: none; /* 领取后隐藏按钮 */
        }
        
        /* --- 3. 左图右文卡片 (通用分享) --- */
        .card-type-2 { display: flex; align-items: center; }
        .card-type-2 .card-image { width: 80px; height: 80px; object-fit: cover; flex-shrink: 0; }
        .card-type-2 .card-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 8px;
            flex-grow: 1;
            overflow: hidden;
        }
        .card-type-2 h4 { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* --- 4. 图标聚焦卡片 (位置分享) --- */
        .card-type-3 { display: flex; align-items: center; padding: 16px; gap: 15px; }
        .card-type-3 .card-icon-area {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--theme-color-1);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .card-type-3 .card-icon-area i { font-size: 1.8rem; color: var(--text-color-white, white); }
        .card-type-3 .card-content { flex-grow: 1; }

        /* --- 5. 文件下载卡片 --- */
        .card-type-9 { display: flex; align-items: center; padding: 15px; gap: 15px; }
        .card-type-9 .file-icon { font-size: 3rem; color: var(--theme-color-4); }
        .card-type-9 .file-info { flex-grow: 1; overflow: hidden; }
        .card-type-9 h4 { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card-type-9 .file-size { font-size: 0.8rem; color: var(--text-color-light); margin-top: 4px; }
        
        /* --- 6. 主动回复与时间戳样式 --- */

        .message-timestamp {
            font-size: 0.75rem;
            color: var(--text-color-light);
            margin-top: 5px;
            padding: 0 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .message-row.sent .message-timestamp {
            justify-content: flex-end;
        }
        .auto-reply-tag {
            font-size: 0.65rem;
            color: #1890FF;
            background-color: #E6F7FF;
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid #91D5FF;
        }
        /* --- 16. 主题设置页面 (新) --- */
        #page-theme-settings .page-content {
            padding: 15px;
            background-color: rgba(0,0,0,0.02); /* 给页面一个淡淡的底色 */
        }

        .theme-setting-card {
            background-color: rgba(255, 255, 255, 0.85); /* 移除模糊效果，适当增加不透明度以保证可读性 */
            /* backdrop-filter: blur(5px); <-- 移除性能消耗巨大的模糊效果 */
            border: 1px solid var(--border-color); /* 使用更柔和的通用边框颜色 */
            border-radius: 16px;
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* 使用更简单、性能更好的阴影 */
            transform: translateZ(0); /* 新增：开启硬件加速，让滚动更丝滑 */
        }
        .theme-setting-card h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--text-color-dark);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        .theme-setting-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .theme-page-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 12px; /* 按钮圆角 */
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s;
            background-color: var(--text-color-white);
            color: var(--text-color-dark);
            border: 1px solid var(--border-color);
        }
        .theme-page-btn:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        /* 颜色选择弹窗 */
        .color-palette-modal-body {
            display: flex;
            justify-content: space-around; /* 水平排列 */
            align-items: center;
            gap: 15px;
            padding: 20px 0;
        }
        .color-picker-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .color-picker-wrapper input[type="color"] {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            padding: 0;
        }
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }

        /* 上传组件 */
        .theme-upload-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        .theme-upload-preview-wrapper {
            position: relative;
            width: 120px;
            height: 80px;
            flex-shrink: 0;
        }
        .theme-upload-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
            background-color: #e9e9e9;
            border: 1px solid var(--border-color);
        }
        /* 羽化效果 */
        .theme-upload-preview-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            box-shadow: inset 0 0 10px 5px rgba(255, 255, 255, 0.9);
            pointer-events: none;
        }
        /* --- 17. 教程页面 (新) --- */
        #page-tutorial {
            background-color: #fff !important;
            background-image: none !important;
        }
        .tutorial-watermark {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.7rem;
            color: #d0d0d0;
            pointer-events: none;
            user-select: none;
            text-align: right; /* 让文字右对齐 */
        }

        /* --- 18. 旁白消息样式 (新) --- */
        .narrator-notice {
            align-self: center;
            padding: 4px 10px;
            border-radius: 10px;
            margin: 5px 0;
            max-width: 90%;
            word-wrap: break-word;
            text-align: left;
            line-height: 1.5;
            white-space: pre-wrap; /* 让换行符生效 */
        }
        .narrator-style-grey {
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            font-size: 0.75rem;
        }
        .narrator-style-white {
            background: rgba(255, 255, 255, 0.9);
            color: var(--text-color-dark);
            font-size: 0.85rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
        }
        .narrator-style-black {
            background: rgba(0, 0, 0, 0.75);
            color: var(--text-color-white);
            font-size: 0.85rem;
        }

        /* --- 拍一拍消息样式 (新) --- */
        .pat-notice {
            align-self: center;
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 10px;
            margin: 5px 0;
            cursor: default;
            user-select: none;
        }

        /* --- 19. 番茄钟 (新) --- */
        #page-pomodoro .page-content {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 30px;
        }

        .pomodoro-timer-display {
            font-size: 5rem;
            font-weight: bold;
            color: var(--text-color-dark);
            font-family: 'Courier New', Courier, monospace;
            letter-spacing: 2px;
        }

        .pomodoro-goal-input {
            width: 100%;
            max-width: 300px;
            text-align: center;
            border: none;
            border-bottom: 2px solid var(--border-color);
            background: transparent;
            padding: 10px;
            font-size: 1.2rem;
            outline: none;
            transition: border-color 0.3s;
        }
        .pomodoro-goal-input:focus {
            border-bottom-color: var(--accent-color);
        }

        .pomodoro-controls {
            display: flex;
            gap: 20px;
        }

        .pomodoro-btn {
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        .pomodoro-btn.start {
            background-color: var(--accent-color);
            color: white;
        }
        .pomodoro-btn.start:hover {
            background-color: var(--accent-color-deep);
            transform: translateY(-2px);
        }
        .pomodoro-btn.stop {
            background-color: #e74c3c;
            color: white;
        }
        .pomodoro-btn.stop:hover {
            background-color: #c0392b;
        }

        #pomodoro-float-ball {
            position: fixed;
            bottom: 150px; /* 向上移动了一点 */
            right: 20px;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.7); /* 降低了一点不透明度 */
            backdrop-filter: blur(10px); /* 增强模糊效果 */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* 增加了高光和更柔和的阴影，营造泡泡感 */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15), inset 0 2px 4px rgba(255, 255, 255, 0.5);
            cursor: grab; /* 提示可以抓取 */
            z-index: 1500;
            transition: opacity 0.3s, transform 0.3s;
            user-select: none; /* 防止长按选中文本 */
            -webkit-user-select: none; /* 兼容老浏览器 */
        }
        #pomodoro-float-ball.dragging {
            cursor: grabbing; /* 拖动时的手型 */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2); /* 拖动时阴影变大，有悬浮感 */
            transform: scale(1.05);
        }
        #pomodoro-float-ball.hidden {
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
        }
        #pomodoro-float-ball .progress-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(var(--accent-color) 0deg, #e0e0e0 0deg);
            z-index: -1;
        }
        #pomodoro-float-ball .time-left {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--text-color-dark);
        }

        .pomodoro-notification-banner {
            pointer-events: auto;
            position: relative;
            width: 48px;
            height: 48px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            color: #fff;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: width 0.5s cubic-bezier(0.65, 0, 0.35, 1);
        }
        .pomodoro-notification-banner.is-playing {
            animation: expand-toast 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }
        .pomodoro-notification-banner .icon-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .pomodoro-notification-banner.is-playing .icon-wrapper {
             animation: move-icon 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }
        .pomodoro-notification-banner .text-content {
            opacity: 0;
            white-space: nowrap;
            padding-left: 52px; /* 给图标留出空间 */
        }
        .pomodoro-notification-banner.is-playing .text-content {
            animation: show-text 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        /* --- 旁白设置选项样式 --- */
        .narrator-style-selector {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            padding: 10px 0;
        }
        .narrator-style-option {
            flex: 1;
            padding: 15px 10px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            border: 2px solid var(--border-color);
            transition: all 0.2s ease-in-out;
        }
        .narrator-style-option.selected {
            border-color: var(--accent-color);
            transform: scale(1.05);
            box-shadow: var(--shadow-light);
        }
        .narrator-style-option.grey-option { background: #ccc; color: white; }
        .narrator-style-option.white-option { background: white; color: #333; }
        .narrator-style-option.black-option { background: #333; color: white; }

        /* --- 20. 送礼物页面 (新) --- */
        #page-gifts .page-content {
            padding: 15px;
            /* 将背景色改为更灰的主背景色 */
            background-color: var(--bg-main); 
        }
        .gifts-search-container {
            /* 改为纵向排列 */
            display: flex;
            flex-direction: column; 
            gap: 15px; /* 增加行间距 */
            margin-bottom: 20px;
        }
        /* 为搜索和按钮行创建包裹层 */
        .gifts-search-container .search-row,
        .gifts-search-container .action-row {
            display: flex;
            width: 100%;
            gap: 10px;
        }
        /* 为长方形按钮设计样式 */
        .gifts-search-container .action-btn {
            flex: 1; /* 让按钮平分宽度 */
            width: auto; /* 覆盖 .gift-header-btn 的固定宽度 */
            height: auto; /* 覆盖 .gift-header-btn 的固定高度 */
            padding: 10px;
            border-radius: 12px; /* 增加圆角 */
            font-weight: 500;
            font-size: 0.9rem; /* 调整字体大小以适应按钮 */
            background-color: rgba(255, 255, 255, 0.85); /* 增加透明度 */
        }
        .gifts-search-container .search-bar-wrapper {
            flex-grow: 1;
            position: relative;
        }
        .gifts-search-container .search-bar-wrapper i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-color-light);
        }
        #gift-search-input {
            width: 100%;
            height: 45px;
            border-radius: 22.5px;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            padding: 0 20px 0 45px;
            font-size: 1rem;
            outline: none;
            transition: all 0.2s;
        }
        #gift-search-input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(167, 199, 231, 0.2);
        }
        #gift-search-refresh-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1rem;
            color: var(--text-color-medium);
            cursor: pointer;
        }
        #gift-search-refresh-btn:hover i {
            color: var(--accent-color);
        }
        .gift-header-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-color-medium);
            transition: all 0.2s;
        }
        .gift-header-btn:hover {
            background-color: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }
        .gifts-section-title {
            font-size: 1.2rem;
            color: var(--text-color-dark);
            margin-bottom: 15px;
            padding-left: 5px;
        }
        .gifts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
        }
        .gift-card {
            background-color: var(--text-color-white);
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .gift-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-medium);
        }
        .gift-card img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
            background-color: var(--theme-color-1);
        }
        .gift-card-info {
            padding: 10px;
        }
        .gift-card-info .name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 5px;
        }
        .gift-card-info .price {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--accent-color-deep);
        }
        .gift-loader {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px 0;
            color: var(--text-color-medium);
        }
        .gift-loader .loader-spinner {
            margin-bottom: 15px;
        }

        /* 礼物消息气泡样式 */
        .bubble.gift-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            max-width: 250px;
            width: 250px;
        }
        #app-container[class*="app-bubble-style-"] .bubble.gift-bubble {
            padding: 0 !important;
            background: none !important;
            border: none !important;
            box-shadow: none !important;
        }
        .gift-message-content {
            background: linear-gradient(135deg, #FFF7E0 0%, #FFE9D1 100%);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(255, 220, 180, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.5);
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .gift-message-content .gift-image {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
            flex-shrink: 0;
        }
        .gift-message-content .gift-info {
            flex-grow: 1;
            color: #8D6E63;
        }
        .gift-message-content .gift-info .gift-name {
            font-weight: bold;
            font-size: 1rem;
        }
        .gift-message-content .gift-info .gift-message {
            font-size: 0.85rem;
            margin-top: 4px;
            font-style: italic;
        }
        .gift-message-content .gift-info .gift-price {
            font-size: 0.8rem;
            margin-top: 6px;
            color: #D32F2F;
        }

        /* --- 21. 聊天记录转发 (新) --- */
        #page-chat.selection-mode-active .message-row,
        #page-chat.selection-mode-active .narrator-notice {
            padding-left: 45px;
            position: relative;
        }
        .message-selector {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            display: none;
        }
        #page-chat.selection-mode-active .message-selector {
            display: block;
        }
        .message-select-checkbox {
            width: 100%;
            height: 100%;
            accent-color: var(--accent-color);
        }

        #chat-selection-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-light);
            backdrop-filter: blur(5px);
            border-top: 1px solid var(--border-color);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 200;
            min-height: 100px; /* 设置一个最小高度来覆盖输入区 */
            box-sizing: border-box; /* 确保内边距不会影响总高度 */
        }
        #chat-selection-bar.visible {
            transform: translateY(0);
        }
        #chat-selection-bar .selection-info {
            font-size: 0.9rem;
            color: var(--text-color-medium);
        }
        #chat-selection-bar .selection-actions {
            display: flex;
            gap: 10px;
        }

        .bubble.forwarded-history-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 250px;
        }
        .bubble.forwarded-history-bubble:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }

        .forwarded-history-card-content {
            background-color: var(--text-color-white);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .forwarded-history-card-content .card-title {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-color-dark) !important;
        }
        .forwarded-history-card-content .card-preview {
            font-size: 0.8rem;
            color: var(--text-color-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .forwarded-history-card-content .card-footer {
            font-size: 0.75rem;
            color: var(--text-color-light);
            border-top: 1px solid var(--border-color);
            padding-top: 8px;
            margin-top: 8px;
        }

        #page-forwarded-history .page-content {
            background-color: var(--theme-color-1);
            padding: 20px 15px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #page-forwarded-history .message-row {
            max-width: 80%;
        }
        #page-forwarded-history .bubble-and-tag-wrapper {
            padding-bottom: 20px; /* 为时间戳留出空间 */
        }
        #page-forwarded-history .message-timestamp {
            position: absolute;
            bottom: 4px;
            left: 12px;
            font-size: 0.7rem;
            color: var(--text-color-light);
        }
        #page-forwarded-history .message-row.sent .message-timestamp {
            left: auto;
            right: 12px;
        }
        .forward-target-search-bar {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            margin-bottom: 10px;
            font-size: 1rem;
        }
        #chat-input-area {
            position: relative; /* 为遮罩层提供定位基准 */
        }
        #chat-selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(240, 240, 240, 0.85);
            backdrop-filter: blur(2px);
            z-index: 150;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            color: var(--text-color-medium);
            cursor: not-allowed;
        }
        #page-chat.selection-mode-active #chat-selection-overlay {
            display: flex;
        }
        #page-forwarded-history .message-name {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }
        #page-forwarded-history .message-name .sender-id {
            font-size: 0.7rem;
            color: var(--text-color-light);
            font-weight: normal;
        }
        
        #page-forwarded-history .page-content {
            background-color: var(--bg-main);
            background-image: none;
        }
        /* --- 22. 页面UI风格 (新) --- */
        .page-header > *,
        #bottom-nav > * {
            position: relative;
            z-index: 1;
        }

        .theme-setting-card .css-editor-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .theme-setting-card #custom-bubble-css-input {
            width: 100%;
            min-height: 200px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            background-color: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            resize: vertical;
            outline-color: var(--accent-color);
        }
        .theme-setting-card .editor-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .css-preview-area {
            padding: 20px;
            background-color: var(--theme-color-1);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .css-tutorial-code {
            background-color: #2d2d2d;
            color: #ccc;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            font-size: 0.85rem;
            position: relative;
            user-select: text;
            -webkit-user-select: text;
        }
        .css-tutorial-code .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #444;
            color: #eee;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .css-tutorial-code .copy-btn:hover {
            background-color: #555;
        }

        /* --- 23. 自定义气泡基础样式 (新) --- */
#app-container.app-bubble-style-custom .bubble {
    /* 这是一个“空白”样式，用于承载用户的自定义CSS，避免被其他内置样式干扰 */
    background: none;
    border: none;
    box-shadow: none;
    padding: 8px 12px; /* 保留一个基础的内边距，用户可以覆盖 */
    border-radius: 16px; /* 保留一个基础的圆角，用户可以覆盖 */
}

        /* --- 24. 公告弹窗样式 (新) --- */
        .announcement-modal-content {
            max-width: 480px; /* 公告可以宽一点 */
            background: #f9f9f9;
            border: 1px solid #ddd;
        }
        .announcement-modal-content .modal-header {
            font-size: 1.4rem;
            color: var(--text-color-dark);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }
        .announcement-modal-content .modal-body {
            line-height: 1.8;
            font-size: 0.95rem;
            color: #444;
        }
        .announcement-modal-content .modal-body h4 {
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: var(--text-color-dark);
        }
        .announcement-modal-content .modal-body p {
            margin-bottom: 15px;
        }
        .announcement-page {
            display: none;
        }
        .announcement-page.active {
            display: block;
        }
        .announcement-auth-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px 15px;
            font-size: 0.9rem;
            color: var(--text-color-medium);
            padding: 10px;
            background-color: rgba(0,0,0,0.02);
            border-radius: 8px;
        }
        .announcement-warning {
            font-size: 0.85rem;
            color: #c0392b;
            margin-top: 15px;
            font-weight: bold;
        }
        .announcement-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }
        .announcement-nav .page-indicator {
            font-size: 0.9rem;
            color: var(--text-color-light);
        }
        .announcement-nav .nav-btn {
            padding: 6px 15px;
            font-size: 0.9rem;
        }

        /* --- API配置页面样式 --- */
        #page-api-settings .form-group {
            background: white;
            padding: 18px 15px;
            margin: 0 0 1px;
        }
        #page-api-settings .settings-list {
            padding-top: 10px;
        }
        .api-key-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 10px 0;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
        }
        .api-key-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f9f9f9;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
        }
        .api-key-item .key-value {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 70%;
        }
        .api-key-item .delete-key-btn {
            background: none;
            border: none;
            color: #e74c3c;
            cursor: pointer;
            font-size: 1rem;
        }
        .api-key-add-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .api-key-add-form input {
            flex-grow: 1;
        }

        .api-key-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .api-key-header .header-icon {
            padding: 5px;
            cursor: pointer;
        }

        #announcement-close-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            color: #666;
        }

        /* --- 聊天设置页面美化 --- */
        #page-chat-settings .settings-list {
            padding: 10px;
            background-color: var(--bg-main);
        }
        #page-chat-settings .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.8); /* 移除模糊效果，适当增加不透明度以保证可读性 */
            /* backdrop-filter: blur(8px); <-- 移除性能消耗巨大的模糊效果 */
            border: 1px solid var(--border-color); /* 使用更柔和的通用边框颜色 */
            box-shadow: var(--shadow-light); /* 使用更简单、性能更好的阴影 */
            margin-bottom: 15px;
            border-radius: 16px;
            gap: 15px;
            transform: translateZ(0); /* 新增：开启硬件加速，让滚动更丝滑 */
        }
        #page-chat-settings .setting-item span {
            font-size: 1rem; /* 统一标题字体大小 */
        }
        #page-chat-settings .setting-item input[type="number"] {
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            border-radius: 10px; /* 增加圆角 */
            font-size: 1rem;
            font-family: var(--font-main);
            outline-color: var(--accent-color);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05); /* 增加内阴影 */
            transition: all 0.2s;
        }
        #page-chat-settings .setting-item input[type="number"]:focus {
            border-color: var(--accent-color);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05), 0 0 0 3px rgba(167, 199, 231, 0.3); /* 聚焦效果 */
        }

</style>
</head>
<body>
    <!-- 开屏动画 -->
    <div id="splash-screen">
        <div class="splash-logo">33聊天室</div>
        <div class="splash-loader"></div>
        <p style="position: absolute; bottom: 20px; font-size: 12px; color: #aaa; user-select: none;">此聊天室(v2.0.4)由33制作，xhs:@回风</p>
    </div>
    <div id="app-container">
        <!-- 顶部浮窗通知容器 -->
        <div id="top-notification-container"></div>
        <!-- 主内容区域 -->
        <main id="main-content">
            <!-- 消息列表页面 -->
            <div id="page-messages" class="page active">
                <div class="page-header">
                    <img id="my-avatar" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=" alt="My Avatar">
                    <h1>消息</h1>
                    <a href="https://www.xiaohongshu.com/user/profile/5e65e0f00000000001002837?xsec_token=YBen3b8AVcwS9WjKSzS_xETWKfb3hsoxlS1uX8KTmQLSU%3D&xsec_source=app_share&xhsshare=CopyLink&appuid=5e65e0f00000000001002837&apptime=1751753800&share_id=a6aa049960ff46489ba8080e8cc476d0&share_channel=copy_link" target="_blank" id="header-link-btn">
                        <i class="fas fa-lightbulb"></i>
                    </a>
                </div>
                <div class="page-content">
                    <ul id="message-list-ul" class="message-list">
                        <!-- 消息项将由JS动态生成 -->
                    </ul>
                </div>
            </div>

            <!-- 通讯录页面 -->
            <div id="page-contacts" class="page">
                <div class="page-header">
                    <div class="header-icon" style="visibility: hidden;"></div> <!-- 占位符 -->
                    <h1>通讯录</h1>
                    <div class="header-icon-group">
                        <div id="batch-delete-btn" class="header-icon" title="批量删除"><i class="fas fa-minus-circle"></i></div>
                        <div id="add-menu-btn" class="header-icon" title="添加"><i class="fas fa-plus"></i></div>
                    </div>
                </div>
                <div class="tabs">
                    <button class="tab-btn active" data-tab="friends">好友</button>
                    <button class="tab-btn" data-tab="groups">群聊</button>
                    <button class="tab-btn" data-tab="friendFolders">分组</button>
                </div>
                <div class="page-content" style="padding: 0 15px;">
                    <div id="contacts-friends" class="contact-section active">
                        <div class="contact-list-header">
                            <span id="sort-friends-btn" class="sort-btn">排序 <i class="fas fa-sort"></i></span>
                        </div>
                        <ul id="friends-list-ul" class="contact-list"></ul>
                    </div>
                    <div id="contacts-groups" class="contact-section">
                        <div class="contact-list-header">
                            <span id="sort-groups-btn" class="sort-btn">排序 <i class="fas fa-sort"></i></span>
                        </div>
                        <ul id="groups-list-ul" class="contact-list"></ul>
                    </div>
                    <div id="contacts-friend-folders" class="contact-section">
                        <!-- Content will be generated by JS -->
                    </div>
                </div>
                <div id="selection-action-bar" class="page-footer" style="display: none; justify-content: space-between; padding: 10px 15px; background: white; border-top: 1px solid var(--border-color);">
                    <button id="select-all-btn" class="modal-btn btn-secondary" style="padding: 8px 20px;">全选</button>
                    <button id="cancel-selection-btn" class="modal-btn btn-secondary" style="padding: 8px 20px;">取消</button>
                    <button id="delete-selected-btn" class="modal-btn btn-danger" style="padding: 8px 20px;">删除已选</button>
                </div>
            </div>

            <!-- 设置页面 -->
            <div id="page-settings" class="page">
                <div class="page-header">
                    <h1>设置</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="setting-tutorial">
                            <i class="fas fa-question-circle"></i>
                            <span>33食用指南</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <!-- 新增的聊天设置项 -->
                        <div class="setting-item" id="setting-chat">
                            <i class="fas fa-comments"></i>
                            <span>聊天设置</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-api">
                            <i class="fas fa-server"></i>
                            <span>API 配置</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-prompts">
                            <i class="fas fa-magic"></i>
                            <span>自定义提示词</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-theme">
                            <i class="fas fa-palette"></i>
                            <span>主题设置</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-bubble">
                            <i class="fas fa-comment-alt"></i>
                            <span>气泡设置</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-data-management">
                            <i class="fas fa-database"></i>
                            <span>导入/导出全部数据</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                         <div class="setting-item" id="setting-reset">
                            <i class="fas fa-trash-alt"></i>
                            <span>重置应用</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 聊天设置页面 (新) -->
            <div id="page-chat-settings" class="page">
                <div class="page-header">
                    <div id="chat-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>聊天设置</h1>
                </div>
                <div class="page-content" id="chat-settings-content">
                    <!-- 设置项将由JS动态生成 -->
                </div>
                <div class="page-footer" style="padding: 10px; text-align: center; border-top: 1px solid var(--border-color); background: rgba(255,255,255,0.5);">
                    <button id="save-chat-settings-btn" class="modal-btn btn-primary" style="width: 90%;"><i class="fas fa-save"></i> 保存设置</button>
                </div>
            </div>

            <!-- API配置页面 (新) -->
            <div id="page-api-settings" class="page">
                <div class="page-header">
                    <div id="api-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>API 配置</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="form-group" style="padding: 0 15px;">
                            <label for="api-provider">API提供商</label>
                            <select id="api-provider">
                                <!-- Options will be generated by JS -->
                            </select>
                        </div>
                        <div class="form-group" style="padding: 0 15px;">
                            <label for="api-url">API URL</label>
                            <input type="text" id="api-url" placeholder="输入API URL">
                        </div>

                        <div class="form-group" style="padding: 0 15px;">
                            <div class="api-key-header">
                                <label>API Keys (<span id="api-key-count">0</span>)</label>
                                <div id="toggle-all-keys-visibility" class="header-icon" title="显示/隐藏"><i class="fas fa-eye"></i></div>
                            </div>
                            <div id="api-key-list" class="api-key-list">
                                <!-- Keys will be generated by JS -->
                            </div>
                            <div class="api-key-add-form">
                                <input type="password" id="new-api-key-input" placeholder="添加新Key...">
                                <button id="add-api-key-btn" class="modal-btn btn-primary" style="padding: 8px 15px; border-radius: 8px;">添加</button>
                            </div>
                        </div>

                        <div class="form-group" style="padding: 0 15px;">
                            <label for="api-model-select">模型</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="api-model-select" style="flex-grow: 1;"></select>
                                <input type="text" id="api-model-input" placeholder="输入自定义模型名称" style="display:none; flex-grow: 1;">
                                <button id="fetch-models-btn" class="modal-btn btn-secondary" style="padding: 8px 15px; flex-shrink: 0;">获取</button>
                            </div>
                        </div>
                        <div class="form-group" style="padding: 0 15px;">
                            <label for="temperature">温度 (0-1)</label>
                            <input type="number" id="temperature" min="0" max="1" step="0.1">
                        </div>
                    </div>
                </div>
                <div class="page-footer" style="padding: 10px; text-align: center; border-top: 1px solid var(--border-color); background: rgba(255,255,255,0.5);">
                    <button id="save-api-settings-btn" class="modal-btn btn-primary" style="width: 90%;"><i class="fas fa-save"></i> 保存配置</button>
                </div>
            </div>
            
            <!-- 聊天页面 -->
            <div id="page-chat" class="page">
                <div class="page-header">
                    <div id="chat-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <div class="header-title-wrapper">
                        <h1 class="header-title" id="chat-title"></h1>
                        <div class="typing-indicator-container" id="chat-typing-indicator">
                            <span>对方正在输入...</span>
                        </div>
                    </div>
                    <div class="header-icon-group">
                        <div id="chat-insight-btn" class="header-icon" title="角色洞察"><i class="fas fa-clover"></i></div>
                        <div id="chat-manage-btn" class="header-icon"><i class="fas fa-ellipsis-v"></i></div> 
                    </div>
                </div>
                <div class="chat-area" id="chat-area">
                    <div id="history-loader"><div class="loader-spinner"></div></div>
                    <!-- 消息气泡将由JS动态生成 -->
                </div>
                <div class="chat-input-area" id="chat-input-area">
                    <!-- 引用预览区域 -->
                    <div class="quote-preview-area" id="quote-preview-area">
                        <div class="quote-preview-content" id="quote-preview-content"></div>
                        <button class="cancel-quote-btn" id="cancel-quote-btn" title="取消引用">×</button>
                    </div>

                    <!-- 输入和发送行 -->
                    <div class="input-top-row">
                        <button id="ai-request-btn"><i class="fas fa-feather-alt"></i></button>
                        <textarea id="message-input" placeholder="输入消息..." rows="1"></textarea>
                        <button id="send-btn"><i class="fas fa-paper-plane"></i></button>
                    </div>

                    <!-- 功能按钮行 -->
                    <div class="input-feature-row-wrapper">
                        <div class="input-feature-row">
                            <button class="feature-btn" id="emoji-btn" title="发送表情"><i class="fas fa-smile"></i></button>
                            <button class="feature-btn" id="favorite-emoji-btn" title="收藏的表情"><i class="fas fa-star"></i></button>
                            <button class="feature-btn" id="voice-btn" title="发送语音"><i class="fas fa-microphone"></i></button>
                            <button class="feature-btn" id="transfer-btn" title="转账"><i class="fas fa-exchange-alt"></i></button>
                            <button class="feature-btn" id="red-packet-btn" title="发红包"><i class="fas fa-wallet"></i></button>
                            <button class="feature-btn" id="simulated-image-btn" title="图文消息"><i class="fas fa-image"></i></button>
                            <button class="feature-btn" id="image-vision-btn" title="发送图片 (AI识图)"><i class="fas fa-camera"></i></button>
                            <button class="feature-btn" id="gift-btn" title="送礼物"><i class="fas fa-gift"></i></button>
                            <button class="feature-btn" id="card-btn" title="发送卡片"><i class="fas fa-share-square"></i></button>
                            <button class="feature-btn" id="edit-last-reply-btn" title="编辑最新AI回复"><i class="fas fa-pencil-alt"></i></button>
                            <button class="feature-btn" id="delete-last-turn-btn" title="删除最新一轮回复"><i class="fas fa-eraser"></i></button>
                        </div>
                    </div>
                    <!-- 表情包面板 (默认隐藏) -->
                    <div class="emoji-card" id="emoji-card">
                        <div class="emoji-grid" id="emoji-grid"></div>
                        <div class="emoji-nav">
                            <button id="emoji-prev-btn"><i class="fas fa-chevron-left"></i></button>
                            <span id="emoji-page-indicator"></span>
                            <button id="emoji-next-btn"><i class="fas fa-chevron-right"></i></button>
                        </div>
                    </div>
                    <!-- 收藏表情包面板 (默认隐藏) -->
                    <div class="emoji-card" id="favorite-emoji-card">
                        <div class="emoji-grid" id="favorite-emoji-grid"></div>
                        <div class="emoji-nav" style="display: none;">
                            <button id="favorite-emoji-prev-btn"><i class="fas fa-chevron-left"></i></button>
                            <span id="favorite-emoji-page-indicator"></span>
                            <button id="favorite-emoji-next-btn"><i class="fas fa-chevron-right"></i></button>
                        </div>
                    </div>
                </div>
            </div>

                <div id="chat-selection-overlay">
                    <span>请先完成或取消转发</span>
                </div>

                <!-- 聊天选择操作栏 (新) -->
                <div id="chat-selection-bar">
                    <span id="selection-info" class="selection-info">已选择 0 条</span>
                    <div class="selection-actions">
                        <button id="cancel-forward-btn" class="modal-btn btn-secondary" style="padding: 8px 15px;">取消</button>
                        <button id="delete-selected-messages-btn" class="modal-btn btn-danger" style="padding: 8px 15px;">删除</button>
                        <button id="confirm-forward-btn" class="modal-btn btn-primary" style="padding: 8px 15px;">转发</button>
                    </div>
                </div>

            <!-- 自定义提示词页面 -->
            <div id="page-prompts" class="page">
                <div class="page-header">
                    <div id="prompts-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>自定义提示词</h1>
                    <div id="prompt-header-actions" style="display: flex; gap: 15px; justify-self: end; padding-right: 15px;">
                        <div id="import-prompts-btn" class="header-icon" title="导入"><i class="fas fa-download"></i></div>
                        <div id="export-prompts-btn" class="header-icon" title="导出"><i class="fas fa-upload"></i></div>
                        <div id="add-prompt-folder-btn" class="header-icon" title="新建文件夹"><i class="fas fa-folder-plus"></i></div>
                    </div>
                </div>
                <div class="page-content" id="prompts-page-content">
                    <!-- 文件夹和提示词将由JS动态生成 -->
                </div>
                <div class="page-footer" style="padding: 10px; text-align: center; border-top: 1px solid var(--border-color); background: rgba(255,255,255,0.5);">
                    <button id="add-new-prompt-btn" class="modal-btn btn-primary" style="width: 90%;"><i class="fas fa-plus-circle"></i> 新建提示词</button>
                </div>
            </div>

            <!-- 发现页面 -->
            <div id="page-discover" class="page">
                <div class="page-header">
                    <h1>发现</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="nav-to-moments">
                            <i class="fas fa-camera-retro"></i>
                            <span>朋友圈</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="nav-to-pomodoro">
                            <i class="fas fa-clock"></i>
                            <span>番茄钟</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>

                        <div class="setting-item" id="setting-wish-pool">
                            <i class="fas fa-heart"></i>
                            <span>角色许愿池</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 主题设置页面 (新) -->
            <div id="page-theme-settings" class="page">
                <div class="page-header">
                    <div id="theme-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>主题设置</h1>
                </div>
                <div class="page-content" id="theme-settings-content">
                    <!-- 卡片内容将由JS动态生成 -->
                </div>
            </div>

            <!-- 气泡设置页面 (新) -->
            <div id="page-bubble-settings" class="page">
                <div class="page-header">
                    <div id="bubble-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>气泡设置</h1>
                </div>
                <div class="page-content" id="bubble-settings-content">
                    <!-- 内容将由JS动态生成 -->
                </div>
            </div>

            <!-- 朋友圈页面 -->
            <div id="page-moments" class="page">
                <!-- 新增的包裹层 -->
                <div id="moments-wrapper">
                    <div class="page-header">
                        <div id="moments-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                        <div id="moments-actions-group">
                             <div id="moments-refresh-btn" class="header-icon"><i class="fas fa-sync-alt"></i></div>
                             <div id="moments-new-post-btn" class="header-icon"><i class="fas fa-camera"></i></div>
                             <div id="moments-manage-btn" class="header-icon"><i class="fas fa-bars"></i></div>
                        </div>
                    </div>
                    <div class="page-content">
                        <div class="moments-header-container">
                            <img id="moments-bg" src="https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png" alt="朋友圈背景">
                            <div class="moments-profile-info">
                                <span id="moments-my-name" class="name">你的名字</span>
                                <img id="moments-my-avatar" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=" alt="你的头像" class="avatar">
                            </div>
                        </div>
                        <ul id="moments-list">
                            <!-- 朋友圈动态将由JS动态生成 -->
                        </ul>
                    </div>
                </div> <!-- 新增的包裹层闭合标签 -->
            </div>
            <!-- 教程页面 (新) -->
            <div id="page-tutorial" class="page">
                <div class="page-header">
                    <div id="tutorial-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>教程</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="setting-announcement">
                            <i class="fas fa-bullhorn"></i>
                            <span>游玩提醒公告</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-api">
                            <i class="fas fa-key"></i>
                            <span>如何配置API</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-character">
                            <i class="fas fa-user-plus"></i>
                            <span>如何创建新角色</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-group">
                            <i class="fas fa-users"></i>
                            <span>如何创建群聊</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-chatting">
                            <i class="fas fa-comment-alt"></i>
                            <span>如何进行聊天</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-opening-scene">
                            <i class="fas fa-scroll"></i>
                            <span>开场白是什么？</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-prompts">
                            <i class="fas fa-magic"></i>
                            <span>提示词是什么？</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                         <div class="setting-item" id="tutorial-import-export">
                            <i class="fas fa-exchange-alt"></i>
                            <span>如何导入导出</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-emoji">
                            <i class="fas fa-smile-wink"></i>
                            <span>如何新增/删除表情包</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-persona">
                            <i class="fas fa-user-tag"></i>
                            <span>玩家人设及绑定</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-narrator">
                            <i class="fas fa-theater-masks"></i>
                            <span>旁白如何使用</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-moments">
                            <i class="fas fa-camera-retro"></i>
                            <span>朋友圈如何使用</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-theme">
                            <i class="fas fa-palette"></i>
                            <span>如何设置主题</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                    <div class="tutorial-watermark">
                        <span>此聊天室由33制作，xhs:@回风。</span><br>
                        <span style="font-size: 0.9em; opacity: 0.8;">功能反馈与新功能需求可联系我噢⌯>ᴗo⌯ .ᐟ.ᐟ</span>
                    </div>
                </div>
            </div>
            
            <!-- 番茄钟页面 (新) -->
            <div id="page-pomodoro" class="page">
                <div class="page-header">
                    <div id="pomodoro-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>番茄钟</h1>
                </div>
                <div class="page-content">
                    <div id="pomodoro-timer-display" class="pomodoro-timer-display">25:00</div>
                    <input type="text" id="pomodoro-goal-input" class="pomodoro-goal-input" placeholder="输入本次专注的目标...">
                    <div class="pomodoro-controls">
                        <button id="pomodoro-start-btn" class="pomodoro-btn start">开始专注</button>
                        <button id="pomodoro-stop-btn" class="pomodoro-btn stop" style="display: none;">停止</button>
                    </div>
                </div>
            </div>

            <!-- 送礼物页面 (新) -->
            <div id="page-gifts" class="page">
                <div class="page-header">
                    <div id="gifts-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>送礼物</h1>
                </div>
                <div class="page-content" id="gifts-page-content">
                    <div class="gifts-search-container">
                        <!-- 第一行：搜索框和刷新 -->
                        <div class="search-row">
                             <div class="search-bar-wrapper">
                                <i class="fas fa-search"></i>
                                <input type="text" id="gift-search-input" placeholder="搜索礼物送给TA...">
                                <button id="gift-search-refresh-btn" style="display: none;"><i class="fas fa-sync-alt"></i></button>
                            </div>
                        </div>
                        <!-- 第二行：功能按钮 -->
                        <div class="action-row">
                             <button id="gift-api-config-btn" class="gift-header-btn action-btn"><i class="fas fa-cog" style="margin-right: 5px;"></i> API配置</button>
                             <button id="custom-gift-btn" class="gift-header-btn action-btn"><i class="fas fa-magic" style="margin-right: 5px;"></i> 自定义</button>
                             <button id="gift-bind-prompt-btn" class="gift-header-btn action-btn"><i class="fas fa-link" style="margin-right: 5px;"></i> 绑定</button>
                             <button id="gift-help-btn" class="gift-header-btn action-btn"><i class="fas fa-question-circle" style="margin-right: 5px;"></i> 帮助</button>
                             <button id="gift-cancel-search-btn" class="gift-header-btn action-btn" style="display:none;"><i class="fas fa-times" style="margin-right: 5px;"></i> 取消搜索</button>
                        </div>
                    </div>
                    <h3 class="gifts-section-title" id="gifts-section-title">大家都在送</h3>
                    <div class="gifts-grid" id="gifts-grid">
                        <!-- 礼物卡片将由JS动态生成 -->
                        <div class="gift-loader" style="display: none;">
                            <div class="loader-spinner"></div>
                            <p>正在努力寻找礼物...</p>
                        </div>
                    </div>
                </div>
            </div>

        </main>

            <!-- 转发历史页面 (新) -->
            <div id="page-forwarded-history" class="page">
                <div class="page-header">
                    <div id="forwarded-history-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1 id="forwarded-history-title">聊天记录</h1>
                </div>
                <div class="page-content" id="forwarded-history-content">
                    <!-- 转发的消息将在这里渲染 -->
                </div>
            </div>

        <!-- 底部导航 -->
        <nav id="bottom-nav">
            <div class="nav-item active" data-page="messages">
                <i class="fas fa-comment-dots"></i>
                <span>消息</span>
            </div>
            <div class="nav-item" data-page="contacts">
                <i class="fas fa-address-book"></i>
                <span>通讯录</span>
            </div>
            <div class="nav-item" data-page="discover">
                <i class="fas fa-compass"></i>
                <span>发现</span>
            </div>
            <div class="nav-item" data-page="settings">
                <i class="fas fa-cog"></i>
                <span>设置</span>
            </div>
        </nav>
    </div>


    <!-- 模态框 -->
    <input type="file" id="font-file-input" accept=".ttf,.otf,.woff,.woff2" style="display: none;">
    <input type="file" id="import-data-input" accept=".json" style="display: none;">
    <input type="file" id="import-presets-input" accept=".json" style="display: none;">
    <div id="modal-overlay">
        <div id="modal-content-wrapper" class="modal-content">
            <!-- 模态框内容将由JS动态生成 -->
        </div>
    </div>
    
    <!-- 点击特效层 -->
    <div id="click-effect-layer"></div>

    <!-- 番茄钟悬浮球 -->
    <div id="pomodoro-float-ball" class="hidden">
        <div class="progress-ring"></div>
        <span class="time-left">25:00</span>
    </div>
    
    <!-- 个人信息侧边栏 -->
    <div id="sidebar-overlay">
        <div id="sidebar-content">
            <!-- 侧边栏内容将由JS动态生成 -->
        </div>
    </div>

    <!-- 底部选择器 -->
    <div id="bottom-sheet-overlay">
        <div id="bottom-sheet-content-wrapper" class="bottom-sheet-content">
             <!-- 内容将由JS动态生成 -->
        </div>
    </div>

    <input type="file" id="moments-bg-input" accept="image/*" style="display: none;">
    <input type="file" id="import-prompts-input" accept=".json" style="display: none;">

<script>
    
    (function() {
        'use strict';

        
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);
        
        const appContainer = $('#app-container');
        const mainContent = $('#main-content');
        const bottomNav = $('#bottom-nav');
        const modalOverlay = $('#modal-overlay');
        const modalContentWrapper = $('#modal-content-wrapper');
        const clickEffectLayer = $('#click-effect-layer');
        
        
        const pages = {
            messages: $('#page-messages'),
            contacts: $('#page-contacts'),
            discover: $('#page-discover'),
            moments: $('#page-moments'),
            tutorial: $('#page-tutorial'),
            pomodoro: $('#page-pomodoro'),
            gifts: $('#page-gifts'),
            'chat-settings': $('#page-chat-settings'),
            settings: $('#page-settings'),
            'api-settings': $('#page-api-settings'),
            'theme-settings': $('#page-theme-settings'),
            'bubble-settings': $('#page-bubble-settings'),
            chat: $('#page-chat'),
            prompts: $('#page-prompts'),
            'forwarded-history': $('#page-forwarded-history'),
        };

        
        const chatTitle = $('#chat-title');
        const chatTypingIndicator = $('#chat-typing-indicator');
        const chatArea = $('#chat-area');
        const aiRequestBtn = $('#ai-request-btn');
        const messageInput = $('#message-input');
        const sendBtn = $('#send-btn');
        const chatBackBtn = $('#chat-back-btn');
        
        const emojiBtn = $('#emoji-btn');
        const voiceBtn = $('#voice-btn');
        const emojiCard = $('#emoji-card');
        const emojiGrid = $('#emoji-grid');
        const quotePreviewArea = $('#quote-preview-area');
        const quotePreviewContent = $('#quote-preview-content');
        const cancelQuoteBtn = $('#cancel-quote-btn');
        const favoriteEmojiBtn = $('#favorite-emoji-btn');
        const favoriteEmojiCard = $('#favorite-emoji-card');
        const favoriteEmojiGrid = $('#favorite-emoji-grid');
        const chatInputArea = $('#chat-input-area');
        
        const BUILTIN_AI_EMOJIS = {
            'iazCCF': '谁在喊本大王','xPHzNC': '尊嘟假嘟','7kVeZJ': '我操','pCQgk2': '老子生气了','IUg8vO': '吃瓜群众','Il6dL9': '对不起','vjEl6R': '花花送你','werDxS': '抱抱我','Ms5AEa': '委屈(可爱)','QX7VnJ': '安慰','nHcfqI': '卖萌(可爱)','oztxES': '比心(可爱)','GOl2dp': '请和我约会','BuD0Gy': '你是狗','jcisbx': '我只是一只狗','Zo82H7': '每天都想你(卖萌)','CcIWXl': '假装无辜(可爱)','zSBHMm': '肯定(可爱)','CIWud3': '谁愿意收留我(可爱)','HOAcPN': '谄媚(可爱)','GP1VJ3': '家里交给我吧(可爱)','BISbnP': '泪了','asnj6B': '试探(可爱)','htNZls': '懂得都懂','2q5VbM': '就你小子是吧(嚣张)','sd0yQX': '放心交给我，我会搞砸的(沙雕)','E0PrxD': '皇帝驾到(沙雕)','7vgm7D': '皇帝驾崩(沙雕)','lPgzpQ': '诛你九族(龙图)','j2d9di': '骂朕，满门抄斩！','hKyKwP': '奴才谢主隆恩(龙图)','IkZP8N': '我饿了','osIpSG': '怎么不回我消息','IgfF9w': '快理我(委屈可爱)','wb63Ag': '等下讲你你又不高兴(吐槽)','8CCMsJ': '我靠，你爱不爱我','34LcOG': '指指点点','hDpVH8': '我吗？(懵逼)','1RcY8W': '注意你的态度','6cIfGp': '急得蹬腿','m1zzxd': '不想活了(沙雕)','YqlPWK': '你和我这个神经病计较什么','LokqQT': '你很牛吗？','qHSXVP': '妈的，被看扁了','CUOA6Y': '令人火大','3jc0XI': '不想活了(可爱)','qZxeWV': '你快哄我(可爱)','3iYdgX': '我被哄好了(可爱)','ZNzgpY': '你就是很好很好(可爱)','PCLA8G': '我好想你吖(委屈可爱)','i0UYTS': '你瞧不起我(委屈)','VWwt5c': '我想要这个(可爱)','SIWqFT': '得意','ff8JWS': '我萎了','oiMaM6': '你精神正常吗','LIQKcy': '想死','EhcgEa': '被看穿了','vnDXiy': '怎么你要打死我吗(犯贱)','71bINa': '你少看扁我(自嘲熊)','gcubY9': 'tui(吐口水)','r1lada': '你太粘人了_把你拿去粘老鼠','y6ldmK': '很不高兴为你服务','yrVneI': '真贱啊','dP6HDY': '你自首吧','jjyR6G': '你是猪','WfSWCe': '你他妈谁啊','B0S4LA': '蒙圈'
        };
        const BUILTIN_PLAYER_EMOJIS = {
            'iazCCF': '谁在喊本大王','xPHzNC': '尊嘟假嘟','7kVeZJ': '我操','pCQgk2': '老子生气了','IUg8vO': '吃瓜群众','Il6dL9': '对不起','vjEl6R': '花花送你','werDxS': '抱抱我','Ms5AEa': '委屈(可爱)','QX7VnJ': '安慰','nHcfqI': '卖萌(可爱)','oztxES': '比心(可爱)','GOl2dp': '请和我约会','BuD0Gy': '你是狗','jcisbx': '我只是一只狗','Zo82H7': '每天都想你(卖萌)','CcIWXl': '假装无辜(可爱)','zSBHMm': '肯定(可爱)','CIWud3': '谁愿意收留我(可爱)','HOAcPN': '谄媚(可爱)','GP1VJ3': '家里交给我吧(可爱)','BISbnP': '泪了','asnj6B': '试探(可爱)','htNZls': '懂得都懂','2q5VbM': '就你小子是吧(嚣张)','sd0yQX': '放心交给我，我会搞砸的(沙雕)','E0PrxD': '皇帝驾到(沙雕)','7vgm7D': '皇帝驾崩(沙雕)','lPgzpQ': '诛你九族(龙图)','j2d9di': '骂朕，满门抄斩！','hKyKwP': '奴才谢主隆恩(龙图)','IkZP8N': '我有点饿了','osIpSG': '怎么不回我消息','Lt1f9K': '特别特别饿','IgfF9w': '快理我(委屈)','wb63Ag': '等下讲你你又不高兴(吐槽)','s9xWmu': '你是个坏东西','8CCMsJ': '我靠，你爱不爱我','34LcOG': '指指点点','hDpVH8': '我吗？(懵逼)','1RcY8W': '注意你的态度','6cIfGp': '急得蹬腿','kRdQhe': '偷听','3jc0XI': '不想活了(可爱)','m1zzxd': '不想活了(沙雕)','YqlPWK': '你和我这个神经病计较什么','LokqQT': '你很牛吗？','4ZkXRx': '他们都欺负我','qZxeWV': '你快哄我','3iYdgX': '我被哄好了(可爱)','qHSXVP': '妈的，被看扁了','278MJW': '不努力就会成为女人的玩物','mzqDku': '我喜欢你(害羞)','dnzCAP': '什么都想和你说','ZNzgpY': '你就是很好很好(可爱)','PCLA8G': '我好想你吖(委屈)','sf7Egt': '我去洗澡啦(可爱)','i0UYTS': '你瞧不起我(委屈)','VWwt5c': '我想要这个','hMTJRH': '和你贴贴','CUOA6Y': '令人火大','Y06FYQ': '我是小孩，让我(可爱)','lFpXLU': '再叫剪了你的小鸡鸡','RaogpF': '没办法人家就是好色嘛','7a48eQ': '你怎么鸡8小小的，说话吊吊的','N3ZzUs': '拿来吧你','oGFqYZ': '出来亲嘴','Z3glHK': '停止思考','9RWtTB': '你人真好，都想和你谈恋爱了','KNRPfQ': '没人爱我(杰瑞猫表情)','bpyimG': '起了杀心','DOwyrR': '给你点了(赞同,抽象)','fd1o0q': '我是国家一级保护废物(猫咪葛优瘫)','0liCnk': '中(肯定的意思)','wTC4Ha': '完力(完了)','n0Ll5b': '无力','SIWqFT': '得意','2up6Um': '嘎嘎大笑','tLsCTf': '不许笑了','ff8JWS': '我萎了','oiMaM6': '你精神正常吗','LIQKcy': '想死','EhcgEa': '被看穿了','vnDXiy': '怎么你要打死我吗(犯贱)','71bINa': '你少看扁我(自嘲熊)','eDzCRs': '疑惑','gcubY9': 'tui(吐口水)','r1lada': '你太粘人了_把你拿去粘老鼠','y6ldmK': '很不高兴为你服务','yrVneI': '真贱啊','dP6HDY': '你自首吧','OFcKsy': '勾引我是吧','jjyR6G': '你是猪','WfSWCe': '你他妈谁啊','ZbqhUq': '已读不回','B0S4LA': '蒙圈','3sp60p': '不做评价(龙图)','VIbUBK': '你是少爷吗','RjmyAc': '下线了兄弟萌(们)','y2w7BR': '一边去(龙图)','fyYVhV': '糟糕的话无需再说(抽象)','PT4fq1': '在干嘛_呼吸也要和我说一声啊','wBBj7q': '老子惹你没','3Yb2hM': '资本你赢了','9K6IPq': '脑子有问题','jHsXmD': '我们不要学他','khoGur': '刚睡醒(自嘲熊)','0svPHM': '想哭(自嘲熊)','39cQOS': '嘻嘻(自嘲熊)','4wZWjY': '尴尬一笑(黄豆)','YaiPfJ': '我超_什么寄吧','mxDIwM': '欺负没力气的我你开心吗','HIRelu': '多找找你自己的原因','RNgGNY': '以后不会和你分享了(委屈)','GWn8O2': '嘬嘬嘬','SwNPaw': '你们好会装逼啊','tDB1Sp': '复婚好吗，孩子总哭','mWU2m4': '你活这么久，和我睡两天怎么了','YCRn9a': '我坏，她好，行了吧','t7vGt6': '当我意识到生活的缩写是SM，我的痛苦就全说得清了','5AaDlW': '本来挺想你的_后来玩手机忘了','a2gifR': '偷偷谈恋爱没事_别偷偷发财好吗','BI9YDr': '荒唐','ScbsVz': '我要报警','yVU6HV': '有趣，草了','WRy68R': '低声些_难道光彩吗','vHBtBv': '偏不睡(抽象表情)','IvfqD7': '装可怜(抽象)','E7e2MS': '够了(抽象)','OWcn1K': '假装懂了','pk06Iq': '你是坏狗(可爱)'
        };
        
        const appState = {
            currentPage: 'messages',
            currentChatId: null,
            currentCircleId: null, 
            momentsLastRefresh: 0, 
            theme: 'neumorphic',
            contactsSortOrder: 'asc',
            groupsSortOrder: 'asc',
            quotingMessage: null,
            longPressTimer: null,
            friendSelectionMode: false,
            groupSelectionMode: false,
            selectionMode: { 
                active: false,
                messageIds: [],
            },
            cardCoverLibrary: [
                'https://z.wiki/u/fHMKzJ',
                'https://z.wiki/u/hmSAIR',
                'https://z.wiki/u/YWUcea',
                'https://z.wiki/u/dDuLcP',
                'https://z.wiki/u/JQtgF6',
                'https://z.wiki/u/bVpr6w',
                'https://z.wiki/u/dVvZ7t'
            ],
            emojiCurrentPage: 0,
            emojisPerPage: 8,
            favoriteEmojis: [],
            favoriteEmojiCurrentPage: 0,
            aiEmojiMap: {}, 
            playerEmojiMap: {}, 
            customEmojis: {}, 
            currentChat: {
                allMessages: [],
                renderedCount: 0,
                lastRefreshTimestamp: 0, 
            },
            messagesPerLoad: 20,
            isSummarizing: {},
            isHistoryLoading: false,
            pomodoro: {
                isActive: false,
                goal: '',
                endTime: null,
                timerId: null,
                totalSeconds: 1500, 
            },
        };
        
        const DBHelper = {
            DB_NAME: 'AIChatRoomDB',
            DB_VERSION: 1,
            db: null,

            async init() {
                
                this.DB_VERSION = 20;

                return new Promise((resolve, reject) => {
                    if (this.db) {
                        return resolve(this.db);
                    }
                    const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                    request.onerror = (event) => {
                        console.error("数据库打开失败", event);
                        reject("数据库打开失败");
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log("数据库打开成功");
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        console.log("数据库升级中... from version", event.oldVersion, "to", event.newVersion);
                        const db = event.target.result;
                        const transaction = event.target.transaction;
                        
                        if (event.oldVersion < 15) {
                            if (!db.objectStoreNames.contains('profile')) {
                                db.createObjectStore('profile', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('contacts')) {
                                const store = db.createObjectStore('contacts', { keyPath: 'id' });
                                store.createIndex('name', 'name', { unique: true });
                                store.createIndex('createdAt', 'createdAt', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('groups')) {
                                 const store = db.createObjectStore('groups', { keyPath: 'id' });
                                 store.createIndex('createdAt', 'createdAt', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('chats')) {
                                db.createObjectStore('chats', { keyPath: 'chatId' });
                            }
                            if (!db.objectStoreNames.contains('apiConfig')) {
                                db.createObjectStore('apiConfig', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('openingScenes')) {
                                const store = db.createObjectStore('openingScenes', { keyPath: 'id' });
                                store.createIndex('groupId', 'groupId', { unique: false });
                                store.createIndex('contactId', 'contactId', { unique: false }); 
                            }
                            if (!db.objectStoreNames.contains('prompts')) {
                                 const store = db.createObjectStore('prompts', { keyPath: 'id' });
                                 store.createIndex('name', 'name', { unique: false });
                                 store.createIndex('folderId', 'folderId', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('promptFolders')) {
                                 const store = db.createObjectStore('promptFolders', { keyPath: 'id' });
                                 store.createIndex('name', 'name', { unique: true });
                            }
                            if (!db.objectStoreNames.contains('circles')) {
                                 const store = db.createObjectStore('circles', { keyPath: 'id' });
                                 store.createIndex('name', 'name', { unique: true });
                            }
                            if (!db.objectStoreNames.contains('moments')) {
                                 const store = db.createObjectStore('moments', { keyPath: 'id' });
                                 store.createIndex('circleId', 'circleId', { unique: false });
                                 store.createIndex('timestamp', 'timestamp', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('friendFolders')) {
                                const store = db.createObjectStore('friendFolders', { keyPath: 'id' });
                                store.createIndex('name', 'name', { unique: true });
                                store.createIndex('createdAt', 'createdAt', { unique: false });
                            }

                            if (db.objectStoreNames.contains('contacts') && !transaction.objectStore('contacts').indexNames.contains('folderId')) {
                                transaction.objectStore('contacts').createIndex('folderId', 'folderId', { unique: false });
                            }
                            if (db.objectStoreNames.contains('openingScenes') && !transaction.objectStore('openingScenes').indexNames.contains('contactId')) {
                                transaction.objectStore('openingScenes').createIndex('contactId', 'contactId', { unique: false });
                            }
                            
                            
                            console.log("开始进行版本15的数据迁移：创建 chatMetadata...");
                            const chatMetadataStore = db.createObjectStore('chatMetadata', { keyPath: 'chatId' });
                            chatMetadataStore.createIndex('lastMessageTimestamp', 'lastMessageTimestamp', { unique: false });
                            
                            chatMetadataStore.createIndex('isPinned', 'isPinned', { unique: false });

                            const chatsStore = transaction.objectStore('chats');
                            chatsStore.openCursor().onsuccess = (e) => {
                                const cursor = e.target.result;
                                if (cursor) {
                                    const chat = cursor.value;
                                    if (chat.history && chat.history.length > 0) {
                                        const displayableHistory = chat.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                        if (displayableHistory.length > 0) {
                                            const lastMessage = displayableHistory[displayableHistory.length - 1];
                                            const unreadCount = chat.history.filter(m => m.isUnread).length;

                                            const metadata = {
                                                chatId: chat.chatId,
                                                lastMessage: lastMessage,
                                                unreadCount: unreadCount,
                                                lastMessageTimestamp: lastMessage.timestamp
                                            };
                                            transaction.objectStore('chatMetadata').put(metadata);
                                        }
                                    }
                                    cursor.continue();
                                } else {
                                    console.log("chatMetadata 迁移完成。");
                                }
                            };
                        }
                        
                        
                        if (event.oldVersion < 16) {
                            console.log("数据库升级至版本 16：创建 messages 表...");

                            const messagesStore = db.createObjectStore('messages', { keyPath: 'messageId' });
                            messagesStore.createIndex('by_chat_and_time', ['chatId', 'timestamp'], { unique: false });
                            messagesStore.createIndex('by_chat_and_sender', ['chatId', 'senderId'], { unique: false });

                            
                            if (db.objectStoreNames.contains('chats')) {
                                const chatsStore = transaction.objectStore('chats');
                                chatsStore.openCursor().onsuccess = (e) => {
                                    const cursor = e.target.result;
                                    if (cursor) {
                                        const chat = cursor.value;
                                        if (chat.history && chat.history.length > 0) {
                                            
                                            
                                            let timestampOffset = 0; 
                                            for (const message of chat.history) {
                                                
                                                message.chatId = chat.chatId;

                                                
                                                
                                                message.timestamp = message.timestamp + (timestampOffset++);

                                                
                                                transaction.objectStore('messages').put(message);
                                            }
                                            
                                        }
                                        cursor.continue();
                                    } else {
                                        console.log("聊天记录迁移到 messages 表完成。");
                                    }
                                };
                            }
                        }

                        
                        if (event.oldVersion < 17) {
                            console.log("数据库升级至版本 17：创建 giftApiConfig 表...");
                            if (!db.objectStoreNames.contains('giftApiConfig')) {
                                db.createObjectStore('giftApiConfig', { keyPath: 'id' });
                            }
                        }

                        
                        if (event.oldVersion < 20) {
                            console.log("数据库升级至版本 20：为 chatMetadata 添加 lastRawAiResponse...");
                            
                            
                        }
                        
                        console.log("数据库升级完成");
                    };
                });
            },


            async get(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`Get error from ${storeName}: ${e.target.error}`);
                });
            },

            async getAll(storeName, indexName, sortOrder = 'next') {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const index = indexName ? store.index(indexName) : store;
                    const request = index.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`GetAll error from ${storeName}: ${e.target.error}`);
                });
            },

            async put(storeName, item) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(item);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`Put error in ${storeName}: ${e.target.error}`);
                });
            },

            async delete(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = (e) => reject(`Delete error from ${storeName}: ${e.target.error}`);
                });
            },

            async getMessages(chatId, limit, beforeTimestamp = Date.now()) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_time');
                    const range = IDBKeyRange.bound([chatId, 0], [chatId, beforeTimestamp], false, true);
                    const messages = [];
                    
                    index.openCursor(range, 'prev').onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor && messages.length < limit) {
                            messages.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(messages.reverse()); 
                        }
                    };
                    transaction.onerror = (e) => reject(`getMessages error: ${e.target.error}`);
                });
            },
            
            async getMessagesBySender(chatId, senderId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_sender');
                    const range = IDBKeyRange.only([chatId, senderId]);
                    const request = index.getAll(range);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`getMessagesBySender error: ${e.target.error}`);
                });
            },
            
            async getChatMessagesCount(chatId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_time');
                    const range = IDBKeyRange.bound([chatId, 0], [chatId, Date.now()]);
                    const request = index.count(range);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`getChatMessagesCount error: ${e.target.error}`);
                });
            },

            async deleteMessagesForChat(chatId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readwrite');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_time');
                    const range = IDBKeyRange.bound([chatId, 0], [chatId, Date.now()]);

                    const request = index.openCursor(range);
                    request.onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor) {
                            cursor.delete();
                            cursor.continue();
                        } else {
                            
                        }
                    };
                    transaction.oncomplete = () => {
                        console.log(`All messages for chat ${chatId} deleted.`);
                        resolve();
                    };
                    transaction.onerror = (e) => {
                        console.error(`Error deleting messages for chat ${chatId}:`, e.target.error);
                        reject(e.target.error);
                    };
                });
            },

            async batchPut(storeName, items) {
                if (!items || items.length === 0) {
                    return Promise.resolve();
                }
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = (e) => reject(`BatchPut error in ${storeName}: ${e.target.error}`);
                    
                    items.forEach(item => {
                        store.put(item);
                    });
                });
            },

            async findLastMessagesBySenderAndTypes(chatId, senderId, typesToFind) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_sender');
                    const range = IDBKeyRange.only([chatId, senderId]);
            
                    const results = {};
                    let foundCount = 0;
                    const typesSet = new Set(typesToFind);
            
                    index.openCursor(range, 'prev').onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor) {
                            const message = cursor.value;
                            const msgType = message.segmentType;
            
                            if (typesSet.has(msgType) && !results[msgType]) {
                                results[msgType] = message;
                                foundCount++;
                            }
            
                            
                            if (foundCount === typesToFind.length) {
                                resolve(results);
                            } else {
                                cursor.continue();
                            }
                        } else {
                            
                            resolve(results);
                        }
                    };
                    transaction.onerror = (e) => reject(`findLastMessagesBySenderAndTypes error: ${e.target.error}`);
                });
            },
        };

        
        const Utils = {
            generateId(prefix) {
                const uniquePart = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                return `${prefix}${uniquePart}`;
            },
            
            getRandomColor() {
                const colors = ['#F4E8DD', '#EDD4D8', '#CCD4CC', '#B5BFCF', '#E8A0BF'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            
            createAvatarDataUrl(color) {
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50"><rect width="50" height="50" fill="${color}"/></svg>`;
                return `data:image/svg+xml;base64,${btoa(svg)}`;
            },

            formatTimestampSmartly(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();

                const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const yesterdayStart = new Date(todayStart);
                yesterdayStart.setDate(yesterdayStart.getDate() - 1);
                
                const formatTime = (d) => d.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                
                if (date >= todayStart) {
                    
                    return formatTime(date);
                } else if (date >= yesterdayStart) {
                    
                    return `昨天 ${formatTime(date)}`;
                } else {
                    
                    return date.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }) + ' ' + formatTime(date);
                }
            },


            formatTimestampForBubble(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();

                const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const yesterdayStart = new Date(todayStart);
                yesterdayStart.setDate(yesterdayStart.getDate() - 1);

                const formatTime = (d) => d.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });

                if (date >= todayStart) {
                    return formatTime(date);
                } else if (date >= yesterdayStart) {
                    return `昨天 ${formatTime(date)}`;
                } else {
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    return `${month}/${day} ${formatTime(date)}`;
                }
            },
            formatTimestampForPrompt(timestamp) {
                const d = new Date(timestamp);
                return `${d.getMonth() + 1}月${d.getDate()}日 ${d.getHours()}:${String(d.getMinutes()).padStart(2, '0')}`;
            },

            compressImage(file, maxWidth = 800, maxHeight = 800, quality = 0.7) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');

                            let width = img.width;
                            let height = img.height;

                            if (width > height) {
                                if (width > maxWidth) {
                                    height = Math.round(height * (maxWidth / width));
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width = Math.round(width * (maxHeight / height));
                                    height = maxHeight;
                                }
                            }

                            canvas.width = width;
                            canvas.height = height;
                            ctx.drawImage(img, 0, 0, width, height);

                            resolve(canvas.toDataURL(file.type, quality));
                        };
                        img.onerror = reject;
                    };
                    reader.onerror = reject;
                });
            },

            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            },

            parseMomentTimestamp(timeStr) { 
                if (!timeStr) return Date.now();
                const now = new Date();
                const year = now.getFullYear();
                const [datePart, timePart] = timeStr.split(' ');
                if (!datePart || !timePart) return Date.now();

                const [month, day] = datePart.split('/');
                const [hour, minute] = timePart.split(':');
                
                
                const parsedDate = new Date(year, parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute));
                
                
                if (parsedDate > now) {
                    parsedDate.setFullYear(year - 1);
                }
                
                return parsedDate.getTime();
            }
        };

        
        const UIManager = {
            notificationQueue: [],
            isDisplayingNotification: false,
       async syncAiButtonState() {
            const aiRequestBtn = $('#ai-request-btn');
            if (!aiRequestBtn) return;

            if (AIHandler.isAwaitingResponse) {
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;
            } else {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const defaultIconHtml = '<i class="fas fa-feather-alt"></i>';
                const iconUrl = settings.aiRequestBtnUrl;
                const style = 'width: 2.2rem; height: 2.2rem; object-fit: contain;';

                if (iconUrl) {
                    const img = new Image();
                    img.onload = () => { aiRequestBtn.innerHTML = `<img src="${iconUrl}" style="${style}">`; };
                    img.onerror = () => { aiRequestBtn.innerHTML = defaultIconHtml; };
                    img.src = iconUrl;
                } else {
                    aiRequestBtn.innerHTML = defaultIconHtml;
                }
            }
        },
       async navigateTo(pageId, fromPage = null) {
            if (!pages[pageId]) return;

            
            if (['chat', 'prompts', 'moments', 'tutorial', 'pomodoro', 'gifts', 'forwarded-history'].includes(pageId)) { 
                bottomNav.style.display = 'none';
            } else {
                bottomNav.style.display = 'flex';
            }

            EventManager.updateFloatingBallVisibility();

            
            $$('#bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.page === pageId);
            });

            
            Object.values(pages).forEach(page => page.classList.remove('active'));
            pages[pageId].classList.add('active');
            appState.currentPage = pageId;
            appState.fromPage = fromPage; 
            
            
            switch(pageId) {
                case 'messages': await this.renderMessagesListPage(); break;
                case 'contacts': await this.renderContactsPage(); break;
                case 'discover':  break;
                case 'moments': await this.renderMomentsPage(); break;
                case 'settings': break; 
                case 'api-settings': await EventManager.renderApiSettingsPage(); break;
                case 'gifts': await UIManager.renderGiftsPage(); break;
                case 'theme-settings': await EventManager.renderThemeSettingsPage(); break;
                case 'bubble-settings': await EventManager.renderBubbleSettingsPage(); break;
                case 'prompts': await EventManager.renderPromptsPage(); break;
            }
        },

            async renderMessagesListPage() {
                const messageListUl = $('#message-list-ul');
                messageListUl.innerHTML = '';
                
                const allMetadata = await DBHelper.getAll('chatMetadata');
                if (allMetadata.length === 0) {
                    messageListUl.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">还没有消息，快去通讯录找好友聊天吧~</li>`;
                    return;
                }
                
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');
                const contactsMap = contacts.reduce((map, c) => (map[c.id] = c, map), {});
                const groupsMap = groups.reduce((map, g) => (map[g.id] = g, map), {});

                const pinnedChats = [];
                const unpinnedChats = [];

                for (const metadata of allMetadata) {
                    if (!metadata) continue; 
                    
                    const { chatId, lastMessage, unreadCount, isPinned, pinnedTimestamp } = metadata;
                    if (!lastMessage) continue;

                    let chatInfo = {
                        id: chatId,
                        lastMessageContent: lastMessage.content,
                        lastMessageTimestamp: lastMessage.timestamp,
                        unreadCount: unreadCount,
                        isPinned: isPinned || false,
                        pinnedTimestamp: pinnedTimestamp || 0
                    };
                    
                    let entity;
                    let isGroupChat = chatId.startsWith('group-');

                    if (isGroupChat) {
                        entity = groupsMap[chatId];
                    } else {
                        entity = contactsMap[chatId];
                    }

                    if (!entity) continue; 

                    chatInfo.name = entity.remark || entity.name;
                    chatInfo.avatar = entity.avatar;

                    switch (lastMessage.segmentType) {
                        case 'pat_a_pat': chatInfo.lastMessageContent = '[拍一拍]'; break;
                        case 'emoji-image':
                            const emojiDesc = appState.playerEmojiMap[lastMessage.content] || appState.aiEmojiMap[lastMessage.content];
                            chatInfo.lastMessageContent = emojiDesc ? `[表情] ${emojiDesc}` : '[未知表情]';
                            break;
                        case 'narrator':
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = lastMessage.content;
                            
                            chatInfo.lastMessageContent = '[旁白] ' + tempDiv.textContent.trim().replace(/\s+/g, ' ').substring(0, 50);
                            break;
                            chatInfo.lastMessageContent = emojiDesc ? `[表情] ${emojiDesc}` : '[未知表情]';
                            break;
                        case 'forward_custom': chatInfo.lastMessageContent = `[转发] ${lastMessage.cardData.title}`; break;
                        case 'image_simulated': chatInfo.lastMessageContent = '[图片]'; break;
                        case 'image_vision': chatInfo.lastMessageContent = '[图片]'; break;
                        case 'card': chatInfo.lastMessageContent = `[${lastMessage.cardData.shareType || '分享'} ${lastMessage.cardData.title}]`; break;
                        case 'voice': chatInfo.lastMessageContent = '[语音]'; break;
                        case 'transfer': chatInfo.lastMessageContent = '[转账]'; break;
                        case 'transfer-return': chatInfo.lastMessageContent = '[转账已退回]'; break;
                        case 'transfer-receipt': chatInfo.lastMessageContent = '[已收款]'; break;
                        case 'red-packet': chatInfo.lastMessageContent = '[红包]'; break;
                        case 'moment_forward': chatInfo.lastMessageContent = '[转发动态]'; break;
                    }

                    if (lastMessage.isRetracted) {
                        chatInfo.lastMessageContent = '[一条消息被撤回]';
                    }
                    
                    if (isGroupChat && lastMessage.type === 'received' && lastMessage.senderId) {
                        const sender = contactsMap[lastMessage.senderId];
                        if (sender) {
                            chatInfo.lastMessageContent = `${sender.remark || sender.name}: ${chatInfo.lastMessageContent}`;
                        }
                    }
                    
                    if (chatInfo.isPinned) {
                        pinnedChats.push(chatInfo);
                    } else {
                        unpinnedChats.push(chatInfo);
                    }
                }
                
                
                pinnedChats.sort((a, b) => b.pinnedTimestamp - a.pinnedTimestamp);
                unpinnedChats.sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);
                
                const combinedChats = [...pinnedChats, ...unpinnedChats];

                combinedChats.forEach(chat => {
                    const li = document.createElement('li');
                    li.className = 'message-item';
                    li.dataset.chatId = chat.id;
                    li.innerHTML = `
                        <img src="${chat.avatar}" alt="avatar" class="item-avatar">
                        <div class="item-content">
                            <div class="item-name">
                                ${chat.isPinned ? '<i class="fas fa-thumbtack item-pin-icon"></i>' : ''}
                                ${chat.name}
                            </div>
                            <div class="item-last-msg">${chat.lastMessageContent}</div>
                        </div>
                        <div class="item-info">
                            <div class="item-time">${Utils.formatTimestampSmartly(chat.lastMessageTimestamp)}</div>
                            ${chat.unreadCount > 0 ? `<div class="unread-badge">${chat.unreadCount}</div>` : ''}
                        </div>
                    `;
                    li.addEventListener('click', () => this.openChat(chat.id));
                    messageListUl.appendChild(li);
                });
            },

            showMessageListOptions(itemElement) {
                const existingPopover = $('.message-list-popover');
                if (existingPopover) {
                    existingPopover.remove();
                }

                const chatId = itemElement.dataset.chatId;
                if (!chatId) return;

                const popover = document.createElement('div');
                popover.className = 'message-list-popover';

                (async () => {
                    const metadata = await DBHelper.get('chatMetadata', chatId);
                    const isPinned = metadata?.isPinned || false;
                    const pinButtonText = isPinned ? '取消置顶' : '置顶';
                    const pinIcon = isPinned ? 'fa-arrow-down' : 'fa-thumbtack';

                    popover.innerHTML = `
                        <button class="message-list-popover-btn" data-action="pin"><i class="fas ${pinIcon}"></i> ${pinButtonText}</button>
                        <button class="message-list-popover-btn" data-action="delete"><i class="fas fa-trash-alt"></i> 删除</button>
                    `;

                    
                    const rect = itemElement.getBoundingClientRect();
                    const containerRect = $('#page-messages .page-content').getBoundingClientRect();
                    
                    popover.style.top = `${rect.top - containerRect.top + (rect.height / 2)}px`;
                    popover.style.left = `${rect.left - containerRect.left + (rect.width / 2)}px`;
                    popover.style.transformOrigin = 'center center';
                    popover.style.transform = 'translate(-50%, -50%) scale(0.9)'; 

                    $('#page-messages .page-content').appendChild(popover);

                    
                    requestAnimationFrame(() => {
                        const popoverRect = popover.getBoundingClientRect();
                        if (popoverRect.bottom > containerRect.bottom - 10) {
                            popover.style.top = `${rect.top - containerRect.top - popoverRect.height - 5}px`;
                            popover.style.transformOrigin = 'bottom center';
                        }
                        if (popoverRect.top < containerRect.top + 10) {
                            popover.style.top = `${rect.bottom - containerRect.top + 5}px`;
                            popover.style.transformOrigin = 'top center';
                        }
                    });
                })();

                
                popover.addEventListener('click', async (e) => {
                    const button = e.target.closest('button');
                    if (!button) return;
                    e.stopPropagation();

                    const action = button.dataset.action;
                    popover.remove(); 

                    if (action === 'pin') {
                        const allMetadata = await DBHelper.getAll('chatMetadata');
                        const pinnedCount = allMetadata.filter(m => m.isPinned).length;
                        const metadata = await DBHelper.get('chatMetadata', chatId);
                        
                        if (!metadata.isPinned && pinnedCount >= 5) {
                            UIManager.showToast("最多只能置顶5个聊天");
                            return;
                        }

                        metadata.isPinned = !metadata.isPinned;
                        metadata.pinnedTimestamp = metadata.isPinned ? Date.now() : 0;
                        await DBHelper.put('chatMetadata', metadata);
                        await this.renderMessagesListPage();

                    } else if (action === 'delete') {
                        this.showModal({
                            title: '删除此会话',
                            body: '<p>请选择删除方式：</p>',
                            actions: [
                                { text: '取消', class: 'btn-secondary', handler: () => this.hideModal() },
                                { text: '仅移除列表', class: 'btn-primary', handler: async () => {
                                    await DBHelper.delete('chatMetadata', chatId);
                                    this.hideModal();
                                    await this.renderMessagesListPage();
                                }},
                                { text: '删除聊天记录', class: 'btn-danger', handler: async () => {
                                    await DBHelper.delete('chatMetadata', chatId);
                                    await DBHelper.deleteMessagesForChat(chatId);

                                    
                                    const isGroup = chatId.startsWith('group-');
                                    const storeName = isGroup ? 'groups' : 'contacts';
                                    const entity = await DBHelper.get(storeName, chatId);
                                    if (entity) {
                                        entity.autoSummary = ''; 
                                        if (entity.totalPlayerTurns) { 
                                            entity.totalPlayerTurns = 0;
                                        }
                                        await DBHelper.put(storeName, entity);
                                    }
                                    

                                    this.hideModal();
                                    await this.renderMessagesListPage();
                                }}
                            ]
                        });
                    }
                });

                
                const hideOnClickOutside = (event) => {
                    if (!popover.contains(event.target)) {
                        popover.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                setTimeout(() => document.addEventListener('click', hideOnClickOutside, true), 0);
            },

            async renderContactsPage(tab = 'friends') {
                $$('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
                $$('.contact-section').forEach(sec => {
                    sec.classList.remove('active');
                });

                if (tab === 'friends') {
                    $('#contacts-friends').classList.add('active');
                    const friends = await DBHelper.getAll('contacts');
                    friends.sort((a, b) => {
                        return appState.contactsSortOrder === 'asc' 
                            ? a.createdAt - b.createdAt 
                            : b.createdAt - a.createdAt;
                    });
                    this.renderContactList($('#friends-list-ul'), friends, 'contact');
                } else if (tab === 'groups') {
                    $('#contacts-groups').classList.add('active');
                    const groups = await DBHelper.getAll('groups');
                     groups.sort((a, b) => {
                        return appState.groupsSortOrder === 'asc' 
                            ? a.createdAt - b.createdAt 
                            : b.createdAt - a.createdAt;
                    });
                    this.renderContactList($('#groups-list-ul'), groups, 'group');
                } else if (tab === 'friendFolders') {
                    $('#contacts-friend-folders').classList.add('active');
                    await this.renderFriendFoldersPage();
                }
            },

            async updateChatMetadata(chatId, newLastMessage = null, unreadChange = 0) {
                
                if (!chatId) {
                    console.error("尝试更新一个空的 chatId 的元数据，操作已阻止。");
                    return;
                }

                const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId, unreadCount: 0 };
                
                if (newLastMessage) {
                    metadata.lastMessage = newLastMessage;
                    metadata.lastMessageTimestamp = newLastMessage.timestamp;
                }
                
                if (unreadChange > 0) {
                    metadata.unreadCount = (metadata.unreadCount || 0) + unreadChange;
                } else if (unreadChange < 0) { 
                    metadata.unreadCount = 0;
                }
                
                if (metadata.lastMessage) { 
                    await DBHelper.put('chatMetadata', metadata);
                }
            },

            
            renderContactList(ulElement, items, type) {
                const isSelectionMode = (type === 'contact' && appState.friendSelectionMode) || (type === 'group' && appState.groupSelectionMode);

                ulElement.classList.toggle('selection-mode', isSelectionMode);
                ulElement.innerHTML = '';

                if (items.length === 0) {
                    ulElement.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">空空如也~</li>`;
                    return;
                }
                items.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'contact-item';
                    li.dataset.id = item.id;
                    li.innerHTML = `
                        ${isSelectionMode ? '<input type="checkbox" class="contact-select-checkbox">' : ''}
                        <img src="${item.avatar}" alt="avatar" class="contact-item-avatar">
                        <span class="contact-item-name">${type === 'contact' ? (item.remark || item.name) : item.name}</span>
                        ${type === 'contact' 
                            ? `<i class="fas fa-info-circle contact-info-btn" data-id="${item.id}"></i>` 
                            : `<i class="fas fa-ellipsis-h contact-info-btn" data-id="${item.id}"></i>`
                        }
                    `;
                    
                    li.addEventListener('click', (e) => {
                        if (isSelectionMode) {
                            if (e.target.type !== 'checkbox') {
                                const checkbox = li.querySelector('.contact-select-checkbox');
                                if (checkbox) checkbox.checked = !checkbox.checked;
                            }
                            return;
                        }
                        if (e.target.classList.contains('contact-info-btn')) return;
                        this.openChat(item.id);
                    });
                    
                    const infoBtn = li.querySelector('.contact-info-btn');
                    if (infoBtn) {
                        infoBtn.addEventListener('click', (e) => {
                           e.stopPropagation();
                           if (type === 'contact') this.showContactInfo(item.id);
                           else this.showGroupInfo(item.id);
                        });
                    }

                    ulElement.appendChild(li);
                });
            },

        async openChat(chatId) {
            appState.currentChatId = chatId;
            const isGroup = chatId.startsWith('group-');
            let target;
            if (isGroup) {
                target = await DBHelper.get('groups', chatId);
            } else {
                target = await DBHelper.get('contacts', chatId);
            }
        
            if (!target) {
                this.showModal({
                    title: "错误",
                    body: `<p>找不到该聊天对象，可能已被删除。</p>`,
                    actions: [{ text: '好的', class: 'btn-primary', handler: () => this.hideModal() }]
                });
                return;
            }
        
            chatTitle.textContent = isGroup ? target.name : (target.remark || target.name);
        
            
            const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId, unreadCount: 0 };
            if (metadata.unreadCount > 0) {
                
                await this.updateChatMetadata(chatId, null, -1);
            }
        
            
            if (isGroup) {
                for (const memberId of target.members) {
                    await this.updateChatMetadata(memberId, null, -1);
                }
            }
        
            await this.refreshChatView();
            this.navigateTo('chat');
            await EventManager.applyChatSpecificStyles();
            await UIManager.applyChatBackground(chatId);
            await UIManager.applyChatBackground(chatId);
            
            this.syncAiButtonState(); 
            
            if (!isGroup && target.allowActiveReply === false) {
                console.log(`已为角色 ${target.name} 关闭主动回复功能。`);
            } else {
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                const intervalHours = (typeof chatSettings.activeReplyInterval === 'number') ? chatSettings.activeReplyInterval : 0;
                const lastAiTimestamp = metadata.lastAiReplyTimestamp || 0;
                const now = Date.now();
                const elapsedHours = (now - lastAiTimestamp) / (1000 * 60 * 60);
        
                if (intervalHours > 0 && lastAiTimestamp > 0 && elapsedHours >= intervalHours) {
                    console.log(`距离上次AI回复已过去 ${elapsedHours.toFixed(2)} 小时，已达到设定的 ${intervalHours} 小时，触发主动回复。`);
                    setTimeout(() => AIHandler.handleActiveReplyRequest(lastAiTimestamp), 500);
                } else {
                    
                    if (intervalHours <= 0) {
                        console.log("主动回复功能已在聊天设置中关闭 (间隔为0)。");
                    } else if (lastAiTimestamp === 0) {
                        console.log("这是你们的第一次互动，暂不触发主动回复。");
                    } else {
                        console.log(`距离上次AI回复 ${elapsedHours.toFixed(2)} 小时，未达到设定的 ${intervalHours} 小时，不触发主动回复。`);
                    }
                }
            }
        },

        async refreshChatView() {
            if (!appState.currentChatId) return;
            
            const totalMessages = await DBHelper.getChatMessagesCount(appState.currentChatId);
            
            appState.currentChat = {
                totalMessages: totalMessages,
                renderedCount: 0,
                oldestMessageTimestamp: Date.now(), 
                lastRefreshTimestamp: Date.now(), 
            };
            
            chatArea.innerHTML = ''; 
            if (totalMessages > 0) {
                const loaderHTML = '<div id="history-loader"><div class="loader-spinner"></div></div>';
                chatArea.insertAdjacentHTML('beforeend', loaderHTML);
            }

            await this.loadMoreMessages(true);
        },

        async loadMoreMessages(isInitialLoad = false) {
            if (appState.isHistoryLoading) return;

            const { totalMessages, renderedCount, oldestMessageTimestamp } = appState.currentChat;
            const loader = $('#history-loader');

            if (renderedCount >= totalMessages) {
                if(loader) loader.remove();
                return;
            }

            appState.isHistoryLoading = true;
            if (loader) loader.classList.add('visible');
            
            const messagesToLoad = await DBHelper.getMessages(appState.currentChatId, appState.messagesPerLoad, oldestMessageTimestamp);
            
            if (messagesToLoad.length === 0) {
                if (loader) loader.remove();
                appState.isHistoryLoading = false;
                return;
            }

            appState.currentChat.oldestMessageTimestamp = messagesToLoad[0].timestamp;
            
            const fragment = document.createDocumentFragment();
            const profile = await EventManager.getPlayerProfileForContext(appState.currentChatId);
            const contacts = await DBHelper.getAll('contacts');

            
            const nextMessageArr = (chatArea.querySelector('.message-row, .system-notice, .narrator-notice, .retracted-notice')?.id) 
                ? [await DBHelper.get('messages', chatArea.querySelector('.message-row, .system-notice, .narrator-notice, .retracted-notice').id)] 
                : [];
            let nextMessageTimestamp = nextMessageArr.length > 0 ? nextMessageArr[0].timestamp : Date.now() + 1000;

            for (let i = messagesToLoad.length - 1; i >= 0; i--) {
                const msg = messagesToLoad[i];
                
                
                if (nextMessageTimestamp - msg.timestamp > 5 * 60 * 1000 && !isInitialLoad) {
                    const timeDiv = this.createTimeDividerElement(nextMessageTimestamp);
                    fragment.prepend(timeDiv); 
                }
                
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                if (!(['inner_voice', 'essay'].includes(msg.segmentType) || msg.isHidden)) {
                    
                    if (msg.segmentType === 'pat_a_pat' && chatSettings.enablePatAPat === false) {
                        nextMessageTimestamp = msg.timestamp;
                        continue;
                    }

                    let senderInfo = (msg.type === 'sent') ? profile : contacts.find(c => c.id === msg.senderId) || { name: '未知成员', avatar: Utils.createAvatarDataUrl('#ccc') };
                    
                    
                    
                    if (msg.segmentType === 'emoji-image' && msg.type === 'received') {
                        const emojiSetting = senderInfo.allowEmoji;
                        if (emojiSetting === 'off') {
                            nextMessageTimestamp = msg.timestamp; 
                            continue; 
                        } else if (emojiSetting === 'prob') {
                            if (Math.random() < 0.5) {
                                nextMessageTimestamp = msg.timestamp;
                                continue; 
                            }
                        }
                    }

                    
                    if (msg.isRetracted && msg.type === 'received' && senderInfo.allowRetraction === false) {
                        msg.isRetracted = false; 
                    }
                    

                    let messageElement;

                    if (msg.isRetracted) {
                        messageElement = this.createRetractionNotice(msg, senderInfo);
                    } else if (msg.segmentType === 'system') {
                        messageElement = document.createElement('div');
                        messageElement.className = 'system-notice';
                        messageElement.id = msg.messageId; 
                        messageElement.textContent = msg.content;
                    } else if (msg.segmentType === 'narrator') {
                        messageElement = await this.createNarratorNoticeElement(msg);
                    } else if (msg.segmentType === 'pat_a_pat') {
                        messageElement = document.createElement('div');
                        messageElement.className = 'pat-notice';
                        messageElement.id = msg.messageId;
                        messageElement.textContent = msg.content.displayText;
                    } else {
                        messageElement = await this.createMessageElement(msg, senderInfo);
                    }
                    fragment.prepend(messageElement); 
                }

                nextMessageTimestamp = msg.timestamp; 
            }

            const oldScrollHeight = chatArea.scrollHeight;
            if (loader) loader.after(fragment);
            else chatArea.prepend(fragment);
            
            if (isInitialLoad) {
                setTimeout(() => chatArea.scrollTop = chatArea.scrollHeight, 10);
            } else {
                chatArea.scrollTop = chatArea.scrollHeight - oldScrollHeight;
            }

            appState.currentChat.renderedCount += messagesToLoad.length;
            if (loader) loader.classList.remove('visible');
            appState.isHistoryLoading = false;
            
            if (appState.currentChat.renderedCount >= totalMessages) {
                if (loader) loader.remove();
            }
        },

        async createMessageElement(msg, senderInfo, isTyping = false, isReadOnly = false) {
            const messageRow = document.createElement('div');
            messageRow.className = `message-row ${msg.type}`;
            
            if (!isTyping) {
                messageRow.id = msg.messageId;
                messageRow.dataset.messageId = msg.messageId;
            }

            let bubbleContent = '';
            let bubbleClass = 'bubble';
            let detailContent = ''; 
            
            
            if (msg.isAutoReply) {
                bubbleClass += ' auto-reply-bubble';
            }

            if (isTyping) {
                bubbleClass += ` bubble-typing`;
                bubbleContent = `<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>`;
            } else {
                 switch(msg.segmentType) {
                    case 'emoji-image':
                        bubbleClass += ` bubble-emoji`;
                        let emojiSrc;
                        if (msg.content.startsWith('custom-')) {
                            emojiSrc = appState.customEmojis[msg.content]?.url || '';
                        } else {
                            emojiSrc = `https://z.wiki/u/${msg.content}`;
                        }
                        bubbleContent = `<img src="${emojiSrc}" alt="${appState.playerEmojiMap[msg.content] || '表情'}">`;
                        break;
                    case 'image_simulated':
                        bubbleClass += ' image-with-desc-bubble';
                        bubbleContent = `
                            ${msg.cardData.imageSrc ? `<img src="${msg.cardData.imageSrc}" alt="图片">` : ''}
                            <div class="description-text">${msg.cardData.description}</div>
                        `;
                        break;
                    case 'image_vision':
                        bubbleClass += ' image-with-desc-bubble vision-image-bubble';
                        bubbleContent = `
                            <img src="${msg.cardData.base64}" alt="用户发送的图片">
                            ${msg.cardData.prompt ? `<div class="description-text">${msg.cardData.prompt}</div>` : ''}
                        `;
                        break;
                    case 'voice':
                        bubbleClass += ' voice-message-bubble';
                        bubbleContent = `<span class="voice-duration">${msg.cardData.duration}</span><div class="voice-wave"><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div></div>`;
                        detailContent = `<div class="voice-transcript">${msg.cardData.content}</div>`;
                        break;
                    case 'quote':
                        bubbleClass += ' quote-message-bubble';
                        bubbleContent = `<div class="quote-block"><span class="quoted-name">${msg.cardData.quotedName}:</span><span>${msg.cardData.quotedContent}</span></div><div>${msg.cardData.newContent}</div>`;
                        break;
                    case 'transfer':
                        bubbleClass += ' transfer-or-red-packet-bubble';
                        if (msg.cardData.isClaimed) bubbleClass += ' claimed';
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const transferCoverStyle = themeSettings.transferCover ? `background-image: url(${themeSettings.transferCover}); background-size: cover; background-position: center;` : '';
                            
                            bubbleContent = `
                                <div class="transfer-content-v3" style="${transferCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-exchange-alt transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>转账给 ${msg.cardData.recipientName}</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    ${msg.cardData.note ? `<div class="transfer-footer-v3">${msg.cardData.note}</div>` : ''}
                                </div>
                            `;
                        }
                        break;
                    case 'transfer-return':
                        bubbleClass += ' transfer-or-red-packet-bubble claimed'; 
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const transferCoverStyle = themeSettings.transferCover ? `background-image: url(${themeSettings.transferCover}); background-size: cover; background-position: center;` : '';
                            const recipientIsPlayer = msg.cardData.recipientName === (await EventManager.getPlayerProfileForContext(appState.currentChatId))?.name;
                            const footerText = recipientIsPlayer ? `已退还给 ${msg.cardData.recipientName}` : `${msg.cardData.senderName} 退还了转账`;
                            
                            bubbleContent = `
                                <div class="transfer-content-v3" style="${transferCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-undo transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>转账已退回</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    <div class="transfer-footer-v3">${footerText}</div>
                                </div>
                            `;
                        }
                        break;
                    case 'transfer-receipt':
                        bubbleClass += ' transfer-or-red-packet-bubble claimed'; 
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const receiptCoverStyle = themeSettings.receiptCover ? `background-image: url(${themeSettings.receiptCover}); background-size: cover; background-position: center;` : '';
                            const footerText = msg.type === 'sent' ? `来自 ${msg.cardData.senderName} 的转账` : `${msg.cardData.recipientName} 已收款`;

                            bubbleContent = `
                                 <div class="transfer-content-v3" style="${receiptCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-check-circle transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>已收款</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    <div class="transfer-footer-v3">${footerText}</div>
                                </div>
                            `;
                        }
                        break;
                    case 'red-packet':
                        bubbleClass += ' transfer-or-red-packet-bubble';
                        if (msg.cardData.isClaimedByPlayer) bubbleClass += ' claimed';
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const defaultCover = 'https://z.wiki/u/IDzEvp';
                            const rpCover = themeSettings.redPacketCover || defaultCover;
                            
                            bubbleContent = `
                                <div class="red-packet-v3-wrapper">
                                    <div class="rp-cover-v3" style="background-image: url('${rpCover}');">
                                        <h4 class="rp-title-v3">${msg.cardData.title}</h4>
                                        <div class="open-button-v3">
                                            <i class="fas fa-paw"></i>
                                        </div>
                                    </div>
                                    <div class="claimed-overlay-v3">已领取</div>
                                </div>
                            `;
                        }
                        break;
                    case 'card':
                        bubbleClass += ' card-bubble';
                        const cardId = `card-detail-${msg.messageId}`;
                        let cardInnerHtml = '';
                        
                        if (msg.type === 'sent') {
                            const cardData = msg.cardData;
                            switch(cardData.shareType) {
                                case '地点分享': cardInnerHtml = `<div class="card-message-wrapper card-type-3" data-card-id="${cardId}"><div class="card-icon-area" style="background-color: var(--theme-color-1);"><i class="fas fa-map-marker-alt"></i></div><div class="card-content"><h4>${cardData.title}</h4><p>${cardData.summary}</p></div></div>`; break;
                                case '文件分享': cardInnerHtml = `<div class="card-message-wrapper card-type-9" data-card-id="${cardId}"><i class="fas fa-file-archive file-icon" style="color: var(--theme-color-4);"></i><div class="file-info"><h4>${cardData.title}</h4><div class="file-size">${cardData.summary}</div></div></div>`; break;
                                default:
                                    const imageToUse = cardData.imageSrc || appState.cardCoverLibrary[Math.floor(Math.random() * appState.cardCoverLibrary.length)];
                                    cardInnerHtml = `<div class="card-message-wrapper card-type-2" data-card-id="${cardId}"><img src="${imageToUse}" class="card-image" alt="Card image"><div class="card-content"><h4>${cardData.title}</h4><p>${cardData.summary}</p></div></div>`;
                                    break;
                            }
                        } else {
                             switch(msg.cardData.shareType) {
                                case '地点分享': cardInnerHtml = `<div class="card-message-wrapper card-type-3" data-card-id="${cardId}"><div class="card-icon-area" style="background-color: var(--theme-color-1);"><i class="fas fa-map-marker-alt"></i></div><div class="card-content"><h4>${msg.cardData.title}</h4><p>${msg.cardData.summary}</p></div></div>`; break;
                                case '文件分享': cardInnerHtml = `<div class="card-message-wrapper card-type-9" data-card-id="${cardId}"><i class="fas fa-file-archive file-icon" style="color: var(--theme-color-4);"></i><div class="file-info"><h4>${msg.cardData.title}</h4><div class="file-size">${msg.cardData.summary}</div></div></div>`; break;
                                default:
                                    const randomCover = appState.cardCoverLibrary[Math.floor(Math.random() * appState.cardCoverLibrary.length)];
                                    cardInnerHtml = `<div class="card-message-wrapper card-type-2" data-card-id="${cardId}"><img src="${randomCover}" class="card-image" alt="Card image"><div class="card-content"><h4>${msg.cardData.title}</h4><p>${msg.cardData.summary}</p></div></div>`;
                                    break;
                            }
                        }
                        
                        const cardDetailHtml = `<div class="card-detail-content" id="${cardId}"><h5>${msg.cardData.title}</h5><p>${msg.cardData.details}</p></div>`;
                        
                        bubbleContent = cardInnerHtml;
                        detailContent = cardDetailHtml; 
                        break;
                    case 'moment_forward':
                        bubbleClass += ' forwarded-moment-bubble';
                        bubbleContent = `
                            <div class="forwarded-moment-card-content" data-moment-id="${msg.cardData.momentId}">
                                <h4 class="card-title">[朋友圈动态]</h4>
                                <p class="card-preview">${msg.cardData.authorName}：${msg.cardData.preview}</p>
                                <div class="card-footer">朋友圈</div>
                            </div>
                        `;
                        break;
                    case 'forwarded_history':
                        bubbleClass += ' forwarded-history-bubble';
                        bubbleContent = `
                            <div class="forwarded-history-card-content">
                                <h4 class="card-title">${msg.cardData.title}</h4>
                                <p class="card-preview">${msg.cardData.preview}</p>
                                <div class="card-footer">聊天记录</div>
                            </div>
                        `;
                        break;
                    case 'forward_custom':
                        bubbleClass += ' forwarded-moment-bubble';
                        bubbleContent = `
                            <div class="forwarded-moment-card-content" data-type="custom-forward">
                                <h4 class="card-title">[转发] ${msg.cardData.title}</h4>
                                <p class="card-preview">${msg.cardData.content}</p>
                                <div class="card-footer">转发</div>
                            </div>
                        `;
                        break;
                    case 'gift':
                        bubbleClass += ' gift-bubble';
                        bubbleContent = `
                            <div class="gift-message-content">
                                <img src="${msg.cardData.image}" class="gift-image" alt="礼物">
                                <div class="gift-info">
                                    <div class="gift-name">${msg.cardData.name}</div>
                                    <p class="gift-message">${msg.cardData.message}</p>
                                    <div class="gift-price">￥${msg.cardData.price}</div>
                                </div>
                            </div>
                        `;
                        break;
                    case 'text':
                    default:
                        bubbleContent = msg.content;
                        break;
                }
            }
            
            bubbleClass += ` ${msg.type}`;
            const avatarSrc = (isTyping && msg.isGroupTyping) ? senderInfo.avatar : (senderInfo.avatar || Utils.createAvatarDataUrl('#ccc'));
            const avatarClass = `message-avatar ${isTyping && msg.isGroupTyping ? 'group-avatar-style' : ''}`;
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            const isGroup = appState.currentChatId.startsWith('group-');
            const isMyMessage = msg.type === 'sent';
            let displayNameHtml = '';
            
            
            let timestampHtml = '';
            if (msg.isAutoReply && msg.displayTimestamp) {
                timestampHtml = `<div class="message-timestamp">${msg.displayTimestamp}<span class="auto-reply-tag">未读</span></div>`;
            }

            if (isReadOnly) {
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);
                const nameColorStyle = chatEntity?.nameColor ? `style="color: ${chatEntity.nameColor};"` : '';
                displayNameHtml = `<div class="message-name" ${nameColorStyle}>${senderInfo.name}</div>`;
            } else if (!isTyping && !['transfer-receipt'].includes(msg.segmentType)) {
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);
                const nameColorStyle = chatEntity?.nameColor ? `style="color: ${chatEntity.nameColor};"` : '';

                if (isGroup) {
                    if (!isMyMessage) displayNameHtml = `<div class="message-name" ${nameColorStyle}>${senderInfo.remark || senderInfo.name}</div>`;
                    else if (chatSettings.showMyNameInGroup) displayNameHtml = `<div class="message-name" ${nameColorStyle}>${senderInfo.name}</div>`;
                } else {
                    if (chatSettings.showNamesInPrivate) displayNameHtml = `<div class="message-name" ${nameColorStyle}>${isMyMessage ? senderInfo.name : (senderInfo.remark || senderInfo.name)}</div>`;
                }
            }
            
            messageRow.innerHTML = `<div class="message-selector"><input type="checkbox" class="message-select-checkbox"></div><img src="${avatarSrc}" alt="avatar" class="${avatarClass}"><div class="message-content">${displayNameHtml}<div class="bubble-and-tag-wrapper"><div class="${bubbleClass}">${bubbleContent}</div>${detailContent}${timestampHtml}</div></div>`;

            const avatarEl = messageRow.querySelector('.message-avatar');
            if (!isTyping && !isReadOnly) {
                avatarEl.style.cursor = 'pointer';

                let clickTimer = null;
                let clickCount = 0;

                avatarEl.addEventListener('click', (e) => {
                    clickCount++;

                    if (clickCount === 1) {
                        clickTimer = setTimeout(() => {
                            
                            if (appState.selectionMode.active) {
                                const checkbox = messageRow.querySelector('.message-select-checkbox');
                                if (checkbox) checkbox.checked = !checkbox.checked;
                                EventManager.handleMessageSelection({ target: checkbox });
                            } else if (msg.type === 'received') {
                                this.showPersonaModal(msg.senderId);
                            } else if (msg.type === 'sent') {
                                AIHandler.handleRegenerateRequest(msg.messageId);
                            }
                            clickCount = 0;
                        }, 300); 
                    } else if (clickCount === 2) {
                        
                        clearTimeout(clickTimer);
                        if (!appState.selectionMode.active) {
                            EventManager.handlePatRequest(msg.type === 'sent' ? 'myProfile' : msg.senderId);
                        }
                        clickCount = 0;
                    }
                });
            }

            if (isReadOnly) {
                const nameContainer = messageRow.querySelector('.message-name');
                if (nameContainer) {
                    
                }
            }
            
                
                if (chatSettings.showBubbleTimestamp && !isTyping && !isReadOnly && !msg.isAutoReply && ['text', 'quote', 'voice'].includes(msg.segmentType)) {
                    const wrapper = messageRow.querySelector('.bubble-and-tag-wrapper');
                    if (wrapper) {
                        const timestampEl = document.createElement('div');
                        timestampEl.className = 'bubble-timestamp';
                        timestampEl.textContent = Utils.formatTimestampForBubble(msg.timestamp);
                        wrapper.appendChild(timestampEl);
                    }
                }
            
                return messageRow;
            },

        async addMessageToDOM(msg, senderInfo, isTyping = false, isAnimating = false) {
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            if (msg.isHidden || (msg.segmentType === 'pat_a_pat' && chatSettings.enablePatAPat === false)) {
                return;
            }

            
            let freshSenderInfo = senderInfo;
            if (msg.type === 'received' && msg.senderId) {
                
                freshSenderInfo = await DBHelper.get('contacts', msg.senderId);
            } else if (msg.type === 'sent') {
                
                freshSenderInfo = await EventManager.getPlayerProfileForContext(msg.chatId);
            }
            
            if (!freshSenderInfo) {
                freshSenderInfo = { name: '未知用户', avatar: Utils.createAvatarDataUrl('#ccc') };
            }
            

            let messageElement;
            if (msg.segmentType === 'system') {
                messageElement = document.createElement('div');
                messageElement.className = 'system-notice';
                messageElement.id = msg.messageId;
                messageElement.textContent = msg.content;
            } else if (msg.segmentType === 'narrator') {
                messageElement = await this.createNarratorNoticeElement(msg);
            } else if (msg.segmentType === 'pat_a_pat') {
                messageElement = document.createElement('div');
                messageElement.className = 'pat-notice';
                messageElement.id = msg.messageId;
                messageElement.dataset.messageId = msg.messageId; 
                messageElement.textContent = msg.content.displayText;
            } else {
                
                messageElement = await this.createMessageElement(msg, freshSenderInfo, isTyping);
            }
            
            if (isTyping && msg.messageId) {
                messageElement.id = msg.messageId;
            }

            chatArea.appendChild(messageElement);
            
            if(!isTyping) {
                appState.currentChat.totalMessages++;
                appState.currentChat.renderedCount++;
            }
            chatArea.scrollTop = chatArea.scrollHeight;
        },
        
        createTimeDividerElement(timestamp) {
            const timeDiv = document.createElement('div');
            timeDiv.className = 'time-divider';
            timeDiv.textContent = Utils.formatTimestampSmartly(timestamp);
            return timeDiv;
        },

        async createNarratorNoticeElement(msg) {
            const notice = document.createElement('div');
            notice.id = msg.messageId;
            notice.dataset.messageId = msg.messageId;

            const isGroup = appState.currentChatId.startsWith('group-');
            const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);
            const narratorStyle = entity?.narratorStyle || 'grey';

            notice.className = `narrator-notice narrator-style-${narratorStyle}`;

            
            const isHtmlContent = msg.content.trim().toLowerCase().startsWith('<!doctype html');

            if (isHtmlContent) {
                
                notice.style.padding = '0'; 
                notice.style.border = 'none'; 
                notice.style.background = 'transparent'; 
                notice.style.boxShadow = 'none'; 

                const iframe = document.createElement('iframe');
                iframe.srcdoc = msg.content;
                iframe.style.width = '100%';
                iframe.style.border = 'none';
                iframe.style.borderRadius = '10px'; 
                iframe.scrolling = 'no';
                
                
                iframe.onload = function() {
                    try {
                        const body = iframe.contentWindow.document.body;
                        const html = iframe.contentWindow.document.documentElement;
                        const height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
                        iframe.style.height = height + 'px';
                    } catch (e) {
                        console.error("无法调整iframe高度:", e);
                    }
                };

                notice.innerHTML = `<div class="message-selector"><input type="checkbox" class="message-select-checkbox"></div>`;
                notice.appendChild(iframe); 
            } else {
                
                notice.innerHTML = `<div class="message-selector"><input type="checkbox" class="message-select-checkbox"></div><span>${msg.content}</span>`;
            }

            return notice;
        },
        
            createRetractionNotice(msg, senderInfo) {
                const notice = document.createElement('div');
                notice.className = 'retracted-notice';
                notice.id = msg.messageId; 
                const isGroup = appState.currentChatId.startsWith('group-');
                const senderName = msg.type === 'sent' ? '你' : (senderInfo.remark || senderInfo.name);
                notice.textContent = `${senderName} 撤回了一条消息`;
                
                notice.addEventListener('click', () => {
                    let retractedContentHtml = '';
                    if (msg.segmentType === 'emoji-image') {
                        retractedContentHtml = `<img src="https://z.wiki/u/${msg.content}" style="max-width: 150px; display: block; margin: 10px auto;">`;
                    } else {
                        retractedContentHtml = `<p style="line-height: 1.6;">${msg.content}</p>`;
                    }
                    this.showModal({
                        title: "被撤回的消息",
                        body: retractedContentHtml,
                        actions: [{ text: '关闭', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                });
                return notice;
            },

            async renderGiftsPage() {
                const giftsGrid = $('#gifts-grid');
                $('#gifts-section-title').textContent = '大家都在送';
                giftsGrid.innerHTML = ''; 

                const PREDEFINED_GIFTS = [
                    { name: '玫瑰花束', price: 128.00, image: 'https://z.wiki/u/OZbNtm', message: '送你一束玫瑰，愿你天天开心。' },
                    { name: '巧克力礼盒', price: 88.00, image: 'https://cfimg.200996.xyz/file/1752744402256_retouch_2025071717245049.png', message: '甜甜的巧克力，给甜甜的你。' },
                    { name: '游戏机', price: 2199.00, image: 'https://cfimg.200996.xyz/file/1752744403509_retouch_2025071717243405.png', message: '一起玩游戏吧！' },
                    { name: '手作蛋糕', price: 68.00, image: 'https://z.wiki/u/18hMdP', message: '亲手为你做的，尝尝看？' },
                    { name: '可爱猫咪', price: 0, image: 'https://z.wiki/u/RSvBmf', message: '路边捡的，给你养了。' },
                    { name: '奶茶一杯', price: 18.00, image: 'https://z.wiki/u/XIexsP', message: '天冷了，喝杯热奶茶吧。' }
                ];
                
                PREDEFINED_GIFTS.forEach(gift => {
                    const card = EventManager.createGiftCard(gift);
                    card.onclick = () => EventManager.showSendGiftModal(gift);
                    giftsGrid.appendChild(card);
                });
            },

            async showPersonaModal(contactOrId, onCancelCallback = null, fromGroupInsight = false) {
                let contact;
                if (typeof contactOrId === 'string') {
                    contact = await DBHelper.get('contacts', contactOrId);
                } else {
                    contact = contactOrId;
                }

                if (!contact) return;

                const lastInnerVoice = contact.lastInnerVoiceId ? await DBHelper.get('messages', contact.lastInnerVoiceId) : null;
                const lastEssay = contact.lastEssayId ? await DBHelper.get('messages', contact.lastEssayId) : null;

                let bodyHtml = `
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
                        <img src="${contact.avatar}" style="width: 70px; height: 70px; border-radius: 12px; object-fit: cover;">
                        <div>
                            <h3 style="font-size: 1.4rem; margin-bottom: 5px;">${contact.remark || contact.name}</h3>
                            <p style="color: #888;">ID: ${contact.name}</p>
                        </div>
                    </div>
                `;

                
                bodyHtml += `<div class="persona-modal-card"><h4>心声</h4><p>${lastInnerVoice ? lastInnerVoice.content : '暂未洞察到心声内容'}</p></div>`;

                
                if (lastEssay) {
                    bodyHtml += `<div class="persona-modal-card note-paper"><h4>随笔</h4><p>${lastEssay.content}</p></div>`;
                }
                
                
                this.showModal({
                    title: "角色洞察",
                    body: bodyHtml,
                    actions: [
                        { text: '进入聊天', class: 'btn-primary', handler: () => {
                            this.hideModal();
                            this.openChat(contact.id); 
                        }}
                    ]
                });

                
                if (fromGroupInsight) {
                    const overlay = $('#modal-overlay');
                    const originalClickHandler = overlay.onclick; 
                    overlay.onclick = (e) => {
                        if (e.target === overlay) {
                            this.hideModal();
                            
                            if (appState.currentChatId) {
                                this.showGroupInsightModal(appState.currentChatId);
                            }
                        }
                    };

                    
                    const originalHide = this.hideModal;
                    this.hideModal = () => {
                        overlay.onclick = originalClickHandler; 
                        originalHide.call(this);
                        this.hideModal = originalHide; 
                    };
                }
            },

            async showModal(config) {
                
                if (appState.theme === 'neumorphic' && !config.customClass) {
                    modalContentWrapper.classList.add('modal-neumorphic');
                } else if (config.customClass) {
                    modalContentWrapper.classList.add(config.customClass);
                }

                
                if (config.isPersistent) {
                    modalOverlay.classList.add('no-overlay-close');
                } else {
                    modalOverlay.classList.remove('no-overlay-close');
                }
                
                let actionsHtml = '';
                if (config.actions) {
                    actionsHtml = `<div class="modal-actions">` + config.actions.map((action, index) => {
                        const idAttribute = action.id ? `id="${action.id}"` : '';
                        return `<button ${idAttribute} class="modal-btn ${action.class}" data-action-index="${index}">${action.text}</button>`;
                    }).join('') + `</div>`;
                }

                modalContentWrapper.innerHTML = `
                    <h2 class="modal-header">${config.title}</h2>
                    <div class="modal-body">${config.body}</div>
                    ${actionsHtml}
                `;

                if (config.actions) {
                    
                    $$('#modal-content-wrapper .modal-actions .modal-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const index = parseInt(btn.dataset.actionIndex, 10);
                            if (config.actions[index] && typeof config.actions[index].handler === 'function') {
                                config.actions[index].handler();
                            }
                        });
                    });
                }
                
                modalOverlay.classList.add('visible');
            },

            hideModal() {
                modalOverlay.classList.remove('visible');
                
                modalContentWrapper.className = 'modal-content';
                modalContentWrapper.innerHTML = '';
            },
            
            showBottomSheet(config) {
                const sheetOverlay = $('#bottom-sheet-overlay');
                const sheetContent = $('#bottom-sheet-content-wrapper');

                sheetContent.className = 'bottom-sheet-content';

                sheetContent.innerHTML = `
                    <div class="bottom-sheet-header">${config.title}</div>
                    <div class="bottom-sheet-body">
                        ${config.items.map(item => `<div class="bottom-sheet-item" data-value="${item.value}">${item.text}</div>`).join('')}
                    </div>
                `;

                if (appState.theme === 'neumorphic') sheetContent.classList.add('neumorphic');
                if (config.customClass) sheetContent.classList.add(...config.customClass.split(' '));
                
                $$('.bottom-sheet-item').forEach(item => {
                    item.addEventListener('click', () => {
                        config.onSelect(item.dataset.value, item.textContent);
                        this.hideBottomSheet();
                    });
                });

                
                sheetOverlay.style.visibility = 'visible';
                requestAnimationFrame(() => {
                    sheetOverlay.classList.add('visible');
                });
            },

            hideBottomSheet() {
                const sheetOverlay = $('#bottom-sheet-overlay');
                sheetOverlay.classList.remove('visible');
                
                setTimeout(() => {
                    sheetOverlay.style.visibility = 'hidden';
                }, 300); 
            },

            showSidebar(config) {
                const sidebarContent = $('#sidebar-content');
                const sidebarOverlay = $('#sidebar-overlay');

                
                sidebarContent.className = 'sidebar-content';

                
                if (appState.theme === 'neumorphic') {
                    sidebarContent.classList.add('neumorphic');
                }

                
                if (config.position === 'left') {
                    sidebarContent.classList.add('sidebar-from-left');
                } else {
                    sidebarContent.classList.remove('sidebar-from-left');
                }

                
                let actionsHtml = '';
                if (config.actions) {
                    actionsHtml = `<div class="modal-actions" style="margin-top: 30px;">` + config.actions.map((action, index) =>
                        `<button class="modal-btn ${action.class}" data-action-index="${index}">${action.text}</button>`
                    ).join('') + `</div>`;
                }
                sidebarContent.innerHTML = `
                    <h2 class="modal-header" style="text-align: left; padding-left: 0;">${config.title}</h2>
                    <div class="modal-body">${config.body}</div>
                    ${actionsHtml}
                `;

                
                if (config.actions) {
                    $$('#sidebar-content .modal-actions .modal-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const index = parseInt(btn.dataset.actionIndex, 10);
                            if (config.actions[index] && typeof config.actions[index].handler === 'function') {
                                config.actions[index].handler();
                            }
                        });
                    });
                }
                
                
                sidebarOverlay.classList.add('visible');
            },

            hideSidebar() {
                const sidebarOverlay = $('#sidebar-overlay');
                const sidebarContent = $('#sidebar-content');
                
                sidebarOverlay.classList.remove('visible');
                
                
                setTimeout(() => {
                    sidebarContent.classList.remove('sidebar-from-left');
                }, 400); 
            },

            showToast(message, duration = 1000) {
                
                const existingToast = $('#toast-notification');
                if (existingToast) {
                    existingToast.remove();
                }

                const toast = document.createElement('div');
                toast.id = 'toast-notification';
                toast.className = 'toast-notification';
                toast.textContent = message;

                
                document.body.appendChild(toast);

                
                setTimeout(() => {
                    
                    toast.classList.add('hiding');
                    
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300); 
                }, duration);
            },

            showTopNotification(msg) {
                this.notificationQueue.push(msg);
                this.processNotificationQueue();
            },

            showEssayNotification(authorName, contactId) {
                
                if ($('.essay-notification-banner')) return;

                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'essay-notification-banner';
                banner.innerHTML = `
                    <div class="icon-wrapper">
                        <i class="fas fa-heart"></i>
                    </div>
                    <span class="text-content">${authorName} 更新了随笔</span>
                `;

                
                banner.addEventListener('click', () => {
                    this.showPersonaModal(contactId);
                    hideAndRemove();
                });

                const hideAndRemove = () => {
                    if (container.contains(banner)) {
                         banner.style.animation = 'notification-exit 0.5s forwards';
                         setTimeout(() => {
                            if (container.contains(banner)) container.removeChild(banner);
                         }, 500);
                    }
                };
                
                container.appendChild(banner);

                
                setTimeout(() => {
                    banner.classList.add('is-playing');
                }, 10);

                
                setTimeout(hideAndRemove, 4000);
            },

            showPomodoroEndNotification(goal) {
                if ($('.pomodoro-notification-banner')) return;

                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'pomodoro-notification-banner';
                banner.innerHTML = `
                    <div class="icon-wrapper">
                        <i class="fas fa-clock"></i>
                    </div>
                    <span class="text-content">${goal} 已结束</span>
                `;

                const hideAndRemove = () => {
                    if (container.contains(banner)) {
                         banner.style.animation = 'notification-exit 0.5s forwards';
                         setTimeout(() => {
                            if (container.contains(banner)) container.removeChild(banner);
                         }, 500);
                    }
                };
                
                container.appendChild(banner);

                setTimeout(() => {
                    banner.classList.add('is-playing');
                }, 10);

                setTimeout(hideAndRemove, 4000);
            },

            async showMomentNotification(moment) {
                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'notification-banner';

                const allContacts = await DBHelper.getAll('contacts');
                const author = allContacts.find(c => c.id === moment.authorId);
                
                if (!author) return;

                banner.innerHTML = `
                    <img src="${author.avatar}" alt="avatar" class="notification-avatar">
                    <div class="notification-content">
                        <div class="notification-header">
                            <span class="notification-name">${author.remark || author.name} 发布了新动态</span>
                        </div>
                        <p class="notification-message">${moment.content}</p>
                    </div>
                `;

                const hideAndRemove = () => {
                    if (container.contains(banner)) {
                         banner.style.animation = 'notification-exit 0.5s forwards';
                         setTimeout(() => {
                            if (container.contains(banner)) container.removeChild(banner);
                         }, 500);
                    }
                };

                banner.addEventListener('click', async () => {
                    await this.navigateTo('moments');
                    await this.renderMomentsPage(moment.circleId);
                    hideAndRemove();
                });
                
                container.appendChild(banner);

                setTimeout(hideAndRemove, 3000);
            },

            renderPomodoroPage() {
                const { isActive, goal } = appState.pomodoro;
                const timerDisplay = $('#pomodoro-timer-display');
                const goalInput = $('#pomodoro-goal-input');
                const startBtn = $('#pomodoro-start-btn');
                const stopBtn = $('#pomodoro-stop-btn');

                if (isActive) {
                    goalInput.value = goal;
                    goalInput.disabled = true;
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                } else {
                    timerDisplay.textContent = '25:00';
                    goalInput.value = '';
                    goalInput.disabled = false;
                    startBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'none';
                }
            },

            async processNotificationQueue() {
                if (this.isDisplayingNotification || this.notificationQueue.length === 0) {
                    return;
                }
                this.isDisplayingNotification = true;

                const msg = this.notificationQueue.shift();
                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'notification-banner';

                let messageContent = msg.content;
                if (msg.segmentType === 'emoji-image') messageContent = '[表情包]';
                else if (msg.segmentType === 'voice') messageContent = msg.cardData.content;
                else if (msg.isRetracted) messageContent = '撤回了一条消息';
                
                let notificationAvatar, notificationName, clickTargetId;
                const isGroup = msg.chatId && msg.chatId.startsWith('group-');
                clickTargetId = msg.chatId;

                if (isGroup) {
                    const group = await DBHelper.get('groups', msg.chatId);
                    if (group) {
                        notificationAvatar = group.avatar;
                        notificationName = group.name;
                        const senderName = msg.senderInfo.remark || msg.senderInfo.name;
                        messageContent = `${senderName}：${messageContent}`;
                    } else { 
                        notificationAvatar = msg.senderInfo.avatar;
                        notificationName = msg.senderInfo.remark || msg.senderInfo.name;
                    }
                } else {
                    notificationAvatar = msg.senderInfo.avatar;
                    notificationName = msg.senderInfo.remark || msg.senderInfo.name;
                }

                banner.innerHTML = `
                    <img src="${notificationAvatar}" alt="avatar" class="notification-avatar">
                    <div class="notification-content">
                        <div class="notification-header">
                            <span class="notification-name">${notificationName}</span>
                            <span class="notification-time">${Utils.formatTimestampSmartly(msg.timestamp)}</span>
                        </div>
                        <p class="notification-message">${messageContent}</p>
                    </div>
                `;

                const hideAndProcessNext = () => {
                    if (!container.contains(banner)) return;
                    clearTimeout(autoHideTimeout);
                    banner.style.animation = 'notification-exit 0.5s forwards';
                    setTimeout(() => {
                        if (container.contains(banner)) container.removeChild(banner);
                        this.isDisplayingNotification = false;
                        setTimeout(() => this.processNotificationQueue(), 200);
                    }, 500);
                };
                
                const displayDuration = this.notificationQueue.length > 0 ? 1000 : 5000;
                const autoHideTimeout = setTimeout(hideAndProcessNext, displayDuration);

                banner.addEventListener('click', () => {
                    this.openChat(clickTargetId);
                    hideAndProcessNext();
                });

                container.appendChild(banner);
            },

            async showContactInfo(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                const bodyHtml = `
                    <div class="details-card">
                        <div class="details-header">
                            <img src="${contact.avatar}" class="avatar">
                            <div class="details-info">
                                <div class="name">${contact.remark || contact.name}</div>
                                <div class="id">ID: ${contact.name}</div>
                            </div>
                        </div>
                         <div class="details-field"><span class="label">性别</span><span class="value">${contact.gender}</span></div>
                    </div>
                    <div class="details-card">
                       ${contact.likes ? `<div class="details-field"><span class="label">喜好</span><span class="value">${contact.likes}</span></div>` : ''}
                       ${contact.dislikes ? `<div class="details-field"><span class="label">厌恶</span><span class="value">${contact.dislikes}</span></div>` : ''}
                       ${contact.habits ? `<div class="details-field"><span class="label">习惯</span><span class="value">${contact.habits}</span></div>` : ''}
                       ${contact.background ? `<div class="details-section">
                            <div class="details-section-title">背景资料</div>
                            <p>${contact.background}</p>
                        </div>` : ''}
                    </div>
                    <div class="details-actions">
                        <button class="details-btn btn-details-primary" data-action="chat">发消息</button>
                        <button class="details-btn" data-action="export" style="border-color: var(--theme-color-4); color: var(--text-color-dark);">导出角色</button>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                             <button class="details-btn" data-action="edit" style="flex: 1;">编辑</button>
                             <button class="details-btn btn-details-danger" data-action="delete" style="flex: 1;">删除好友</button>
                        </div>
                    </div>
                `;

                this.showModal({
                    
                    title: `
                        <span style="flex-grow: 1;">详细资料</span>
                        ${contact.author ? `<div class="details-header-attribution" data-action="show-attribution" title="查看作者信息" style="position: static; transform: none;">?</div>` : ''}
                    `,
                    body: bodyHtml,
                    actions: [] 
                });

                
                modalContentWrapper.querySelector('.modal-header').style.display = 'flex';
                modalContentWrapper.querySelector('.modal-header').style.alignItems = 'center';
                
                
                modalContentWrapper.querySelector('[data-action="chat"]').addEventListener('click', () => {
                    this.hideModal();
                    this.openChat(contactId);
                });
                modalContentWrapper.querySelector('[data-action="edit"]').addEventListener('click', () => {
                    this.hideModal();
                    
                    EventManager.showEditFriendModal(contactId, async () => {
                        await UIManager.renderContactsPage('friends');
                    });
                });
                modalContentWrapper.querySelector('[data-action="delete"]').addEventListener('click', async () => {
                    const groups = await DBHelper.getAll('groups');
                    const isInGroup = groups.some(g => g.members.includes(contactId));
                    this.confirmDeleteContact(contactId, isInGroup);
                });
                modalContentWrapper.querySelector('[data-action="export"]').addEventListener('click', () => EventManager.handleExportContact(contactId));
                
                const attributionBtn = modalContentWrapper.querySelector('[data-action="show-attribution"]');
                if (attributionBtn) {
                    attributionBtn.addEventListener('click', () => EventManager.showAttributionModal(contact));
                }
            },
            
            async showGroupInfo(groupId) {
                const group = await DBHelper.get('groups', groupId);
                if (!group) return;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                let creatorName = '未知';
                if (group.creatorId === myProfile.id) {
                    creatorName = `我 (${myProfile.name})`;
                } else {
                    const creatorContact = allContacts.find(c => c.id === group.creatorId);
                    if (creatorContact) creatorName = creatorContact.remark || creatorContact.name;
                }
                
                const membersDetails = group.members
                    .map(memberId => allContacts.find(c => c.id === memberId))
                    .filter(Boolean);

                const membersHtml = membersDetails.map(member => `
                    <div class="member-item">
                        <img src="${member.avatar}" class="avatar" alt="${member.name}">
                        <span class="name">${member.remark || member.name}</span>
                    </div>
                `).join('');

                const isMyGroup = group.creatorId === myProfile.id;

                const bodyHtml = `
                    <div class="details-card">
                        <div class="details-header">
                            <img src="${group.avatar}" class="avatar">
                            <div class="details-info">
                                <div class="name">${group.name}</div>
                                <div class="id">群主: ${creatorName}</div>
                            </div>
                        </div>
                    </div>
                    <div class="details-card">
                        <div class="details-section-title">群成员 (${group.members.length})</div>
                        <div class="member-grid">${membersHtml}</div>
                    </div>
                    <div class="details-actions">
                        <button class="details-btn btn-details-primary" data-action="chat">发消息</button>
                        <button class="details-btn" data-action="export" style="border-color: var(--theme-color-4); color: var(--text-color-dark);">导出群聊</button>
                        <button class="details-btn btn-details-danger" data-action="delete">${isMyGroup ? '解散群聊' : '退出群聊'}</button>
                    </div>
                `;

                this.showModal({
                    title: `
                        <span style="flex-grow: 1;">群聊资料</span>
                        ${group.author ? `<div class="details-header-attribution" data-action="show-attribution" title="查看作者信息" style="position: static; transform: none;">?</div>` : ''}
                    `,
                    body: bodyHtml,
                    actions: []
                });

                
                modalContentWrapper.querySelector('.modal-header').style.display = 'flex';
                modalContentWrapper.querySelector('.modal-header').style.alignItems = 'center';

                modalContentWrapper.querySelector('[data-action="chat"]').addEventListener('click', () => {
                    this.hideModal();
                    this.openChat(groupId);
                });
                modalContentWrapper.querySelector('[data-action="delete"]').addEventListener('click', () => {
                    this.confirmDeleteGroup(groupId, isMyGroup);
                });
                modalContentWrapper.querySelector('[data-action="export"]').addEventListener('click', () => EventManager.handleExportGroup(groupId));

                const attributionBtn = modalContentWrapper.querySelector('[data-action="show-attribution"]');
                if (attributionBtn) {
                    attributionBtn.addEventListener('click', () => EventManager.showAttributionModal(group));
                }
            },
            
            confirmDeleteGroup(groupId, isCreator, onCancel) { 
                const actionText = isCreator ? '解散' : '退出';
                this.showModal({
                    title: `确认${actionText}`,
                    body: `<p>你确定要${actionText}此群聊吗？所有聊天记录将被清空且无法恢复。</p>`,
                    actions: [
                        
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            this.hideModal();
                            if (onCancel) {
                                onCancel();
                            } else {
                                this.showGroupInfo(groupId);
                            }
                        }},
                        { text: `确认${actionText}`, class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('groups', groupId);
                            await DBHelper.delete('chatMetadata', groupId);
                            await DBHelper.deleteMessagesForChat(groupId); 
                            this.hideModal();
                            this.hideSidebar();
                            
                            await this.navigateTo('contacts');
                            await this.renderContactsPage('groups');
                            await this.renderMessagesListPage(); 
                        }}
                    ]
                });
            },
            async confirmDeleteContact(contactId, isInGroup) {
                if (isInGroup) {
                    const groups = (await DBHelper.getAll('groups')).filter(g => g.members.includes(contactId));
                    const groupNames = groups.map(g => g.name).join('、');
                    this.showModal({
                        title: "无法删除",
                        body: `<p>无法删除好友，因为对方仍在群聊：<strong>${groupNames}</strong> 中。请先将其移出群聊或解散群聊。</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => this.showContactInfo(contactId) }]
                    });
                    return;
                }
                
                this.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除该好友吗？所有聊天记录将被清空且无法恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => this.showContactInfo(contactId) },
                        { text: '确认删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('contacts', contactId);
                            await DBHelper.delete('chatMetadata', contactId);
                            await DBHelper.deleteMessagesForChat(contactId); 
                            this.hideModal();
                            await this.renderContactsPage();
                            await this.renderMessagesListPage(); 
                        }}
                    ]
                });
            },
            async showGroupManagementSidebar(group) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const isMyGroup = group.creatorId === myProfile.id;
                
                
                this.showSidebar({
                    position: 'right', 
                    title: "群聊管理",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-edit-group">
                                <i class="fas fa-edit"></i>
                                <span>修改群聊信息</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-view-members">
                                <i class="fas fa-users"></i>
                                <span>查看群成员</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-invite-members">
                                <i class="fas fa-user-plus"></i>
                                <span>邀请新成员</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            ${isMyGroup ? `
                            <div class="setting-item" id="sidebar-remove-members">
                                <i class="fas fa-user-minus"></i>
                                <span>移除群成员</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            ` : ''}
                            <div class="setting-item" id="sidebar-bind-prompts">
                                <i class="fas fa-link"></i>
                                <span>绑定提示词</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-persona">
                                <i class="fas fa-user-tag"></i>
                                <span>绑定玩家人设</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-opening-scene">
                                <i class="fas fa-scroll"></i>
                                <span>开场白设定</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-chat-background">
                                <i class="fas fa-image"></i>
                                <span>专属聊天背景</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
<div class="setting-item" id="sidebar-auto-summary">
    <i class="fas fa-file-alt"></i>
    <span>自动总结</span>
    <i class="fas fa-chevron-right"></i>
</div>
<div class="setting-item" id="sidebar-forward-chat">
                                <i class="fas fa-share-square"></i>
                                <span>多选消息</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-clear-history-group">
                                <i class="fas fa-eraser"></i>
                                <span>清空聊天记录</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-leave-group">
                                <i class="fas ${isMyGroup ? 'fa-dumpster-fire' : 'fa-door-open'}"></i>
                                <span>${isMyGroup ? '解散群聊' : '退出群聊'}</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
                
                
                $('#sidebar-edit-group').addEventListener('click', () => {
                    this.showModal({
                        title: "修改群聊信息",
                        body: `
                            <div class="form-group">
                                <label>群头像</label>
                                <div class="avatar-uploader">
                                    <img src="${group.avatar}" id="group-manage-avatar-preview" class="avatar-preview">
                                    <input type="file" id="group-manage-avatar-input" accept="image/*" style="display:none;">
                                    <button class="upload-btn" onclick="document.getElementById('group-manage-avatar-input').click()">上传新头像</button>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="group-manage-name">群名称</label>
                                <input type="text" id="group-manage-name" value="${group.name}">
                            </div>
                        `,
                        actions: [
                            { text: '取消', class: 'btn-secondary', handler: () => this.hideModal() },
                            { text: '保存', class: 'btn-primary', handler: async () => {
                                const newName = $('#group-manage-name').value.trim();
                                if (!newName) return;
                                const oldName = group.name;
                                const updatedGroup = { ...group, name: newName, avatar: $('#group-manage-avatar-preview').src };
                                await DBHelper.put('groups', updatedGroup);
                                chatTitle.textContent = newName;

                                if (oldName !== newName) {
                                    const myProfile = await DBHelper.get('profile', 'myProfile');
                                    const systemMessage = {
                                        messageId: Utils.generateId('msg'),
                                        chatId: group.id, 
                                        content: `${myProfile.name} 修改群名为 “${newName}”`,
                                        timestamp: Date.now(),
                                        type: 'received',
                                        segmentType: 'system',
                                        forAi: true,
                                    };
                                    
                                    await DBHelper.put('messages', systemMessage);
                                    
                                    await UIManager.updateChatMetadata(group.id, systemMessage);
                                    
                                    if (appState.currentChatId === group.id) {
                                        await UIManager.refreshChatView();
                                    }
                                }
                                this.hideModal();
                            }}
                        ]
                    });
                     $('#group-manage-avatar-input').addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) $('#group-manage-avatar-preview').src = await Utils.fileToBase64(file);
                    });
                });
                
                $('#sidebar-view-members').addEventListener('click', () => this.showGroupMemberListModal(group.id));
                $('#sidebar-invite-members').addEventListener('click', () => EventManager.handleInviteMembers(group.id));
                if (isMyGroup) {
                    $('#sidebar-remove-members').addEventListener('click', () => EventManager.handleRemoveMembers(group.id));
                }
                $('#sidebar-bind-prompts').addEventListener('click', () => EventManager.showBindingModal(group.id)); 
                $('#sidebar-bind-persona').addEventListener('click', () => EventManager.showPersonaBindingModal(group.id, true));
                $('#sidebar-opening-scene').addEventListener('click', () => EventManager.handleOpeningSceneSettings(group.id, true));
                $('#sidebar-chat-background').addEventListener('click', () => EventManager.handleChatBackgroundSettings(group.id, true));
                $('#sidebar-auto-summary').addEventListener('click', () => EventManager.handleAutoSummarySettings(group.id, true));
                $('#sidebar-forward-chat').addEventListener('click', () => {
                    UIManager.hideSidebar();
                    EventManager.toggleSelectionMode();
                });
                $('#sidebar-clear-history-group').addEventListener('click', () => EventManager.handleClearChatHistory(group.id, true));
                $('#sidebar-leave-group').addEventListener('click', () => {
                    this.confirmDeleteGroup(group.id, isMyGroup, () => this.showGroupManagementSidebar(group));
                });
            },

            async showGroupInsightModal(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');

                const members = group.members
                    .map(id => allContacts.find(c => c.id === id))
                    .filter(Boolean);

                const membersHtml = members.map(member => `
                    <div class="insight-member-item">
                        <img src="${member.avatar}" alt="${member.name}">
                        <span>${member.remark || member.name}</span>
                        <button class="modal-btn btn-secondary insight-view-btn" data-member-id="${member.id}">查看</button>
                    </div>
                `).join('');

                this.showModal({
                    title: "选择成员进行洞察",
                    body: `<div class="insight-member-list">${membersHtml}</div>`,
                    actions: [{ text: '关闭', class: 'btn-primary', handler: () => this.hideModal() }]
                });

                
                const modalBody = modalContentWrapper.querySelector('.modal-body');
                if (modalBody) {
                    modalBody.addEventListener('click', (e) => {
                        const viewBtn = e.target.closest('.insight-view-btn');
                        if (viewBtn) {
                            const memberId = viewBtn.dataset.memberId;
                            this.hideModal();
                            
                            this.showPersonaModal(memberId, null, true); 
                        }
                    });
                }
            },

            async showGroupMemberListModal(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                
                const aiMembers = group.members
                    .map(id => allContacts.find(c => c.id === id))
                    .filter(Boolean);

                
                const playerAsMember = {
                    id: myProfile.id,
                    avatar: myProfile.avatar,
                    name: myProfile.name,
                    isPlayer: true
                };

                
                const allParticipants = [...aiMembers, playerAsMember];

                
                let owner;
                const otherMembers = [];
                allParticipants.forEach(p => {
                    if (p.id === group.creatorId) {
                        owner = p;
                    } else {
                        otherMembers.push(p);
                    }
                });
                
                
                const finalOrderedList = owner ? [owner, ...otherMembers] : otherMembers;

                
                const membersHtml = finalOrderedList.map(member => `
                    <div class="member-list-modal-item">
                        <img src="${member.avatar}" alt="${member.name}">
                        <span>${member.remark || member.name}</span>
                        ${member.id === group.creatorId ? '<span class="owner-tag">群主</span>' : ''}
                        ${member.isPlayer ? '<span class="owner-tag" style="background-color: var(--accent-color);">你</span>' : ''}
                    </div>
                `).join('');

                this.showModal({
                    title: `群成员 (${finalOrderedList.length})`,
                    body: `<div class="member-list-modal-body"><ul>${membersHtml}</ul></div>`,
                    actions: [{ text: '关闭', class: 'btn-primary', handler: () => this.hideModal() }]
                });
            },

            async showFriendManagementSidebar(contact) {
                 this.showSidebar({
                    position: 'right', 
                    title: "好友管理",
                     body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-view-friend">
                                <i class="fas fa-info-circle"></i>
                                <span>查看详细资料</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-edit-friend">
                                <i class="fas fa-user-edit"></i>
                                <span>修改好友信息</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-persona-friend">
                                <i class="fas fa-user-tag"></i>
                                <span>绑定玩家人设</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-prompts">
                                <i class="fas fa-link"></i>
                                <span>绑定提示词</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-opening-scene-friend">
                                <i class="fas fa-scroll"></i>
                                <span>开场白设定</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-chat-background">
                                <i class="fas fa-image"></i>
                                <span>专属聊天背景</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-auto-summary">
    <i class="fas fa-file-alt"></i>
    <span>自动总结</span>
    <i class="fas fa-chevron-right"></i>
</div>
                            <div class="setting-item" id="sidebar-bind-circle">
                                <i class="fas fa-link"></i>
                                <span>绑定朋友圈</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-forward-chat-friend">
                                <i class="fas fa-share-square"></i>
                                <span>多选消息</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-clear-history-friend">
                                <i class="fas fa-eraser"></i>
                                <span>清空聊天记录</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-delete-friend">
                                <i class="fas fa-user-times"></i>
                                <span>删除好友</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });

                $('#sidebar-view-friend').addEventListener('click', () => {
                     this.showModal({
                        title: "详细资料",
                        body: `
                            <div class="details-card">
                                <div class="details-header"><img src="${contact.avatar}" class="avatar"><div class="details-info"><div class="name">${contact.remark || contact.name}</div><div class="id">ID: ${contact.name}</div></div></div>
                                <div class="details-field"><span class="label">性别</span><span class="value">${contact.gender}</span></div>
                            </div>
                            <div class="details-card">
                               ${contact.likes ? `<div class="details-field"><span class="label">喜好</span><span class="value">${contact.likes}</span></div>` : ''}
                               ${contact.dislikes ? `<div class="details-field"><span class="label">厌恶</span><span class="value">${contact.dislikes}</span></div>` : ''}
                               ${contact.habits ? `<div class="details-field"><span class="label">习惯</span><span class="value">${contact.habits}</span></div>` : ''}
                               ${contact.background ? `<div class="details-section"><div class="details-section-title">背景资料</div><p>${contact.background}</p></div>` : ''}
                            </div>
                        `,
                        actions: [{ text: '关闭', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                });

                $('#sidebar-edit-friend').addEventListener('click', () => {
                    EventManager.showEditFriendModal(contact.id);
                });
                
                $('#sidebar-bind-persona-friend').addEventListener('click', () => EventManager.showPersonaBindingModal(contact.id, false));
                
                $('#sidebar-bind-prompts').addEventListener('click', () => EventManager.showBindingModal(contact.id)); 
                $('#sidebar-opening-scene-friend').addEventListener('click', () => EventManager.handleOpeningSceneSettings(contact.id, false));
                $('#sidebar-chat-background').addEventListener('click', () => EventManager.handleChatBackgroundSettings(contact.id, false));
                $('#sidebar-auto-summary').addEventListener('click', () => EventManager.handleAutoSummarySettings(contact.id, false));
                $('#sidebar-bind-circle').addEventListener('click', () => EventManager.showCircleBindingModal(contact.id, false));
                $('#sidebar-forward-chat-friend').addEventListener('click', () => {
                    UIManager.hideSidebar();
                    EventManager.toggleSelectionMode();
                });
                $('#sidebar-clear-history-friend').addEventListener('click', () => EventManager.handleClearChatHistory(contact.id, false));
                $('#sidebar-delete-friend').addEventListener('click', async () => {
                    const groups = await DBHelper.getAll('groups');
                    const isInGroup = groups.some(g => g.members.includes(contact.id));
                    UIManager.confirmDeleteContact(contact.id, isInGroup);
                });
            },


            async confirmDeleteContact(contactId, isInGroup) {
                if (isInGroup) {
                    const groups = (await DBHelper.getAll('groups')).filter(g => g.members.includes(contactId));
                    const groupNames = groups.map(g => g.name).join('、');
                    UIManager.showModal({
                        title: "无法删除",
                        body: `<p>无法删除好友，因为对方仍在群聊：<strong>${groupNames}</strong> 中。请先将其移出或解散相关群聊。</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }
                
                UIManager.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除该好友吗？所有聊天记录将被清空且无法恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('contacts', contactId);
                            await DBHelper.delete('chatMetadata', contactId);
                            await DBHelper.deleteMessagesForChat(contactId);
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.navigateTo('messages');
                            await UIManager.renderContactsPage();
                            await UIManager.renderMessagesListPage();
                        }}
                    ]
                });
            },

async showAutoSummaryModal(entityId, isGroup) {
    const storeName = isGroup ? 'groups' : 'contacts';
    const entity = await DBHelper.get(storeName, entityId);
    if (!entity) return;

    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
    const defaultSummaryPrompt = `你是一个聊天记录总结助手。请根据“最新聊天记录”，为我生成一段不超过350个字的新总结。新的总结需要融合旧总结的核心内容和新聊天记录的要点，保持故事的连贯性。请重点关注时间的发生时间、人物关系的变化、关键事件的进展、以及重要信息的交换。内容应客观、信息丰富且凝练。`;
    const userSummaryPrompt = chatSettings.summaryPrompt || defaultSummaryPrompt;

    const summaryEnabled = entity.autoSummaryEnabled || false;
    const summaryText = entity.autoSummary || '';
    const isSummarizing = appState.isSummarizing[entityId] || false;

    const summaryStatusHtml = isSummarizing ? `
        <div style="display: flex; align-items: center; gap: 8px; font-size: 0.9rem; color: var(--accent-color); margin-top: 10px;">
            <div class="loader-spinner" style="width: 16px; height: 16px; border-width: 2px;"></div>
            <span>AI正在总结中，请稍后...</span>
        </div>
    ` : '';

    UIManager.showModal({
        title: "自动总结设置",
        body: `
            <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                <label style="margin: 0;">启用自动总结</label>
                <label class="switch">
                    <input type="checkbox" id="auto-summary-switch" ${summaryEnabled ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
            </div>
            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: -10px; margin-bottom: 20px;">
                开启后，每隔N条消息(包含你和AI 默认值200)，AI会自动总结一次聊天内容。你可以在“聊天设置”中修改此间隔。
            </p>
            <div class="form-group">
                <label for="summary-prompt-input">总结提示词 (可修改)</label>
                <textarea id="summary-prompt-input" rows="6">${userSummaryPrompt}</textarea>
            </div>
            <button id="immediate-summary-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 20px;" ${isSummarizing ? 'disabled' : ''}>
                <i class="fas fa-magic"></i> 立即总结
            </button>
            <div class="form-group">
                <label for="auto-summary-content">当前总结内容 (可编辑)</label>
                <textarea id="auto-summary-content" rows="8" placeholder="暂无总结内容..." ${isSummarizing ? 'readonly' : ''}>${summaryText}</textarea>
                ${summaryStatusHtml}
            </div>
        `,
        actions: [
            { text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() },
            { text: '保存', class: 'btn-primary', handler: async () => {
                if (isSummarizing) {
                    return UIManager.showToast("正在总结中，请稍后再保存。");
                }
                const updatedEntity = await DBHelper.get(storeName, entityId);
                updatedEntity.autoSummaryEnabled = $('#auto-summary-switch').checked;
                updatedEntity.autoSummary = $('#auto-summary-content').value.trim();
                await DBHelper.put(storeName, updatedEntity);
                
                const currentChatSettings = await DBHelper.get('apiConfig', 'chatSettings') || { id: 'chatSettings' };
                currentChatSettings.summaryPrompt = $('#summary-prompt-input').value.trim();
                await DBHelper.put('apiConfig', currentChatSettings);

                UIManager.hideModal();
                UIManager.showToast("设置已保存！");
            }}
        ]
    });

    $('#immediate-summary-btn').addEventListener('click', () => {
        EventManager.handleImmediateSummary(entityId, isGroup);
    });
},

            async showOpeningSceneModal(entityId, isGroup) {
                const scenes = (await DBHelper.getAll('openingScenes')).filter(s => {
                    return isGroup ? s.groupId === entityId : s.contactId === entityId;
                });

                let scenesHtml = scenes.map(scene => `
                    <div class="details-card" style="padding: 15px; margin-bottom: 15px;">
                        <h4 style="margin-bottom: 10px; font-size: 1.1rem;">${scene.name}</h4>
                        <p style="font-size: 0.9rem; color: var(--text-color-medium); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${scene.content}
                        </p>
                        <div class="modal-actions" style="margin-top: 15px; justify-content: flex-end; gap: 8px;">
                            <button class="modal-btn btn-danger" data-action="delete" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">删除</button>
                            <button class="modal-btn btn-secondary" data-action="edit" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">编辑</button>
                            <button class="modal-btn btn-primary" data-action="apply" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">应用</button>
                        </div>
                    </div>
                `).join('');

                if (scenes.length === 0) {
                    scenesHtml = `<p style="text-align: center; color: #aaa; padding: 20px 0;">还没有开场白，快来创建一个吧！</p>`;
                }

                this.showModal({
                    title: "开场白设定",
                    body: `
                        <div id="opening-scene-list">${scenesHtml}</div>
                    `,
                    actions: [
                        { text: '新建开场白', class: 'btn-primary', handler: () => EventManager.handleNewOpeningScene(entityId, isGroup) }
                    ]
                });

                
                $('#opening-scene-list').addEventListener('click', async (e) => {
                    const button = e.target.closest('button');
                    if (!button) return;

                    const action = button.dataset.action;
                    const sceneId = button.dataset.sceneId;

                    if (action === 'delete') {
                        EventManager.handleDeleteOpeningScene(sceneId, entityId, isGroup);
                    } else if (action === 'edit') {
                        const scene = await DBHelper.get('openingScenes', sceneId);
                        EventManager.handleEditOpeningScene(scene, isGroup);
                    } else if (action === 'apply') {
                        const scene = await DBHelper.get('openingScenes', sceneId);
                        EventManager.handleApplyOpeningScene(scene);
                    }
                });
            },


            async renderMomentsPage(circleId = null) {
                
                if (circleId) {
                    appState.currentCircleId = circleId;
                } else if (!appState.currentCircleId) {
                    const circles = await DBHelper.getAll('circles');
                    if (circles.length > 0) {
                        appState.currentCircleId = circles[0].id; 
                    } else {
                        
                        $('#moments-list').innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">还没有创建任何圈子，<br>点击右上角菜单去创建一个吧！</li>`;
                        return;
                    }
                }

                
                const currentCircle = await DBHelper.get('circles', appState.currentCircleId);
                
                
                
                
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile }; 

                if (currentCircle && currentCircle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === currentCircle.boundPersonaPresetId);
                    if (boundPreset) {
                        
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                

                if (!currentCircle) {
                     $('#moments-list').innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">圈子不存在或已被删除。</li>`;
                     appState.currentCircleId = null; 
                     
                     $('#moments-my-name').textContent = myProfile.name;
                     $('#moments-my-avatar').src = myProfile.avatar;
                     return;
                }

                const moments = (await DBHelper.getAll('moments')).filter(m => m.circleId === appState.currentCircleId).sort((a, b) => b.timestamp - a.timestamp);
                const allContacts = await DBHelper.getAll('contacts');

                
                $('#moments-bg').src = currentCircle.backgroundImage || 'https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png';
                $('#moments-my-name').textContent = myProfile.name;
                $('#moments-my-avatar').src = myProfile.avatar;

                
                const momentsListUl = $('#moments-list');
                momentsListUl.innerHTML = '';
                if (moments.length === 0) {
                    momentsListUl.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">这个圈子还没有动态，<br>点击右上角刷新一下试试？</li>`;
                } else {
                    for (const moment of moments) {
                        const momentElement = this.createMomentElement(moment, myProfile, allContacts, currentCircle.extraMembers);
                        momentsListUl.appendChild(momentElement);
                    }
                }
            },

            createMomentElement(moment, myProfile, allContacts, extraMembersStr) {
                const li = document.createElement('li');
                li.className = 'moments-post';
                li.dataset.momentId = moment.id;

                
                let author;
                if (moment.authorId === myProfile.id) {
                    author = myProfile;
                } else {
                    const contactAuthor = allContacts.find(c => c.id === moment.authorId);
                    if (contactAuthor) {
                        author = contactAuthor;
                    } else if (extraMembersStr && extraMembersStr.includes(moment.authorId)) {
                        author = { id: moment.authorId, name: moment.authorId, avatar: Utils.createAvatarDataUrl(Utils.getRandomColor()) };
                    } else {
                        author = { id: moment.authorId, name: '未知用户', avatar: Utils.createAvatarDataUrl('#ccc') };
                    }
                }
                
                
                let imagesHtml = '';
                if (moment.images && moment.images.length > 0) {
                    const gridClass = `grid-${moment.images.length > 9 ? 9 : moment.images.length}`;
                    imagesHtml = `
                        <div class="post-images-grid ${gridClass}">
                            ${moment.images.map(src => `<img src="${src}" alt="动态图片">`).join('')}
                        </div>`;
                }
                
                
                const hasLikes = moment.likes && moment.likes.length > 0;
                const hasComments = moment.comments && moment.comments.length > 0;
                const playerHasLiked = moment.likes && moment.likes.includes(myProfile.name);

                let likesHtml = '';
                if (hasLikes) {
                    likesHtml = `<div class="post-likes"><i class="fas fa-heart"></i> ${moment.likes.join(', ')}</div>`;
                }

                let commentsHtml = '';
                if (hasComments) {
                    commentsHtml = moment.comments.map(comment => {
                         let commentAuthor;
                         
                         if (comment.authorId === myProfile.id) {
                            commentAuthor = myProfile;
                         } else {
                            
                            const contactCommenter = allContacts.find(c => c.id === comment.authorId);
                            if (contactCommenter) {
                                commentAuthor = contactCommenter;
                            } else {
                                
                                
                                commentAuthor = { name: comment.authorId, id: comment.authorId };
                            }
                         }
                         
                         const authorStyle = commentAuthor.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';
                         const replyHtml = comment.replyTo ? `<span class="comment-reply-to"> 回复 </span><span class="comment-author">${comment.replyTo}:</span>` : ':';

                         return `<div class="post-comment-item" data-author-name="${commentAuthor.name}" data-author-id="${commentAuthor.id}">
                                    <span class="comment-author" ${authorStyle}>${commentAuthor.name}</span>${replyHtml} ${comment.content}
                                </div>`;
                    }).join('');
                }
                
                const authorStyle = author.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';

                const isMyPost = author.id === myProfile.id;

                li.innerHTML = `
                    <img src="${author.avatar}" alt="作者头像" class="post-avatar">
                    <div class="post-main-content">
                        <div class="post-author-name" ${authorStyle}>${author.name}</div>
                        <div class="post-text">${moment.content}</div>
                        ${imagesHtml}
                        <div class="post-footer">
                            <span class="post-timestamp">${Utils.formatTimestampSmartly(moment.timestamp)}</span>
                        <div class="action-buttons-wrapper">
                            <button class="post-action-icon-btn" data-action="delete-moment" title="删除">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                            <button class="post-action-icon-btn" data-action="forward" title="转发">
                                <i class="fas fa-share"></i>
                            </button>
                            <button class="post-action-icon-btn ${playerHasLiked ? 'liked' : ''}" data-action="like" title="点赞">
                                <i class="far fa-heart"></i>
                            </button>
                            <button class="post-actions-btn" data-action="toggle-comment" title="评论">
                                <i class="fas fa-comment-dots"></i>
                            </button>
                        </div>
                      </div>
                        ${(hasLikes || hasComments) ? `
                        <div class="post-interactions">
                            ${likesHtml}
                            <div class="post-comments-list">${commentsHtml}</div>
                            <div class="comment-input-wrapper">
                                <input type="text" placeholder="评论...">
                                <button data-action="submit-comment">发送</button>
                            </div>
                        </div>
                        ` : `
                        <div class="post-interactions" style="display:none;">
                            <div class="post-likes"></div>
                            <div class="post-comments-list"></div>
                            <div class="comment-input-wrapper">
                                <input type="text" placeholder="评论...">
                                <button data-action="submit-comment">发送</button>
                            </div>
                        </div>
                        `}
                    </div>
                `;
                return li;
            },

            async showCircleManagementSidebar() {
                this.showSidebar({
                    position: 'right',
                    title: "朋友圈管理",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-switch-circle">
                                <i class="fas fa-sync-alt"></i>
                                <span>切换圈子</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-view-circle">
                                <i class="fas fa-info-circle"></i>
                                <span>查看圈子信息</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-add-circle">
                                <i class="fas fa-plus-circle"></i>
                                <span>新增圈子</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-edit-circle">
                                <i class="fas fa-edit"></i>
                                <span>修改当前圈子</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-delete-circle">
                                <i class="fas fa-trash-alt"></i>
                                <span>删除圈子</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-clear-circle-history">
                                <i class="fas fa-eraser"></i>
                                <span>清空朋友圈记录</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
                
                $('#sidebar-clear-circle-history').onclick = () => EventManager.handleClearCircleHistory();
                $('#sidebar-switch-circle').onclick = () => EventManager.handleSwitchCircle();
                $('#sidebar-view-circle').onclick = () => EventManager.handleViewCircleInfo();
                $('#sidebar-add-circle').onclick = () => EventManager.handleAddCircle();
                $('#sidebar-edit-circle').onclick = () => EventManager.handleEditCircle(appState.currentCircleId);
                $('#sidebar-delete-circle').onclick = () => EventManager.handleDeleteCircle();
            },

            async applyChatBackground(chatId) {
                const isGroup = chatId.startsWith('group-');
                const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const chatAreaEl = $('#chat-area');
                
                
                const defaultChatBgColor = 'var(--bg-main)';

                
                if (entity && entity.chatBackground) {
                    chatAreaEl.style.backgroundImage = `url(${entity.chatBackground})`;
                    chatAreaEl.style.backgroundSize = 'cover';
                    chatAreaEl.style.backgroundPosition = 'center';
                    chatAreaEl.style.backgroundColor = ''; 
                    return;
                }

                
                if (themeSettings.globalChatBg) {
                    chatAreaEl.style.backgroundImage = `url(${themeSettings.globalChatBg})`;
                    chatAreaEl.style.backgroundSize = 'cover';
                    chatAreaEl.style.backgroundPosition = 'center';
                    chatAreaEl.style.backgroundColor = ''; 
                    return;
                }

                
                chatAreaEl.style.backgroundImage = ''; 
                chatAreaEl.style.backgroundColor = defaultChatBgColor; 
            },
            async renderFriendFoldersPage() {
                const contentArea = $('#contacts-friend-folders');
                contentArea.innerHTML = ''; 
                const friendFolders = await DBHelper.getAll('friendFolders');
                const allContacts = await DBHelper.getAll('contacts');

                const folderMap = friendFolders.reduce((acc, folder) => {
                    acc[folder.id] = folder;
                    return acc;
                }, {});

                const sortedFolders = friendFolders.sort((a, b) => a.createdAt - b.createdAt);

                for (const folder of sortedFolders) {
                    const folderContacts = allContacts.filter(c => c.folderId === folder.id);
                    const folderElement = this.createFriendFolderElement(folder, folderContacts);
                    contentArea.appendChild(folderElement);
                }

                const ungroupedContacts = allContacts.filter(c => !c.folderId || !folderMap[c.folderId]);
                if (ungroupedContacts.length > 0) {
                    const ungroupedFolder = { id: 'unclassified', name: '未分组好友', isUnclassified: true };
                    const ungroupedElement = this.createFriendFolderElement(ungroupedFolder, ungroupedContacts);
                    contentArea.appendChild(ungroupedElement);
                }
                
                this.bindFriendFolderEvents();
            },

            createFriendFolderElement(folder, contacts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder'; 
                folderDiv.dataset.folderId = folder.id;

                let contactsHtml = contacts.map(contact => `
                    <div class="contact-item" data-id="${contact.id}" style="cursor: pointer; padding: 10px 5px;">
                        <img src="${contact.avatar}" alt="avatar" class="contact-item-avatar">
                        <span class="contact-item-name">${contact.remark || contact.name}</span>
                    </div>
                `).join('');
                if (contacts.length === 0 && !folder.isUnclassified) {
                    contactsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">此分组为空</p>`;
                }

                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            ${folder.name} (${contacts.length})
                        </h3>
                        ${!folder.isUnclassified ? `
                        <div class="prompt-folder-controls">
                            <button class="folder-action-btn" data-action="show-binding-options" title="绑定"><i class="fas fa-link"></i></button>
                            <button class="folder-action-btn" data-action="edit-folder" title="编辑分组"><i class="fas fa-edit"></i></button>
                            <button class="folder-action-btn" data-action="delete-folder" title="删除分组"><i class="fas fa-trash-alt"></i></button>
                        </div>
                        ` : ''}
                    </div>
                    <div class="prompt-folder-content collapsed" style="display: block; grid-template-columns: 1fr;">${contactsHtml}</div>
                `;
                return folderDiv;
            },

            bindFriendFolderEvents() {
                $('#contacts-friend-folders').onclick = (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const actionBtn = target.closest('.folder-action-btn');
                    const contactItem = target.closest('.contact-item');

                    if (actionBtn) {
                        e.stopPropagation();
                        const folderId = actionBtn.closest('.prompt-folder').dataset.folderId;
                        const action = actionBtn.dataset.action;
                        if (action === 'edit-folder') {
                            EventManager.showAddEditFriendFolderModal(folderId);
                        } else if (action === 'delete-folder') {
                            EventManager.confirmDeleteFriendFolder(folderId);
                        } else if (action === 'show-binding-options') {
                            EventManager.showFolderBindingOptionsModal(folderId);
                        }
                    } else if (folderHeader) {
                        const content = folderHeader.nextElementSibling;
                        folderHeader.classList.toggle('collapsed');
                        content.classList.toggle('collapsed');
                    } else if (contactItem) {
                        const contactId = contactItem.dataset.id;
                        this.openChat(contactId);
                    }
                };
            },
        };
            

        
        const AIHandler = {
            getGroupChatRules(settings) {
                let ruleTexts = [
                    `**多角色发言**：你可以让多个角色发言，每个角色的发言都是独立的单元，你可以根据人设安排部分群友不发言(例如有的角色是早睡设定,时间太晚就不会回复)，但至少需要构造一名群友的发言。`,
                    `**心声规则**：你必须为群聊中所有在本回合出场发言的角色生成【心声】。对于未出场（即本回合未发言）的角色，你有一定概率为他们生成【心声】，以体现他们在窥屏但不发言的状态。`
                ];

                if (settings.memoryInterconnection) {
                    ruleTexts.push(`**私聊消息**: 如果想对**玩家**说一些不想让其他人知道的话，请使用 <私聊></私聊> 标签包裹。标签内的消息格式依然遵循所有基础规则（如 <私聊>[方鹤安|你在群里说的那句话是什么意思]</私聊>）。<私聊>格式只能私聊玩家，私聊其他角色的内容禁止使用<私聊>标签。`);
                }

                ruleTexts.push(
                    `**修改群名**: 你可以根据剧情发展，主动修改群名。格式为：<系统>角色名 修改群名为"新群名"</系统>。例如：<系统>商时序 修改群名为"F4"</系统>。注意：此行为必须符合你的角色设定，不能随意或无理由地修改。`,
                    `**群友回复顺序不固定，可以交叉回复，例如群友A、群友B、群友B、群友A、群友C这样的交叉顺序。不一定要一个人全部说完了才轮到下一个人。群友之间也可以有互动对话，例如使用@提及其他群友。**`
                );

                const formattedRules = ruleTexts.map((text, index) => `${index + 1}.  ${text}`).join('\n');
                return `\n---\n群聊专属规则：\n${formattedRules}\n---`;
            },
            formatPromptTpl: `\n---
回复规则（非常重要！请严格遵守！）：
1.  你的所有回复都必须严格遵循以下格式，使用**角色名**，而不是其他昵称/称呼，每一句话都是一个独立的单元。
2.  **普通文本消息**：请将你的普通回复拆分成多个通畅的短句，并使用格式：[角色名|消息内容]。例如：[陈奚楷|你好啊]。
3.  **表情包消息**：<角色名|表情包ID>，**禁止在<>外面包裹[]**。你必须在< >中使用冒号左边的ID，而不是文字描述。可用表情包ID及其含义：\n{EMOJI_LIST}。一次回复内一般最多使用2个表情包。
4.  **撤回消息**：如果你想表达某种情绪或者说出一些角色会后悔的话或者不小心发出来的话，请将该短句用英文大括号包裹，格式为：{角色名|已经发送然后立刻撤回的原始消息内容}。例如：例如：{孟祁年|装货，你以为老子不知道你什么心思吗}。不要发送一条正常消息再发送一条“撤回”的指令。
5.  **语音消息**：[角色名|语音|语音时长|语音内容]。语音时长最长不超过60s。例如：[三三|语音|13s|太好了！那我们下午三点在公司会议室详细讨论]。
6.  **引用消息**: [角色名|引用|被引用人ID|被引用的消息内容|你的新消息内容]。不要滥用。例如: [陈奚楷|引用|楚寻|你哪里不会?|关于最后一题我还有点疑问。]。禁止引用转账/红包消息
7.  **转账消息**: [角色名|转账|被转账角色名|金额|备注]。金额格式为 "￥XX.XX"。例如: [孟祁年|转账|商时序|￥520.00|给你的惊喜]。
8.  **红包消息**: [角色名|红包|红包名称|金额|红包个数]。私聊时红包个数必须为1。例如: [孟祁年|红包|请大家喝奶茶|￥88.88|4]。
9. **卡片消息**: 当你想分享一类卡片消息（如：地点分享、文件分享、歌曲分享、或者其他有趣的可以用卡片发出来的分享内容）时，使用这种格式：『角色名|分享类型|分享标题|简介15字以内|详细内容30-60字』，举例：『角色名|图片分享|夏日海滩|一张记录美好瞬间的照片|照片里是蔚蓝的大海和金色的沙滩，充满了夏日的活力与惬意。』
10. **礼物消息**: 当某个角色基于人物设定/聊天记录内容想赠送礼物时，使用以下格式，并确保每个字段都填写完整：
<礼物>
发送方：角色名
接收方：玩家名或另一角色名
礼物名称：xxx
礼物价格：xxx
礼物介绍：xxx（不超过50字）
寄语：xxx（简单一句话）
</礼物>
{PAT_A_PAT_RULES}
13. **心声 (强制要求)**: 在你本次所有消息内容之后，你必须以【心声|角色名|你的心声内容】的格式来结束你的整个回复。**字数不超过30字。**
14. **随笔 (概率出现)**: 你有一定概率会在【心声】之后，额外写一段「随笔|角色名|你的随笔内容」。这段随笔是角色在当前情境下，有感而发的一些思考或经历，可以与当前对话内容相关，也可以是独立的小故事或心情记录。字数请控制在50到250字之间。
15. **严禁事项(1)**：绝不允许你代入玩家（“{PLAYER_NAME}”）的角色发言或为其生成心声。
16. **严禁事项(2)**：你的回复内容中，不要使用括号 ()、星号 ** 或其他任何符号来描述角色的动作、表情或内心活动。
---
现在，请根据以上信息，对玩家的最新消息进行回应。`,

            activeReplyPromptTpl: `\n---
主动回复规则（非常重要！请严格遵守！）：
1.  你现在需要主动发送一些消息。你的所有回复都必须严格遵循以下格式，在每条消息的末尾附带消息时间，使用 | 分隔。
2.  **普通文本消息**：请将你的普通回复拆分成多个通畅的短句，并使用格式：[角色名|消息内容|消息时间]。例如：[陈奚楷|下午去看电影吗|14:50]。
3.  **表情包消息**：<角色名|表情包ID|消息时间>，**禁止在<>外面包裹[]**。你必须在< >中使用冒号左边的ID，而不是文字描述。可用表情包ID及其含义：{EMOJI_LIST}。
4.  **撤回消息**：如果你想表达某种情绪或者说出一些角色会后悔的话或者不小心发出来的话，请将该短句用英文大括号包裹，格式为：{角色名|消息内容|消息时间}
5.  **语音消息**：[角色名|语音|语音时长|语音内容|消息时间]。语音时长最长不超过60s。例如：[三三|语音|13s|太好了！那我们下午三点在公司会议室详细讨论|13:43]。
6.  **引用消息**: [角色名|引用|被引用人ID|被引用的消息内容|你的新消息内容|消息时间]。不要滥用。例如: [陈奚楷|引用|楚寻|你哪里不会?|关于最后一题我还有点疑问。|9:46]。禁止引用转账/红包消息
7.  **转账消息**: [角色名|转账|收款人角色名|金额|备注]。金额格式为 "￥XX.XX"。例如: [孟祁年|转账|商时序|￥520.00|给你的惊喜]。
8.  **红包消息**: [角色名|红包|红包名称|金额|红包个数]。金额必须大于等于“红包个数 * 0.01”。私聊时红包个数必须为1。例如: [孟祁年|红包|请大家喝奶茶|￥88.88|4]。
9. **卡片消息**: 当你想分享一类卡片消息（如：地点分享、文件分享、歌曲分享、或者其他有趣的可以用卡片发出来的分享内容）时，使用这种格式：『角色名|分享类型|分享标题|简介15字以内|详细内容30-60字|消息时间』，举例：『角色名|图片分享|夏日海滩|一张记录美好瞬间的照片|照片里是蔚蓝的大海和金色的沙滩，充满了夏日的活力与惬意。|7/2 12:36』
10. **礼物消息**: 当你想主动赠送礼物时，使用以下格式：
<礼物>
发送方：角色名
接收方：玩家名或另一角色名
礼物名称：xxx
礼物价格：xxx
礼物介绍：xxx（不超过50字）
寄语：xxx（简单一句话）
</礼物>
{PAT_A_PAT_RULES}
13. **心声 (强制要求)**: 在你本次所有消息内容之后，你必须以【心声|角色名|你的心声内容】的格式来结束你的整个回复。字数不超过30字。
14. **随笔 (概率出现)**: 你有一定概率会在【心声】之后，额外写一段「随笔|角色名|你的随笔内容」。这段随笔是角色在当前情境下，有感而发的一些思考或经历，可以与当前对话内容相关，也可以是独立的小故事或心情记录。字数请控制在50到250字之间。
15. **严禁事项(1)**：绝不允许你代入玩家（“{PLAYER_NAME}”）的角色发言或为其生成心声。
16. **严禁事项(2)**：你的回复内容中，不要使用括号 ()、星号 ** 或其他任何符号来描述角色的动作、表情或内心活动。
---
现在，请根据以上信息，开始你的主动发言。`,

            buildTurnsFromHistory(history, allContacts, myProfile) {
                if (!history || history.length === 0) return [];
                
                const formatMessageContent = (msg, senderName, myName) => {
                    const recipientName = msg.cardData?.recipientName || '对方';
                    if (msg.isRetracted) {
                        const retracter = (msg.type === 'sent') ? myName : senderName;
                        return `{${retracter}|${msg.content}}`;
                    }
                    if (msg.segmentType === 'inner_voice') {
                         return `【心声|${senderName}|${msg.content}】`;
                    }
                    switch (msg.segmentType) {
                        case 'text': return `[${senderName}|${msg.content}]`;
                        case 'emoji-image': return `<${senderName}|${msg.content}>`;
                        case 'voice': return `[${senderName}|语音|${msg.cardData.duration}|${msg.cardData.content}]`;
                        case 'quote': return `[${senderName}|引用|${msg.cardData.quotedName}|${msg.cardData.quotedContent}|${msg.cardData.newContent}]`;
                        case 'transfer': return `[${senderName}|转账|${recipientName}|${msg.cardData.amount}|${msg.cardData.note || ''}]`;
                        case 'transfer-receipt': 
                            const receiptSender = allContacts.find(c => c.name === msg.cardData.senderName) || myProfile;
                            const receiptRecipient = allContacts.find(c => c.name === msg.cardData.recipientName) || myProfile;
                            return `[${receiptRecipient.name}|领取转账|${receiptSender.name}|${msg.cardData.amount}]`;
                        case 'transfer-return': return `[${senderName}|退还转账|${recipientName}|${msg.cardData.amount}]`;
                        case 'red-packet': return `[${senderName}|红包|${msg.cardData.title}|￥${msg.cardData.amount.toFixed(2)}|${msg.cardData.count}]`;
                        case 'image_simulated': return `[${senderName}|图片描述|${msg.cardData.description}]`;
                        case 'image_vision':
                            const promptText = msg.cardData.prompt ? ` ${msg.cardData.prompt}` : '';
                            return `[${senderName}|[图片]${promptText}]`;
                        case 'gift': return `<礼物>\n发送方：${senderName}\n接收方：${recipientName}\n礼物名称：${msg.cardData.name}\n礼物价格：${msg.cardData.price}\n礼物介绍：${msg.cardData.description || '无'}\n寄语：${msg.cardData.message}\n</礼物>`;
                        case 'pat_a_pat':
                            const pat = msg.content;
                            
                            const actionText = pat.action || '拍了拍';
                            const contentText = pat.content ? ` ${pat.content}` : '';
                            return `<拍一拍>${pat.patterName} ${actionText} ${pat.patteeName}${contentText}</拍一拍>`;
                        case 'modify_pat_a_pat':
                            const mod = msg.content;
                            return `<修改拍一拍>\n修改人：${mod.modifierName}\n拍一拍动作：${mod.action}\n拍一拍内容：${mod.content}\n</修改拍一拍>`;
                        case 'system': return msg.forAi ? `<系统>${msg.content}</系统>`: '';
                        case 'narrator': return `<旁白>${msg.content}</旁白>`;
                        case 'forwarded_history': return msg.content; 
                        case 'card':
                            if (msg.type === 'sent') {
                                return `『${myName}|${msg.cardData.shareType}|${msg.cardData.title}|${msg.cardData.summary}|${msg.cardData.details}』`;
                            } else {
                                return `『${senderName}|${msg.cardData.shareType}|${msg.cardData.title}|${msg.cardData.summary}|${msg.cardData.details}』`;
                            }
                        case 'moment_forward': return msg.content;
                        case 'forward_custom': return msg.content; 
                        default: return '';
                    }
                };

                const relevantHistory = history.filter(m => m.segmentType !== 'essay' && (!m.isHidden || (m.isHidden && m.forAi === true)));
                if (relevantHistory.length === 0) return [];

                let turns = [];
                let currentTurn = null;

                for (const msg of relevantHistory) {
                    const sender = (msg.type === 'sent') ? myProfile : allContacts.find(c => c.id === msg.senderId);
                    if (!sender && msg.segmentType !== 'system') continue;
                    
                    const senderName = sender ? (msg.type === 'sent' ? myProfile.name : sender.name) : '系统';
                    const formattedContent = formatMessageContent(msg, senderName, myProfile.name);
                    if (!formattedContent) continue;

                    const role = msg.type === 'sent' ? 'player' : 'ai';

                    if (currentTurn && currentTurn.role === role) {
                        currentTurn.content += formattedContent;
                    } else {
                        if (currentTurn) {
                            turns.push(currentTurn);
                        }
                        currentTurn = {
                            role: role,
                            time: Utils.formatTimestampForPrompt(msg.timestamp),
                            content: formattedContent
                        };
                    }
                }
                if (currentTurn) {
                    turns.push(currentTurn);
                }
                return turns;
            },

            apiConfig: {}, 
            isAwaitingResponse: false,
            abortController: null,

            async loadApiConfig() {
                let config = await DBHelper.get('apiConfig', 'mainConfig');
                if (!config) {
                    config = {
                        id: 'mainConfig',
                        provider: 'gemini',
                        url: 'https://generativelanguage.googleapis.com/v1beta/models/',
                        model: 'gemini-2.5-flash',
                        temperature: 0.7,
                        keys: { gemini: [], siliconflow: [], paioupu: [], volcano: [], custom: [] } 
                    };
                    await DBHelper.put('apiConfig', config);
                }

                
                if (config.key && !config.keys) {
                    console.log("正在迁移旧的API Key结构...");
                    config.keys = { gemini: [], siliconflow: [], paioupu: [], volcano: [], custom: [] };
                    
                    if (config.provider && config.keys[config.provider]) {
                        config.keys[config.provider].push(config.key);
                    }
                    delete config.key; 
                    await DBHelper.put('apiConfig', config);
                    console.log("API Key结构迁移完成。");
                }
                
                
                if (!config.keys) {
                     config.keys = { gemini: [], siliconflow: [], paioupu: [], volcano: [], custom: [] };
                }


                this.apiConfig = config;
            },

            async saveApiConfig(newConfig) {
                
                Object.assign(this.apiConfig, newConfig);

                
                if (this.apiConfig.provider === 'custom') {
                    this.apiConfig.customUrl = this.apiConfig.url;
                }
                
            
                
                
                if (newConfig.model) {
                    if (!this.apiConfig.models) {
                        this.apiConfig.models = {};
                    }
                    
                    this.apiConfig.models[this.apiConfig.provider] = this.apiConfig.model;
                    
                    delete this.apiConfig.model;
                }
            
                
                this.apiConfig.id = 'mainConfig';
            
                
                await DBHelper.put('apiConfig', this.apiConfig);
            },

            async getApiKeyAndRotate() {
                await this.loadApiConfig(); 
                const provider = this.apiConfig.provider;
                const keyArray = this.apiConfig.keys[provider] || [];

                if (keyArray.length === 0) {
                    throw new Error(`当前提供商 (${provider}) 没有可用的API Key。`);
                }

                const keyToUse = keyArray.shift(); 
                keyArray.push(keyToUse); 

                this.apiConfig.keys[provider] = keyArray;
                await this.saveApiConfig(this.apiConfig); 

                return keyToUse;
            },

            async getPendingTransfersPrompt(chatId, aiCharactersInChat) {
                const history = await DBHelper.getMessages(chatId, 30); 
                if (history.length === 0) return '';
                
                const aiCharacterIds = aiCharactersInChat.map(c => c.id);

                const pendingTransfers = history.filter(msg => 
                    msg.segmentType === 'transfer' &&
                    msg.cardData && !msg.cardData.isClaimed &&
                    aiCharactersInChat.some(ai => ai.name === msg.cardData.recipientName)
                );
                
                if (pendingTransfers.length === 0) return '';

                const promptLines = pendingTransfers.map(t => {
                    const senderName = (t.type === 'sent') ? '玩家' : t.senderInfo.name;
                    return `- 来自 ${senderName} 的转账 ${t.cardData.amount}，备注：${t.cardData.note || '无'}`;
                });
                
                return `\n---
转账待办事项：
有以下未处理的转账，请在本次回复中，根据被转账人的人设和聊天记录决定【领取转账】或【退还转账】，并使用对应的格式进行回复。
${promptLines.join('\n')}
---\n
**收款回复格式**：[收款人角色名|领取转账|转账人名字|转账金额]
**退还回复格式**：[退款人角色名|退还转账|转账人名字|转账金额]
例如：[孟祁年|领取转账|商时序|￥0.01]
---`;
            },

            async buildPrompt() {
                const chatId = appState.currentChatId;
                if (!chatId) return null;

                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const allContacts = await DBHelper.getAll('contacts');
                const allGroups = await DBHelper.getAll('groups');
                
                const defaults = { memoryInterconnection: false, historyCharLimit: 5000, promptTurnFrequency: 1 };
                const savedSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const chatSettings = { ...defaults, ...savedSettings };
                const isGroup = chatId.startsWith('group-');
                
                const chatMetadata = await DBHelper.get('chatMetadata', chatId) || { chatId, turnCountSinceLastPrompt: 0 };
                
                const recentMessages = await DBHelper.getMessages(chatId, 5);
                let extraEmojiHintPrompt = '';
                if (recentMessages.length > 0) {
                    const lastPlayerTurnMessages = [];
                    for (let i = recentMessages.length - 1; i >= 0; i--) {
                        if (recentMessages[i].type === 'sent') lastPlayerTurnMessages.unshift(recentMessages[i]);
                        else break;
                    }

                    if (lastPlayerTurnMessages.length > 0) {
                        const extraEmojiIds = new Set(
                            lastPlayerTurnMessages
                                .filter(msg => msg.segmentType === 'emoji-image' && !appState.aiEmojiMap.hasOwnProperty(msg.content))
                                .map(msg => msg.content)
                        );
                        if (extraEmojiIds.size > 0) {
                            const hintContent = Array.from(extraEmojiIds)
                                .map(id => appState.playerEmojiMap[id] ? `${id}：${appState.playerEmojiMap[id]}` : null)
                                .filter(Boolean).join('\n');
                            if (hintContent) {
                                extraEmojiHintPrompt = `\n--- 补充信息：玩家最新发送的表情包含义如下 ---\n${hintContent}\n---`;
                            }
                        }
                    }
                }
                
                const turnFrequency = chatSettings.promptTurnFrequency;
                
                
                const shouldSendFullPrompt = turnFrequency <= 1 ? true : (chatMetadata.turnCountSinceLastPrompt || 0) >= turnFrequency;
                
                
                const buildHistoryBlock = async (targetChatId, title, charLimit, turnLimit = null) => {
                    
                    const messages = await DBHelper.getMessages(targetChatId, 200); 
                    if (messages.length === 0) return '';

                    let turns = AIHandler.buildTurnsFromHistory(messages, allContacts, myProfile);
                    if (turns.length === 0) return '';

                    
                    if (turnLimit !== null && turns.length > turnLimit) {
                        turns = turns.slice(-turnLimit);
                    }
                    
                    
                    let finalTurns = [];
                    let currentCharCount = 0;
                    for (let i = turns.length - 1; i >= 0; i--) {
                        const turn = turns[i];
                        const turnString = JSON.stringify(turn);
                        if (currentCharCount + turnString.length > charLimit) {
                            break; 
                        }
                        finalTurns.unshift(turn);
                        currentCharCount += turnString.length;
                    }

                    if (finalTurns.length === 0) return '';
                    return `--- ${title} ---\n${finalTurns.map(turn => JSON.stringify(turn)).join('\n')}\n`;
                };

                const now = new Date();
                const systemTime = `当前系统时间是：${Utils.formatTimestampForPrompt(now)}，${['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][now.getDay()]}。`;
                
                let taskPrompt = '', characterInfoPrompt = '', chatEntity, pendingTransfersPrompt = '';
                
                if (isGroup) {
                    chatEntity = await DBHelper.get('groups', chatId);
                    const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    taskPrompt = `你现在正在一个名为“${chatEntity.name}”的群聊中，需要同时扮演以下几位角色：${members.map(m => m.name).join('、')}。你的任务是根据每个角色的性格设定，与群里的“${myProfile.name}”（也就是玩家）进行互动。**禁止让群聊外的角色进行发言，禁止让被移出群聊的角色发言**`;
                    characterInfoPrompt = `群聊成员资料如下：\n` + members.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n拍一拍动作(${m.name}自己设定的): ${m.patAction || '拍了拍'}\n拍一拍内容(${m.name}自己设定的): ${m.patContent || ''}\n背景: ${m.background || '无'}`).join('\n---\n');
                } else {
                    chatEntity = await DBHelper.get('contacts', chatId);
                    taskPrompt = `你现在正在扮演“${chatEntity.name}”，与“${myProfile.name}”（也就是玩家）进行一对一私聊。`;
                    characterInfoPrompt = `你的角色资料如下：\n角色名: ${chatEntity.name}\n性别: ${chatEntity.gender}\n喜好: ${chatEntity.likes || '无'}\n厌恶: ${chatEntity.dislikes || '无'}\n习惯: ${chatEntity.habits || '无'}\n拍一拍动作(${chatEntity.name}自己设定的): ${chatEntity.patAction || '拍了拍'}\n拍一拍内容(${chatEntity.name}自己设定的): ${chatEntity.patContent || ''}\n背景: ${chatEntity.background || '无'}`;
                }

                let aiCharactersInChat = isGroup ? chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean) : [chatEntity];
                pendingTransfersPrompt = await this.getPendingTransfersPrompt(chatId, aiCharactersInChat);

                const playerInfoPrompt = `玩家（“${myProfile.name}”）的信息如下：\n性别: ${myProfile.gender}\n${chatSettings.enablePatAPat !== false ? `拍一拍动作: ${myProfile.patAction || '拍了拍'}\n拍一拍内容: ${myProfile.patContent || ''}\n` : ''}背景: ${myProfile.background || '无'}`;

                let pomodoroPromptSection = '';
                if (appState.pomodoro && appState.pomodoro.isActive && appState.pomodoro.endTime) {
                    const remainingSeconds = Math.max(0, Math.round((appState.pomodoro.endTime - Date.now()) / 1000));
                    const remainingMinutes = Math.ceil(remainingSeconds / 60);
                    const startTime = new Date(appState.pomodoro.endTime - appState.pomodoro.totalSeconds * 1000);
                    pomodoroPromptSection = `\n---
番茄钟状态：玩家当前正在进行一个为期25分钟的番茄钟专注时段。
- 专注目标：${appState.pomodoro.goal}
- 开始时间：${Utils.formatTimestampForPrompt(startTime)}
- 剩余时间：约 ${remainingMinutes} 分钟
请注意，玩家此时给你发消息属于“分心”行为，你可以结合你的角色设定，对此作出回应。
---`;
                }

                
                let momentsPromptSection = '';
                let charactersWithCircle = [];
                
                if (isGroup) {
                    const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    charactersWithCircle = members.filter(m => m.boundCircleId);
                } else {
                    if (chatEntity.boundCircleId) {
                        charactersWithCircle.push(chatEntity);
                    }
                }

                if (charactersWithCircle.length > 0) {
                    const allowedAuthors = charactersWithCircle.map(c => c.name).join('、');
                    momentsPromptSection = `
---
即时朋友圈动态规则 (可选):
1. 在本次聊天回复中，你有一定几率可以发布一条或多条朋友圈动态。结合历史聊天记录里的朋友圈的发送情况，**不允许频繁、连续发送朋友圈动态**，**如果上次聊天内发送了朋友圈，本次如果没有特殊情况(如玩家要求)，禁止发送朋友圈**
2. 动态内容需要与当前聊天情景、角色近期经历或人设紧密相关。
3. 每条动态都必须被一个 <朋友圈> 标签包裹。
4. 动态格式: 【作者角色名：动态内容|动态时间(月/日 HH:mm)】
5. 点赞格式(强制要求): 在动态格式之后，另起一行，用中文括号包裹点赞列表，格式为（已点赞：好友名字,好友名字）。
6. 评论格式: 〖评论者角色名：评论内容〗
7. 在本次群聊中，只允许以下角色发布动态：${allowedAuthors}。
8. 严禁代替玩家（“${myProfile.name}”）点赞或评论。
9. 举例:
<朋友圈>
【三三：今天天气真不错，有没有要一起出去玩的？|7/3 8:36】
（已点赞：vv,入入）
〖vv：带我一个！〗
</朋友圈>
---
`;
                }
                

                
                
                let customPromptsSection = '';
                if (shouldSendFullPrompt && chatEntity && chatEntity.boundPromptFolderIds?.length > 0) {
                    const allFolders = await DBHelper.getAll('promptFolders');
                    const allPrompts = await DBHelper.getAll('prompts');
                    const playerLastMessage = (await DBHelper.getMessages(chatId, 1)).pop()?.content || '';

                    const activeBoundFolders = allFolders.filter(f => chatEntity.boundPromptFolderIds.includes(f.id) && f.isActive);
                    if (activeBoundFolders.length > 0) {
                        const activeBoundFolderIds = activeBoundFolders.map(f => f.id);
                        const relevantPrompts = allPrompts.filter(p => activeBoundFolderIds.includes(p.folderId) && p.isActive);
                        const promptsToInject = relevantPrompts
                            .filter(p => p.type === 'explicit' || (p.type === 'implicit' && JSON.parse(p.keywords).some(kw => playerLastMessage.includes(kw))))
                            .map(p => p.content);
                        if (promptsToInject.length > 0) {
                            customPromptsSection = `\n--- 其他资料 ---\n${promptsToInject.join('\n\n')}\n---`;
                        }
                    }
                }

                
                let historyPrompt = "以下是聊天记录，请结合上下文进行回复（每行是一个JSON对象，代表一个回合）：\n";
                const historyCharLimit = chatSettings.historyCharLimit || 5000;

                if (chatSettings.memoryInterconnection) {
                    if (isGroup) {
                        const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                        let privateContext = '--- 以下是各角色的私聊记忆 (仅角色自己可见, 最多10回合) ---\n';
                        for (const member of members) {
                            privateContext += await buildHistoryBlock(member.id, `与 ${member.name} 的私聊记录`, 2000, 10);
                        }
                        historyPrompt += privateContext;
                        historyPrompt += await buildHistoryBlock(chatId, '当前群聊记录', historyCharLimit);
                    } else { 
                        const relatedGroups = allGroups.filter(g => g.members.includes(chatEntity.id));
                        let groupContext = '--- 以下是相关的群聊记忆 (最多8回合) ---\n';
                        for (const group of relatedGroups) {
                            groupContext += await buildHistoryBlock(group.id, `群聊“${group.name}”的记录`, 1500, 8);
                        }
                        historyPrompt += groupContext;
                        historyPrompt += await buildHistoryBlock(chatId, '当前私聊记录', historyCharLimit);
                    }
                } else { 
                    historyPrompt += await buildHistoryBlock(chatId, '当前聊天记录', historyCharLimit);
                }

                
                const useBuiltin = chatSettings.useBuiltinEmojis !== false;
                const useCustom = chatSettings.useCustomEmojisInPrompt !== false;

                let emojiMapForPrompt = {};
                if (useBuiltin) {
                    Object.assign(emojiMapForPrompt, BUILTIN_AI_EMOJIS);
                }
                if (useCustom) {
                    for (const [id, data] of Object.entries(appState.customEmojis)) {
                        emojiMapForPrompt[id] = data.name;
                    }
                }

                const emojiListString = Object.entries(emojiMapForPrompt).map(([id, desc]) => `${id}：${desc}`).join('\n');
                
                let patAPatRulesForPrompt = '';
                if (chatSettings.enablePatAPat !== false) {
                    patAPatRulesForPrompt = `11. **拍一拍**: 当你想表达一些俏皮、提醒或想互动但无话可说的场景时，可以使用拍一拍。你必须使用被拍者的自定义动作和内容，使用此格式：<拍一拍>拍人角色名 (被拍人设定的动作) 被拍角色名 (被拍人设定的内容)</拍一拍>。
例如，如果玩家的拍一拍内容是“被弹飞了”，则格式为：<拍一拍>33 拍了拍 {PLAYER_NAME} 被弹飞了</拍一拍>。
绝对不能用拍人者的自定义动作和内容来回复，这是错误的。
12. **修改拍一拍**: 当角色基于聊天语境下想修改自己的拍一拍设置时，使用此格式：
<修改拍一拍>
修改人：角色名
拍一拍动作：xxx（不超过5个字，例如:捏了捏）
拍一拍内容：xxx（不超过20个字，例如:的脸，并说好软好软;或者:的头,被弹飞了）
</修改拍一拍>`;
                }

                const formatPrompt = AIHandler.formatPromptTpl.replace('{EMOJI_LIST}', emojiListString).replace('{PLAYER_NAME}', myProfile.name).replace('{PAT_A_PAT_RULES}', patAPatRulesForPrompt);
                let summaryPromptSection = '';
                if (chatEntity && chatEntity.autoSummary) {
                    summaryPromptSection = `--- 会话概要---\n${chatEntity.autoSummary}\n---`;
                }

                
                const promptParts = [
                    systemTime, 
                    taskPrompt, 
                    characterInfoPrompt, 
                    playerInfoPrompt, 
                    pendingTransfersPrompt, 
                    pomodoroPromptSection,
                    momentsPromptSection, 
                    summaryPromptSection, 
                    customPromptsSection, 
                    historyPrompt, 
                    extraEmojiHintPrompt, 
                    formatPrompt
                ];

                if (shouldSendFullPrompt) {
                    chatMetadata.turnCountSinceLastPrompt = 0;
                    await DBHelper.put('chatMetadata', chatMetadata);
                }
                
                let finalPrompt = promptParts.filter(Boolean).join('\n\n');
                if (isGroup) finalPrompt += this.getGroupChatRules(chatSettings);
                
                
                console.log(`--- PROMPT SENT TO AI (Full: ${shouldSendFullPrompt}) ---\n`, finalPrompt);
                return finalPrompt;
            },

            async getApiResponse(textPrompt, images, signal) {
                
                await this.loadApiConfig();

                
                const { provider, url, temperature, models } = this.apiConfig;
                const model = models ? models[provider] : null; 
                
                
                const key = await this.getApiKeyAndRotate();

                
                if (!key || !url || !model) {
                    throw new Error('API配置不完整，请在设置中检查。');
                }

                let apiUrl = url;
                let headers = { 'Content-Type': 'application/json' };
                let body;

                
                if (images && images.length > 0) {
                    console.log(`正在发送一个包含 ${images.length} 张图片的多模态请求。`);
                    if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                        headers['Authorization'] = `Bearer ${key}`;
                        if (!apiUrl.endsWith('/chat/completions')) {
                            apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                        }
                        const content = [{ "type": "text", "text": textPrompt }];
                        images.forEach(img => {
                            content.push({ "type": "image_url", "image_url": { "url": img.base64 } });
                        });
                        body = { model: model, messages: [{ "role": "user", "content": content }], temperature: temperature };
                    } else if (provider === 'gemini') {
                        apiUrl += `${model}:generateContent?key=${key}`;
                        const parts = [{ "text": textPrompt }];
                        images.forEach(img => {
                            const base64Data = img.base64.split(',')[1];
                            const mimeTypeMatch = img.base64.match(/^data:(image\/[a-zA-Z]+);base64,/);
                            const mimeType = mimeTypeMatch ? mimeTypeMatch[1] : 'image/jpeg';
                            parts.push({ "inline_data": { "mime_type": mimeType, "data": base64Data } });
                        });
                        body = {
                            contents: [{ role: 'user', parts: parts }],
                            generationConfig: { temperature: temperature }
                        };
                    } else {
                        throw new Error('不支持的API提供商。');
                    }
                } else {
                    
                    const messagesForApi = [{ role: 'user', content: textPrompt }];
                    if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                        headers['Authorization'] = `Bearer ${key}`;
                        if (!apiUrl.endsWith('/chat/completions')) {
                            apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                        }
                        body = { model: model, messages: messagesForApi, temperature: temperature };
                    } else if (provider === 'gemini') {
                        apiUrl += `${model}:generateContent?key=${key}`;
                        body = {
                            contents: [{ role: 'user', parts: [{ text: textPrompt }] }],
                            generationConfig: { temperature: temperature }
                        };
                    } else {
                        throw new Error('不支持的API提供商。');
                    }
                }

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(body),
                        signal: signal
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("API Error Response:", errorData);
                        throw new Error(`API请求失败: ${response.status} - ${errorData.error ? errorData.error.message : JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    console.log("API Response Data:", JSON.stringify(data, null, 2));

                    if (provider === 'gemini') {
                        if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
                            return data.candidates[0].content.parts[0].text;
                        } else {
                            let reason = "未知原因。";
                            if (data.promptFeedback && data.promptFeedback.blockReason) {
                                reason = `内容被阻止，原因：${data.promptFeedback.blockReason}。请检查您的Prompt或调整API的安全设置。`;
                            } else {
                                reason = "API返回了空的或无效的候选内容。";
                            }
                            throw new Error(`Gemini API未返回有效回复：${reason}`);
                        }
                    } else { 
                        if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                            return data.choices[0].message.content;
                        } else {
                            let reason = "API返回了空的或无效的选项。";
                            if (data.choices && data.choices.length > 0 && data.choices[0].finish_reason) {
                                reason = `内容被阻止，原因：${data.choices[0].finish_reason}。`;
                            }
                            throw new Error(`API未返回有效回复：${reason}`);
                        }
                    }
                } catch (error) {
                    if (error instanceof TypeError && error.message === 'Failed to fetch') {
                        throw new Error('API请求失败。原因：Failed to fetch。<br>请尝试检查你的API配置是否正确，网络服务是否通畅<br>详情可前往【设置-食用指南】查看教程。');
                    }
                    
                    throw error;
                }
            },
            
            async handleAiReplyRequest() {
                if (this.isAwaitingResponse) return; 

                const requestedChatId = appState.currentChatId;
                if (!requestedChatId) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController(); 
                
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false; 

                const isGroup = requestedChatId.startsWith('group-');
                let typingBubbleId = Utils.generateId('typing');
                let typingTarget;
                
                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', requestedChatId);
                    if(typingTarget) {
                         UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', requestedChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const textPrompt = await this.buildPrompt();
                    if (!textPrompt) {
                         this.showError("无法构建prompt");
                         this.isAwaitingResponse = false;
                         aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                         return;
                    }
                    
                    
                    const allMessages = await DBHelper.getMessages(requestedChatId, 15);
                    const imagesForApi = [];
                    
                    for (let i = allMessages.length - 1; i >= 0; i--) {
                        const msg = allMessages[i];
                        if (msg.type === 'sent') {
                            if (msg.segmentType === 'image_vision') {
                                imagesForApi.push({ base64: msg.cardData.base64 });
                            }
                        } else {
                            break;
                        }
                    }

                    const aiRawResponse = await this.getApiResponse(textPrompt, imagesForApi.reverse(), this.abortController.signal);
                    
                    const metadata = await DBHelper.get('chatMetadata', requestedChatId) || { chatId: requestedChatId };
                    metadata.lastRawAiResponse = aiRawResponse;
                    await DBHelper.put('chatMetadata', metadata);
                    
                    console.log("--- AI 原始回复 ---\n", aiRawResponse);
                    await this.parseAndDisplayAIResponse(aiRawResponse, requestedChatId);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log("AI请求已被用户取消。");
                    } else {
                        console.error("AI回复失败:", error);
                        this.showError(`AI回复失败: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    if (typingBubbleId) {
                        const typingBubble = $(`#${typingBubbleId}`);
                        if (typingBubble) typingBubble.remove();
                    }
                    UIManager.syncAiButtonState();
                }
            },
            cancelAiRequest() {
                if (this.abortController) {
                    this.abortController.abort();
                    console.log("正在取消AI请求...");
                }
            },
            async handleActiveReplyRequest(lastAiTimestamp) {
                if (this.isAwaitingResponse) return;
                
                const requestedChatId = appState.currentChatId;
                if (!requestedChatId) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();

                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const prompt = await this.buildActiveReplyPrompt(lastAiTimestamp);
                if (!prompt) {
                     this.showError("无法构建主动回复prompt");
                     this.isAwaitingResponse = false;
                     aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                     return;
                }
                
                const isGroup = requestedChatId.startsWith('group-');
                let typingBubbleId = Utils.generateId('typing');
                let typingTarget;
                
                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', requestedChatId);
                    if(typingTarget) {
                         UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', requestedChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(prompt, null, this.abortController.signal); 
                    
                    const metadata = await DBHelper.get('chatMetadata', requestedChatId) || { chatId: requestedChatId };
                    metadata.lastRawAiResponse = aiRawResponse;
                    await DBHelper.put('chatMetadata', metadata);
                    
                    console.log("--- AI 主动回复 (原始) ---\n", aiRawResponse);
                    await this.parseAndDisplayActiveAIResponse(aiRawResponse, requestedChatId);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log("AI主动回复请求已被用户取消。");
                    } else {
                        console.error("AI主动回复失败:", error);
                        this.showError(`AI主动回复失败: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    if (typingBubbleId) {
                        const typingBubble = $(`#${typingBubbleId}`);
                        if (typingBubble) typingBubble.remove();
                    }
                    UIManager.syncAiButtonState();
                }
            },
            
            async buildActiveReplyPrompt(lastAiTimestamp) {
                const chatId = appState.currentChatId;
                if (!chatId) return null;

                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const allContacts = await DBHelper.getAll('contacts');
                const allGroups = await DBHelper.getAll('groups');
                const isGroup = chatId.startsWith('group-');
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const fullHistory = await DBHelper.getMessages(chatId, 100); 
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                const historyLength = 10; 

                const now = Date.now();
                const lastDate = new Date(lastAiTimestamp);
                const elapsedMillis = now - lastAiTimestamp;
                const elapsedHours = Math.floor(elapsedMillis / (1000 * 60 * 60));
                const elapsedMinutes = Math.floor((elapsedMillis % (1000 * 60 * 60)) / (1000 * 60));
                const lastTimeFormatted = `${lastDate.getMonth() + 1}月${lastDate.getDate()}日 ${String(lastDate.getHours()).padStart(2, '0')}:${String(lastDate.getMinutes()).padStart(2, '0')}`;
                const durationString = `${elapsedHours > 0 ? `${elapsedHours}小时` : ''}${elapsedMinutes}分钟`;

                let situationPrompt = '';
                if (isGroup) {
                    situationPrompt = `你们上次聊天是${lastTimeFormatted}，距离现在过去${durationString}了，在这段时间内，玩家“${myProfile.name}”并不在线，你们可以自由交流，交流内容可以与玩家有关，也可以与玩家无关。`;
                } else {
                    situationPrompt = `“${myProfile.name}”上次和你聊天时间是${lastTimeFormatted}，距离现在已经过去了${durationString}。请你根据你的人设，说一些在这段时间里你可能会对“${myProfile.name}”说的话，也可能是这段时间内你遇到的新鲜的事，想和TA分享。这些话不一定是同一时间发的，有时候只隔了一两分钟，有可能你可能隔了十几二十分钟才发下一条，所以注意消息的口吻。**禁止超出这个时间范围，禁止出现比现在时间还要晚的时间**，如果对方离开的时间只有几个小时或者只是晚上到白天(睡觉)，可以不用发很多条消息。`;
                }

                const formatMessageContent = (msg, senderName, myName) => { 
                    const recipientName = msg.cardData?.recipientName || '对方'; 
                    if (msg.isRetracted) return `{${(msg.type === 'sent') ? myName : senderName}|${msg.content}}`;
                    if (msg.segmentType === 'inner_voice') return `【心声|${senderName}|${msg.content}】`;
                    switch (msg.segmentType) {
                        case 'text': return `[${senderName}|${msg.content}]`;
                        case 'emoji-image': return `<${senderName}|${msg.content}>`;
                        case 'voice': return `[${senderName}|语音|${msg.cardData.duration}|${msg.cardData.content}]`;
                        case 'quote': return `[${senderName}|引用|${msg.cardData.quotedName}|${msg.cardData.quotedContent}|${msg.cardData.newContent}]`;
                        case 'transfer-return': return `[${senderName}|退还转账|${msg.cardData.recipientName}|${msg.cardData.amount}]`;
                        case 'transfer': return `[${senderName}|转账|${msg.cardData.recipientName}|${msg.cardData.amount}|${msg.cardData.note || ''}]`;
                        case 'red-packet': return `[${senderName}|红包|${msg.cardData.title}|￥${msg.cardData.amount.toFixed(2)}|${msg.cardData.count}]`;
                        case 'image_simulated': return `[${senderName}|图片描述|${msg.cardData.description}]`;
                        case 'gift': return `<礼物>\n发送方：${senderName}\n接收方：${recipientName}\n礼物名称：${msg.cardData.name}\n礼物价格：${msg.cardData.price}\n礼物介绍：${msg.cardData.description || '无'}\n寄语：${msg.cardData.message}\n</礼物>`;
                        case 'pat_a_pat':
                            const pat = msg.content;
                            const actionText = pat.action ? `(${pat.action})` : '拍了拍';
                            const contentText = pat.content ? `(${pat.content})` : '';
                            return `<拍一拍>${pat.patterName} ${actionText} ${pat.patteeName} ${contentText}</拍一拍>`;
                        case 'modify_pat_a_pat':
                            const mod = msg.content;
                            return `<修改拍一拍>\n修改人：${mod.modifierName}\n拍一拍动作：${mod.action}\n拍一拍内容：${mod.content}\n</修改拍一拍>`;
                        case 'system': return msg.forAi ? `<系统>${msg.content}</系统>`: '';
                        case 'narrator': return `<旁白>${msg.content}</旁白>`;
                        case 'moment_forward': return msg.content; 
                        default: return '';
                    }
                };
                const buildHistoryBlock = (history, title, turnLimit) => { 
                    if (!history || history.length === 0) return '';
                    let promptHistoryTurns = [];
                    for (const msg of history.filter(m => m.segmentType !== 'essay')) {
                        const sender = (msg.type === 'sent') ? myProfile : allContacts.find(c => c.id === msg.senderId);
                        if (!sender && msg.segmentType !== 'system') continue;
                        const formattedContent = formatMessageContent(msg, sender ? sender.name : '系统', myProfile.name);
                        if (!formattedContent) continue;
                        const role = msg.type === 'sent' ? 'player' : 'ai';
                        if (promptHistoryTurns.length > 0 && promptHistoryTurns[promptHistoryTurns.length - 1].role === role) {
                            promptHistoryTurns[promptHistoryTurns.length - 1].content += formattedContent;
                        } else {
                            promptHistoryTurns.push({ role: role, time: Utils.formatTimestampForPrompt(msg.timestamp), content: formattedContent });
                        }
                    }
                    const finalTurns = turnLimit ? promptHistoryTurns.slice(-turnLimit) : promptHistoryTurns;
                    if (finalTurns.length === 0) return '';
                    return `--- ${title} ---\n${finalTurns.map(turn => JSON.stringify(turn)).join('\n')}\n`;
                };
                
                let historyPrompt = "作为参考，以下是你们之前的聊天记录：\n";

                if (chatSettings.memoryInterconnection) {
                     if (isGroup) {
                        historyPrompt += buildHistoryBlock(fullHistory, '当前群聊记录', historyLength); 
                        let privateContext = '--- 以下是各角色的私聊记忆 (仅角色自己可见) ---\n';
                        for (const member of chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean)) {
                            const privateChatHistory = await DBHelper.getMessages(member.id, 20);
                            if (privateChatHistory.length > 0) privateContext += buildHistoryBlock(privateChatHistory, `与 ${member.name} 的私聊记录`, 10);
                        }
                        historyPrompt += privateContext;
                    } else {
                        historyPrompt += buildHistoryBlock(fullHistory, '当前私聊记录', historyLength); 
                        const relatedGroups = allGroups.filter(g => g.members.includes(chatEntity.id));
                        let groupContext = '--- 以下是相关的群聊记忆 ---\n';
                        for (const group of relatedGroups) {
                            const groupChatHistory = await DBHelper.getMessages(group.id, 20);
                            if (groupChatHistory.length > 0) groupContext += buildHistoryBlock(groupChatHistory, `群聊“${group.name}”的记录`, 8);
                        }
                        historyPrompt += groupContext;
                    }
                } else {
                    historyPrompt += buildHistoryBlock(fullHistory, '当前聊天记录', historyLength); 
                }

                const taskPrompt = isGroup ? 
                    `你现在正在一个名为“${chatEntity.name}”的群聊中，需要同时扮演以下几位角色：${chatEntity.members.map(id => allContacts.find(c => c.id === id)?.name).filter(Boolean).join('、')}。` :
                    `你现在正在扮演“${chatEntity.name}”，与“${myProfile.name}”进行一对一私聊。`;

                const characterInfoPrompt = isGroup ?
                    `群聊成员资料如下：\n` + chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean).map(m => `角色名: ${m.name}\n性别: ${m.gender}\n背景: ${m.background || '无'}`).join('\n---\n') :
                    `你的角色资料如下：\n角色名: ${chatEntity.name}\n性别: ${chatEntity.gender}\n背景: ${chatEntity.background || '无'}`;
                
                const playerInfoPrompt = `玩家（“${myProfile.name}”）的信息如下：\n性别: ${myProfile.gender}\n拍一拍动作: ${myProfile.patAction || '拍了拍'}\n拍一拍内容: ${myProfile.patContent || ''}\n背景: ${myProfile.background || '无'}`;

                const useBuiltin = chatSettings.useBuiltinEmojis !== false;
                const useCustom = chatSettings.useCustomEmojisInPrompt !== false;

                let emojiMapForPrompt = {};
                if (useBuiltin) {
                    Object.assign(emojiMapForPrompt, BUILTIN_AI_EMOJIS);
                }
                if (useCustom) {
                    for (const [id, data] of Object.entries(appState.customEmojis)) {
                        emojiMapForPrompt[id] = data.name;
                    }
                }

                const emojiListString = Object.entries(emojiMapForPrompt).map(([id, desc]) => `${id}：${desc}`).join('\n');

                let patAPatRulesForPrompt = '';
                if (chatSettings.enablePatAPat !== false) {
                    patAPatRulesForPrompt = `11. **拍一拍**: 当你想表达一些俏皮、提醒或想互动但无话可说的场景时，可以使用拍一拍。你必须使用被拍者的自定义动作和内容，使用此格式：<拍一拍>拍人角色名 (被拍人设定的动作) 被拍角色名 (被拍人设定的内容)</拍一拍>。
例如，如果玩家的拍一拍内容是“被弹飞了”，则格式为：<拍一拍>33 拍了拍 {PLAYER_NAME} 被弹飞了</拍一拍>。
绝对不能用拍人者的自定义动作和内容来回复，这是错误的。
12. **修改拍一拍**: 当角色基于聊天语境想修改自己的拍一拍设置时，使用此格式：
<修改拍一拍>
修改人：角色名
拍一拍动作：xxx（不超过5个字，例如:捏了捏）
拍一拍内容：xxx（不超过20个字，例如:的脸，并说好软好软;或者:的头,被弹飞了）
</修改拍一拍>`;
                }
                
                const finalPrompt = [
                    situationPrompt,
                    taskPrompt,
                    characterInfoPrompt,
                    playerInfoPrompt, 
                    historyPrompt,
                    AIHandler.activeReplyPromptTpl.replace('{EMOJI_LIST}', emojiListString).replace('{PLAYER_NAME}', myProfile.name).replace('{PAT_A_PAT_RULES}', patAPatRulesForPrompt)
                ].join('\n\n');

                console.log(`--- ACTIVE REPLY PROMPT SENT TO AI ---\n`, finalPrompt);
                return finalPrompt;
            },

            async parseAndDisplayMixedAIResponse(text, chatId) {
                
                const contacts = await DBHelper.getAll('contacts');
                const baseTimestamp = Date.now();
                let timestampOffset = 0;
                const displayableMessages = [];
                const messagesToSave = [];
                const contactUpdates = {};

                const createBaseMessage = (senderName, isAutoReply = false, displayTimestamp = null) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`未在通讯录中找到名为 "${senderName}" 的角色，跳过此消息。`);
                        return null;
                    }
                    return {
                        messageId: Utils.generateId('msg'),
                        chatId: chatId,
                        senderId: sender.id,
                        timestamp: baseTimestamp + timestampOffset++,
                        type: 'received',
                        isUnread: chatId !== appState.currentChatId,
                        isAutoReply: isAutoReply,
                        displayTimestamp: displayTimestamp,
                    };
                };

                const allMessageRegex = /『([^』]+?)』|【([^】]+?)】|「([^」]+?)」|{([^{}]+?)}|\[([\s\S]+?)\]|<([^>]+?)>/g;

                text.replace(allMessageRegex, (match, cardContent, innerVoiceContent, essayContent, retractedContent, standardContent, emojiContent) => {
                    if (innerVoiceContent || essayContent) {
                        const content = innerVoiceContent || essayContent;
                        const parts = content.split('|').map(p => p.trim());
                        if (parts.length < 3) return;

                        const type = parts[0];
                        const senderName = parts[1];
                        const msgContent = parts.slice(2).join('|');
                        const sender = contacts.find(c => c.name === senderName);
                        if (!sender) return;

                        let message;
                        if (type === '心声') {
                            message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'inner_voice' };
                            if (!contactUpdates[sender.id]) contactUpdates[sender.id] = {};
                            contactUpdates[sender.id].lastInnerVoiceId = message.messageId;
                        } else if (type === '随笔') {
                            message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'essay' };
                            if (!contactUpdates[sender.id]) contactUpdates[sender.id] = {};
                            contactUpdates[sender.id].lastEssayId = message.messageId;
                            UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                        }
                        if (message) messagesToSave.push(message);
                        return;
                    }

                    let innerContent, bracketType;
                    if (cardContent) { bracketType = '『'; innerContent = cardContent; }
                    else if (retractedContent) { bracketType = '{'; innerContent = retractedContent; }
                    else if (standardContent) { bracketType = '['; innerContent = standardContent; }
                    else if (emojiContent) { bracketType = '<'; innerContent = emojiContent; }
                    else { return; }

                    const parts = innerContent.split('|').map(p => p.trim());
                    if (parts.length < 2) return;
                    
                    const senderName = parts[0];
                    const lastPart = parts[parts.length - 1];
                    const timeRegex = /^(\d{1,2}\/\d{1,2}\s+)?\d{1,2}:\d{2}$/;
                    let isAutoReply = timeRegex.test(lastPart);
                    let displayTimestamp = isAutoReply ? lastPart : null;

                    const baseMessage = createBaseMessage(senderName, isAutoReply, displayTimestamp);
                    if (!baseMessage) return;

                    baseMessage.isRetracted = bracketType === '{';
                    baseMessage.toBeRetracted = bracketType === '{';

                    const contentParts = isAutoReply ? parts.slice(1, -1) : parts.slice(1);

                    if (bracketType === '『') {
                        if(contentParts.length < 4) return;
                        baseMessage.segmentType = 'card';
                        baseMessage.content = `[卡片] ${contentParts[1]}`;
                        baseMessage.cardData = { shareType: contentParts[0], title: contentParts[1], summary: contentParts[2], details: contentParts[3], isExpanded: false };
                    } else if (bracketType === '<') {
                        baseMessage.segmentType = 'emoji-image';
                        baseMessage.content = contentParts[0];
                    } else { 
                        if (contentParts.length === 1) {
                            baseMessage.segmentType = 'text';
                            baseMessage.content = contentParts[0];
                        } else {
                            const typeKeyword = contentParts[0];
                            switch (typeKeyword) {
                                case '语音':
                                    baseMessage.segmentType = 'voice';
                                    baseMessage.content = `[语音] ${contentParts[2]}`;
                                    baseMessage.cardData = { duration: contentParts[1], content: contentParts[2] };
                                    break;
                                case '引用':
                                    baseMessage.segmentType = 'quote';
                                    baseMessage.content = `[引用] ${contentParts[3]}`;
                                    baseMessage.cardData = { quotedName: contentParts[1], quotedContent: contentParts[2], newContent: contentParts[3] };
                                    break;
                                default:
                                    baseMessage.segmentType = 'text';
                                    baseMessage.content = contentParts.join('|');
                                    break;
                            }
                        }
                    }

                    if (baseMessage.segmentType) {
                        messagesToSave.push(baseMessage);
                        displayableMessages.push(baseMessage);
                    }
                });

                await DBHelper.batchPut('messages', messagesToSave);

                for (const [contactId, updates] of Object.entries(contactUpdates)) {
                    const contactToUpdate = await DBHelper.get('contacts', contactId);
                    if (contactToUpdate) {
                        Object.assign(contactToUpdate, updates);
                        await DBHelper.put('contacts', contactToUpdate);
                    }
                }

                if (displayableMessages.length > 0) {
                    const lastDisplayableMsg = displayableMessages[displayableMessages.length - 1];
                    const isUnread = chatId !== appState.currentChatId;
                    await UIManager.updateChatMetadata(chatId, lastDisplayableMsg, isUnread ? displayableMessages.length : 0);
                }
                
                let lastTimestamp = 0;
                for (const msg of displayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));

                    const senderForDisplay = contacts.find(c => c.id === msg.senderId) || { name: '未知用户' };

                    if (chatId === appState.currentChatId) {
                        if (lastTimestamp > 0 && msg.timestamp - lastTimestamp > 5 * 60 * 1000) {
                            chatArea.appendChild(UIManager.createTimeDividerElement(msg.timestamp));
                        }
                        await UIManager.addMessageToDOM(msg, senderForDisplay, false, true);
                        if (msg.toBeRetracted) {
                            setTimeout(async () => {
                                const msgToRetract = await DBHelper.get('messages', msg.messageId);
                                if (msgToRetract) {
                                    msgToRetract.isRetracted = true;
                                    await DBHelper.put('messages', msgToRetract);
                                    const bubbleEl = $(`#${msg.messageId}`);
                                    if (bubbleEl) {
                                        bubbleEl.replaceWith(UIManager.createRetractionNotice(msgToRetract, senderForDisplay));
                                    }
                                }
                            }, Math.random() * 1000 + 1000);
                        }
                        chatArea.scrollTop = chatArea.scrollHeight;
                        lastTimestamp = msg.timestamp;
                    } else {
                        msg.senderInfo = senderForDisplay;
                        UIManager.showTopNotification(msg);
                    }
                }
            },

            async handleRegenerateRequest(messageId) {
                const confirmation = await new Promise(resolve => {
                    UIManager.showModal({
                        title: "重新生成回复",
                        body: "<p>你确定要让AI重新生成上一条回复吗？这会删除AI的最新几条消息。</p>",
                        actions: [
                            { text: '取消', class: 'btn-secondary', handler: () => { UIManager.hideModal(); resolve(false); } },
                            { text: '确定', class: 'btn-primary', handler: () => { UIManager.hideModal(); resolve(true); } }
                        ]
                    });
                });

                if (!confirmation) return;

                const chatId = appState.currentChatId;
                const allMessages = await DBHelper.getMessages(chatId, 1000, Date.now()); 
                if (!allMessages || allMessages.length === 0) return;

                const playerMessageIndex = allMessages.findIndex(m => m.messageId === messageId);
                if (playerMessageIndex === -1) return;

                const messagesToDelete = [];
                for (let i = playerMessageIndex + 1; i < allMessages.length; i++) {
                    if (allMessages[i].type === 'received') {
                        
                        messagesToDelete.push(allMessages[i]);
                    }
                }
                
                
                for (const msgToDelete of messagesToDelete) {
                    if ((msgToDelete.segmentType === 'inner_voice' || msgToDelete.segmentType === 'essay') && msgToDelete.senderId) {
                        const contact = await DBHelper.get('contacts', msgToDelete.senderId);
                        if (contact) {
                            let contactNeedsUpdate = false;
                            if (msgToDelete.segmentType === 'inner_voice' && contact.lastInnerVoiceId === msgToDelete.messageId) {
                                delete contact.lastInnerVoiceId;
                                contactNeedsUpdate = true;
                            }
                            if (msgToDelete.segmentType === 'essay' && contact.lastEssayId === msgToDelete.messageId) {
                                delete contact.lastEssayId;
                                contactNeedsUpdate = true;
                            }
                            if (contactNeedsUpdate) {
                                await DBHelper.put('contacts', contact);
                            }
                        }
                    }
                }

                
                for (const msg of messagesToDelete) {
                    await DBHelper.delete('messages', msg.messageId);
                }
                
                if (messagesToDelete.length > 0) {
                     const messagesToDeleteIds = messagesToDelete.map(m => m.messageId);
                     const remainingMessages = allMessages.filter(m => !messagesToDeleteIds.includes(m.messageId));
                     if (remainingMessages.length > 0) {
                        const lastMessage = remainingMessages[remainingMessages.length - 1];
                        await UIManager.updateChatMetadata(chatId, lastMessage);
                     } else {
                        await DBHelper.delete('chatMetadata', chatId);
                     }
                }

                for (const msg of messagesToDelete) {
                    const elementToDelete = $(`#${msg.messageId}`);
                    if (elementToDelete) {
                        elementToDelete.remove();
                    }
                }

                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const regenerationInstruction = `\n---
紧急指令：玩家（“${myProfile.name}”）要求你重新生成刚才的回复，因为你之前的回复可能“不符合角色性格(OOC)”或“未使用正确的格式”。请你仔细复核你的角色设定和所有回复规则，然后给出一个更优质的回复。
---`;
                
                const basePrompt = await this.buildPrompt();
                const newPrompt = basePrompt + regenerationInstruction;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const isGroup = chatId.startsWith('group-');
                let typingTarget;
                const typingBubbleId = Utils.generateId('typing');

                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', chatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', appState.currentChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const messagesForImageCheck = await DBHelper.getMessages(chatId, 15);
                    const imagesForApi = [];
                    
                    for (let i = messagesForImageCheck.length - 1; i >= 0; i--) {
                        const msg = messagesForImageCheck[i];
                        if (msg.type === 'sent' && msg.messageId !== messageId) { 
                            if (msg.segmentType === 'image_vision') {
                                imagesForApi.push({ base64: msg.cardData.base64 });
                            }
                        } else if (msg.messageId === messageId) {
                            
                            break; 
                        }
                    }

                    const aiRawResponse = await this.getApiResponse(newPrompt, imagesForApi.reverse(), this.abortController.signal);
                    
                    const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId };
                    metadata.lastRawAiResponse = aiRawResponse;
                    await DBHelper.put('chatMetadata', metadata);

                    console.log("--- AI 原始回复 ---\n", aiRawResponse);

                    await this.parseAndDisplayAIResponse(aiRawResponse, chatId);
                } catch (error) {
                    if (error.name !== 'AbortError') this.showError(`AI回复失败: ${error.message}`);
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    const typingBubble = $(`#${typingBubbleId}`);
                    if (typingBubble) typingBubble.remove();
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    UIManager.syncAiButtonState();
                }
            },

async buildSummaryPrompt(chatId) {
    const isGroup = chatId.startsWith('group-');
    const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
    if (!entity) return null;

    const myProfile = await EventManager.getPlayerProfileForContext(chatId);
    const allContacts = await DBHelper.getAll('contacts');
    
    const history = await DBHelper.getMessages(chatId, 60);
    const turns = this.buildTurnsFromHistory(history, allContacts, myProfile);
    const last30turns = turns.slice(-30);
    if (last30turns.length === 0) return null;
    
    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
    const defaultSummaryPrompt = `你是一个聊天记录总结助手。请根据“最新聊天记录”，为我生成一段不超过350个字的新总结。新的总结需要融合旧总结的核心内容和新聊天记录的要点，保持故事的连贯性。请重点关注时间的发生时间、人物关系的变化、关键事件的进展、以及重要信息的交换。内容应客观、信息丰富且凝练。`;
    const userSummaryPrompt = chatSettings.summaryPrompt || defaultSummaryPrompt;

    let prompt = `${userSummaryPrompt}\n\n`;
    prompt += `--- 最新聊天记录 (最近30轮) ---\n${last30turns.map(turn => `${turn.role}: ${turn.content}`).join('\n')}\n\n`;

    return prompt;
},

async handleAutoSummaryRequest(chatId) {
    if (appState.isSummarizing[chatId]) {
        console.log("已在总结中，跳过此次请求。");
        return;
    }

    try {
        appState.isSummarizing[chatId] = true;
        
        if ($('#auto-summary-content')) {
            const isGroup = chatId.startsWith('group-');
            UIManager.showAutoSummaryModal(chatId, isGroup);
        }

        const prompt = await this.buildSummaryPrompt(chatId);
        if (!prompt) {
            console.log("构建总结Prompt失败或无需总结。");
            return;
        }

        console.log("--- SUMMARY PROMPT SENT TO AI ---\n", prompt);
        const summaryResponse = await this.getApiResponse(prompt, new AbortController().signal);

        if (summaryResponse) {
            const isGroup = chatId.startsWith('group-');
            const storeName = isGroup ? 'groups' : 'contacts';
            const entity = await DBHelper.get(storeName, chatId);
            
                const newSummaryPart = summaryResponse.trim().slice(0, 350);
                const separator = `\n\n--- ${new Date().toLocaleString()} ---\n`;
                
                if (entity.autoSummary) {
                    entity.autoSummary += separator + newSummaryPart;
                } else {
                    entity.autoSummary = newSummaryPart;
                }
                UIManager.showToast(`“${entity.name}”的总结已更新！`); 
            
            await DBHelper.put(storeName, entity);
            console.log("新总结已保存:", entity.autoSummary);
        }

    } catch (error) {
        console.error("自动总结失败:", error);
    } finally {
        appState.isSummarizing[chatId] = false;
        
        if ($('#auto-summary-content')) {
            const isGroup = chatId.startsWith('group-');
            UIManager.showAutoSummaryModal(chatId, isGroup);
        }
    }
},

            async handleOpeningSceneRequest(scene) {
                if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const isGroup = !!scene.groupId;
                const chatId = isGroup ? scene.groupId : scene.contactId;
                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const allContacts = await DBHelper.getAll('contacts');
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};

                let taskPrompt, characterInfoPrompt, finalPrompt;
                
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);

                if (isGroup) {
                    const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    taskPrompt = `你现在正在一个名为“${chatEntity.name}”的群聊中，需要同时扮演以下几位角色：${members.map(m => m.name).join('、')}。`;
                    characterInfoPrompt = `群聊成员资料如下：\n` + members.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n背景: ${m.background || '无'}`).join('\n---\n');
                } else {
                    taskPrompt = `你现在正在扮演“${chatEntity.name}”，与“${myProfile.name}”（也就是玩家）进行一对一私聊。`;
                    characterInfoPrompt = `你的角色资料如下：\n角色名: ${chatEntity.name}\n性别: ${chatEntity.gender}\n喜好: ${chatEntity.likes || '无'}\n厌恶: ${chatEntity.dislikes || '无'}\n习惯: ${chatEntity.habits || '无'}\n背景: ${chatEntity.background || '无'}`;
                }
                
                let customPromptsSection = '';
                if (chatEntity && chatEntity.boundPromptFolderIds?.length > 0) {
                    const allFolders = await DBHelper.getAll('promptFolders');
                    const allPrompts = await DBHelper.getAll('prompts');
                    const playerInputForScene = scene.content;

                    const activeBoundFolders = allFolders.filter(f => chatEntity.boundPromptFolderIds.includes(f.id) && f.isActive);
                    if (activeBoundFolders.length > 0) {
                        const activeBoundFolderIds = activeBoundFolders.map(f => f.id);
                        const relevantPrompts = allPrompts.filter(p => activeBoundFolderIds.includes(p.folderId) && p.isActive);
                        const promptsToInject = relevantPrompts
                            .filter(p => p.type === 'explicit' || (p.type === 'implicit' && JSON.parse(p.keywords).some(kw => playerInputForScene.includes(kw))))
                            .map(p => p.content);
                        if (promptsToInject.length > 0) {
                            customPromptsSection = `\n--- 其他资料 ---\n${promptsToInject.join('\n\n')}\n---`;
                        }
                    }
                }

                const playerInfoPrompt = `玩家（“${myProfile.name}”）的信息如下：\n性别: ${myProfile.gender}\n拍一拍动作: ${myProfile.patAction || '拍了拍'}\n拍一拍内容: ${myProfile.patContent || ''}\n背景: ${myProfile.background || '无'}`;
                const openingInstruction = `\n---
紧急指令：这是一个全新的开场。请根据以下“开场白”内容，让角色开始对话，营造出开场氛围。不要提及“开场白”这三个字，直接开始表演。
开场白内容：
“${scene.content}”
---`;
                
                const useBuiltin = chatSettings.useBuiltinEmojis !== false;
                const useCustom = chatSettings.useCustomEmojisInPrompt !== false;
                let emojiMapForPrompt = {};
                if (useBuiltin) Object.assign(emojiMapForPrompt, BUILTIN_AI_EMOJIS);
                if (useCustom) {
                    for (const [id, data] of Object.entries(appState.customEmojis)) {
                        emojiMapForPrompt[id] = data.name;
                    }
                }
                const emojiListString = Object.entries(emojiMapForPrompt).map(([id, desc]) => `${id}：${desc}`).join('\n');
                
                let patAPatRulesForPrompt = '';
                if (chatSettings.enablePatAPat !== false) {
                    patAPatRulesForPrompt = `11. **拍一拍**: 当你想表达一些俏皮、提醒或想互动但无话可说的场景时，可以使用拍一拍。你必须使用被拍者的自定义动作和内容，使用此格式：<拍一拍>拍人角色名 (被拍人设定的动作) 被拍角色名 (被拍人设定的内容)</拍一拍>。
例如，如果玩家的拍一拍内容是“被弹飞了”，则格式为：<拍一拍>33 拍了拍 {PLAYER_NAME} 被弹飞了</拍一拍>。
绝对不能用拍人者的自定义动作和内容来回复，这是错误的。
12. **修改拍一拍**: 当角色基于聊天语境下想修改自己的拍一拍设置时，使用此格式：
<修改拍一拍>
修改人：角色名
拍一拍动作：xxx（不超过5个字，例如:捏了捏）
拍一拍内容：xxx（不超过20个字，例如:的脸，并说好软好软;或者:的头,被弹飞了）
</修改拍一拍>`;
                }
                
                const formatPrompt = AIHandler.formatPromptTpl.replace('{EMOJI_LIST}', emojiListString).replace('{PLAYER_NAME}', myProfile.name).replace('{PAT_A_PAT_RULES}', patAPatRulesForPrompt);

                const promptParts = [
                    taskPrompt, 
                    characterInfoPrompt, 
                    playerInfoPrompt, 
                    customPromptsSection,
                    openingInstruction, 
                    formatPrompt
                ];

                finalPrompt = promptParts.filter(Boolean).join('\n\n');
                if (isGroup) {
                    finalPrompt += this.getGroupChatRules(chatSettings);
                }
                
                console.log("--- OPENING SCENE PROMPT SENT TO AI ---\n", finalPrompt);
                
                const typingTarget = chatEntity;
                const typingBubbleId = Utils.generateId('typing');
                if (typingTarget) {
                     if (isGroup) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    } else {
                        chatTypingIndicator.style.display = 'block';
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(finalPrompt, null, this.abortController.signal);
                    const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId };
                    metadata.lastRawAiResponse = aiRawResponse;
                    await DBHelper.put('chatMetadata', metadata);
                    
                    console.log("--- AI 原始回复 ---\n", aiRawResponse);
                    await this.parseAndDisplayAIResponse(aiRawResponse, chatId);
                } catch (error) {
                    if (error.name !== 'AbortError') this.showError(`AI回复失败: ${error.message}`);
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    const typingBubble = $(`#${typingBubbleId}`);
                    if (typingBubble) typingBubble.remove();
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },

            async findAndClaimTransfer(senderName, recipientName, amount, chatId) {
                const history = await DBHelper.getMessages(chatId, 30);
                const targetTransfer = history.reverse().find(msg => 
                    msg.segmentType === 'transfer' &&
                    !msg.cardData.isClaimed &&
                    msg.cardData.recipientName === recipientName &&
                    msg.cardData.amount === `￥${amount.toFixed(2)}` 
                );

                if (targetTransfer) {
                    targetTransfer.cardData.isClaimed = true;
                    await DBHelper.put('messages', targetTransfer);
                    const bubble = $(`#${targetTransfer.messageId} .bubble`);
                    if (bubble) bubble.classList.add('claimed');
                    console.log(`Transfer ${targetTransfer.messageId} has been claimed.`);
                } else {
                    console.warn(`Could not find matching unclaimed transfer for ${recipientName} from ${senderName}.`);
                }
            },
            async parseAndDisplayAIResponse(text, chatId) {
                const contacts = await DBHelper.getAll('contacts');
                const baseTimestamp = Date.now();
                let timestampOffset = 0;
                const displayableMessages = [];
                const parseStartTime = Date.now(); 
                let newGroupNameFromAI = null;
                const chatMetadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId };

                const createBaseMessage = (senderName) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`未在通讯录中找到名为 "${senderName}" 的角色，跳过此消息。`);
                        return null;
                    }
                    const baseMessage = {
                        messageId: Utils.generateId('msg'),
                        chatId: chatId,
                        senderId: sender.id,
                        timestamp: baseTimestamp + timestampOffset++,
                        type: 'received',
                        isUnread: chatId !== appState.currentChatId,
                    };
                    return { baseMessage, sender };
                };

                const allMessageRegex = /<朋友圈>([\s\S]*?)<\/朋友圈>|<旁白>([\s\S]*?)<\/旁白>|<系统>([\s\S]*?)<\/系统>|<私聊>([\s\S]*?)<\/私聊>|<礼物>([\s\S]*?)<\/礼物>|<拍一拍>([\s\S]*?)<\/拍一拍>|<修改拍一拍>([\s\S]*?)<\/修改拍一拍>|『([^』]+?)』|【([^】]+?)】|「([^」]+?)」|{([^{}]+?)}|\[([\s\S]+?)\]|<((?!系统|私聊)[^>]+?)>/g;

                const messagesToSave = [];
                const contactUpdates = {};

                const matches = text.matchAll(allMessageRegex);
                
                const isGroup = chatId.startsWith('group-');
                let currentMemberIds = [];
                if (isGroup) {
                    const group = await DBHelper.get('groups', chatId);
                    if(group) {
                        currentMemberIds = group.members;
                    }
                }
                
                
                for (const match of matches) {
                    const [
                        fullMatch, momentContent, narratorContent, systemContent, privateContent,
                        giftContent, patAPatContent, modifyPatContent, cardContent,
                        innerVoiceContent, essayContent, retractedContent,
                        standardContent, emojiContent
                    ] = match;

                    if (momentContent !== undefined) {
                        (async () => {
                            const block = momentContent.trim();
                            const postMatch = block.match(/【(.*?)】/);
                            if (!postMatch) return;

                            const [authorPart, timePart] = postMatch[1].split('|');
                            const [authorName, ...contentParts] = authorPart.split('：');
                            const content = contentParts.join('：').trim();
                            const trimmedAuthorName = authorName.trim();

                            const author = contacts.find(c => c.name === trimmedAuthorName);
                            if (!author || !author.boundCircleId) {
                                console.log(`朋友圈动态被跳过：角色“${trimmedAuthorName}”未找到或未绑定朋友圈。`);
                                return;
                            }

                            const myProfile = await EventManager.getPlayerProfileForContext(author.boundCircleId);

                            const likeMatch = block.match(/（已点赞：(.*?)）/);
                            const likerNames = likeMatch ? likeMatch[1].split(/,|，/).map(n => n.trim()) : [];

                            const newMoment = {
                                id: Utils.generateId('moment'),
                                circleId: author.boundCircleId,
                                authorId: author.id,
                                content: content,
                                images: [], 
                                timestamp: Utils.parseMomentTimestamp(timePart ? timePart.trim() : null),
                                likes: likerNames, 
                                comments: []
                            };
                            
                            const commentMatches = block.match(/〖(.*?)〗/g) || [];
                            for (const cMatch of commentMatches) {
                                const inner = cMatch.slice(1, -1);
                                const [cAuthorName, ...cContentParts] = inner.split('：');
                                const trimmedCommentAuthor = cAuthorName.trim();
                                
                                let cAuthorId;
                                if (trimmedCommentAuthor === myProfile.name) {
                                    cAuthorId = myProfile.id; 
                                } else {
                                    const cAuthorContact = contacts.find(c => c.name === trimmedCommentAuthor);
                                    cAuthorId = cAuthorContact ? cAuthorContact.id : trimmedCommentAuthor; 
                                }
                                
                                newMoment.comments.push({
                                    authorId: cAuthorId,
                                    content: cContentParts.join('：').trim(),
                                    timestamp: Date.now()
                                });
                            }

                            await DBHelper.put('moments', newMoment);
                            UIManager.showMomentNotification(newMoment);
                        })();
                    } else if (patAPatContent !== undefined) {
                        const content = patAPatContent.trim();
                        const patMatch = content.match(/(\S+)\s+.*?\s+(\S+)/);

                        if (patMatch) {
                            const [, patterName, patteeName] = patMatch.map(s => s.trim());
                            
                            
                            const patterContact = contacts.find(c => c.name === patterName);
                            const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                            const patteeIsPlayer = patteeName === myProfile.name;
                            const patteeContact = patteeIsPlayer ? myProfile : contacts.find(c => c.name === patteeName);

                            if (patterContact && patteeContact) {
                                const finalAction = patteeContact.patAction || '拍了拍';
                                const finalContent = patteeContact.patContent || '';
                                const finalDisplayText = `${patterName} ${finalAction} ${patteeName}${finalContent ? ` ${finalContent}` : ''}`;

                                const message = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: chatId,
                                    senderId: patterContact.id,
                                    timestamp: baseTimestamp + timestampOffset++,
                                    type: 'received',
                                    isUnread: chatId !== appState.currentChatId,
                                    segmentType: 'pat_a_pat',
                                    content: {
                                        patterName: patterName,
                                        patteeName: patteeName,
                                        action: finalAction,
                                        content: finalContent,
                                        displayText: finalDisplayText
                                    }
                                };
                                messagesToSave.push(message);
                                displayableMessages.push(message);
                            }
                        }
                    } else if (modifyPatContent !== undefined) {
                        const content = modifyPatContent.trim();
                        const modifierMatch = content.match(/修改人：(.+)/);
                        const actionMatch = content.match(/拍一拍动作：(.+)/);
                        const contentMatch = content.match(/拍一拍内容：(.+)/);

                        const modifierName = modifierMatch ? modifierMatch[1].trim() : null;
                        if (modifierName) {
                            const contactToUpdate = contacts.find(c => c.name === modifierName);
                            if (contactToUpdate) {
                                if (actionMatch) contactToUpdate.patAction = actionMatch[1].trim();
                                if (contentMatch) contactToUpdate.patContent = contentMatch[1].trim();
                                
                                if (!contactUpdates[contactToUpdate.id]) {
                                    contactUpdates[contactToUpdate.id] = {};
                                }
                                Object.assign(contactUpdates[contactToUpdate.id], {
                                    patAction: contactToUpdate.patAction,
                                    patContent: contactToUpdate.patContent
                                });

                                const systemMessage = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: chatId,
                                    timestamp: baseTimestamp + timestampOffset++,
                                    type: 'received',
                                    content: `${modifierName} 更新了自己的拍一拍`,
                                    segmentType: 'system',
                                    forAi: false
                                };
                                messagesToSave.push(systemMessage);
                                displayableMessages.push(systemMessage);
                            }
                        }
                    } else if (narratorContent !== undefined) {
                        const message = { 
                            messageId: Utils.generateId('msg'), 
                            chatId: chatId,
                            timestamp: baseTimestamp + timestampOffset++,
                            type: 'received',
                            content: narratorContent.trim(), 
                            segmentType: 'narrator' 
                        };
                        messagesToSave.push(message);
                        displayableMessages.push(message);
                    } else if (systemContent !== undefined) {
                        const content = systemContent.trim();
                        const nameChangeParts = content.match(/(.+?)\s*修改群名为\s*(.*)$/);

                        if (nameChangeParts && nameChangeParts.length === 3) {
                            const modifierName = nameChangeParts[1].trim();
                            const rawNewName = nameChangeParts[2].trim();
                            
                            
                            if (isGroup) {
                                const modifierContact = contacts.find(c => c.name === modifierName);
                                if (!modifierContact || !currentMemberIds.includes(modifierContact.id)) {
                                    console.warn(`已忽略：群聊外的成员 "${modifierName}" 尝试修改群名。`);
                                    continue; 
                                }
                            }
                            

                            const parsedNewName = rawNewName.replace(/^["“]|["”]$/g, '');
                            newGroupNameFromAI = parsedNewName;

                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                chatId: chatId,
                                timestamp: baseTimestamp + timestampOffset++,
                                type: 'received',
                                content: `${modifierName} 修改群名为 “${parsedNewName}”`,
                                segmentType: 'system',
                                forAi: true
                            };
                            messagesToSave.push(systemMessage);
                            displayableMessages.push(systemMessage);
                        }
                    } else if (privateContent !== undefined) {
                        const innerContent = privateContent.trim();
                        (async () => {
                            const innerMatches = innerContent.matchAll(allMessageRegex);
                            for (const innerMatch of innerMatches) {
                                const [
                                    innerFullMatch, iMoment, iNarrator, iSystem, iPrivate, iGift,
                                    iPat, iModifyPat, iCard, iInnerVoice, iEssay,
                                    iRetracted, iStandard, iEmoji
                                ] = innerMatch;

                                let senderName, sender;
                                const contentToParse = iRetracted || iStandard || iEmoji || '';
                                const senderMatch = contentToParse.match(/^([^|]+?)\|/);

                                if (!senderMatch) continue;
                                senderName = senderMatch[1].trim();
                                sender = contacts.find(c => c.name === senderName);
                                if (!sender) continue;

                                const privateMessage = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: sender.id,
                                    senderId: sender.id,
                                    timestamp: Date.now() + timestampOffset++,
                                    type: 'received',
                                    isUnread: true,
                                    isPrivateInGroup: true,
                                };

                                if (iRetracted) {
                                    const parts = iRetracted.split('|');
                                    privateMessage.segmentType = 'text';
                                    privateMessage.content = parts.slice(1).join('|').trim();
                                    privateMessage.isRetracted = true;
                                } else if (iEmoji) {
                                    const parts = iEmoji.split('|');
                                    privateMessage.segmentType = 'emoji-image';
                                    privateMessage.content = parts[1].trim();
                                } else if (iStandard) {
                                    const parts = iStandard.split('|').map(p => p.trim());
                                    const typeKeyword = parts[1];
                                    switch (typeKeyword) {
                                        case '语音':
                                            privateMessage.segmentType = 'voice';
                                            privateMessage.content = `[语音] ${parts[3]}`;
                                            privateMessage.cardData = { duration: parts[2], content: parts[3] };
                                            break;
                                        case '引用':
                                            privateMessage.segmentType = 'quote';
                                            privateMessage.content = `[引用] ${parts[4]}`;
                                            privateMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] };
                                            break;
                                        default:
                                            privateMessage.segmentType = 'text';
                                            privateMessage.content = parts.slice(1).join('|').trim();
                                            break;
                                    }
                                } else {
                                    continue;
                                }

                                if (privateMessage.segmentType) {
                                    await DBHelper.put('messages', privateMessage);
                                    await UIManager.updateChatMetadata(sender.id, privateMessage, 1);
                                    const senderForDisplay = await DBHelper.get('contacts', privateMessage.senderId);
                                    privateMessage.senderInfo = senderForDisplay;
                                    UIManager.showTopNotification(privateMessage);
                                    if (appState.currentPage === 'messages') {
                                        await UIManager.renderMessagesListPage();
                                    }
                                }
                            }
                        })();
                    } else if (giftContent !== undefined) {
                        const content = giftContent.trim();
                        const senderMatch = content.match(/发送方：(.+)/);
                        const recipientMatch = content.match(/接收方：(.+)/);
                        const nameMatch = content.match(/礼物名称：(.+)/);
                        const priceMatch = content.match(/礼物价格：(.+)/);
                        const descMatch = content.match(/礼物介绍：([\s\S]+?)寄语：/);
                        const messageMatch = content.match(/寄语：(.+)/);

                        const senderName = senderMatch ? senderMatch[1].trim() : null;
                        if (!senderName) continue;
                        
                        
                        const result = createBaseMessage(senderName);
                        if (result) {
                            const { baseMessage, sender } = result; 
                            baseMessage.segmentType = 'gift';
                            baseMessage.content = `[礼物] ${nameMatch ? nameMatch[1].trim() : '一份礼物'}`;
                            baseMessage.cardData = {
                                recipientName: recipientMatch ? recipientMatch[1].trim() : '你',
                                name: nameMatch ? nameMatch[1].trim() : '礼物',
                                price: priceMatch ? priceMatch[1].trim() : '0.00',
                                description: descMatch ? descMatch[1].trim() : '',
                                message: messageMatch ? messageMatch[1].trim() : '一份心意。',
                                image: [
                                    'https://cfimg.200996.xyz/file/1752744399723_retouch_2025071717250175.png',
                                    'https://cfimg.200996.xyz/file/1752744402256_retouch_2025071717245049.png',
                                    'https://cfimg.200996.xyz/file/1752744401540_retouch_2025071717242531.png',
                                    'https://cfimg.200996.xyz/file/1752744403509_retouch_2025071717243405.png',
                                    'https://cfimg.200996.xyz/file/1752744399889_retouch_2025071717244351.png'
                                ][Math.floor(Math.random() * 5)]
                            };
                            messagesToSave.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    } else if (cardContent !== undefined) {
                        const parts = cardContent.split('|').map(p => p.trim());
                        const [senderName, shareType, title, summary, details] = parts;
                        const result = createBaseMessage(senderName);
                        if (!result) continue;
                        const { baseMessage, sender } = result;

                        baseMessage.segmentType = 'card';
                        baseMessage.content = `[卡片] ${title}`;
                        baseMessage.cardData = { shareType, title, summary, details, isExpanded: false };
                        messagesToSave.push(baseMessage);
                        displayableMessages.push(baseMessage);
                    } else if (innerVoiceContent !== undefined || essayContent !== undefined) {
                        const content = innerVoiceContent || essayContent;
                        const parts = content.split('|').map(p => p.trim());
                        if (parts.length !== 3) continue;

                        const type = parts[0];
                        const senderName = parts[1];
                        const msgContent = parts[2];
                        
                        const sender = contacts.find(c => c.name === senderName);
                        if (!sender) continue;

                        let message;
                        if (type === '心声') {
                            message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'inner_voice' };
                        } else if (type === '随笔') {
                            message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'essay' };
                            UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                        } else {
                            continue;
                        }
                        
                        messagesToSave.push(message);

                        if (!contactUpdates[sender.id]) {
                            contactUpdates[sender.id] = {};
                        }
                        if (type === '心声') {
                            contactUpdates[sender.id].lastInnerVoiceId = message.messageId;
                        } else if (type === '随笔') {
                            contactUpdates[sender.id].lastEssayId = message.messageId;
                        }
                    } else { 
                        let bracketType, innerContent;
                        if (retractedContent) { bracketType = '{'; innerContent = retractedContent; }
                        else if (standardContent) { bracketType = '['; innerContent = standardContent; }
                        else if (emojiContent) { bracketType = '<'; innerContent = emojiContent; }
                        else { continue; } 

                        if (bracketType === '<' && innerContent.startsWith('随笔|')) {
                            const parts = innerContent.split('|').map(p => p.trim());
                            if (parts.length >= 3) {
                                const senderName = parts[1];
                                const msgContent = parts.slice(2).join('|');
                                const sender = contacts.find(c => c.name === senderName);
                                if (sender) {
                                    messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'essay' });
                                    UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                                }
                            }
                            continue; 
                        }

                        const parts = innerContent.split('|').map(p => p.trim());
                        const [senderName] = parts;
                        const result = createBaseMessage(senderName);
                        
                        if (isGroup) {
                            const senderContact = contacts.find(c => c.name === senderName);
                            if (!senderContact || !currentMemberIds.includes(senderContact.id)) {
                                console.warn(`已忽略：群聊外的成员 "${senderName}" 的消息。`);
                                continue; 
                            }
                        }
                        if (!result) continue;
                        const { baseMessage, sender } = result;

                        if (bracketType === '<') {
                            const emojiSetting = sender.allowEmoji;
                            let shouldDisplay = true;

                            if (emojiSetting === 'off') {
                                shouldDisplay = false;
                            } else if (emojiSetting === 'prob') {
                                shouldDisplay = Math.random() < 0.5;
                            }
                            
                            if (!shouldDisplay) {
                                continue;
                            }

                            baseMessage.segmentType = 'emoji-image';
                            baseMessage.content = parts[1];
                        } else {
                            baseMessage.isRetracted = bracketType === '{';
                            baseMessage.toBeRetracted = bracketType === '{';

                            if (baseMessage.toBeRetracted && sender.allowRetraction === false) {
                                baseMessage.toBeRetracted = false;
                                baseMessage.isRetracted = false;
                            }
                            
                            if (parts.length === 2) { baseMessage.segmentType = 'text'; baseMessage.content = parts[1]; }
                            else if (parts[1] === '领取转账') { 
                                baseMessage.segmentType = 'transfer-receipt'; 
                                baseMessage.content = `${parts[2]}已收款${parts[3]}`; 
                                baseMessage.cardData = { recipientName: parts[0], senderName: parts[2], amount: parts[3] }; 
                                this.findAndClaimTransfer(parts[2], parts[0], parseFloat(parts[3].replace('￥', '')), chatId);
                            }
                            else if (parts[1] === '退还转账') {
                                baseMessage.segmentType = 'transfer-return';
                                baseMessage.content = `${parts[0]}退还了转账${parts[3]}`;
                                baseMessage.cardData = { recipientName: parts[2], senderName: parts[0], amount: parts[3] };
                                this.findAndClaimTransfer(parts[2], parts[0], parseFloat(parts[3].replace('￥', '')), chatId);
                            }
                            else if (parts[1] === '语音') { baseMessage.segmentType = 'voice'; baseMessage.content = `[语音] ${parts[3]}`; baseMessage.cardData = { duration: parts[2], content: parts[3] }; }
                            else if (parts[1] === '引用') { baseMessage.segmentType = 'quote'; baseMessage.content = `[引用] ${parts[4]}`; baseMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] }; }
                            else if (parts[1] === '转账') { baseMessage.segmentType = 'transfer'; baseMessage.content = `[转账] ${parts[3]}`; baseMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false }; }
                            else if (parts[1] === '红包') { baseMessage.segmentType = 'red-packet'; baseMessage.content = `[红包] ${parts[2]}`; baseMessage.cardData = { title: parts[2], amount: parseFloat(parts[3].replace('￥', '')), count: parseInt(parts[4]), claimedBy: [] }; }
                        }

                        if (baseMessage.segmentType) {
                            messagesToSave.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    }
                }

                
                for (const [contactId, updates] of Object.entries(contactUpdates)) {
                    const contactToUpdate = await DBHelper.get('contacts', contactId);
                    if (contactToUpdate) {
                        Object.assign(contactToUpdate, updates);
                        await DBHelper.put('contacts', contactToUpdate);
                    }
                }



                
                const validMessagesToSave = messagesToSave.filter(msg => {
                    if (msg.messageId) {
                        return true;
                    } else {
                        
                        console.warn("过滤掉一个无效的消息对象 (缺少 messageId):", msg);
                        return false;
                    }
                });
                
                await DBHelper.batchPut('messages', validMessagesToSave);
                

                if (newGroupNameFromAI && chatId.startsWith('group-')) {
                    const group = await DBHelper.get('groups', chatId);
                    if (group) {
                        group.name = newGroupNameFromAI;
                        await DBHelper.put('groups', group);
                        if (chatId === appState.currentChatId) {
                            chatTitle.textContent = newGroupNameFromAI;
                        }
                    }
                }

                
                
                const validDisplayableMessages = displayableMessages.filter(displayMsg =>
                    validMessagesToSave.some(savedMsg => savedMsg.messageId === displayMsg.messageId)
                );

                
                if (validDisplayableMessages.length > 0) {
                    chatMetadata.lastAiReplyTimestamp = Date.now();
                    await DBHelper.put('chatMetadata', chatMetadata);
                }

                if (validDisplayableMessages.length > 0) {
                    const lastDisplayableMsg = validDisplayableMessages[validDisplayableMessages.length - 1];
                    const isUnread = chatId !== appState.currentChatId;
                    await UIManager.updateChatMetadata(chatId, lastDisplayableMsg, isUnread ? validDisplayableMessages.length : 0);
                }
                

                
                const lastMessageBeforeLoop = (await DBHelper.getMessages(chatId, 1, baseTimestamp)).pop();
                let lastTimestamp = lastMessageBeforeLoop ? lastMessageBeforeLoop.timestamp : 0;
                
                for (const msg of validDisplayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));

                    
                    const senderForDisplay = contacts.find(c => c.id === msg.senderId) || { name: '未知用户', avatar: Utils.createAvatarDataUrl('#ccc') };
                    msg.senderInfo = senderForDisplay;

                    if (chatId === appState.currentChatId) {
                        
                        if (appState.currentChat.lastRefreshTimestamp > parseStartTime) {
                            console.log("聊天视图已在AI回复处理期间被刷新，中止多余的DOM更新以防止重复。");
                            break; 
                        }

                        
                        if (lastTimestamp > 0 && msg.timestamp - lastTimestamp > 5 * 60 * 1000) {
                            const timeDiv = UIManager.createTimeDividerElement(msg.timestamp);
                            chatArea.appendChild(timeDiv);
                        }
                        
                        if (msg.segmentType === 'system') {
                            const notice = document.createElement('div');
                            notice.className = 'system-notice'; notice.id = msg.messageId; notice.textContent = msg.content;
                            chatArea.appendChild(notice);
                        } else if (msg.segmentType === 'narrator') {
                            const narratorNotice = await UIManager.createNarratorNoticeElement(msg);
                            chatArea.appendChild(narratorNotice);
                        } else {
                             await UIManager.addMessageToDOM(msg, msg.senderInfo, false, true);
                             if (msg.toBeRetracted) {
                                const retractDelay = Math.random() * 1000 + 1000;
                                setTimeout(async () => {
                                    const msgToRetract = await DBHelper.get('messages', msg.messageId);
                                    if (msgToRetract) {
                                        msgToRetract.isRetracted = true;
                                        await DBHelper.put('messages', msgToRetract);
                                        const bubbleEl = $(`#${msg.messageId}`);
                                        if (bubbleEl) {
                                            const retractionNotice = UIManager.createRetractionNotice(msgToRetract, msg.senderInfo);
                                            bubbleEl.replaceWith(retractionNotice);
                                        }
                                    }
                                }, retractDelay);
                            }
                        }
                        chatArea.scrollTop = chatArea.scrollHeight;
                        lastTimestamp = msg.timestamp; 

                    } else {
                        if (msg.segmentType !== 'system' && msg.segmentType !== 'narrator' && !msg.isRetracted) {
                            UIManager.showTopNotification(msg);
                        }
                    }
                }
            },

            async parseAndDisplayActiveAIResponse(text, chatId) {
                const contacts = await DBHelper.getAll('contacts');
                const baseTimestamp = Date.now();
                let timestampOffset = 0;
                const displayableMessages = [];
                const contactUpdates = {};
                const createBaseMessage = (senderName, displayTimestamp) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`未找到角色 "${senderName}"，跳过此主动回复消息。`);
                        return null;
                    }
                    return {
                        messageId: Utils.generateId('msg'),
                        chatId: chatId, 
                        senderId: sender.id,
                        timestamp: baseTimestamp + timestampOffset++,
                        type: 'received',
                        isUnread: chatId !== appState.currentChatId, 
                        
                        isAutoReply: true, 
                        displayTimestamp: displayTimestamp,
                    };
                };

                const allMessageRegex = /『([^』]+?)』|【([^】]+?)】|「([^」]+?)」|{([^{}]+?)}|\[([\s\S]+?)\]|<([^>]+?)>/g;

                const messagesToSave = []; 

                text.replace(allMessageRegex, (match, cardContent, innerVoiceContent, essayContent, retractedContent, standardContent, emojiContent) => {
                    
                    
                    if (innerVoiceContent) { 
                        const parts = innerVoiceContent.split('|').map(p => p.trim());
                        const sender = contacts.find(c => c.name === parts[1]);
                        if (sender) {
                            let message;
                            if (parts[0] === '心声' && parts.length === 3) {
                                message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'inner_voice' };
                                if (!contactUpdates[sender.id]) contactUpdates[sender.id] = {};
                                contactUpdates[sender.id].lastInnerVoiceId = message.messageId;
                            } else if (parts[0] === '随笔' && parts.length === 3) {
                                message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'essay' };
                                if (!contactUpdates[sender.id]) contactUpdates[sender.id] = {};
                                contactUpdates[sender.id].lastEssayId = message.messageId;
                                UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                            }
                            if (message) {
                                messagesToSave.push(message);
                            }
                        }
                        return;
                    }
                    
                    if (essayContent) {
                        const parts = essayContent.split('|').map(p => p.trim());
                        if (parts[0] === '随笔' && parts.length === 3) {
                            const sender = contacts.find(c => c.name === parts[1]);
                            if (sender) {
                                messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'essay' });
                                UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                            }
                        }
                        return; 
                    }

                    let parts, senderName, displayTimestamp, baseMessage;

                    if (cardContent !== undefined) {
                        parts = cardContent.split('|').map(p => p.trim());
                        if (parts.length < 5) return;
                        senderName = parts[0];
                        displayTimestamp = parts.pop();
                        baseMessage = createBaseMessage(senderName, displayTimestamp);
                        if (baseMessage) {
                            baseMessage.segmentType = 'card';
                            baseMessage.content = `[卡片] ${parts[2]}`;
                            baseMessage.cardData = { shareType: parts[1], title: parts[2], summary: parts[3], details: parts[4], isExpanded: false };
                            messagesToSave.push(baseMessage); 
                            displayableMessages.push(baseMessage);
                        }
                    } else {
                        let innerContent, bracketType;
                        if (retractedContent) { innerContent = retractedContent; bracketType = '{'; }
                        else if (standardContent) { innerContent = standardContent; bracketType = '['; }
                        else if (emojiContent) { innerContent = emojiContent; bracketType = '<'; }
                        else { return; }

                        if (bracketType === '<' && innerContent.startsWith('随笔|')) {
                            const parts = innerContent.split('|').map(p => p.trim());
                            if (parts.length >= 3) {
                                const senderName = parts[1];
                                const msgContent = parts.slice(2).join('|');
                                const sender = contacts.find(c => c.name === senderName);
                                if (sender) {
                                    messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'essay' });
                                    UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                                }
                            }
                            return; 
                        }

                        parts = innerContent.split('|').map(p => p.trim());
                        if (parts.length < 2) return;

                        senderName = parts[0];
                        displayTimestamp = parts.pop();
                        baseMessage = createBaseMessage(senderName, displayTimestamp);
                        if (!baseMessage) return;
                        
                        baseMessage.chatId = chatId;
                        
                        if (bracketType === '{') {
                            baseMessage.isRetracted = true;
                            baseMessage.toBeRetracted = true;
                        }

                        if (bracketType === '<') {
                            baseMessage.segmentType = 'emoji-image';
                            baseMessage.content = parts[1];
                        } else if (bracketType === '[') {
                            const typeKeyword = parts[1];
                            switch (typeKeyword) {
                                case '语音':
                                    baseMessage.segmentType = 'voice';
                                    baseMessage.content = `[语音] ${parts[3]}`;
                                    baseMessage.cardData = { duration: parts[2], content: parts[3] };
                                    break;
                                case '引用':
                                    baseMessage.segmentType = 'quote';
                                    baseMessage.content = `[引用] ${parts[4]}`;
                                    baseMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] };
                                    break;
                                case '转账':
                                    baseMessage.segmentType = 'transfer';
                                    baseMessage.content = `[转账] ${parts[3]}`;
                                    baseMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false };
                                    break;
                                case '红包':
                                    baseMessage.segmentType = 'red-packet';
                                    baseMessage.content = `[红包] ${parts[2]}`;
                                    baseMessage.cardData = { title: parts[2], amount: parseFloat(parts[3].replace('￥', '')), count: parseInt(parts[4]), claimedBy: [] };
                                    break;
                                default:
                                    baseMessage.segmentType = 'text';
                                    baseMessage.content = parts.slice(1).join('|');
                                    break;
                            }
                        } else {
                            baseMessage.segmentType = 'text';
                            baseMessage.content = parts.slice(1).join('|');
                        }

                        if (baseMessage.segmentType) {
                            messagesToSave.push(baseMessage); 
                            displayableMessages.push(baseMessage);
                        }
                    }
                });

                 
                for (const msg of messagesToSave) {
                    await DBHelper.put('messages', msg);
                }
                
                for (const [contactId, updates] of Object.entries(contactUpdates)) {
                    const contactToUpdate = await DBHelper.get('contacts', contactId);
                    if (contactToUpdate) {
                        Object.assign(contactToUpdate, updates);
                        await DBHelper.put('contacts', contactToUpdate);
                    }
                }
                if (displayableMessages.length > 0 || messagesToSave.some(m => m.segmentType === 'inner_voice' || m.segmentType === 'essay')) {
                    const chatMetadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId, unreadCount: 0 };
                    chatMetadata.lastAiReplyTimestamp = Date.now();

                    
                    const lastDisplayableMsg = displayableMessages.length > 0 ? displayableMessages[displayableMessages.length - 1] : null;
                    if (lastDisplayableMsg) {
                        chatMetadata.lastMessage = lastDisplayableMsg;
                        chatMetadata.lastMessageTimestamp = lastDisplayableMsg.timestamp;
                    }

                    await DBHelper.put('chatMetadata', chatMetadata);
                }

                if (displayableMessages.length > 0) {
                    const lastDisplayableMsg = displayableMessages[displayableMessages.length - 1];
                    const isUnread = chatId !== appState.currentChatId;
                    await UIManager.updateChatMetadata(chatId, lastDisplayableMsg, isUnread ? displayableMessages.length : 0);
                }

                for (const msg of displayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));
                    
                    
                    const senderForDisplay = contacts.find(c => c.id === msg.senderId) || { name: '未知用户', avatar: Utils.createAvatarDataUrl('#ccc') };
                    
                    msg.senderInfo = senderForDisplay;

                    if (chatId === appState.currentChatId) {
                        UIManager.addMessageToDOM(msg, senderForDisplay, false, true);

                        if (msg.toBeRetracted) {
                            const retractDelay = Math.random() * 1000 + 1000;
                            setTimeout(async () => {
                                
                                const msgToRetract = await DBHelper.get('messages', msg.messageId);
                                if (msgToRetract) {
                                    msgToRetract.isRetracted = true;
                                    await DBHelper.put('messages', msgToRetract);
                                    const bubbleEl = $(`#${msg.messageId}`);
                                    if (bubbleEl) {
                                        
                                        const retractionNotice = UIManager.createRetractionNotice(msgToRetract, senderForDisplay);
                                        bubbleEl.replaceWith(retractionNotice);
                                    }
                                }
                            }, retractDelay);
                        }
                    } else {
                        
                        UIManager.showTopNotification(msg);
                    }
                }
            },

            showError(message) {
                 UIManager.showModal({
                    title: "错误",
                    body: `<p>${message}</p>`,
                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleMomentsRefreshRequest() {
                if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const refreshBtn = $('#moments-refresh-btn i');
                refreshBtn.classList.add('fa-spin');

                try {
                    const prompt = await this.buildMomentsRefreshPrompt();
                    if (!prompt) {
                        UIManager.showToast("无法生成动态：圈子信息不完整。");
                        return;
                    }
                    
                    const aiRawResponse = await this.getApiResponse(prompt, null, this.abortController.signal);
                    console.log("--- AI 朋友圈动态 (原始) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsResponse(aiRawResponse);
                    
                    
                    const circle = await DBHelper.get('circles', appState.currentCircleId);
                    if (circle) {
                        circle.lastRefreshed = Date.now();
                        await DBHelper.put('circles', circle);
                    }

                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error("朋友圈动态生成失败:", error);
                        this.showError(`动态生成失败: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    refreshBtn.classList.remove('fa-spin');
                }
            },
            
            async _getBoundPromptsForMoments(circle, playerInputText = '') {
                if (!circle || !circle.boundPromptFolderIds || circle.boundPromptFolderIds.length === 0) {
                    return '';
                }

                const allFolders = await DBHelper.getAll('promptFolders');
                const allPrompts = await DBHelper.getAll('prompts');

                const activeBoundFolders = allFolders.filter(f => circle.boundPromptFolderIds.includes(f.id) && f.isActive);
                if (activeBoundFolders.length === 0) return '';
                
                const activeBoundFolderIds = activeBoundFolders.map(f => f.id);
                const relevantPrompts = allPrompts.filter(p => activeBoundFolderIds.includes(p.folderId) && p.isActive);

                const promptsToInject = relevantPrompts
                    .filter(p => 
                        p.type === 'explicit' || 
                        (p.type === 'implicit' && playerInputText && JSON.parse(p.keywords).some(kw => playerInputText.includes(kw)))
                    )
                    .map(p => p.content);

                if (promptsToInject.length > 0) {
                    return `\n--- 附加风格要求 (来自绑定的提示词) ---\n${promptsToInject.join('\n\n')}\n---`;
                }
                return '';
            },
            
            async handleMomentsCommentRequest(momentId) {
                 if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const commentsSection = postElement.querySelector('.post-interactions'); 
                
                
                let typingIndicator = commentsSection.querySelector('.post-comment-typing-indicator');
                if (!typingIndicator) {
                    typingIndicator = document.createElement('div');
                    typingIndicator.className = 'post-comment-typing-indicator';
                    
                    commentsSection.style.display = 'block'; 
                    commentsSection.insertBefore(typingIndicator, commentsSection.querySelector('.comment-input-wrapper'));
                }
                typingIndicator.textContent = '朋友们正在赶来评论...';


                try {
                    const prompt = await this.buildMomentsCommentPrompt(momentId);
                    if (!prompt) return;

                    const aiRawResponse = await this.getApiResponse(prompt, null, this.abortController.signal);
                    console.log("--- AI 朋友圈评论 (原始) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsCommentsResponse(momentId, aiRawResponse);

                } catch (error) {
                     if (error.name !== 'AbortError') {
                        console.error("朋友圈评论生成失败:", error);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    if(typingIndicator) typingIndicator.remove();
                }
            },

            async handleMomentsPlayerCommentResponse(momentId, playerComment) {
                 if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const commentsSection = postElement.querySelector('.post-interactions');
                
                let typingIndicator = commentsSection.querySelector('.post-comment-typing-indicator');
                if (!typingIndicator) {
                    typingIndicator = document.createElement('div');
                    typingIndicator.className = 'post-comment-typing-indicator';
                    commentsSection.insertBefore(typingIndicator, commentsSection.querySelector('.comment-input-wrapper'));
                }
                typingIndicator.textContent = '朋友们正在赶来评论...';
                commentsSection.style.display = 'block'; 

                try {
                    const prompt = await this.buildMomentsPlayerCommentPrompt(momentId, playerComment);
                    if (!prompt) return;

                    const aiRawResponse = await this.getApiResponse(prompt, null, this.abortController.signal);
                    console.log("--- AI 朋友圈玩家评论回复 (原始) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsPlayerCommentResponse(momentId, aiRawResponse);

                } catch (error) {
                     if (error.name !== 'AbortError') {
                        console.error("朋友圈AI回复玩家评论失败:", error);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    if(typingIndicator) typingIndicator.remove();
                }
            },

            async buildMomentsRefreshPrompt() {
                const circle = await DBHelper.get('circles', appState.currentCircleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const allContacts = await DBHelper.getAll('contacts');
                
                
                const validMemberIds = circle.memberIds.filter(id => allContacts.some(c => c.id === id));
                if (validMemberIds.length !== circle.memberIds.length) {
                    circle.memberIds = validMemberIds; 
                    await DBHelper.put('circles', circle);
                    UIManager.showToast("已自动移除圈子中不存在的好友。");
                }
                if(validMemberIds.length === 0) return null;

                
                const shuffled = validMemberIds.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedMemberIds = shuffled.slice(0, Math.min(numToSelect, validMemberIds.length));
                const selectedMembers = selectedMemberIds.map(id => allContacts.find(c => c.id === id));
                
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile };
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                const allGroups = await DBHelper.getAll('groups');

                
                const timeNow = new Date();
                const lastRefreshTime = new Date(circle.lastRefreshed || (Date.now() - 24*60*60*1000)); 
                const timePrompt = `现在是 ${timeNow.toLocaleString('zh-CN')}。上次生成动态的时间是 ${lastRefreshTime.toLocaleString('zh-CN')}。请确保本次生成的动态时间在此范围之内。`;

                const membersInfo = selectedMembers.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n背景: ${m.background || '无'}`).join('\n---\n');
                const playerInfo = `玩家名: ${myProfile.name}\n性别: ${myProfile.gender}\n背景: ${myProfile.background || '无'}`;
                const extraMembersInfo = circle.extraMembers ? `这个圈子还有一些其他朋友：${circle.extraMembers}。` : '';

                let contextHistory = '';
for (const member of selectedMembers) {
    
    const privateChatHistory = await DBHelper.getMessages(member.id, 10); 
    if (privateChatHistory && privateChatHistory.length > 0) {
        const turns = this.buildTurnsFromHistory(privateChatHistory, allContacts, myProfile);
        const lastTwoTurns = turns.slice(-2);
        if (lastTwoTurns.length > 0) {
            contextHistory += `与 ${member.name} 的最新私聊 (最多2轮):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
        }
    }
    
    
    const groupsWithMember = allGroups.filter(g => g.members.includes(member.id));
    for (const group of groupsWithMember) {
        const groupChatHistory = await DBHelper.getMessages(group.id, 10); 
        if (groupChatHistory && groupChatHistory.length > 0) {
            const turns = this.buildTurnsFromHistory(groupChatHistory, allContacts, myProfile);
            const lastTwoTurns = turns.slice(-2);
            if (lastTwoTurns.length > 0) {
                contextHistory += `在群聊 ${group.name} 中 ${member.name} 的相关动态 (最多2轮):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
            }
        }
    }
}
                const formatRules = `
---
朋友圈动态生成规则（非常重要！）：
1.  你将扮演 ${selectedMembers.map(m=>m.name).join('、')} 这几位角色，并为他们生成朋友圈动态。
2.  **严格按照以下格式，每条动态都必须被一个 <朋友圈> 标签包裹。**
3.  动态格式: 【作者角色名：动态内容|动态时间(月/日 HH:mm)】
4.  点赞格式(强制要求): 在动态格式之后，另起一行，用中文括号包裹点赞列表，格式为（已点赞：张三,李四,王五）。点赞者可以是圈内任何AI角色、额外好友”。
5.  评论格式: 〖评论者角色名：评论内容〗禁止在〖〗内嵌套〖〗
6.  你可以让角色互相评论，也可以让圈子里的额外好友（${circle.extraMembers || '无'}）参与评论。
7.  动态内容要符合角色人设，可以图文并茂（用文字描述图片），也可以只是纯文字。
8.  生成1到4条不等的动态，内容不能重复。
9.  作者和评论者的角色名必须是角色的名字（例如：${selectedMembers.map(m=>m.name).join(', ')}）、额外好友的名字。
10. **严禁OOC，严禁生成格式之外的内容，严禁代替玩家 (“${myProfile.name}”) 进行评论、回复或者点赞**。**禁止代替玩家 (“${myProfile.name}”) 进行评论、回复或点赞**
11.举例：
<朋友圈>
【33：今天天气真不错，有没有要一起出去玩的？|7/3 8:36】
（已点赞：vv,入入）
〖vv：带我一个！〗
〖入入：我也要去——〗
</朋友圈>
<朋友圈>
【vv：新手柄到手啦！|7/3 9:35】
（已点赞：三三,入入）
〖入入：好用吗？链接发我〗
</朋友圈>
---
`;
                
                const customPromptsSection = await this._getBoundPromptsForMoments(circle);

                const finalPrompt = [
                    timePrompt,
                    playerInfo,
                    `--- 圈子里的AI角色 ---\n${membersInfo}`,
                    extraMembersInfo,
                    `--- 最近的聊天记录参考 ---\n${contextHistory}`,
                    customPromptsSection,
                    formatRules
                ].join('\n\n');
                
                console.log("--- MOMENTS REFRESH PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async buildMomentsCommentPrompt(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                const circle = await DBHelper.get('circles', moment.circleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const allContacts = await DBHelper.getAll('contacts');
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile };
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                const allGroups = await DBHelper.getAll('groups'); 

                
                const momentAuthor = allContacts.find(c => c.id === moment.authorId);
                const circleMembers = allContacts.filter(c => circle.memberIds.includes(c.id));
                const otherMembers = circleMembers.filter(c => c.id !== moment.authorId);
                const shuffled = otherMembers.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedRandomMembers = shuffled.slice(0, Math.min(numToSelect, otherMembers.length));

                let membersToProvideInfo = [];
                if (momentAuthor) { 
                    membersToProvideInfo.push(momentAuthor);
                }
                membersToProvideInfo.push(...selectedRandomMembers);
                membersToProvideInfo = [...new Set(membersToProvideInfo)]; 

                const membersInfo = membersToProvideInfo.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n背景: ${m.background || '无'}`).join('\n---\n');
                
                
                let contextHistory = '';
                for (const member of membersToProvideInfo) {
                    const privateChat = await DBHelper.get('chats', member.id);
                    if (privateChat && privateChat.history.length > 0) {
                        const turns = this.buildTurnsFromHistory(privateChat.history, allContacts, myProfile);
                        const lastTwoTurns = turns.slice(-2);
                        if (lastTwoTurns.length > 0) {
                            contextHistory += `与 ${member.name} 的最新私聊 (最多2轮):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                        }
                    }
                    const groupsWithMember = allGroups.filter(g => g.members.includes(member.id));
                    for (const group of groupsWithMember) {
                        const groupChat = await DBHelper.get('chats', group.id);
                        if (groupChat && groupChat.history.length > 0) {
                            const turns = this.buildTurnsFromHistory(groupChat.history, allContacts, myProfile);
                            const lastTwoTurns = turns.slice(-2);
                            if (lastTwoTurns.length > 0) {
                                contextHistory += `在群聊 ${group.name} 中 ${member.name} 的相关动态 (最多2轮):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                            }
                        }
                    }
                }

                const postContentText = `玩家“${myProfile.name}”发布了一条动态：\n“${moment.content}”`;

                const privateChatRules = `
---
私聊规则:
1.  如果你想让某位角色私聊玩家，请使用 <私聊></私聊> 标签包裹私聊内容。只能私聊玩家，私聊其他角色的内容禁止使用<私聊>标签
2.  私聊内容格式可以是: [角色名|消息内容] 或 {角色名|撤回内容} 或 [角色名|语音|时长|内容] 或 [角色名|转账|收款人|金额|备注]
3.  例如: <私聊>[三三|你刚才发的动态是什么意思？]</私聊>
---
`;

                const formatRules = `
---
朋友圈评论生成规则：
1.  你将扮演圈子里的好友，对玩家的动态进行评论和点赞。
2.  点赞格式：用中文括号包裹点赞列表，格式为（已点赞：张三,李四,王五）。点赞者可以是圈内任何AI角色或额外好友。
3.  严格按照以下格式，每条评论都是一个独立的单元: 〖评论者角色名：评论内容〗，禁止在〖〗内嵌套〖〗。
4.  评论内容要符合角色人设，不超过20个字。
5.  **严禁OOC，严禁生成格式之外的内容，严禁代替玩家 (“${myProfile.name}”) 进行评论或回复**。**禁止代替玩家 (“${myProfile.name}”) 进行评论、回复或点赞**
6.  至少生成2条评论，最多生成5条评论。
7.  举例：
（已点赞：33,vv,入入）
〖33：这是什么，看起来很好吃的样子〗
〖入入：我也要吃www〗
---
`;
                const playerInfo = `--- 发布动态的玩家资料 ---\n玩家名: ${myProfile.name}\n性别: ${myProfile.gender}\n背景: ${myProfile.background || '无'}`;

                const customPromptsSection = await this._getBoundPromptsForMoments(circle, moment.content);

                const finalPrompt = [
                    postContentText,
                    playerInfo, 
                    `--- 参与评论的角色资料参考 ---\n${membersInfo}`,
                    `--- 最近的聊天记录参考 ---\n${contextHistory}`,
                    customPromptsSection,
                    privateChatRules,
                    formatRules
                ].join('\n\n');
                
                console.log("--- MOMENTS COMMENT PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async buildMomentsPlayerCommentPrompt(momentId, playerComment) {
                const moment = await DBHelper.get('moments', momentId);
                const circle = await DBHelper.get('circles', moment.circleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile };
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                const allContacts = await DBHelper.getAll('contacts');
                
                
                let membersToProvideInfo = [];
                const circleMembers = allContacts.filter(c => circle.memberIds.includes(c.id));
                
                
                const repliedToContact = playerComment.replyTo ? circleMembers.find(c => c.name === playerComment.replyTo) : null;
                if (repliedToContact) {
                    membersToProvideInfo.push(repliedToContact);
                }

                
                const otherMembers = circleMembers.filter(c => c.name !== playerComment.replyTo);
                const shuffled = otherMembers.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedRandomMembers = shuffled.slice(0, Math.min(numToSelect, otherMembers.length));
                membersToProvideInfo.push(...selectedRandomMembers);

                membersToProvideInfo = [...new Set(membersToProvideInfo)]; 

                const membersInfo = membersToProvideInfo.length > 0
                    ? membersToProvideInfo.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n背景: ${m.background || '无'}`).join('\n---\n')
                    : '无';

                
                let momentAuthor = moment.authorId === myProfile.id ? myProfile : allContacts.find(c => c.id === moment.authorId) || { name: moment.authorId };
                let postAndCommentsHistory = `这是“${momentAuthor.name}”发布的动态：“${moment.content}”\n目前的评论有：\n` + 
                    (moment.comments || []).map(c => {
                        const cAuthor = c.authorId === myProfile.id ? myProfile : allContacts.find(u => u.id === c.authorId) || { name: c.authorId };
                        return `“${cAuthor.name}${c.replyTo ? ` 回复 ${c.replyTo}` : ''}：${c.content}”`;
                    }).join('\n');
                
                const playerActionText = playerComment.replyTo 
                    ? `玩家“${myProfile.name}”回复了“${playerComment.replyTo}”说：“${playerComment.content}”` 
                    : `玩家“${myProfile.name}”评论说：“${playerComment.content}”`;

                const privateChatRules = `
---
私聊规则(可选):
1.  如果你想让某个角色私聊玩家，请使用 <私聊></私聊> 标签包裹。只能私聊玩家，私聊其他角色的内容禁止使用<私聊>标签
2.  私聊内容格式可以是: [角色名|消息内容] 或 {角色名|撤回内容} 或 [角色名|语音|时长|内容] 或 [角色名|转账|收款人|金额|备注]
3.  例如: <私聊>[33|你刚才发的动态是什么意思？]</私聊>
---
`;
                
                const formatRules = `
---
朋友圈评论生成规则：
1.  你将扮演圈内好友对玩家的评论做出回应。
2.  严格按照以下格式生成回复，可以只有点赞，或只有评论，或两者都有。
3.  点赞格式：用中文括号包裹点赞列表，格式为（已点赞：张三,李四）。
4.  评论格式: 〖评论者角色名：评论内容〗，禁止在〖〗内嵌套〖〗。
5.  评论内容要符合角色人设，可以是对玩家评论的直接回应，也可以是角色之间的互动。
6.  **严禁OOC，严禁生成格式之外的内容，严禁代替玩家 (“${myProfile.name}”) 进行评论、回复或点赞。**
---
`;
                
                const playerInfo = `--- 评论的玩家资料 ---\n玩家名: ${myProfile.name}\n性别: ${myProfile.gender}\n背景: ${myProfile.background || '无'}`;

                const customPromptsSection = await this._getBoundPromptsForMoments(circle, playerComment.content);

                const finalPrompt = [
                    `--- 动态与历史评论 ---\n${postAndCommentsHistory}`,
                    `--- 玩家最新动作 ---\n${playerActionText}`,
                    playerInfo, 
                    `--- 其他角色资料参考 ---\n${membersInfo}`,
                    customPromptsSection,
                    privateChatRules,
                    formatRules
                ].join('\n\n');

                console.log("--- MOMENTS PLAYER COMMENT PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async parseAndDisplayMomentsResponse(text) {
                const momentsListUl = $('#moments-list');
                const momentBlocks = text.match(/<朋友圈>[\s\S]*?<\/朋友圈>/g) || [];
                const allContacts = await DBHelper.getAll('contacts');
                const circle = await DBHelper.get('circles', appState.currentCircleId);
                
                
                const myProfile = await EventManager.getPlayerProfileForContext(appState.currentCircleId);

                if (momentBlocks.length > 0 && momentsListUl.innerHTML.includes('还没有动态')) {
                    momentsListUl.innerHTML = ''; 
                }

                for (const block of momentBlocks) {
                    const postMatch = block.match(/【(.*?)】/);
                    if (!postMatch) continue;

                    const [authorPart, timePart] = postMatch[1].split('|');
                    const [authorName, ...contentParts] = authorPart.split('：');
                    const content = contentParts.join('：');

                    const author = allContacts.find(c => c.name === authorName.trim());
                    
                    const likeMatch = block.match(/（已点赞：(.*?)）/);
                    let likerNames = likeMatch ? likeMatch[1].split(/,|，/).map(n => n.trim()) : [];
                    
                    likerNames = likerNames.filter(name => name !== myProfile.name);

                    const newMoment = {
                        id: Utils.generateId('moment'),
                        circleId: appState.currentCircleId,
                        authorId: author ? author.id : authorName.trim(),
                        content: content.trim(),
                        images: [], 
                        timestamp: Utils.parseMomentTimestamp(timePart ? timePart.trim() : null),
                        likes: likerNames, 
                        comments: []
                    };
                    
                    const commentMatches = block.match(/〖(.*?)〗/g) || [];
                    for (const cMatch of commentMatches) {
                        const inner = cMatch.slice(1, -1);
                        const [cAuthorName, ...cContentParts] = inner.split('：');
                        const trimmedAuthorName = cAuthorName.trim();
                        
                        
                        if (trimmedAuthorName === myProfile.name) {
                            continue;
                        }
                        
                        const cAuthor = allContacts.find(c => c.name === trimmedAuthorName);
                        const authorId = cAuthor ? cAuthor.id : trimmedAuthorName; 
                        
                        newMoment.comments.push({
                            authorId: authorId,
                            content: cContentParts.join('：').trim(),
                            timestamp: Date.now()
                        });
                    }

                    await DBHelper.put('moments', newMoment);
                    const momentElement = UIManager.createMomentElement(newMoment, myProfile, allContacts, circle.extraMembers);
                    momentsListUl.prepend(momentElement);
                }
            },
            async parseAndDisplayMomentsCommentsResponse(momentId, text) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return; 

                
                const privateChatRegex = /<私聊>([\s\S]*?)<\/私聊>/g;
                let privateMessageMatch;
                while ((privateMessageMatch = privateChatRegex.exec(text)) !== null) {
                    await this.handlePrivateMessageFromMoment(privateMessageMatch[1], moment);
                }
                const publicText = text.replace(privateChatRegex, '').trim();

                
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await EventManager.getPlayerProfileForContext(moment.circleId);
                const postElement = $(`[data-moment-id="${momentId}"]`);

                if (!postElement) return;

                const interactionsContainer = postElement.querySelector('.post-interactions');
                if (!interactionsContainer) return;
                interactionsContainer.style.display = 'block';

                const likeMatch = publicText.match(/（已点赞：(.*?)）/);
                if (likeMatch && likeMatch[1]) {
                    const likerNames = likeMatch[1].split(/,|，/).map(n => n.trim()).filter(Boolean);
                    if (!moment.likes) moment.likes = [];
                    likerNames.forEach(name => {
                        if (!moment.likes.includes(name)) moment.likes.push(name);
                    });
                    const likesContainer = interactionsContainer.querySelector('.post-likes');
                    if (likesContainer && moment.likes.length > 0) {
                        likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    }
                    const likeBtn = postElement.querySelector('[data-action="like"]');
                    if (likeBtn) {
                        likeBtn.classList.toggle('liked', moment.likes.includes(myProfile.name));
                    }
                }

                const commentMatches = publicText.match(/〖(.*?)〗/g) || [];
                const commentsListContainer = interactionsContainer.querySelector('.post-comments-list');
                if (!commentsListContainer) return;

                if (commentMatches.length === 0 && !likeMatch) {
                    if (likeMatch) await DBHelper.put('moments', moment);
                    return;
                }

                for (const cMatch of commentMatches) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                    const inner = cMatch.slice(1, -1);
                    const [cAuthorName, ...cContentParts] = inner.split('：');
                    const content = cContentParts.join('：').trim();
                    if (!content) continue;

                    const cAuthor = allContacts.find(c => c.name === cAuthorName.trim());
                    const authorId = cAuthor ? cAuthor.id : cAuthorName.trim();
                    
                    const newComment = { authorId, content, timestamp: Date.now() };
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push(newComment);
                    
                    let commentAuthorInfo;
                     if (authorId === myProfile.id) {
                        commentAuthorInfo = myProfile;
                    } else {
                        commentAuthorInfo = allContacts.find(c => c.id === authorId) || { name: authorId, id: authorId };
                    }
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'post-comment-item';
                    const authorStyle = commentAuthorInfo.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';
                    commentDiv.innerHTML = `<span class="comment-author" ${authorStyle}>${commentAuthorInfo.name}:</span> ${content}`;

                    commentsListContainer.appendChild(commentDiv);
                }

                await DBHelper.put('moments', moment);
            },

            async handlePrivateMessageFromMoment(privateContent, moment) {
                if (!moment || !moment.id) return; 

                
                const freshMoment = await DBHelper.get('moments', moment.id);
                if (!freshMoment) return; 
                

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await EventManager.getPlayerProfileForContext(freshMoment.circleId);
                
                const standardMatch = privateContent.match(/\[([^\[\]]+?)\]/);
                const retractedMatch = privateContent.match(/{([^{}]+?)}/);
                const emojiMatch = privateContent.match(/<([^>]+?)>/);

                let parts, senderName, sender;
                let match = standardMatch || retractedMatch || emojiMatch;
                if (!match) return;

                parts = match[1].split('|').map(p => p.trim());
                senderName = parts[0];
                sender = allContacts.find(c => c.name === senderName);
                if (!sender) return;

                
                const momentAuthor = (await EventManager.getMomentAuthor(freshMoment.authorId, freshMoment.circleId))?.name || '未知作者';
                let commentsText = '无';
                if (freshMoment.comments && freshMoment.comments.length > 0) {
                    commentsText = '\n' + freshMoment.comments.map(c => {
                        const cAuthor = c.authorId === myProfile.id ? myProfile : allContacts.find(u => u.id === c.authorId) || { name: c.authorId };
                        return `${cAuthor.name}${c.replyTo ? ` 回复 ${c.replyTo}` : ''}: ${c.content}`;
                    }).join('\n');
                }
                const contextContent = `<朋友圈动态>
动态发帖人：${momentAuthor}
动态内容：${freshMoment.content}
动态时间：${Utils.formatTimestampSmartly(freshMoment.timestamp)}
点赞情况：${(freshMoment.likes && freshMoment.likes.length > 0) ? freshMoment.likes.join(', ') : '无'}
评论区：${commentsText}
</朋友圈动态>`;

                const contextMessage = {
                    messageId: Utils.generateId('sys'),
                    chatId: sender.id,
                    timestamp: Date.now() - 1,
                    type: 'system',
                    segmentType: 'system',
                    content: contextContent,
                    isHidden: true,
                    forAi: true,
                };

                
                const visibleMessage = {
                    messageId: Utils.generateId('msg'),
                    chatId: sender.id,
                    senderId: sender.id,
                    timestamp: Date.now(),
                    type: 'received',
                    isUnread: appState.currentPage !== 'chat' || appState.currentChatId !== sender.id,
                    senderInfo: sender,
                };
                
                if (retractedMatch) {
                    visibleMessage.isRetracted = true;
                    visibleMessage.segmentType = 'text';
                    visibleMessage.content = parts[1];
                } else if (emojiMatch) {
                    visibleMessage.segmentType = 'emoji-image';
                    visibleMessage.content = parts[1];
                } else {
                    if (parts.length === 2) {
                        visibleMessage.segmentType = 'text';
                        visibleMessage.content = parts[1];
                    } else if (parts[1] === '语音') {
                        visibleMessage.segmentType = 'voice';
                        visibleMessage.content = `[语音] ${parts[3]}`;
                        visibleMessage.cardData = { duration: parts[2], content: parts[3] };
                    } else if (parts[1] === '转账') {
                        visibleMessage.segmentType = 'transfer';
                        visibleMessage.content = `[转账] ${parts[3]}`;
                        visibleMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false };
                    } else {
                        return;
                    }
                }
                
                
                await DBHelper.put('messages', contextMessage);
                await DBHelper.put('messages', visibleMessage);

                
                await UIManager.updateChatMetadata(sender.id, visibleMessage, 1);
                UIManager.showTopNotification(visibleMessage);
                UIManager.renderMessagesListPage(); 
            },

            async parseAndDisplayMomentsPlayerCommentResponse(momentId, text) {
                const moment = await DBHelper.get('moments', momentId);
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const postElement = $(`[data-moment-id="${momentId}"]`);

                if (!postElement) return;

                const interactionsContainer = postElement.querySelector('.post-interactions');
                interactionsContainer.style.display = 'block';

                
                const likeMatch = text.match(/（已点赞：(.*?)）/);
                if (likeMatch && likeMatch[1]) {
                    const newLikerNames = likeMatch[1].split(/,|，/).map(n => n.trim()).filter(Boolean);
                    
                    if (!moment.likes) moment.likes = [];
                    newLikerNames.forEach(name => {
                        if (!moment.likes.includes(name)) {
                            moment.likes.push(name);
                        }
                    });

                    const likesContainer = interactionsContainer.querySelector('.post-likes');
                    if (likesContainer && moment.likes.length > 0) {
                        likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    }
                }

                
                const commentMatches = text.match(/〖(.*?)〗/g) || [];
                const commentsListContainer = interactionsContainer.querySelector('.post-comments-list');
                
                if (commentMatches.length === 0 && !likeMatch) return;
                
                for (const cMatch of commentMatches) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));

                    const inner = cMatch.slice(1, -1);
                    const [cAuthorName, ...cContentParts] = inner.split('：');
                    const content = cContentParts.join('：').trim();
                    if (!content) continue;

                    const cAuthor = allContacts.find(c => c.name === cAuthorName.trim());
                    
                    const newComment = {
                        authorId: cAuthor ? cAuthor.id : cAuthorName.trim(),
                        content: content,
                        timestamp: Date.now()
                    };
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push(newComment);
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'post-comment-item';
                    commentDiv.dataset.authorName = cAuthor ? cAuthor.name : cAuthorName.trim();
                    commentDiv.dataset.authorId = newComment.authorId;
                    commentDiv.innerHTML = `<span class="comment-author">${cAuthor ? cAuthor.name : cAuthorName.trim()}:</span> ${content}`;
                    commentsListContainer.appendChild(commentDiv);
                }
                
                await DBHelper.put('moments', moment);
            },
            async getGiftApiResponse(prompt, signal) {
                let giftApiConfig = await DBHelper.get('giftApiConfig', 'mainConfig');
                
                if (!giftApiConfig || !giftApiConfig.key) {
                    throw new Error('礼物搜索API未配置，请先在礼物页面右上角设置。设置前阅读帮助内容，你也可以点击“使用主API配置”按钮来快速配置。\n如果不想配置API，可以选择自定义按钮，自定义自己想要赠送的礼物');
                }
                
                
                const { provider, url, key, model, temperature } = giftApiConfig;
                
                let apiUrl = url;
                let headers = { 'Content-Type': 'application/json' };
                let body;

                const messagesForApi = [{ role: 'user', content: prompt }];

                if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                    headers['Authorization'] = `Bearer ${key}`;
                    if (!apiUrl.endsWith('/chat/completions')) {
                        apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                    }
                    body = { model: model, messages: messagesForApi, temperature: temperature || 0.5 };
                } else if (provider === 'gemini') {
                    apiUrl += `${model}:generateContent?key=${key}`;
                    body = {
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        generationConfig: { temperature: temperature || 0.5 }
                    };
                } else {
                    throw new Error('不支持的API提供商。');
                }

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body),
                    signal: signal
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API请求失败: ${response.status} - ${errorData.error ? errorData.error.message : JSON.stringify(errorData)}`);
                }
                
                const data = await response.json();
                
                if (provider === 'gemini') {
                    if (data.candidates && data.candidates[0].content) {
                        return data.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error(`Gemini API未返回有效回复。`);
                    }
                } else {
                    if (data.choices && data.choices[0].message) {
                        return data.choices[0].message.content;
                    } else {
                        throw new Error(`API未返回有效回复。`);
                    }
                }
            },

            async handleGiftSearchRequest(keyword) {
                if (!keyword) return;

                const giftsGrid = $('#gifts-grid');
                const refreshBtn = $('#gift-search-refresh-btn');
                const sectionTitle = $('#gifts-section-title');
                const cancelBtn = $('#gift-cancel-search-btn');

                giftsGrid.innerHTML = '';

                const loader = document.createElement('div');
                loader.className = 'gift-loader';
                loader.style.display = 'block';
                loader.innerHTML = `
                    <div class="loader-spinner"></div>
                    <p>正在努力寻找礼物...</p>
                `;
                giftsGrid.appendChild(loader);

                refreshBtn.style.display = 'block';
                cancelBtn.style.display = 'inline-flex';
                sectionTitle.textContent = `“${keyword}”的搜索结果`;
                
                
                let customPrompt = '';
                try {
                    const giftApiConfig = await DBHelper.get('giftApiConfig', 'mainConfig');
                    if (giftApiConfig && giftApiConfig.giftPromptFolderIds && giftApiConfig.giftPromptFolderIds.length > 0) {
                        const allPrompts = await DBHelper.getAll('prompts');
                        const relevantPrompts = allPrompts
                            .filter(p => giftApiConfig.giftPromptFolderIds.includes(p.folderId) && p.isActive)
                            .map(p => p.content);
                        if (relevantPrompts.length > 0) {
                            customPrompt = `\n--- 附加风格要求 ---\n${relevantPrompts.join('\n\n')}\n---`;
                        }
                    }
                } catch(e) { console.error("获取礼物绑定提示词失败", e); }


                const prompt = `请你扮演一位专业的电商商品文案策划，为我推荐8个与关键词“${keyword}”同类或相关的创意礼物。
要求：
1. 礼物名称要生动有趣，可以包含虚构的品牌名或系列名。
2. 礼物简介要精炼且有吸引力，20字以内，突出礼物的特点或寓意。
3. 礼物图片必须是来自Unsplash, Pexels等免费图库的高质量URL。
4. 严格以JSON数组格式返回，不要有任何多余的文字或代码块标记。
5. 每个JSON对象必须包含四个键：
   - "url": 图片链接 (string)
   - "name": 礼物名称 (string)
   - "summary": 礼物简介 (string)
   - "price": 礼物价格 (number)${customPrompt}
`;
                try {
                    const response = await this.getGiftApiResponse(prompt, new AbortController().signal);
                    console.log("--- AI 礼物搜索 (原始) ---\n", response); 
                    
                    const jsonString = response.replace(/```json/g, '').replace(/```/g, '').trim();
                    const gifts = JSON.parse(jsonString);

                    giftsGrid.innerHTML = '';

                    if (Array.isArray(gifts) && gifts.length > 0) {
                        gifts.forEach(gift => {
                            const giftData = {
                                name: gift.name,
                                price: Number(gift.price) || 0,
                                image: gift.url,
                                message: gift.summary
                            };
                            const card = EventManager.createGiftCard(giftData);
                            card.onclick = () => EventManager.showSendGiftModal(giftData);
                            giftsGrid.appendChild(card);
                        });
                    } else {
                        giftsGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: #aaa;">没有找到相关的礼物，换个关键词试试？</p>';
                    }
                } catch (error) {
                    console.error("礼物搜索失败:", error);
                    giftsGrid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: #e74c3c;">搜索失败了...<br>${error.message}</p>`;
                }
            },
        };

        
        const EventManager = {

            async showAnnouncementModal(isFromTutorial = false) {
                const page1Content = `
                    <h4>为了33聊天室保持友好和谐的交流气氛，我们在这里作出以下提醒：</h4>
                    <p>1. 聊天室内具有自定义角色功能，角色卡并非强制购买。</p>
                    <p>2. 请尊重原创，不要使用其他老师未授权的角色设定或其他设定。如果因使用未授权内容引发侵权问题，后果需自行承担。</p>
                    <p>3. 请大家尊重所有人的产出，不要在任何公开平台上将33聊天室与其他ai聊天工具进行拉踩、比较。</p>
                    <p>4. 禁止直接外传网址或外传带有33聊天室网址的截图，否则过多非购买33聊天器的访客访问网址，将导致网址失效，所有人的记录全都会被清除。我们将不予负责，请各自维护好自身权益。</p>
                    <p><strong>在这里诚挚地祝愿各位在聊天室玩得开心。</strong></p>
                `;

                const page2Content = `
                    <h4>聊天室授权老师ID</h4>
                    <div class="announcement-auth-list">
                        <span>盐汽水Vio.</span><span>VV</span><span>DD要努力</span>
                        <span>灯灯</span><span>假发卫衣</span><span>魔王咕叽</span>
                        <span>小甜Sweettt</span><span>九系萌</span><span>莓莓の24h</span>
                        <span>喻禧の文游</span><span>云朵の</span><span>云朵朵</span>
                        <span>原如</span><span>是短短</span><span>美味厨房ai</span>
                        <span>初月月月月</span>
                    </div>
                    <p class="announcement-warning">如果你是从其他途径获取，说明对方是倒卖/二传的，我们抵制盗用二贩行为，且不承担售后解答义务。</p>
                `;

                const modalBody = `
                    <div id="announcement-page-1" class="announcement-page active">${page1Content}</div>
                    <div id="announcement-page-2" class="announcement-page">${page2Content}</div>
                    <div class="announcement-nav">
                        <button id="announcement-prev-btn" class="modal-btn btn-secondary nav-btn" style="visibility: hidden;">上一页</button>
                        <span class="page-indicator">1 / 2</span>
                        <button id="announcement-next-btn" class="modal-btn btn-secondary nav-btn">下一页</button>
                    </div>
                `;

                UIManager.showModal({
                    title: "重要提醒",
                    customClass: 'announcement-modal-content',
                    body: modalBody,
                    actions: [
                        { text: '已阅读', class: 'btn-primary', id: 'announcement-close-btn' }
                    ]
                });
                
                const pages = $$('.announcement-page');
                const prevBtn = $('#announcement-prev-btn');
                const nextBtn = $('#announcement-next-btn');
                const pageIndicator = $('.page-indicator');
                const closeBtn = $('#announcement-close-btn');
                let currentPage = 0;

                const updateNav = () => {
                    pages.forEach((page, index) => page.classList.toggle('active', index === currentPage));
                    prevBtn.style.visibility = currentPage === 0 ? 'hidden' : 'visible';
                    nextBtn.style.visibility = currentPage === pages.length - 1 ? 'hidden' : 'visible';
                    pageIndicator.textContent = `${currentPage + 1} / ${pages.length}`;
                };

                prevBtn.onclick = () => {
                    if (currentPage > 0) {
                        currentPage--;
                        updateNav();
                        
                        closeBtn.disabled = true;
                    }
                };
                nextBtn.onclick = () => {
                    if (currentPage < pages.length - 1) {
                        currentPage++;
                        updateNav();
                        
                        if (currentPage === pages.length - 1) {
                            closeBtn.disabled = false;
                        }
                    }
                };
                
                closeBtn.onclick = async () => {
                    UIManager.hideModal();
                    const config = await DBHelper.get('apiConfig', 'mainConfig') || {id: 'mainConfig'};
                    config.announcementReadV1 = true;
                    await DBHelper.put('apiConfig', config);
                };

                
                if (!isFromTutorial) {
                    nextBtn.disabled = true;
                    closeBtn.disabled = true;
                    let countdown = 3;
                    nextBtn.textContent = `下一页 (${countdown}s)`;
                    const interval = setInterval(() => {
                        countdown--;
                        if (countdown > 0) {
                            nextBtn.textContent = `下一页 (${countdown}s)`;
                        } else {
                            clearInterval(interval);
                            nextBtn.disabled = false;
                            nextBtn.textContent = '下一页';
                        }
                    }, 1000);
                } else {
                    
                    closeBtn.disabled = true;
                }
            },

            _scopeCSS(css, prefix) {
                if (!css || !prefix) return '';
                
                let scopedCss = '';
                let depth = 0;
                let buffer = '';
                let selectors = [];

                for (let i = 0; i < css.length; i++) {
                    const char = css[i];
                    buffer += char;

                    if (char === '{') {
                        if (depth === 0) {
                            const selectorPart = buffer.slice(0, -1).trim();
                            selectors = selectorPart.split(',').map(s => s.trim());
                            buffer = '{';
                        }
                        depth++;
                    } else if (char === '}') {
                        depth--;
                        if (depth === 0) {
                            const prefixedSelectors = selectors.map(s => {
                                if (s.startsWith('@')) return s; 
                                return `${prefix} ${s}`;
                            }).join(', ');
                            scopedCss += `${prefixedSelectors} ${buffer}\n`;
                            buffer = '';
                            selectors = [];
                        }
                    }
                }
                return scopedCss;
            },

            async setupEmojiMaps() {
                const profile = await DBHelper.get('profile', 'myProfile');
                appState.customEmojis = profile.customEmojis || {};

                appState.aiEmojiMap = { ...BUILTIN_AI_EMOJIS };

                appState.playerEmojiMap = { ...BUILTIN_PLAYER_EMOJIS };
                for (const [id, data] of Object.entries(appState.customEmojis)) {
                    appState.playerEmojiMap[id] = data.name;
                }
            },

            BUILTIN_CHARACTERS: {
                '旁白001': {
                    id: '旁白001',
                    remark: '旁白',
                    avatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj48cmVjdCB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNMTYuMSA1LjJjLTEuNyAyLjUtMy44IDQuOC02LjIgNi43LTIuNCAxLjktNS4xIDMuMy03LjkgNC4xLjQgMi4xIDEuMyA0LjEgMi43IDUuOCAxLjQgMS',
                    gender: '其他',
                    likes: '描述场景、补充设定、推动剧情',
                    previewDesc: '推动剧情、描述场景。需要添加到群聊内使用。',
                    dislikes: '被当成普通角色对话',
                    habits: '在关键时刻出现',
                    background: '请严格使用 <旁白>旁白内容</旁白> 的格式进行回复，用于描述场景、补充设定或推动剧情。'
                }
            },
            _syncColorInputs(colorPickerId, hexInputId) {
                const colorPicker = $(`#${colorPickerId}`);
                const hexInput = $(`#${hexInputId}`);

                if (!colorPicker || !hexInput) return;

                const updateHex = () => {
                    hexInput.value = colorPicker.value.toUpperCase();
                };

                const updatePicker = () => {
                    let value = hexInput.value.trim();
                    if (/^#?([0-9A-F]{6}|[0-9A-F]{3})$/i.test(value)) {
                         if (!value.startsWith('#')) {
                            value = '#' + value;
                        }
                        colorPicker.value = value;
                        
                        colorPicker.dispatchEvent(new Event('input', { bubbles: true }));
                    } else {
                        
                        hexInput.value = colorPicker.value.toUpperCase();
                    }
                };

                colorPicker.addEventListener('input', updateHex);
                hexInput.addEventListener('change', updatePicker);
            },
            init() {
                
                bottomNav.addEventListener('click', (e) => {
                    const navItem = e.target.closest('.nav-item');
                    if (navItem) UIManager.navigateTo(navItem.dataset.page);
                });

                
                $('#nav-to-moments').addEventListener('click', () => UIManager.navigateTo('moments', 'discover'));

                $('#nav-to-pomodoro').addEventListener('click', () => UIManager.navigateTo('pomodoro', 'discover'));
                
                $('#moments-back-btn').addEventListener('click', () => UIManager.navigateTo('discover'));
                $('#moments-refresh-btn').addEventListener('click', () => AIHandler.handleMomentsRefreshRequest());
                $('#moments-new-post-btn').addEventListener('click', () => this.handleNewMoment());
                $('#moments-manage-btn').addEventListener('click', () => UIManager.showCircleManagementSidebar());
                $('#moments-list').addEventListener('click', (e) => {
                    const postElement = e.target.closest('.moments-post');
                    if (!postElement) return;

                    const momentId = postElement.dataset.momentId;
                    const actionBtn = e.target.closest('[data-action]');
                    const commentItem = e.target.closest('.post-comment-item');

                    
                    if (actionBtn) {
                        const action = actionBtn.dataset.action;

                        if (action === 'toggle-comment') {
                            this.toggleCommentInput(postElement);
                        } else if (action === 'submit-comment') {
                            this.handlePlayerComment(momentId);
                        } else if (action === 'like') {
                            this.handlePlayerLike(momentId);
                        } else if (action === 'forward') {
                            this.handleForwardMoment(momentId);
                        } else if (action === 'delete-moment') {
                            this.confirmDeleteMoment(momentId, postElement);
                        }
                        return; 
                    }
                    
                    
                    if (commentItem) {
                        const authorName = commentItem.dataset.authorName;
                        this.toggleCommentInput(postElement, authorName);
                    }
                });

                $('#moments-list').addEventListener('mousedown', e => this.handleMomentCommentInteractionStart(e, 'mouse'));
                $('#moments-list').addEventListener('keypress', async (e) => {
                    
                    if (!e.target.matches('.comment-input-wrapper input') || e.key !== 'Enter' || e.shiftKey) {
                        return;
                    }

                    
                    e.preventDefault();

                    
                    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                    if (chatSettings.enterToSend) {
                        const momentId = e.target.closest('.moments-post').dataset.momentId;
                        if (momentId) {
                            this.handlePlayerComment(momentId);
                        }
                    }
                });

                $('#moments-list').addEventListener('touchstart', e => this.handleMomentCommentInteractionStart(e, 'touch'));
                
                $('#page-forwarded-history').addEventListener('click', async (e) => {
                    const unclickableBubble = e.target.closest('.transfer-or-red-packet-bubble, .gift-bubble, .forwarded-moment-bubble, .forwarded-history-bubble');
                    if (unclickableBubble) {
                        UIManager.showToast('当前状态无法查看');
                        return;
                    }

                    const voiceBubble = e.target.closest('.voice-message-bubble');
                    if (voiceBubble) {
                        const wrapper = voiceBubble.closest('.bubble-and-tag-wrapper');
                        const transcript = wrapper.querySelector('.voice-transcript');
                        if (transcript) transcript.classList.toggle('show');
                        return;
                    }

                    const cardWrapper = e.target.closest('.card-message-wrapper');
                    if (cardWrapper) {
                        const messageRow = cardWrapper.closest('.message-row');
                        if (!messageRow) return;
                        const cardId = `card-detail-${messageRow.dataset.messageId}`;
                        const detailElement = document.getElementById(cardId);
                        if (detailElement) detailElement.classList.toggle('visible');
                        return;
                    }
                });

                
                
                $('#gift-btn').addEventListener('click', () => UIManager.navigateTo('gifts', 'chat'));
                $('#gifts-back-btn').addEventListener('click', () => UIManager.navigateTo('chat'));
                $('#custom-gift-btn').addEventListener('click', () => this.showCustomGiftModal());
                $('#gift-api-config-btn').addEventListener('click', () => this.showGiftApiConfigModal());
                $('#gift-search-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        AIHandler.handleGiftSearchRequest(e.target.value);
                    }
                });
                $('#gift-search-refresh-btn').addEventListener('click', () => {
                    const keyword = $('#gift-search-input').value.trim();
                    if(keyword) AIHandler.handleGiftSearchRequest(keyword);
                });
                $('#gift-cancel-search-btn').addEventListener('click', async () => {
                    $('#gift-search-input').value = '';
                    $('#gift-search-refresh-btn').style.display = 'none';
                    $('#gift-cancel-search-btn').style.display = 'none';
                    await UIManager.renderGiftsPage();
                });
                $('#gift-bind-prompt-btn').addEventListener('click', () => this.handleGiftPromptBinding());
                $('#gift-help-btn').addEventListener('click', () => this.showGiftHelpModal());
                $('#my-avatar').addEventListener('click', () => this.handleEditProfile());
                $('#batch-delete-btn').addEventListener('click', () => this.handleBatchDelete());
                $('#select-all-btn').addEventListener('click', () => this.handleSelectAll());
                $('#cancel-selection-btn').addEventListener('click', () => this.handleBatchDelete());
                $('#delete-selected-btn').addEventListener('click', () => this.handleConfirmBatchDelete());
                $('#add-menu-btn').addEventListener('click', () => this.showAddMenu());
                $$('.tab-btn').forEach(btn => btn.addEventListener('click', () => UIManager.renderContactsPage(btn.dataset.tab)));
                $('#sort-friends-btn').addEventListener('click', () => this.handleSortContacts());
                $('#sort-groups-btn').addEventListener('click', () => this.handleSortGroups());
                $('#chat-settings-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#save-chat-settings-btn').onclick = () => this.handleSaveChatSettings();
                $('#setting-chat').addEventListener('click', async () => {
                    await UIManager.navigateTo('chat-settings', 'settings');
                    await this.renderChatSettingsPage();
                });
                $('#setting-api').addEventListener('click', () => UIManager.navigateTo('api-settings', 'settings'));
                $('#setting-prompts').addEventListener('click', () => UIManager.navigateTo('prompts', 'settings'));
                $('#setting-theme').addEventListener('click', () => UIManager.navigateTo('theme-settings', 'settings'));
                $('#setting-bubble').addEventListener('click', () => UIManager.navigateTo('bubble-settings', 'settings'));
                $('#setting-data-management').addEventListener('click', () => this.showDataManagementModal());
                $('#setting-reset').addEventListener('click', () => this.handleResetApp());
                $('#setting-wish-pool').addEventListener('click', () => this.handleWishPool());

                $('#pomodoro-back-btn').addEventListener('click', () => UIManager.navigateTo('discover'));
                $('#pomodoro-start-btn').addEventListener('click', () => this.startPomodoro());
                $('#pomodoro-stop-btn').addEventListener('click', () => this.stopPomodoro());
                $('#pomodoro-float-ball').addEventListener('click', () => {
                    
                    if ($('#pomodoro-float-ball').isDragging) {
                        $('#pomodoro-float-ball').isDragging = false; 
                        return;
                    }
                    UIManager.navigateTo('pomodoro');
                });
                
                
                const setupPomodoroDrag = () => {
                    const floatBall = $('#pomodoro-float-ball');
                    let isDragging = false;
                    let initialY;
                    let initialBottom;
                    let hasMoved = false;

                    const onDragStart = (e) => {
                        if (e.target.closest('.time-left') || e.target.closest('.progress-ring')) {
                            isDragging = true;
                            hasMoved = false;
                            floatBall.isDragging = false; 
                            floatBall.classList.add('dragging');

                            initialY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                            initialBottom = parseInt(window.getComputedStyle(floatBall).bottom, 10);
                            
                            
                            e.preventDefault();

                            document.addEventListener('mousemove', onDragMove);
                            document.addEventListener('touchmove', onDragMove, { passive: false });
                            document.addEventListener('mouseup', onDragEnd);
                            document.addEventListener('touchend', onDragEnd);
                        }
                    };

                    const onDragMove = (e) => {
                        if (!isDragging) return;

                        e.preventDefault();
                        hasMoved = true;
                        floatBall.isDragging = true;

                        const currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                        const deltaY = currentY - initialY;
                        let newBottom = initialBottom - deltaY;

                        
                        const maxHeight = window.innerHeight - floatBall.offsetHeight - 20; 
                        const minHeight = 80; 
                        newBottom = Math.max(minHeight, Math.min(newBottom, maxHeight));
                        
                        floatBall.style.bottom = `${newBottom}px`;
                    };

                    const onDragEnd = () => {
                        isDragging = false;
                        floatBall.classList.remove('dragging');
                        
                        document.removeEventListener('mousemove', onDragMove);
                        document.removeEventListener('touchmove', onDragMove);
                        document.removeEventListener('mouseup', onDragEnd);
                        document.removeEventListener('touchend', onDragEnd);
                        
                        
                        if (!hasMoved) {
                            setTimeout(() => { floatBall.isDragging = false; }, 10);
                        }
                    };

                    floatBall.addEventListener('mousedown', onDragStart);
                    floatBall.addEventListener('touchstart', onDragStart, { passive: false });
                };
                setupPomodoroDrag();
                
                
                const messageListUl = $('#message-list-ul');
                let messageListLongPressTimer = null;
                messageListUl.addEventListener('mousedown', (e) => handleInteractionStart(e, 'mouse'));
                messageListUl.addEventListener('touchstart', (e) => handleInteractionStart(e, 'touch'), { passive: true });

                function handleInteractionStart(e, type) {
                    const item = e.target.closest('.message-item');
                    if (!item) return;

                    clearTimeout(messageListLongPressTimer);
                    messageListLongPressTimer = setTimeout(() => {
                        UIManager.showMessageListOptions(item);
                    }, 500);

                    function clearLongPress() {
                        clearTimeout(messageListLongPressTimer);
                        document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                        document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                    }
                    document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                }
                
                $('#setting-tutorial').addEventListener('click', () => UIManager.navigateTo('tutorial', 'settings'));
                
                
                $('#tutorial-back-btn').addEventListener('click', () => UIManager.navigateTo('settings'));
                $('#page-tutorial .page-content').addEventListener('click', (e) => {
                    const item = e.target.closest('.setting-item');
                    if (!item) return;

                    const showTutorialModal = (title, body) => {
                        UIManager.showModal({
                            title: title,
                            body: `<div style="line-height: 1.7; font-size: 0.95rem;">${body}</div>`,
                            actions: [{ text: '我明白了', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                        });
                    };

                    switch (item.id) {
                        case 'setting-announcement':
                            this.showAnnouncementModal(true);
                            break;
                        case 'tutorial-api':
                            showTutorialModal('如何配置API', `
                                <p>聊天室需要你提供一个AI服务商的API Key才能运行。</p>
                                <p>1. 进入 <strong>设置 > API配置</strong> 页面。</p>
                                <p>2. 从“API提供商”下拉框中选择你拥有的服务商。如Gemini(谷歌官方), SiliconFlow(硅基流动)等。</p>
                                <p>3. 系统会自动填充大部分服务商的默认URL和模型，你只需在 <strong>API Key</strong> 输入框中填入你的密钥即可。</p>
                                <p>4. 如果你使用自定义或未列出的服务商，请选择“自定义”并手动填写所有字段。</p>
                                <p>5. 如果你是<strong>自己购入的Gemini模型</strong>，请选择“自定义”并手动填写所有字段。所有需要填入的字段可询问你的api卖家</p>
                                <p><strong>提示：</strong>API Key非常重要，请妥善保管，不要泄露。</p>
                            `);
                            break;
                        case 'tutorial-character':
                            showTutorialModal('如何创建新角色', `
                                <p>角色是与你聊天的好友。</p>
                                <p>1. 进入 <strong>通讯录</strong> 页面。</p>
                                <p>2. 点击右上角的 <strong>+</strong> 号按钮。</p>
                                <p>3. 在弹出的菜单中选择 <strong>添加新好友</strong>。</p>
                                <p>4. 填写角色的各项信息。<strong>姓名</strong>是角色的唯一ID，不可重复。其他信息如喜好、背景按需要填写。</p>
                                <p>5. 点击“添加”即可完成创建。</p>
                                <p>6. 点击<strong>通讯录</strong>页面的好友可进入聊天界面</p>
                            `);
                            break;
                        case 'tutorial-group':
                            showTutorialModal('如何创建群聊', `
                                <p>你可以创建包含多个好友角色的群聊。</p>
                                <p>1. 同样在 <strong>通讯录</strong> 页面，点击右上角 <strong>+</strong> 号并选择 <strong>新建群聊</strong>。</p>
                                <p>2. 为群聊起一个名字，并从好友列表中勾选要加入群聊的好友角色（至少一位）。</p>
                                <p>3. 你还可以指定一位群主，群主可以是你自己或任何一位好友角色。</p>
                                <p>4. 创建成功后，你就可以在群聊中与多个好友同时互动了。</p>
                            `);
                            break;
                        case 'tutorial-chatting':
                            showTutorialModal('如何进行聊天', `
                                <p><strong>1. 发送与回复：</strong></p>
                                <p>在聊天输入框（右下角）输入并发送你的所有消息后，点击左下角的 <strong>羽毛按钮 <i class="fas fa-feather-alt"></i></strong> 来让AI进行回复。</p>
                                <p><strong>2. 重新生成：</strong></p>
                                <p>如果你对AI的最新回复不满意，可以点击你自己的头像，AI会撤销刚才的回复并重新生成一次。</p>
                                <p><strong>3. 查看内心：</strong></p>
                                <p>想知道好友在想什么吗？点击好友的头像，可以看到TA最近的“心声”和“随笔”。</p>
                                <p><strong>4. 更多操作：</strong></p>
                                <p>长按任意一条消息气泡，可以进行“引用”、“删除”或“撤回”（仅自己发的消息）操作。</p>
                            `);
                            break;
                        case 'tutorial-opening-scene':
                            showTutorialModal('开场白是什么？', `
                                <p>开场白是一个<strong>预设的对话场景</strong>，用于快速开启一段特定情境的对话，而无需从零开始引导。</p>
                                <p><strong>如何添加与应用：</strong></p>
                                <p>1. 在好友或群聊的聊天界面，点击右上角的菜单按钮(<i class="fas fa-ellipsis-v"></i> 或 <i class="fas fa-ellipsis-h"></i>)进入管理界面。</p>
                                <p>2. 选择 <strong>开场白设定</strong>，你可以在这里新建、编辑或删除多个开场白方案。</p>
                                <p>3. 在开场白列表中点击 <strong>应用</strong> 按钮后，<strong>当前聊天记录会被清空</strong>，然后好友/群聊会根据你设定的开场白内容，自动开始一段新的对话。</p>
                                <p><strong>提示：</strong>这是一个非常适合快速测试角色设定或开启新剧情的功能。</p>
                            `);
                            break;
                        case 'tutorial-prompts':
                            showTutorialModal('提示词是什么？', `
                                <p>提示词（Prompt）是用来指导AI如何回应的特殊指令，能极大地影响角色的性格、说话风格和行为逻辑。</p>
                                <p><strong>功能与绑定：</strong></p>
                                <p>你可以在 <strong>设置 > 自定义提示词</strong> 页面创建和管理提示词。提示词可以绑定给单个好友、群聊、甚至朋友圈（影响动态生成），让好友在不同场景下遵循不同的规则。</p>
                                <p>点击<strong>聊天界面/朋友圈界面右上角</strong>的管理按钮，选择<strong>绑定提示词</strong></p>
                                <p><strong>提示词类型：</strong></p>
                                <p>  - <strong>显性(Explicit):</strong> 这种提示词<strong>总是</strong>会被激活，非常适合定义角色的核心性格、世界观或必须遵守的规则。</p>
                                <p>  - <strong>隐性(Implicit):</strong> 只有当你的发言中包含预设的<strong>关键词</strong>时，这种提示词才会被激活。适合设定一些特定情境下的反应，如“当玩家提到‘下雨’时，角色会表现出悲伤”。</p>
                                <p><strong>导入与导出：</strong></p>
                                <p>在提示词管理页面，你可以将写好的提示词文件夹导出为<code>.json</code>文件，用于备份或分享给他人。同样，也可以导入他人分享的提示词文件。</p>
                                <p><strong>注意（Token消耗）：</strong></p>
                                <p>提示词内容越长、绑定的提示词越多，每次与好友交互时消耗的Token就越多，并降低响应速度。请根据需要自行取舍。</p>
                            `);
                            break;
                        case 'tutorial-import-export':
                             showTutorialModal('如何导入导出', `
                                <p>你可以方便地分享或备份你的角色与群聊数据。</p>
                                <p><strong>导出：</strong></p>
                                <p>1. 在通讯录点击好友或群聊的详情按钮，或在聊天页面点击右上角菜单进入管理页面。</p>
                                <p>2. 点击“导出角色/群聊”按钮，会生成一个 <code>.json</code> 格式的配置文件，保存到本地即可。</p>
                                <p><strong>导入：</strong></p>
                                <p>1. 在通讯录页面，点击右上角 <strong>+</strong> 号，选择 <strong>导入角色/群聊</strong>。</p>
                                <p>2. 选择你之前导出的 <code>.json</code> 文件，系统会自动识别并导入。</p>
                                <p>导入前确保导入的文件是支持这个聊天室使用的。</p>
                                <p><strong>提示：</strong>如果导入的角色名与现有角色冲突，系统会提示你选择“更新”或“覆盖”。</p>
                            `);
                            break;
                        case 'tutorial-emoji':
                            showTutorialModal('如何新增/删除表情包', `
                                <p>你可以添加和管理自己的专属表情包。</p>
                                <p>1. 在任意聊天界面，点击输入框下方的 <strong>收藏表情 <i class="fas fa-star"></i></strong> 按钮，打开收藏表情面板。</p>
                                <p>2. 点击面板左上角的 <strong><i class="fas fa-plus"></i></strong> 按钮，可以<strong>新增</strong>自定义表情。你需要提供表情图片的URL链接和表情的文字描述（这个描述会告诉AI表情的含义）。</p>
                                <p>3. 点击 <strong><i class="fas fa-minus"></i></strong> 按钮，可以<strong>删除</strong>你添加过的自定义表情。</p>
                                <p><strong>提示：</strong>在普通表情包面板，你也可以点击每个表情右上角的星星 <i class="fas fa-star"></i> 来收藏或取消收藏内置表情。</p>
                            `);
                            break;
                        case 'tutorial-persona':
                            showTutorialModal('玩家人设及绑定', `
                                <p>你可以创建多套“你”的人设，并在不同聊天中切换，让AI根据不同的人设与你互动。</p>
                                <p><strong>1. 创建/管理预设：</strong></p>
                                <p>  - 在 <strong>消息</strong> 页面，点击左上角你自己的头像，会滑出“我的信息”侧边栏。</p>
                                <p>  - 在这里编辑你的姓名、性别、背景等信息，这就是你<strong>当前使用</strong>的人设。</p>
                                <p>  - 点击下方的 <strong>读取/保存/删除</strong> 按钮，可以管理你的人设<strong>预设</strong>。你可以将当前的人设保存为一个新的预设，或读取一个已有的预设来替换当前人设。</p>
                                <p><strong>2. 绑定人设：</strong></p>
                                <p>  - <strong>绑定</strong>的作用是将某个特定的人设预设<strong>固定</strong>给一个聊天对象或场景。</p>
                                <p>  - 你可以在以下地方进行绑定：</p>
                                <p>    • <strong>私聊/群聊：</strong>聊天界面右上角菜单 > 绑定玩家人设。</p>
                                <p>    • <strong>好友分组：</strong>通讯录 > 分组 > 对应分组右上角菜单 > 绑定玩家人设 (会对此分组下所有未单独绑定的好友生效)。</p>
                                <p>    • <strong>朋友圈：</strong>发现 > 朋友圈 > 右上角菜单 > 修改当前圈子 > 绑定玩家人设。</p>
                                <p><strong>重要：</strong>如果一个聊天对象没有绑定任何特定人设，AI将默认使用你在“我的信息”侧边栏中<strong>当前正在使用</strong>的人设与你对话。</p>
                            `);
                            break;
                        case 'tutorial-narrator':
                             showTutorialModal('旁白如何使用', `
                                <p>“旁白”功能允许你设定一个“故事的讲述者”来描述场景、补充设定或推动剧情。</p>
                                <p><strong>使用方法：</strong></p>
                                <p>通讯录新增内置角色选择旁白，将旁白添加进入群聊内。或者自行创建一个旁白角色，固定它使用 <code>&lt;旁白&gt;...&lt;/旁白&gt;</code> 的格式来发送旁白消息。</p>
                                <p>当然，你也可以自己输入旁白消息格式，来作为那个剧情的推动者。</p>
                                <p><strong>示例：</strong></p>
                                <p><code>&lt;旁白&gt;窗外下起了淅淅沥沥的小雨，房间里的气氛有些沉闷。&lt;/旁白&gt;</code></p>
                            `);
                            break;
                        case 'tutorial-moments':
                            showTutorialModal('朋友圈如何使用', `
                                <p>朋友圈是一个模拟社交动态的趣味功能。</p>
                                <p>1. 进入 <strong>发现 > 朋友圈</strong>。首次进入需要点击右上角菜单按钮，先创建一个“圈子”。</p>
                                <p>2. 点击右上角菜单按钮可以 <strong>管理圈子</strong>（增删改查、切换）。</p>
                                <p>3. 点击相机图标可以 <strong>发布你自己的动态</strong>。</p>
                                <p>4. 点击刷新按钮，好友会根据已有设定，<strong>自动生成新的朋友圈动态</strong>。</p>
                                <p>5. 你可以像真实社交软件一样，对动态进行点赞、评论和转发。</p>
                            `);
                            break;
                        case 'tutorial-theme':
                            showTutorialModal('如何设置主题', `
                                <p>你可以高度自定义应用的外观。</p>
                                <p>1. 进入 <strong>设置 > 主题设置</strong>。</p>
                                <p>2. 在这里，你可以更改<strong>弹窗风格</strong>、<strong>聊天气泡样式</strong>、<strong>字体大小</strong>和<strong>颜色</strong>。</p>
                                <p>3. 点击 <strong>通用设置 > 背景与封面</strong>，可以上传你喜欢的图片作为全局页面背景、全局聊天背景，好友/群聊聊天界面右上角可设置专属聊天背景。支持自定义红包和转账的封面图。</p>
                                <p>4. <strong>字体设置</strong>你可以加载可免费使用的或已购买的本地字体文件/网络字体资源</p>
                            `);
                            break;
                    }
                });
                
                
                chatBackBtn.addEventListener('click', async () => {
                    if (appState.selectionMode.active) {
                        UIManager.showToast('请先取消多选模式');
                        return;
                    }
                    const chatId = appState.currentChatId;
                    if (chatId) {
                        const chatData = await DBHelper.get('chats', chatId);
                        if (chatData && chatData.history) {
                            let madeChanges = false;
                            chatData.history.forEach(msg => {
                                if (msg.isUnread) {
                                    msg.isUnread = false;
                                    madeChanges = true;
                                }
                            });
                            if (madeChanges) {
                                await DBHelper.put('chats', chatData);
                            }
                        }
                    }
                    this.resetQuoteState();
                    UIManager.navigateTo('messages');
                });
                $('#chat-manage-btn').addEventListener('click', () => {
                    const chatId = appState.currentChatId;
                    if (!chatId) return;
                    if (chatId.startsWith('group-')) this.handleOpenGroupManagementSidebar(chatId);
                    else this.handleOpenFriendManagementSidebar(chatId);
                });
                $('#chat-insight-btn').addEventListener('click', () => {
                    const chatId = appState.currentChatId;
                    if (!chatId) return;
                    
                    if (chatId.startsWith('group-')) {
                        UIManager.showGroupInsightModal(chatId);
                    } else {
                        UIManager.showPersonaModal(chatId);
                    }
                });
                 sendBtn.addEventListener('click', () => this.handlePlayerSendMessage());
                messageInput.addEventListener('keypress', async (e) => {
                    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                    if (chatSettings.enterToSend && e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handlePlayerSendMessage();
                    }
                });
                aiRequestBtn.addEventListener('click', () => {
                    if (AIHandler.isAwaitingResponse) AIHandler.cancelAiRequest();
                    else AIHandler.handleAiReplyRequest();
                });
                messageInput.addEventListener('input', () => {
                    messageInput.style.height = 'auto';
                    messageInput.style.height = (messageInput.scrollHeight) + 'px';
                });

                
                appContainer.addEventListener('click', (e) => this.handleClickEffect(e));
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay && !modalOverlay.classList.contains('no-overlay-close')) UIManager.hideModal();
                });
                $('#sidebar-overlay').addEventListener('click', (e) => {
                    if (e.target === $('#sidebar-overlay')) UIManager.hideSidebar();
                });

                $('#bottom-sheet-overlay').addEventListener('click', (e) => {
                    if (e.target === $('#bottom-sheet-overlay')) UIManager.hideBottomSheet();
                });

                
                emojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    favoriteEmojiCard.classList.remove('active'); 
                    emojiCard.classList.toggle('active');
                });

                favoriteEmojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    emojiCard.classList.remove('active'); 
                    favoriteEmojiCard.classList.toggle('active');
                    if (favoriteEmojiCard.classList.contains('active')) {
                        this.renderFavoriteEmojiPage();
                    }
                });

                $('#simulated-image-btn').addEventListener('click', () => this.handleSimulatedImageSend());
                $('#image-vision-btn').addEventListener('click', () => this.handleVisionImageSend());
                $('#card-btn').addEventListener('click', () => this.handlePlayerCardSend());
                $('#delete-last-turn-btn').addEventListener('click', () => this.handleDeleteLastTurn());
                $('#edit-last-reply-btn').addEventListener('click', () => this.handleEditLastReply());
                voiceBtn.addEventListener('click', () => this.handleVoiceInput());
                $('#transfer-btn').addEventListener('click', () => this.handlePlayerTransfer());
                $('#red-packet-btn').addEventListener('click', () => this.handlePlayerRedPacket());
                document.addEventListener('click', (e) => {
                    if (!chatInputArea.contains(e.target)) {
                        emojiCard.classList.remove('active');
                        favoriteEmojiCard.classList.remove('active');
                    }
                });
                $('#emoji-prev-btn').addEventListener('click', () => { appState.emojiCurrentPage--; this.renderEmojiPage(); });
                $('#emoji-next-btn').addEventListener('click', () => { appState.emojiCurrentPage++; this.renderEmojiPage(); });
                $('#favorite-emoji-prev-btn').addEventListener('click', () => {
                    const slotsOnFirstPage = appState.emojisPerPage - 3;
                    const slotsOnOtherPages = appState.emojisPerPage;
                    let pageCount = 1;
                    if (appState.favoriteEmojis.length > slotsOnFirstPage) {
                        pageCount = 1 + Math.ceil((appState.favoriteEmojis.length - slotsOnFirstPage) / slotsOnOtherPages);
                    }
                    
                    appState.favoriteEmojiCurrentPage--;
                    if (appState.favoriteEmojiCurrentPage < 0) {
                        appState.favoriteEmojiCurrentPage = pageCount - 1;
                    }
                    this.renderFavoriteEmojiPage();
                });
                $('#favorite-emoji-next-btn').addEventListener('click', () => {
                    const slotsOnFirstPage = appState.emojisPerPage - 3;
                    const slotsOnOtherPages = appState.emojisPerPage;
                    let pageCount = 1;
                    if (appState.favoriteEmojis.length > slotsOnFirstPage) {
                        pageCount = 1 + Math.ceil((appState.favoriteEmojis.length - slotsOnFirstPage) / slotsOnOtherPages);
                    }

                    appState.favoriteEmojiCurrentPage++;
                    if (appState.favoriteEmojiCurrentPage >= pageCount) {
                        appState.favoriteEmojiCurrentPage = 0;
                    }
                    this.renderFavoriteEmojiPage();
                });
                
                chatArea.addEventListener('mousedown', (e) => this.handleInteractionStart(e, 'mouse'));
                chatArea.addEventListener('touchstart', (e) => this.handleInteractionStart(e, 'touch'));
                cancelQuoteBtn.addEventListener('click', () => this.resetQuoteState());
                $('#forwarded-history-back-btn').addEventListener('click', () => UIManager.navigateTo('chat'));
                $('#cancel-forward-btn').addEventListener('click', () => this.toggleSelectionMode());
                $('#delete-selected-messages-btn').addEventListener('click', () => this.handleDeleteSelectedMessages());
                $('#confirm-forward-btn').addEventListener('click', () => this.showForwardTargetModal());

                chatArea.addEventListener('click', async (e) => {
                    
                    if (appState.selectionMode.active) {
                        const messageElement = e.target.closest('[data-message-id]');
                        if (messageElement) {
                            const checkbox = messageElement.querySelector('.message-select-checkbox');
                            if (checkbox && e.target !== checkbox) {
                                checkbox.checked = !checkbox.checked;
                            }
                            
                            this.handleMessageSelection({ target: checkbox });
                        }
                        return; 
                    }

                    const messageRow = e.target.closest('.message-row');
                    if (!messageRow) return;
                    const messageId = messageRow.dataset.messageId;
                    const voiceBubble = e.target.closest('.voice-message-bubble');
                    if (voiceBubble) {
                        const wrapper = voiceBubble.closest('.bubble-and-tag-wrapper');
                        const transcript = wrapper.querySelector('.voice-transcript');
                        if (transcript) transcript.classList.toggle('show');
                        return;
                    }
                    const cardWrapper = e.target.closest('.card-message-wrapper');
                    if (cardWrapper) {
                        const cardId = cardWrapper.dataset.cardId;
                        if (!cardId) return;
                        const detailElement = document.getElementById(cardId);
                        if (detailElement) detailElement.classList.toggle('visible');
                        return;
                    }
                    const specialBubble = e.target.closest('.transfer-or-red-packet-bubble');
                    if (specialBubble) {
                        const msg = await DBHelper.get('messages', messageId);
                        if (!msg) return;
                        if (msg.segmentType === 'transfer' && !msg.cardData.isClaimed) {
                            this.handleTransferClick(msg);
                        } else if (msg.segmentType === 'red-packet' && !msg.cardData.isClaimedByPlayer) {
                            this.handleRedPacketClick(msg);
                        }
                        return; 
                    }

                    
                    const customForwardCard = e.target.closest('[data-type="custom-forward"]');
                    if (customForwardCard) {
                        const messageId = customForwardCard.closest('.message-row').dataset.messageId;
                        if (messageId) {
                            this.showCustomForwardDetail(messageId);
                        }
                        return;
                    }
                    
                    const forwardedMomentCard = e.target.closest('.forwarded-moment-card-content');
                    if (forwardedMomentCard) {
                        const momentId = forwardedMomentCard.dataset.momentId;
                        if (momentId) {
                            this.showForwardedMomentDetail(momentId);
                        }
                        return; 
                    }
                    const giftBubble = e.target.closest('.gift-bubble');
                    if (giftBubble) {
                        this.showGiftDetailsModal(messageId);
                        return;
                    }
                    const forwardedHistoryBubble = e.target.closest('.forwarded-history-bubble');
                    if (forwardedHistoryBubble) {
                        this.openForwardedHistoryPage(messageId);
                        return;
                    }
                });
                chatArea.addEventListener('scroll', () => {
                    if (chatArea.scrollTop < 50 && !appState.isHistoryLoading) {
                        UIManager.loadMoreMessages();
                    }
                });

                const momentsBg = $('#moments-bg');
                const momentsBgInput = $('#moments-bg-input');

                momentsBg.addEventListener('click', () => {
                    momentsBgInput.click();
                });

                momentsBgInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file || !appState.currentCircleId) return;

                    try {
                        const compressedImage = await Utils.compressImage(file, 1000, 1000, 0.8);
                        const circle = await DBHelper.get('circles', appState.currentCircleId);
                        if (circle) {
                            circle.backgroundImage = compressedImage;
                            await DBHelper.put('circles', circle);
                            momentsBg.src = compressedImage;
                            UIManager.showToast('背景已更换！');
                        }
                    } catch (error) {
                        console.error("更换背景失败：", error);
                        UIManager.showToast('图片处理失败，请重试');
                    }
                });
            },

            async getPlayerProfileForContext(contextId) {
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                if (!contextId) {
                    return baseProfile;
                }

                let boundId = null;

                if (contextId.startsWith('group-')) { 
                    const group = await DBHelper.get('groups', contextId);
                    boundId = group?.boundPersonaPresetId;
                } else if (contextId.startsWith('contact')) { 
                    const contact = await DBHelper.get('contacts', contextId);
                    if (contact) {
                        if (contact.boundPersonaPresetId) {
                            boundId = contact.boundPersonaPresetId;
                        } else if (contact.folderId) {
                            const folder = await DBHelper.get('friendFolders', contact.folderId);
                            boundId = folder?.boundPersonaPresetId;
                        }
                    }
                } else if (contextId.startsWith('circle')) {
                    const circle = await DBHelper.get('circles', contextId);
                    boundId = circle?.boundPersonaPresetId;
                }

                if (boundId && baseProfile.presets && Array.isArray(baseProfile.presets)) {
                    const boundProfile = baseProfile.presets.find(p => p && p.presetId === boundId);
                    if (boundProfile) {
                        
                        return { ...baseProfile, ...boundProfile };
                    }
                }

                
                return baseProfile;
            },

            async handlePatRequest(patteeId) {
                if (appState.selectionMode.active) return; //
                const chatId = appState.currentChatId;
                if (!chatId) return;

                const patter = await this.getPlayerProfileForContext(chatId);
                const pattee = patteeId === 'myProfile' ? patter : await DBHelper.get('contacts', patteeId);
                
                if (!patter || !pattee) return;

                const patAction = pattee.patAction || '拍了拍';
                const patContent = pattee.patContent || '';

                const displayText = `${patter.name} ${patAction} ${pattee.name}${patContent ? ` ${patContent}` : ''}`;

                const message = {
                    messageId: Utils.generateId('msg'),
                    senderId: patter.id, 
                    content: { 
                        patterName: patter.name,
                        patteeName: pattee.name,
                        action: patAction,
                        content: patContent,
                        displayText: displayText
                    },
                    type: 'sent', 
                    segmentType: 'pat_a_pat',
                };
                
                await this.handlePlayerSendMessage(message);
            },

        async handlePlayerSendMessage(prebuiltMessage = null) {
            const content = messageInput.value.trim();
            if (!prebuiltMessage && (!content || !appState.currentChatId)) return;

            let message;
            const profile = await this.getPlayerProfileForContext(appState.currentChatId);
            const allMessages = await DBHelper.getMessages(appState.currentChatId, 1, Date.now());
            const lastMessage = allMessages.pop();

            const now = Date.now();
            
            if (lastMessage && (now - lastMessage.timestamp > 5 * 60 * 1000)) {
                const timeDivider = UIManager.createTimeDividerElement(now);
                chatArea.appendChild(timeDivider);
            }

            if (prebuiltMessage) {
                message = prebuiltMessage;
                message.timestamp = now; 
            } else if (appState.quotingMessage) {
                
                const quotedMsg = appState.quotingMessage;
                let senderName = '对方'; 

                if (quotedMsg.type === 'sent') {
                    
                    const profile = await this.getPlayerProfileForContext(appState.currentChatId);
                    senderName = profile.name;
                } else {
                    
                    const contact = await DBHelper.get('contacts', quotedMsg.senderId);
                    senderName = contact ? (contact.remark || contact.name) : '对方';
                }

                let quotedContentText;
                switch (quotedMsg.segmentType) {
                    case 'text':
                        quotedContentText = quotedMsg.content;
                        break;
                    case 'card':
                        quotedContentText = `[卡片消息] ${quotedMsg.cardData.title}`;
                        break;
                    case 'image_vision':
                        quotedContentText = '[图片]';
                        break;
                    case 'quote':
                        quotedContentText = quotedMsg.cardData.newContent;
                        break;
                    case 'voice':
                        quotedContentText = '[语音]';
                        break;
                    case 'emoji-image':
                        const emojiId = quotedMsg.content;
                        const emojiDesc = appState.playerEmojiMap[emojiId] || '未知表情';
                        quotedContentText = `[表情] ${emojiDesc}`;
                        break;
                    case 'image_simulated':
                        quotedContentText = '[图片]';
                        break;
                    default:
                        quotedContentText = '[消息]';
                        break;
                }

                message = {
                    messageId: Utils.generateId('msg'),
                    content: `[引用] ${content}`,
                    timestamp: now,
                    type: 'sent',
                    segmentType: 'quote',
                    cardData: {
                        quotedName: senderName,
                        quotedContent: quotedContentText,
                        newContent: content
                    }
                };
                this.resetQuoteState();
            } else {
                const narratorRegex = /^<旁白>([\s\S]*)<\/旁白>$/;
                const narratorMatch = content.match(narratorRegex);

                if (narratorMatch) {
                    message = {
                        messageId: Utils.generateId('msg'),
                        content: narratorMatch[1].trim(),
                        timestamp: now,
                        type: 'sent',
                        segmentType: 'narrator',
                    };
                } else {
                    message = {
                        messageId: Utils.generateId('msg'),
                        content,
                        timestamp: now,
                        type: 'sent',
                        isRetracted: false,
                        isUnread: false,
                        segmentType: 'text',
                    };
                }
            }
            
            message.chatId = appState.currentChatId;
            await DBHelper.put('messages', message);
            await UIManager.updateChatMetadata(appState.currentChatId, message);
            
            const chatMetadata = await DBHelper.get('chatMetadata', appState.currentChatId) || { chatId: appState.currentChatId, turnCountSinceLastPrompt: 0, totalPlayerTurns: 0 };
chatMetadata.turnCountSinceLastPrompt = (chatMetadata.turnCountSinceLastPrompt || 0) + 1;
chatMetadata.totalPlayerTurns = (chatMetadata.totalPlayerTurns || 0) + 1;
await DBHelper.put('chatMetadata', chatMetadata);

UIManager.addMessageToDOM(message, profile, false, true);


const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
const summaryInterval = chatSettings.summaryMessageInterval || 200;

const isGroup = appState.currentChatId.startsWith('group-');
const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);

if (entity && entity.autoSummaryEnabled && summaryInterval > 0 && appState.currentChat.totalMessages > 0 && appState.currentChat.totalMessages % summaryInterval === 0) {
    console.log(`达到第 ${appState.currentChat.totalMessages} 条消息，触发自动总结。`);
    setTimeout(() => AIHandler.handleAutoSummaryRequest(appState.currentChatId), 0);
}
            
            
            if (!prebuiltMessage) {
                messageInput.value = '';
                messageInput.style.height = 'auto';
                messageInput.focus();
            }
        },
            
            
            
            async renderEmojiPage() {
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                const useBuiltin = chatSettings.useBuiltinEmojis !== false; 

                let emojiEntries;

                if (useBuiltin) {
                    
                    emojiEntries = Object.entries(appState.playerEmojiMap);
                } else {
                    
                    
                    emojiEntries = Object.entries(appState.customEmojis).map(([id, data]) => [id, data.name]);
                }
                
                const pageCount = Math.ceil(emojiEntries.length / appState.emojisPerPage);

                if (appState.emojiCurrentPage < 0) appState.emojiCurrentPage = pageCount - 1;
                if (appState.emojiCurrentPage >= pageCount) appState.emojiCurrentPage = 0;
                
                const pageIndex = appState.emojiCurrentPage;
                const start = pageIndex * appState.emojisPerPage;
                const end = start + appState.emojisPerPage;
                const pageEmojis = emojiEntries.slice(start, end);

                emojiGrid.innerHTML = '';
                pageEmojis.forEach(([id, desc]) => {
                    const item = document.createElement('div');
                    item.className = 'emoji-item';
                    item.dataset.emojiId = id;
                    item.title = desc;
                    
                    let emojiSrc;
                    if (id.startsWith('custom-')) {
                        emojiSrc = appState.customEmojis[id]?.url || '';
                    } else {
                        emojiSrc = `https://z.wiki/u/${id}`;
                    }
                    
                    const isFavorite = appState.favoriteEmojis.includes(id);

                    item.innerHTML = `
                        <img src="${emojiSrc}" alt="${desc}">
                        <div class="favorite-emoji-toggle ${isFavorite ? 'is-favorite' : ''}" title="收藏">
                            <i class="fas fa-star"></i>
                        </div>
                    `;
                    
                    const imgEl = item.querySelector('img');
                    imgEl.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const message = {
                            messageId: Utils.generateId('msg'),
                            content: id,
                            timestamp: Date.now(), 
                            type: 'sent',
                            segmentType: 'emoji-image',
                        };
                        
                        await EventManager.handlePlayerSendMessage(message);
                        emojiCard.classList.remove('active');
                    });

                    const favToggle = item.querySelector('.favorite-emoji-toggle');
                    favToggle.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const emojiId = item.dataset.emojiId;
                        const index = appState.favoriteEmojis.indexOf(emojiId);
                        
                        if (index > -1) {
                            appState.favoriteEmojis.splice(index, 1);
                            favToggle.classList.remove('is-favorite');
                        } else {
                            appState.favoriteEmojis.push(emojiId);
                            favToggle.classList.add('is-favorite');
                        }
                        
                        const profile = await DBHelper.get('profile', 'myProfile');
                        profile.favoriteEmojis = appState.favoriteEmojis;
                        await DBHelper.put('profile', profile);
                    });
                    
                    emojiGrid.appendChild(item);
                });
                
                $('#emoji-page-indicator').textContent = `${pageIndex + 1} / ${pageCount}`;
            },

            renderFavoriteEmojiPage() {
                favoriteEmojiGrid.innerHTML = '';
                const favNav = $('#favorite-emoji-card .emoji-nav');
                const favoriteEmojis = appState.favoriteEmojis;
                const pageIndex = appState.favoriteEmojiCurrentPage;

                const slotsOnFirstPage = appState.emojisPerPage - 3;
                const slotsOnOtherPages = appState.emojisPerPage;

                if (pageIndex === 0) {
                    const extractBtn = document.createElement('div');
                    extractBtn.className = 'emoji-item-add';
                    extractBtn.innerHTML = '<i class="fas fa-paw"></i>';
                    extractBtn.title = '提取自定义表情包ID';
                    extractBtn.onclick = () => EventManager.showEmojiIdExtractionModal();
                    favoriteEmojiGrid.appendChild(extractBtn);

                    const addEmojiBtn = document.createElement('div');
                    addEmojiBtn.className = 'emoji-item-add';
                    addEmojiBtn.innerHTML = '<i class="fas fa-plus"></i>';
                    addEmojiBtn.title = '添加自定义表情';
                    addEmojiBtn.onclick = () => this.showAddCustomEmojiModal();
                    favoriteEmojiGrid.appendChild(addEmojiBtn);

                    const deleteEmojiBtn = document.createElement('div');
                    deleteEmojiBtn.className = 'emoji-item-add';
                    deleteEmojiBtn.innerHTML = '<i class="fas fa-minus"></i>';
                    deleteEmojiBtn.title = '删除自定义表情';
                    deleteEmojiBtn.onclick = () => this.showDeleteCustomEmojiModal();
                    favoriteEmojiGrid.appendChild(deleteEmojiBtn);
                }

                let pageCount = 1;
                if (favoriteEmojis.length > slotsOnFirstPage) {
                    pageCount = 1 + Math.ceil((favoriteEmojis.length - slotsOnFirstPage) / slotsOnOtherPages);
                }

                favNav.style.display = pageCount > 1 ? 'flex' : 'none';
                if (favoriteEmojis.length === 0) return;

                if (appState.favoriteEmojiCurrentPage < 0) appState.favoriteEmojiCurrentPage = 0;
                if (appState.favoriteEmojiCurrentPage >= pageCount) appState.favoriteEmojiCurrentPage = pageCount - 1;

                let start, end;
                if (pageIndex === 0) {
                    start = 0;
                    end = slotsOnFirstPage;
                } else {
                    start = slotsOnFirstPage + (pageIndex - 1) * slotsOnOtherPages;
                    end = start + slotsOnOtherPages;
                }
                const pageEmojis = favoriteEmojis.slice(start, end);

                pageEmojis.forEach(id => {
                    const desc = appState.playerEmojiMap[id] || '已收藏表情';
                    const emojiItem = document.createElement('div');
                    emojiItem.className = 'emoji-item';
                    emojiItem.dataset.emojiId = id;
                    emojiItem.title = desc;

                    let emojiSrc;
                    if (id.startsWith('custom-')) {
                        emojiSrc = appState.customEmojis[id]?.url || '';
                    } else {
                        emojiSrc = `https://z.wiki/u/${id}`;
                    }

                    emojiItem.innerHTML = `<img src="${emojiSrc}" alt="${desc}" style="width: 60px; height: 60px;">`;
                    
                    let longPressTimer;
                    let isLongPress = false;
                    
                    const startLongPress = (e) => {
                        isLongPress = false; 
                        longPressTimer = setTimeout(() => {
                            isLongPress = true;
                            UIManager.showModal({
                                title: "取消收藏",
                                body: `<p>要将这个表情移出收藏吗？</p>`,
                                actions: [
                                    { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: '确定', class: 'btn-danger', handler: async () => {
                                        const index = appState.favoriteEmojis.indexOf(id);
                                        if (index > -1) {
                                            appState.favoriteEmojis.splice(index, 1);
                                            const profile = await DBHelper.get('profile', 'myProfile');
                                            profile.favoriteEmojis = appState.favoriteEmojis;
                                            await DBHelper.put('profile', profile);
                                            this.renderFavoriteEmojiPage();
                                            UIManager.showToast("已取消收藏");
                                        }
                                        UIManager.hideModal();
                                    }}
                                ]
                            });
                        }, 500);
                    };

                    const cancelLongPress = () => clearTimeout(longPressTimer);
                    
                    const handleClick = async (e) => {
                        if (isLongPress) return;
                        await this.handlePlayerSendMessage({
                            messageId: Utils.generateId('msg'),
                            content: id,
                            type: 'sent',
                            segmentType: 'emoji-image',
                        });
                        favoriteEmojiCard.classList.remove('active');
                    };

                    emojiItem.addEventListener('mousedown', startLongPress);
                    emojiItem.addEventListener('touchstart', startLongPress, { passive: true });
                    emojiItem.addEventListener('mouseup', cancelLongPress);
                    emojiItem.addEventListener('mouseleave', cancelLongPress);
                    emojiItem.addEventListener('touchend', cancelLongPress);
                    emojiItem.addEventListener('touchcancel', cancelLongPress);
                    emojiItem.addEventListener('click', handleClick);

                    favoriteEmojiGrid.appendChild(emojiItem);
                });

                if (pageCount > 1) {
                    $('#favorite-emoji-page-indicator').textContent = `${pageIndex + 1} / ${pageCount}`;
                }
            },

            async showBatchAddEmojiResultModal(addedEmojis) {
                let formattedText = '额外表情包:\n';
                addedEmojis.forEach(emoji => {
                    formattedText += `${emoji.id}:${emoji.name}\n`;
                });

                UIManager.showModal({
                    title: `成功添加 ${addedEmojis.length} 个表情包`,
                    body: `
                        <style>
                            #emoji-id-display {
                                width: 100%;
                                max-height: 200px;
                                overflow-y: auto;
                                font-family: monospace;
                                white-space: pre-wrap;
                                word-break: break-all;
                                user-select: text;
                                -webkit-user-select: text;
                                background-color: var(--text-color-white);
                                border: 1px solid var(--border-color);
                                border-radius: 8px;
                                padding: 10px;
                                font-size: 0.9rem;
                                color: var(--text-color-dark);
                                box-sizing: border-box;
                            }
                        </style>
                        <p>以下是新添加的表情包及其ID，可用于提示词中：</p>
                        <pre id="emoji-id-display">${formattedText}</pre>
                    `,
                    actions: [
                        { text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '复制', class: 'btn-primary', id: 'copy-emoji-ids-btn' }
                    ]
                });

                const copyButton = $('#copy-emoji-ids-btn');
                if (copyButton) {
                    copyButton.addEventListener('click', async () => {
                        const textToCopy = $('#emoji-id-display').textContent;
                        
                        const copyTextFallback = (text) => {
                            const textArea = document.createElement("textarea");
                            textArea.value = text;
                            textArea.style.position = "fixed";
                            textArea.style.top = "-9999px";
                            textArea.style.left = "-9999px";
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            try {
                                const successful = document.execCommand('copy');
                                if (successful) {
                                    UIManager.showToast("已成功复制到剪贴板！");
                                } else {
                                    UIManager.showToast("复制失败，请手动复制");
                                }
                            } catch (err) {
                                console.error('使用 execCommand 复制失败: ', err);
                                UIManager.showToast("复制失败，请手动复制");
                            }
                            document.body.removeChild(textArea);
                        };

                        if (navigator.clipboard && window.isSecureContext) {
                            try {
                                await navigator.clipboard.writeText(textToCopy);
                                UIManager.showToast("已成功复制到剪贴板！");
                            } catch (err) {
                                console.error('使用 navigator.clipboard 复制失败，将尝试备用方法: ', err);
                                copyTextFallback(textToCopy);
                            }
                        } else {
                            console.log("当前环境不安全或不支持 Clipboard API，使用备用方法。");
                            copyTextFallback(textToCopy);
                        }
                    });
                }
            },

            async showAddCustomEmojiModal() {
                UIManager.showModal({
                    title: "添加自定义表情",
                    body: `
                        <div class="creation-mode-tabs" style="margin-bottom: 20px;">
                            <button class="mode-btn active" data-mode="single">单个添加</button>
                            <button class="mode-btn" data-mode="batch">批量添加</button>
                        </div>

                        <div id="add-emoji-single-panel">
                            <div class="form-group">
                                <label for="custom-emoji-url">表情包链接 (URL)</label>
                                <input type="text" id="custom-emoji-url" placeholder="请粘贴图片的URL">
                            </div>
                            <div class="form-group">
                                <label for="custom-emoji-name">表情包名称/描述</label>
                                <input type="text" id="custom-emoji-name" placeholder="例如：可爱猫猫摇尾巴">
                            </div>
                            <p style="font-size:0.8rem; color:#aaa;">表情包可以是静态图片/动态图片，表情包名称将用于AI理解表情含义，请准确填写含义。</p>
                        </div>

                        <div id="add-emoji-batch-panel" style="display: none;">
                            <div class="form-group">
                                <label for="batch-emoji-input">批量添加表情包</label>
                                <textarea id="batch-emoji-input" rows="8" placeholder="请按格式输入，每个表情包占一行：\n表情包名称：表情包链接\n可爱猫猫：https://.../cat.gif"></textarea>
                            </div>
                            <p style="font-size:0.8rem; color:#aaa;">名称与链接之间请使用中文冒号“：”隔开。不符合格式的行将被自动忽略。</p>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '添加', class: 'btn-primary', handler: async () => {
                            const isBatchMode = $('#add-emoji-batch-panel').style.display !== 'none';
                            const profile = await DBHelper.get('profile', 'myProfile');
                            if (!profile.customEmojis) profile.customEmojis = {};
                            
                            if (isBatchMode) {
                                const batchInput = $('#batch-emoji-input').value.trim();
                                if (!batchInput) return UIManager.showToast("批量输入内容不能为空。");

                                const lines = batchInput.split('\n');
                                const addedEmojis = [];
                                let successCount = 0;

                                for (const line of lines) {
                                    const parts = line.split('：');
                                    if (parts.length < 2) continue;

                                    const name = parts[0].trim();
                                    const url = parts.slice(1).join('：').trim();

                                    if (name && url && url.startsWith('http')) {
                                        const emojiId = Utils.generateId('custom-');
                                        profile.customEmojis[emojiId] = { url, name };
                                        
                                        appState.customEmojis[emojiId] = { url, name };
                                        appState.playerEmojiMap[emojiId] = name;
                                        appState.aiEmojiMap[emojiId] = name;
                                        
                                        addedEmojis.push({ id: emojiId, name: name });
                                        successCount++;
                                    }
                                }

                                if (successCount > 0) {
                                    await DBHelper.put('profile', profile);
                                    UIManager.hideModal();
                                    this.showBatchAddEmojiResultModal(addedEmojis);
                                    this.renderFavoriteEmojiPage();
                                } else {
                                    UIManager.showToast("没有找到任何符合格式的有效表情包。");
                                }
                            } else {
                                const url = $('#custom-emoji-url').value.trim();
                                const name = $('#custom-emoji-name').value.trim();

                                if (!url || !name) return UIManager.showToast("链接和名称都不能为空。");
                                if (!url.startsWith('http')) return UIManager.showToast("请输入一个有效的URL。");

                                const emojiId = Utils.generateId('custom-');
                                profile.customEmojis[emojiId] = { url, name };
                                await DBHelper.put('profile', profile);

                                appState.customEmojis[emojiId] = { url, name };
                                appState.playerEmojiMap[emojiId] = name;
                                appState.aiEmojiMap[emojiId] = name;

                                UIManager.hideModal();
                                UIManager.showToast("自定义表情添加成功！");
                                
                                if (!appState.favoriteEmojis.includes(emojiId)) {
                                    appState.favoriteEmojis.push(emojiId);
                                    profile.favoriteEmojis = appState.favoriteEmojis;
                                    await DBHelper.put('profile', profile);
                                }
                                this.renderFavoriteEmojiPage();
                            }
                        }}
                    ]
                });

                const singlePanel = $('#add-emoji-single-panel');
                const batchPanel = $('#add-emoji-batch-panel');
                $$('.creation-mode-tabs .mode-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        $$('.creation-mode-tabs .mode-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        const isBatch = e.target.dataset.mode === 'batch';
                        singlePanel.style.display = isBatch ? 'none' : 'block';
                        batchPanel.style.display = isBatch ? 'block' : 'none';
                    };
                });
            },


            async showDeleteCustomEmojiModal() {
                const customEmojis = appState.customEmojis;
                if (Object.keys(customEmojis).length === 0) {
                    return UIManager.showToast("没有可删除的自定义表情");
                }

                const emojiListHtml = Object.entries(customEmojis).map(([id, data]) => `
                    <label class="member-select-item">
                        <input type="checkbox" name="delete-custom-emoji" value="${id}">
                        <img src="${data.url}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${data.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "删除自定义表情",
                    body: `
                        <button id="select-all-emojis-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 8px;">全选</button>
                        <div class="member-select-list" style="max-height: 40vh;">${emojiListHtml}</div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除选中', class: 'btn-danger', handler: async () => {
                            const checkedEmojis = $$('input[name="delete-custom-emoji"]:checked');
                            if (checkedEmojis.length === 0) {
                                return UIManager.showToast("请选择要删除的表情");
                            }
                            const idsToDelete = Array.from(checkedEmojis).map(cb => cb.value);

                            const profile = await DBHelper.get('profile', 'myProfile');
                            if (!profile.customEmojis) profile.customEmojis = {};
                            if (!profile.favoriteEmojis) profile.favoriteEmojis = [];

                            idsToDelete.forEach(id => {
                                delete profile.customEmojis[id];
                                const favIndexDB = profile.favoriteEmojis.indexOf(id);
                                if (favIndexDB > -1) profile.favoriteEmojis.splice(favIndexDB, 1);
                                
                                const favIndexApp = appState.favoriteEmojis.indexOf(id);
                                if (favIndexApp > -1) appState.favoriteEmojis.splice(favIndexApp, 1);
                            });
                            
                            await DBHelper.put('profile', profile);
                            await this.setupEmojiMaps();
                            this.renderFavoriteEmojiPage();

                            UIManager.hideModal();
                            UIManager.showToast("选中的表情已删除");
                        }}
                    ]
                });

                $('#select-all-emojis-btn').addEventListener('click', () => {
                    $$('input[name="delete-custom-emoji"]').forEach(cb => cb.checked = true);
                });
            },

        async initEmojiPanel() {
            this.renderEmojiPage(); 
        },

        handleVoiceInput() {
            UIManager.showModal({
                isPersistent: true, 
                customClass: 'modal-neumorphic',
                title: "发送语音",
                body: `
                    <div class="form-group">
                        <label for="modal-voice-text-input">语音内容 (文本)</label>
                        <textarea id="modal-voice-text-input" rows="4" placeholder="输入语音消息内容..."></textarea>
                    </div>
                `,
                actions: [
                    { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                    { text: '发送', class: 'btn-primary', handler: async () => {
                        const text = $('#modal-voice-text-input').value.trim();
                        if (!text) return;

                        let duration = Math.max(1, Math.ceil(text.length / 4));
                        duration = Math.min(duration, 60); 

                        const profile = await DBHelper.get('profile', 'myProfile');
                        const message = {
                            messageId: Utils.generateId('msg'),
                            content: `[语音] ${text}`,
                            timestamp: Date.now(),
                            type: 'sent',
                            segmentType: 'voice',
                            cardData: {
                                duration: `${duration}s`,
                                content: text
                            }
                        };
                        
                        await this.handlePlayerSendMessage(message);
                        UIManager.hideModal();
                    }}
                ]
            });
            setTimeout(() => $('#modal-voice-text-input').focus(), 100);
        },           

            async handlePlayerTransfer() {
                const isGroup = appState.currentChatId.startsWith('group-');
                let recipientHtml;
                let recipientName; 

                if (isGroup) {
                    
                    recipientHtml = `
                        <div class="form-group">
                            <label>转账给</label>
                            <div id="transfer-recipient-display" class="form-group" style="padding: 12px 15px; cursor: pointer; background: #F0F0F3; border-radius: 12px; box-shadow: inset -5px -5px 9px rgba(255,255,255,0.7), inset 5px 5px 9px rgba(174,174,192,0.2);">
                                <span style="color: #888;">请选择收款人</span>
                            </div>
                        </div>
                    `;
                } else {
                    
                    const contact = await DBHelper.get('contacts', appState.currentChatId);
                    recipientName = contact.name;
                }
                
                UIManager.showModal({
                    isPersistent: true, 
                    customClass: 'modal-neumorphic',
                    title: "转账",
                    body: `
                        ${isGroup ? recipientHtml : ''}
                        <div class="form-group">
                            <label for="modal-transfer-amount">转账金额</label>
                            <input type="number" id="modal-transfer-amount" placeholder="0.00" min="0.01" step="0.01">
                        </div>
                        <div class="form-group">
                            <label for="modal-transfer-note">备注 (选填)</label>
                            <input type="text" id="modal-transfer-note" placeholder="转账说明">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '转账', class: 'btn-primary', handler: async () => {
                            const amount = parseFloat($('#modal-transfer-amount').value);
                            const note = $('#modal-transfer-note').value.trim();

                            if (isNaN(amount) || amount <= 0) {
                                return UIManager.showToast('请输入有效的金额');
                            }
                            if (isGroup && !recipientName) { 
                                return UIManager.showToast('请选择收款人');
                            }

                            const formattedAmount = `￥${amount.toFixed(2)}`;
                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[转账] ${formattedAmount}`,
                                type: 'sent',
                                segmentType: 'transfer',
                                cardData: {
                                    recipientName: recipientName,
                                    amount: formattedAmount,
                                    note: note,
                                    isClaimed: false
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
                
                
                if(isGroup) {
                    const displayDiv = $('#transfer-recipient-display');
                    displayDiv.addEventListener('click', async () => {
                         const group = await DBHelper.get('groups', appState.currentChatId);
                         const contacts = await DBHelper.getAll('contacts');
                         const members = group.members
                            .map(id => contacts.find(c => c.id === id))
                            .filter(Boolean);

                        if (members.length === 0) return;
                        
                        UIManager.showBottomSheet({
                            title: '选择收款人',
                            customClass: 'compact-list', 
                            items: members.map(m => ({ value: m.name, text: m.remark || m.name })),
                            onSelect: (value, text) => {
                                recipientName = value; 
                                displayDiv.querySelector('span').textContent = text; 
                                displayDiv.querySelector('span').style.color = 'var(--text-color-dark)';
                            }
                        });
                    });
                }
            },

            async handlePlayerRedPacket() {
                const isGroup = appState.currentChatId.startsWith('group-');
                const groupOnlyHtml = isGroup ? `
                    <div class="form-group">
                        <label for="modal-rp-count">红包个数</label>
                        <input type="number" id="modal-rp-count" value="1" min="1" step="1">
                    </div>
                ` : '';

                UIManager.showModal({
                    isPersistent: true, 
                    customClass: 'modal-neumorphic',
                    title: "发红包",
                    body: `
                        <div class="form-group">
                            <label for="modal-rp-amount">总金额</label>
                            <input type="number" id="modal-rp-amount" placeholder="0.00" min="0.01" step="0.01">
                        </div>
                        <div class="form-group">
                            <label for="modal-rp-title">红包祝福语 (选填)</label>
                            <input type="text" id="modal-rp-title" placeholder="恭喜发财，大吉大利">
                        </div>
                        ${groupOnlyHtml}
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '塞钱进红包', class: 'btn-primary', handler: async () => {
                            const amount = parseFloat($('#modal-rp-amount').value);
                            const title = $('#modal-rp-title').value.trim() || '恭喜发财，大吉大利';
                            const count = isGroup ? parseInt($('#modal-rp-count').value, 10) : 1;

                            if (isNaN(amount) || amount <= 0) {
                                return UIManager.showToast('请输入有效的金额');
                            }
                            if (isGroup && (isNaN(count) || count <= 0)) {
                                return UIManager.showToast('请输入有效的红包个数');
                            }
                            if (isGroup && amount < count * 0.01) {
                                return UIManager.showToast('单个红包金额不能少于0.01元');
                            }

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[红包] ${title}`,
                                type: 'sent',
                                segmentType: 'red-packet',
                                cardData: {
                                    title: title,
                                    amount: amount,
                                    count: count,
                                    isClaimedByPlayer: false, 
                                    claimedBy: []
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
            },
           
            
            
            handleInteractionStart(e, type) {
                if (appState.selectionMode.active) return; 

                const targetElement = e.target.closest('.bubble, .narrator-notice, .pat-notice');
                if (!targetElement) return;

                const messageRow = targetElement.closest('.message-row, .narrator-notice, .pat-notice');
                if (!messageRow || !messageRow.dataset.messageId) return;

                clearTimeout(appState.longPressTimer);

                const startAction = () => {
                    const existingButton = $('.retract-button-wrapper.show');
                    if (existingButton) {
                        existingButton.remove();
                    }
                    
                    if (messageRow.classList.contains('narrator-notice')) {
                        this.showMessageOptions(messageRow, 'narrator');
                    } else if (messageRow.classList.contains('pat-notice')) {
                        this.showMessageOptions(messageRow, 'pat_a_pat');
                    } else if (messageRow.classList.contains('received')) {
                        this.showMessageOptions(messageRow, 'received');
                    } else if (messageRow.classList.contains('sent')) {
                        this.showMessageOptions(messageRow, 'sent');
                    }
                };

                appState.longPressTimer = setTimeout(startAction, 500);

                const clearLongPress = () => {
                    clearTimeout(appState.longPressTimer);
                    document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                };
                document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
            },

            async startQuote(messageRowElement) {
                const messageId = messageRowElement.dataset.messageId;
                const messageData = await DBHelper.get('messages', messageId);
                if (!messageData || messageData.isRetracted) return;

                appState.quotingMessage = messageData;
                
                let senderName = '对方'; 
                if (messageData.type === 'sent') {
                    
                    const profile = await this.getPlayerProfileForContext(appState.currentChatId);
                    senderName = profile.name;
                } else {
                    
                    const contact = await DBHelper.get('contacts', messageData.senderId);
                    senderName = contact ? (contact.remark || contact.name) : '对方';
                }

                let quotedContentText;
                switch (messageData.segmentType) {
                    case 'text':
                        quotedContentText = messageData.content;
                        break;
                    case 'card':
                        quotedContentText = `[卡片消息] ${messageData.cardData.title}`;
                        break;
                    case 'image_vision':
                        quotedContentText = '[图片]';
                        break;
                    case 'quote':
                        quotedContentText = messageData.cardData.newContent;
                        break;
                    case 'voice':
                        quotedContentText = '[语音]';
                        break;
                    case 'emoji-image':
                        const emojiId = messageData.content;
                        const emojiDesc = appState.playerEmojiMap[emojiId] || '未知表情';
                        quotedContentText = `[表情] ${emojiDesc}`;
                        break;
                    case 'image_simulated':
                        quotedContentText = '[图片]';
                        break;
                    default:
                        quotedContentText = '[消息]';
                        break;
                }
                
                quotePreviewContent.textContent = `${senderName}: ${quotedContentText}`;
                quotePreviewArea.style.display = 'flex';
                messageInput.focus();
            },

            resetQuoteState() {
                appState.quotingMessage = null;
                quotePreviewArea.style.display = 'none';
            },

            async showMessageOptions(messageRowElement, messageType) {
                const messageId = messageRowElement.dataset.messageId;
                if (!messageId) return;

                const wrapper = document.createElement('div');
                wrapper.className = 'retract-button-wrapper';

                let buttonsHtml = '';
                if (messageType === 'narrator' || messageType === 'pat_a_pat') {
                    buttonsHtml = `<button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> 删除</button>`;
                } else if (messageType === 'sent') {
                    buttonsHtml = `
                        <button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> 删除</button>
                        <button class="retract-btn" data-action="retract"><i class="fas fa-undo"></i> 撤回</button>
                        <button class="retract-btn" data-action="quote"><i class="fas fa-quote-left"></i> 引用</button>
                    `;
                } else { 
                    buttonsHtml = `
                        <button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> 删除</button>
                        <button class="retract-btn" data-action="quote"><i class="fas fa-quote-left"></i> 引用</button>
                    `;
                }
                wrapper.innerHTML = buttonsHtml;
                
                wrapper.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const button = e.target.closest('.retract-btn');
                    if (!button) return;

                    const action = button.dataset.action;

                    if (action === 'delete') {
                        await DBHelper.delete('messages', messageId);
                        const originalRow = $(`#${messageId}`);
                        if (originalRow) originalRow.remove();
                        wrapper.remove();
                    } else if (action === 'retract') {
                        const msgToRetract = await DBHelper.get('messages', messageId);
                        if (!msgToRetract) return;

                        msgToRetract.isRetracted = true;
                        await DBHelper.put('messages', msgToRetract);

                        const myProfile = await DBHelper.get('profile', 'myProfile');
                        const retractionNotice = UIManager.createRetractionNotice(msgToRetract, myProfile);
                        
                        const originalRow = $(`#${messageId}`);
                        if (originalRow) originalRow.replaceWith(retractionNotice);
                        wrapper.remove();
                    } else if (action === 'quote') {
                        this.startQuote(messageRowElement);
                        wrapper.remove();
                    }
                });

                let attachTarget;
                if (messageType === 'narrator' || messageType === 'pat_a_pat') {
                    attachTarget = messageRowElement;
                    messageRowElement.style.position = 'relative';
                } else {
                    attachTarget = messageRowElement.querySelector('.bubble-and-tag-wrapper');
                }

                if (attachTarget) {
                    attachTarget.appendChild(wrapper);
                    setTimeout(() => wrapper.classList.add('show'), 10);
                }

                const hideOnClickOutside = (event) => {
                    if (!wrapper.contains(event.target)) {
                        wrapper.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                document.addEventListener('click', hideOnClickOutside, true);
            },

            async handleEditProfile() {
                const profile = await DBHelper.get('profile', 'myProfile');
                UIManager.showSidebar({
                    position: 'left', 
                    title: "我的信息",
                    body: `
                        <div class="form-group">
                            <label>头像</label>
                            <div class="avatar-uploader">
                                <img src="${profile.avatar}" id="profile-avatar-preview" class="avatar-preview">
                                <input type="file" id="profile-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('profile-avatar-input').click()">上传新头像</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="profile-name-input">姓名</label>
                            <input type="text" id="profile-name-input" value="${profile.name}">
                        </div>
                        <div class="form-group">
                            <label for="profile-gender-select">性别</label>
                            <select id="profile-gender-select">
                                <option value="男" ${profile.gender === '男' ? 'selected' : ''}>男</option>
                                <option value="女" ${profile.gender === '女' ? 'selected' : ''}>女</option>
                                <option value="其他" ${profile.gender === '其他' ? 'selected' : ''}>其他</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="profile-pat-action-input">拍一拍动作</label>
                            <input type="text" id="profile-pat-action-input" value="${profile.patAction || ''}" maxlength="5" placeholder="选填, 例如:拍一拍">
                        </div>
                        <div class="form-group">
                            <label for="profile-pat-content-input">拍一拍内容</label>
                            <input type="text" id="profile-pat-content-input" value="${profile.patContent || ''}" maxlength="20" placeholder="选填, 例如:的头,被揍了">
                        </div>
                        <div class="form-group">
                            <label for="profile-background-input">背景资料</label>
                            <textarea id="profile-background-input">${profile.background || ''}</textarea>
                        </div>
                        <div class="details-actions" style="margin-top: 20px; flex-direction: row; justify-content: space-around; gap: 10px;">
                            <button class="details-btn" id="load-profile-preset-btn" style="flex: 1;">读取</button>
                            <button class="details-btn" id="save-profile-preset-btn" style="flex: 1;">保存</button>
                            <button class="details-btn" id="delete-profile-preset-btn" style="flex: 1;">删除</button>
                        </div>
                        <p style="text-align: center; font-size: 12px; color: #aaa; user-select: none; margin-top: 30px;">此聊天室由33制作，xhs:@回风</p>
                    `,
                    actions: [
                        { text: '导入', class: 'btn-secondary', handler: () => this.handleImportProfilePresets() },
                        { text: '导出', class: 'btn-secondary', handler: () => this.handleExportProfilePresets() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const profileToUpdate = await DBHelper.get('profile', 'myProfile');
                            const newAvatar = $('#profile-avatar-preview').src;
                            const newName = $('#profile-name-input').value.trim();
                            if (!newName) { 
                                UIManager.showModal({ title:"提示", body:"<p>姓名不能为空！</p>", actions:[{text:"好的", class:"btn-primary", handler:()=>UIManager.hideModal()}]});
                                return; 
                            }
                            
                            const updatedProfile = {
                                ...profileToUpdate,
                                avatar: newAvatar,
                                name: newName,
                                gender: $('#profile-gender-select').value,
                                patAction: $('#profile-pat-action-input').value.trim(),
                                patContent: $('#profile-pat-content-input').value.trim(),
                                background: $('#profile-background-input').value.trim()
                            };
                            
                            await DBHelper.put('profile', updatedProfile);
                            $('#my-avatar').src = newAvatar;
                            UIManager.hideSidebar();
                        }}
                    ]
                });
                
                
                $('#profile-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const base64 = await Utils.fileToBase64(file);
                        $('#profile-avatar-preview').src = base64;
                    }
                });

                $('#load-profile-preset-btn').addEventListener('click', () => this.handleLoadProfilePreset());
                $('#save-profile-preset-btn').addEventListener('click', () => this.handleSaveProfilePreset());
                $('#delete-profile-preset-btn').addEventListener('click', () => this.handleDeleteProfilePreset());
            },

            async handleLoadProfilePreset() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p); 

                if (presets.length === 0) {
                    return UIManager.showToast("没有可读取的预设");
                }

                const items = presets.map((preset) => ({
                    value: preset.presetId, 
                    text: preset.presetName || preset.name // 优先使用显示名，兼容旧数据
                }));

                UIManager.showBottomSheet({
                    title: '选择要读取的预设',
                    items: items,
                    onSelect: (presetId) => { 
                        const selectedPreset = presets.find(p => p.presetId === presetId);
                        if (selectedPreset) {
                            $('#profile-avatar-preview').src = selectedPreset.avatar;
                            $('#profile-name-input').value = selectedPreset.name;
                            $('#profile-gender-select').value = selectedPreset.gender;
                            $('#profile-pat-action-input').value = selectedPreset.patAction || '';
                            $('#profile-pat-content-input').value = selectedPreset.patContent || '';
                            $('#profile-background-input').value = selectedPreset.background || '';
                            UIManager.showToast(`已加载预设 "${selectedPreset.name}"`);
                        }
                    }
                });
            },
            
            async handleSaveProfilePreset() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p);

                const items = [{
                    value: 'new',
                    text: `保存为新预设 (${presets.length}/20)`
                }];

                presets.forEach((preset) => {
                    items.push({
                        value: preset.presetId, 
                        text: `覆盖预设: ${preset.presetName || preset.name}` // 优先使用显示名
                    });
                });

                UIManager.showBottomSheet({
                    title: '保存预设',
                    items: items,
                    onSelect: (value) => { 
                        const currentData = {
                            name: $('#profile-name-input').value.trim(),
                            avatar: $('#profile-avatar-preview').src,
                            gender: $('#profile-gender-select').value,
                            background: $('#profile-background-input').value.trim()
                        };

                        if (!currentData.name) {
                            UIManager.showToast("保存失败，姓名不能为空");
                            return;
                        }

                        if (value === 'new') {
                            this.confirmAndSavePreset(null, currentData); 
                        } else {
                            this.confirmAndSavePreset(value, currentData); 
                        }
                    }
                });
            },
            
            async confirmAndSavePreset(presetIdToOverwrite, currentData) {
                const profile = await DBHelper.get('profile', 'myProfile');
                const isNew = presetIdToOverwrite === null;
                const existingPreset = isNew ? null : (profile.presets || []).find(p => p.presetId === presetIdToOverwrite);

                const doSave = async (presetName) => {
                        const newPreset = {
                            ...currentData, // currentData中包含了正确的玩家姓名 name
                            presetId: isNew ? Utils.generateId('persona') : presetIdToOverwrite,
                            presetName: presetName, // 这是预设的显示名称
                            patAction: $('#profile-pat-action-input').value.trim(),
                            patContent: $('#profile-pat-content-input').value.trim()
                        };
                        delete newPreset.playerName; // 清理可能存在的旧字段

                    
                    profile.presets = (profile.presets || []).filter(p => p);

                    if (isNew) {
                        if (profile.presets.length >= 20) {
                            UIManager.showToast("预设已达到20个上限");
                            return;
                        }
                        profile.presets.push(newPreset);
                    } else {
                        const indexToUpdate = profile.presets.findIndex(p => p.presetId === presetIdToOverwrite);
                        if (indexToUpdate !== -1) {
                            profile.presets[indexToUpdate] = newPreset;
                        } else {
                            
                            profile.presets.push(newPreset);
                        }
                    }

                    await DBHelper.put('profile', profile); 
                    UIManager.hideModal();
                    UIManager.showToast(`预设 "${presetName}" 已保存`);
                };

                UIManager.showModal({
                    title: isNew ? '保存为新预设' : '覆盖预设',
                    body: `
                        <p>${existingPreset ? `这将覆盖预设 "${existingPreset.name}"。` : '为这个新预设起个名字吧。'}</p>
                        <div class="form-group">
                            <label for="preset-name-input">预设名称</label>
                            <input type="text" id="preset-name-input" value="${existingPreset ? (existingPreset.presetName || existingPreset.name) : currentData.name}">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认保存', class: 'btn-primary', handler: () => {
                            const presetName = $('#preset-name-input').value.trim();
                            if (!presetName) {
                                UIManager.showToast("预设名称不能为空");
                                return;
                            }
                            doSave(presetName);
                        }}
                    ]
                });
            },

            async handleDeleteProfilePreset() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p);

                if (presets.length === 0) {
                    return UIManager.showToast("没有可删除的预设");
                }

                const presetsHtml = presets.map(preset => `
                    <label class="member-select-item">
                        <input type="checkbox" name="delete-preset" value="${preset.presetId}">
                        <img src="${preset.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${preset.presetName || preset.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "删除玩家预设",
                    body: `
                        <button id="select-all-presets-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 8px;">全选</button>
                        <div class="member-select-list" style="max-height: 40vh;">${presetsHtml}</div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除选中', class: 'btn-danger', handler: async () => {
                            const checkedPresets = $$('input[name="delete-preset"]:checked');
                            if (checkedPresets.length === 0) {
                                return UIManager.showToast("请选择要删除的预设");
                            }
                            
                            UIManager.showModal({
                                title: '确认删除',
                                body: `<p>确定要删除选中的 ${checkedPresets.length} 个预设吗？所有与这些预设的绑定都将被清除。</p>`,
                                actions: [
                                    { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: '删除', class: 'btn-danger', handler: async () => {
                                        const idsToDelete = Array.from(checkedPresets).map(cb => cb.value);
                                        const storesToUpdate = ['contacts', 'groups', 'friendFolders', 'circles'];
                                        for (const storeName of storesToUpdate) {
                                            const entities = await DBHelper.getAll(storeName);
                                            for (const entity of entities) {
                                                if (idsToDelete.includes(entity.boundPersonaPresetId)) {
                                                    entity.boundPersonaPresetId = null;
                                                    await DBHelper.put(storeName, entity);
                                                }
                                            }
                                        }

                                        const profileToUpdate = await DBHelper.get('profile', 'myProfile');
                                        profileToUpdate.presets = profileToUpdate.presets.filter(p => !idsToDelete.includes(p.presetId));
                                        await DBHelper.put('profile', profileToUpdate);
                                        
                                        UIManager.hideModal();
                                        UIManager.showToast(`${idsToDelete.length} 个预设已删除`);
                                    }}
                                ]
                            });
                        }}
                    ]
                });

                $('#select-all-presets-btn').addEventListener('click', () => {
                    const checkboxes = $$('input[name="delete-preset"]');
                    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                    checkboxes.forEach(cb => cb.checked = !allChecked);
                });
            },

            async handleExportProfilePresets() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p);

                if (presets.length === 0) {
                    return UIManager.showToast("没有可导出的预设");
                }

                const presetsHtml = presets.map(preset => `
                    <label class="member-select-item">
                        <input type="checkbox" name="export-preset" value="${preset.presetId}">
                        <img src="${preset.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${preset.presetName || preset.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "选择要导出的预设",
                    body: `
                        <button id="select-all-export-presets-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 8px;">全选</button>
                        <div class="member-select-list" style="max-height: 40vh;">${presetsHtml}</div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '生成文件', class: 'btn-primary', handler: () => {
                            const checkedPresets = $$('input[name="export-preset"]:checked');
                            if (checkedPresets.length === 0) {
                                return UIManager.showToast("请至少选择一个预设");
                            }
                            
                            const idsToExport = Array.from(checkedPresets).map(cb => cb.value);
                            const presetsToExport = presets.filter(p => idsToExport.includes(p.presetId));

                            let filename;
                            if (presetsToExport.length === 1) {
                                filename = `${presetsToExport[0].presetName || presetsToExport[0].name}.json`;
                            } else {
                                filename = `${presetsToExport[0].name} 等${presetsToExport.length}个玩家预设.json`;
                            }
                            
                            const exportData = presetsToExport;
                            const jsonString = JSON.stringify(exportData, null, 2);
                            const blob = new Blob([jsonString], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);

                            UIManager.showModal({
                                title: '文件已生成',
                                body: `<a href="${url}" download="${filename}" class="modal-btn btn-primary" style="display: block; text-align: center;">点击下载预设文件</a>`,
                                actions: [{ text: '关闭', class: 'btn-secondary', handler: () => { URL.revokeObjectURL(url); UIManager.hideModal(); } }]
                            });
                        }}
                    ]
                });

                $('#select-all-export-presets-btn').addEventListener('click', () => {
                    const checkboxes = $$('input[name="export-preset"]');
                    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                    checkboxes.forEach(cb => cb.checked = !allChecked);
                });
            },

            async handleImportProfilePresets() {
                const fileInput = $('#import-presets-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const importedPresets = JSON.parse(event.target.result);
                            if (!Array.isArray(importedPresets)) {
                                throw new Error("文件格式不正确，应为JSON数组。");
                            }

                            const profile = await DBHelper.get('profile', 'myProfile');
                            const currentPresets = profile.presets || [];
                            const availableSlots = 20 - currentPresets.length;
                            const numToImport = importedPresets.length;

                            if (numToImport > availableSlots) {
                                let message = `预设位置不足。文件内有 ${numToImport} 个预设，但当前只有 ${availableSlots} 个空位。请先手动删除一些预设后再试。`;
                                if (numToImport === 1 && availableSlots === 0) {
                                    message = "预设位置已满，请先手动删除一个预设后再导入。";
                                }
                                UIManager.showModal({
                                    title: "导入失败",
                                    body: `<p>${message}</p>`,
                                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            UIManager.showModal({
                                title: "确认导入",
                                body: `<p>文件内包含 ${numToImport} 个预设。请确保你有足够的空余位置。同名预设将被跳过。确定要继续吗？</p>`,
                                actions: [
                                    { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: '继续导入', class: 'btn-primary', handler: async () => {
                                        const profileToUpdate = await DBHelper.get('profile', 'myProfile');
                                        profileToUpdate.presets = profileToUpdate.presets || [];
                                        const existingNames = profileToUpdate.presets.map(p => p.presetName || p.name);
                                        let skippedCount = 0;
                                        let importedCount = 0;

                                        for (const preset of importedPresets) {
                                            // 检查新格式的显示名(presetName)或旧格式的名称(name)是否存在
                                            const presetDisplayName = preset.presetName || preset.name;
                                            if (existingNames.includes(presetDisplayName)) {
                                                skippedCount++;
                                                continue;
                                            }
                                            
                                            // 兼容旧格式的导入数据
                                            if (!preset.presetName) {
                                                preset.presetName = preset.name; // 将旧的name作为显示名
                                            }
                                            
                                            
                                            preset.presetId = Utils.generateId('persona'); 
                                            profileToUpdate.presets.push(preset);
                                            existingNames.push(preset.presetName);
                                            importedCount++;
                                        }

                                        await DBHelper.put('profile', profileToUpdate);
                                        UIManager.hideModal();
                                        
                                        let successMessage = `成功导入 ${importedCount} 个预设。`;
                                        if (skippedCount > 0) {
                                            successMessage += `\n跳过了 ${skippedCount} 个同名预设。`;
                                        }
                                        UIManager.showToast(successMessage, 3000);
                                    }}
                                ]
                            });

                        } catch (error) {
                            UIManager.showModal({
                                title: "导入失败",
                                body: `<p>文件解析失败或格式不正确。请确保文件是正确的玩家预设导出文件。<br>错误: ${error.message}</p>`,
                                actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                            });
                        } finally {
                            fileInput.value = '';
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            async showFolderBindingOptionsModal(folderId) {
                const folder = await DBHelper.get('friendFolders', folderId);
                if (!folder) return;
            
                UIManager.showModal({
                    customClass: 'modal-default-style', 
                    title: `为分组“${folder.name}”绑定`,
                    body: `
                        <div class="settings-list" style="padding:0; margin:0;">
                            <div class="setting-item" id="folder-bind-persona-btn">
                                <i class="fas fa-user-tag"></i>
                                <span>绑定玩家人设</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="folder-bind-prompts-btn">
                                <i class="fas fa-magic"></i>
                                <span>绑定提示词</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="folder-bind-circle-btn">
                                <i class="fas fa-camera-retro"></i>
                                <span>绑定朋友圈</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
            
                $('#folder-bind-persona-btn').onclick = () => {
                    UIManager.hideModal();
                    this.showPersonaBindingModal(folderId, false);
                };
                $('#folder-bind-prompts-btn').onclick = () => {
                    UIManager.hideModal();
                    this.showPromptBindingModalForFolder(folderId);
                };
                $('#folder-bind-circle-btn').onclick = () => {
                    UIManager.hideModal();
                    this.showCircleBindingModal(folderId, true);
                };
            },
            
            async showPromptBindingModalForFolder(folderId) {
                const folder = await DBHelper.get('friendFolders', folderId);
                if (!folder) return;
            
                const allPromptFolders = await DBHelper.getAll('promptFolders');
                if (allPromptFolders.length === 0) {
                    return UIManager.showToast("还没有创建任何提示词文件夹。");
                }
            
                const boundFolderIds = folder.boundPromptFolderIds || [];
                const folderListHtml = allPromptFolders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="bind-folder" value="${f.id}" ${boundFolderIds.includes(f.id) ? 'checked' : ''}>
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');
            
                UIManager.showModal({
                    title: `为分组“${folder.name}”绑定提示词`,
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const selectedIds = [...$$('input[name="bind-folder"]:checked')].map(cb => cb.value);
                            
                            UIManager.showModal({
                                title: '确认批量绑定',
                                body: `<p>这将把分组“<strong>${folder.name}</strong>”内所有好友的提示词绑定都更新为当前所选。确定要继续吗？</p><p style="font-size: 0.8rem; color: #aaa;">此操作会覆盖好友原有的单独绑定。</p>`,
                                actions: [
                                    { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: '确认', class: 'btn-primary', handler: async () => {
                                        folder.boundPromptFolderIds = selectedIds;
                                        await DBHelper.put('friendFolders', folder);
                                        
                                        const contactsInFolder = (await DBHelper.getAll('contacts')).filter(c => c.folderId === folderId);
                                        for (const contact of contactsInFolder) {
                                            contact.boundPromptFolderIds = selectedIds;
                                            await DBHelper.put('contacts', contact);
                                        }
                                        UIManager.hideModal();
                                        UIManager.showToast('分组提示词绑定已更新！');
                                    }}
                                ]
                            });
                        }}
                    ]
                });
            },

            showAddMenu() {
                UIManager.showModal({
                    title: "新建/导入",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0;">
                            <div class="setting-item" id="add-friend-menu">
                                <i class="fas fa-user-plus"></i>
                                <span>添加新好友</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="create-group-menu">
                                <i class="fas fa-users"></i>
                                <span>新建群聊</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="create-friend-folder-menu">
                                <i class="fas fa-folder-plus"></i>
                                <span>新建分组</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="add-builtin-character-menu">
                                <i class="fas fa-user-secret"></i>
                                <span>新增内置角色</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="import-data-menu">
                                <i class="fas fa-file-import"></i>
                                <span>导入角色/群聊</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>`,
                    actions: [] 
                });
                
                $('#add-friend-menu').addEventListener('click', () => this.handleAddFriend());
                $('#create-group-menu').addEventListener('click', () => this.handleCreateGroup());
                $('#add-builtin-character-menu').addEventListener('click', () => this.showBuiltinCharacterSelection());
                $('#import-data-menu').addEventListener('click', () => this.handleImportData());
                $('#create-friend-folder-menu').addEventListener('click', () => this.showAddEditFriendFolderModal());
            },
            
            handleAddFriend() {
                const defaultAvatar = Utils.createAvatarDataUrl(Utils.getRandomColor());
                UIManager.showModal({
                    isPersistent: true, 
                    title: "添加新好友",
                    body: `
                        <div class="form-group">
                            <label>头像</label>
                            <div class="avatar-uploader">
                                <img src="${defaultAvatar}" id="add-friend-avatar-preview" class="avatar-preview">
                                <input type="file" id="add-friend-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('add-friend-avatar-input').click()">上传头像</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-name">姓名 (唯一ID, 必填)</label>
                            <input type="text" id="add-friend-name" placeholder="为AI好友起个名字">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-remark">备注 (选填)</label>
                            <input type="text" id="add-friend-remark" placeholder="你对TA的称呼">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-gender">性别 (必填)</label>
                            <select id="add-friend-gender">
                                <option value="男">男</option>
                                <option value="女">女</option>
                                <option value="其他">其他</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-allow-retraction">允许撤回消息</label>
                            <select id="add-friend-allow-retraction">
                                <option value="true" selected>开启</option>
                                <option value="false">关闭</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-allow-emoji">允许发送表情包</label>
                            <select id="add-friend-allow-emoji">
                                <option value="on" selected>开启</option>
                                <option value="off">关闭</option>
                                <option value="prob">概率</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-allow-active-reply">允许主动回复</label>
                            <select id="add-friend-allow-active-reply">
                                <option value="true" selected>遵循聊天设置</option>
                                <option value="false">关闭</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-likes">喜好 (选填)</label>
                            <textarea id="add-friend-likes" placeholder="例如：甜食、运动、旅游"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-dislikes">厌恶 (选填)</label>
                            <textarea id="add-friend-dislikes" placeholder="例如：被忽视、下雨"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-habits">习惯 (选填)</label>
                            <textarea id="add-friend-habits" placeholder="例如：晨跑、运动"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-pat-action">拍一拍动作 (选填)</label>
                            <input type="text" id="add-friend-pat-action" placeholder="例如：拍了拍" maxlength="5">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-pat-content">拍一拍内容 (选填)</label>
                            <input type="text" id="add-friend-pat-content" placeholder="例如：的头，被反弹了" maxlength="20">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-background">背景资料 (选填)</label>
                            <textarea id="add-friend-background" placeholder="角色的其他资料"></textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal(); 
                            this.showAddMenu(); 
                        }},
                        { text: '添加', class: 'btn-primary', handler: async () => {
                            const name = $('#add-friend-name').value.trim();
                            if (!name) { 
                                this.showAddMenu(); 
                                UIManager.showModal({
                                    title: "提示",
                                    body: `<p>好友的姓名不能为空哦。</p>`,
                                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return; 
                            }
                            
                            
                            const existing = await DBHelper.getAll('contacts', 'name');
                            if (existing.some(c => c.name === name)) {
                                this.showAddMenu(); 
                                UIManager.showModal({
                                    title: "提示",
                                    body: `<p>姓名 "${name}" 已经被其他好友占用了，换一个吧。</p>`,
                                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            const newContact = {
                                id: Utils.generateId('contact'),
                                createdAt: Date.now(),
                                name,
                                avatar: $('#add-friend-avatar-preview').src,
                                remark: $('#add-friend-remark').value.trim(),
                                gender: $('#add-friend-gender').value,
                                allowRetraction: $('#add-friend-allow-retraction').value === 'true',
                                allowEmoji: $('#add-friend-allow-emoji').value,
                                allowActiveReply: $('#add-friend-allow-active-reply').value === 'true',
                                likes: $('#add-friend-likes').value.trim(),
                                dislikes: $('#add-friend-dislikes').value.trim(),
                                habits: $('#add-friend-habits').value.trim(),
                                patAction: $('#add-friend-pat-action').value.trim(),
                                patContent: $('#add-friend-pat-content').value.trim(),
                                background: $('#add-friend-background').value.trim()
                            };
                            
                            await DBHelper.put('contacts', newContact);
                            UIManager.hideModal();
                            await UIManager.renderContactsPage();
                        }}
                    ]
                });

                $('#add-friend-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#add-friend-avatar-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },

            async showBuiltinCharacterSelection() {
                const existingContacts = await DBHelper.getAll('contacts');
                const existingNames = existingContacts.map(c => c.name);

                const charactersHtml = Object.entries(this.BUILTIN_CHARACTERS).map(([id, char]) => {
                    const isAdded = existingNames.includes(id);
                    return `
                        <label class="member-select-item" style="${isAdded ? 'opacity: 0.5; cursor: not-allowed;' : 'cursor: pointer;'}">
                            <input type="radio" name="builtin-char" value="${id}" ${isAdded ? 'disabled' : ''}>
                            <img src="${char.avatar}" class="contact-item-avatar" style="width:40px;height:40px;margin-right:10px;">
                            <div>
                                <span style="font-weight: bold;">${char.remark}</span>
                                <p style="font-size: 0.8rem; color: #888; margin: 2px 0 0 0;">${char.previewDesc || char.likes}</p>
                            </div>
                        </label>
                    `;
                }).join('');

                UIManager.showModal({
                    title: '选择内置角色',
                    body: `<div class="member-select-list" style="max-height: 40vh;">${charactersHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '添加', class: 'btn-primary', handler: () => {
                            const selectedRadio = $('input[name="builtin-char"]:checked');
                            if (!selectedRadio) {
                                UIManager.showToast("请选择一个要添加的角色");
                                return;
                            }
                            this.addSpecificBuiltinCharacter(selectedRadio.value);
                        }}
                    ]
                });
            },

            async addSpecificBuiltinCharacter(characterId) {
                const charData = this.BUILTIN_CHARACTERS[characterId];
                if (!charData) {
                    UIManager.showToast("未找到该内置角色");
                    return;
                }

                const existing = await DBHelper.getAll('contacts');
                if (existing.some(c => c.name === charData.id)) {
                    UIManager.showToast(`角色 "${charData.remark}" 已存在`);
                    UIManager.hideModal();
                    return;
                }

                const newContact = {
                    id: Utils.generateId('contact'),
                    createdAt: Date.now(),
                    name: charData.id,
                    remark: charData.remark,
                    avatar: charData.avatar,
                    gender: charData.gender,
                    likes: charData.likes,
                    dislikes: charData.dislikes,
                    habits: charData.habits,
                    background: charData.background
                };

                await DBHelper.put('contacts', newContact);
                UIManager.hideModal();
                await UIManager.renderContactsPage();
                UIManager.showToast(`内置角色 “${charData.remark}” 已添加`);
            },

            async handleCreateGroup() {
                const friends = await DBHelper.getAll('contacts');
                const friendFolders = await DBHelper.getAll('friendFolders');

                if (friends.length === 0) {
                    this.showAddMenu();
                    UIManager.showModal({
                        title: "提示",
                        body: `<p>通讯录中还没有好友，快去添加一些好友再来创建群聊吧！</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const myProfile = await DBHelper.get('profile', 'myProfile');
                const defaultAvatar = Utils.createAvatarDataUrl(Utils.getRandomColor());

                const folderMap = friendFolders.reduce((map, f) => {
                    map[f.id] = f.name;
                    return map;
                }, {});

                const membersHtml = friends.map(f => {
                    const folderName = f.folderId ? folderMap[f.folderId] || '未知分组' : '未分组';
                    return `
                    <label class="member-select-item" data-friend-name="${(f.remark || f.name).toLowerCase()}" data-friend-id="${f.name.toLowerCase()}" data-folder-id="${f.folderId || ''}" data-folder-name="${folderName.toLowerCase()}">
                        <input type="checkbox" name="group-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>`;
                }).join('');

                const foldersHtml = friendFolders.map(folder => `
                    <label class="member-select-item">
                        <input type="radio" name="select-by-folder" value="${folder.id}">
                        <i class="fas fa-folder" style="margin-right: 10px; color: var(--text-color-medium);"></i>
                        <span>${folder.name} (${folder.memberIds.length}人)</span>
                    </label>
                `).join('');

                const creatorOptionsHtml = `<option value="${myProfile.id}">我 (${myProfile.name})</option>` + friends.map(f =>
                    `<option value="${f.id}">${f.remark || f.name}</option>`
                ).join('');

                UIManager.showModal({
                    title: "新建群聊",
                    body: `
                        <div class="form-group"><label>群头像 (选填)</label><div class="avatar-uploader"><img src="${defaultAvatar}" id="create-group-avatar-preview" class="avatar-preview"><input type="file" id="create-group-avatar-input" accept="image/*" style="display:none;"><button class="upload-btn" onclick="document.getElementById('create-group-avatar-input').click()">上传头像</button></div></div>
                        <div class="form-group"><label for="create-group-name">群名称 (必填)</label><input type="text" id="create-group-name" placeholder="为群聊起个名字"></div>
                        <div class="form-group"><label for="create-group-creator">选择群主 (必填)</label><select id="create-group-creator">${creatorOptionsHtml}</select></div>
                        
                        <div class="creation-mode-tabs">
                            <button class="mode-btn active" data-mode="friends">按好友选择</button>
                            <button class="mode-btn" data-mode="folders">按分组选择</button>
                        </div>

                        <div id="friends-panel" class="selection-panel">
                            <input type="text" id="group-creation-search" placeholder="搜索好友 (备注/ID/分组)...">
                            <div class="member-select-list">${membersHtml}</div>
                        </div>
                        <div id="folders-panel" class="selection-panel hidden">
                            <div class="member-select-list">${foldersHtml}</div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '创建', class: 'btn-primary', handler: async () => {
                            const name = $('#create-group-name').value.trim();
                            if (!name) return UIManager.showToast("群聊名称不能为空");
                            
                            const selectedMembers = [...$$('input[name="group-members"]:checked')].map(cb => cb.value);
                            if (selectedMembers.length < 1) return UIManager.showToast("至少需要选择一位好友");
                            
                            const creatorId = $('#create-group-creator').value;
                            if (creatorId !== myProfile.id && !selectedMembers.includes(creatorId)) {
                                selectedMembers.push(creatorId);
                            }
                            
                            const newGroup = {
                                id: Utils.generateId('group-'), createdAt: Date.now(), name,
                                avatar: $('#create-group-avatar-preview').src,
                                members: selectedMembers, creatorId: creatorId
                            };
                            
                            await DBHelper.put('groups', newGroup);
                            
                            const invitedNames = (await Promise.all(newGroup.members.filter(id => id !== myProfile.id).map(id => DBHelper.get('contacts', id)))).map(c => c.name).join('、'); 
                            const creatorContact = creatorId === myProfile.id ? myProfile : await DBHelper.get('contacts', creatorId);
                            const creatorNameForScene = creatorContact ? creatorContact.name : "一位朋友";
                            const defaultSceneContent = `${creatorNameForScene} 创建了群聊 “${newGroup.name}”，群聊成员有：${invitedNames}。现在，大家开始积极发言吧！`;
                            await DBHelper.put('openingScenes', {id: Utils.generateId('scene'), groupId: newGroup.id, name: '默认开场白', content: defaultSceneContent});

                            UIManager.hideModal();
                            await UIManager.renderContactsPage('groups');
                        }}
                    ]
                });
                
                $('#create-group-avatar-input').onchange = async (e) => {
                    if (e.target.files[0]) $('#create-group-avatar-preview').src = await Utils.fileToBase64(e.target.files[0]);
                };

                
                const modeBtns = $$('.mode-btn');
                const friendsPanel = $('#friends-panel');
                const foldersPanel = $('#folders-panel');
                
                modeBtns.forEach(btn => {
                    btn.onclick = () => {
                        modeBtns.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const isFriendsMode = btn.dataset.mode === 'friends';
                        friendsPanel.classList.toggle('hidden', !isFriendsMode);
                        foldersPanel.classList.toggle('hidden', isFriendsMode);
                    };
                });

                $('#group-creation-search').oninput = (e) => {
                    const term = e.target.value.toLowerCase();
                    $$('#friends-panel .member-select-item').forEach(item => {
                        const name = item.dataset.friendName;
                        const id = item.dataset.friendId;
                        const folderName = item.dataset.folderName;
                        item.style.display = (name.includes(term) || id.includes(term) || folderName.includes(term)) ? 'flex' : 'none';
                    });
                };

                $$('input[name="select-by-folder"]').forEach(radio => {
                    radio.onchange = (e) => {
                        const selectedFolderId = e.target.value;
                        const folder = friendFolders.find(f => f.id === selectedFolderId);
                        if (folder) {
                            $$('input[name="group-members"]').forEach(cb => {
                                cb.checked = folder.memberIds.includes(cb.value);
                            });
                            
                            modeBtns.forEach(b => b.classList.toggle('active', b.dataset.mode === 'friends'));
                            friendsPanel.classList.remove('hidden');
                            foldersPanel.classList.add('hidden');
                        }
                    };
                });
            },
            
            async handleSortContacts() {
                appState.contactsSortOrder = appState.contactsSortOrder === 'asc' ? 'desc' : 'asc';
                await UIManager.renderContactsPage('friends');
            },
            
            async handleSortGroups() {
                appState.groupsSortOrder = appState.groupsSortOrder === 'asc' ? 'desc' : 'asc';
                await UIManager.renderContactsPage('groups');
            },
            
            async handleBatchDelete() {
                const activeTab = $('.tabs .tab-btn.active').dataset.tab;
                const actionBar = $('#selection-action-bar');
                const contactsPage = $('#page-contacts');
                
                if (activeTab === 'friends') {
                    appState.friendSelectionMode = !appState.friendSelectionMode;
                    appState.groupSelectionMode = false; 
                } else {
                    appState.groupSelectionMode = !appState.groupSelectionMode;
                    appState.friendSelectionMode = false; 
                }
                
                const isAnyModeActive = appState.friendSelectionMode || appState.groupSelectionMode;
                actionBar.style.display = isAnyModeActive ? 'flex' : 'none';
                contactsPage.classList.toggle('selection-mode', isAnyModeActive);
                
                await UIManager.renderContactsPage(activeTab);
            },

            handleSelectAll() {
                const activeTab = $('.tabs .tab-btn.active').dataset.tab;
                const listId = activeTab === 'friends' ? '#friends-list-ul' : '#groups-list-ul';
                const checkboxes = $$(`${listId} .contact-select-checkbox`);
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                checkboxes.forEach(cb => cb.checked = !allChecked);
            },
            
            async handleConfirmBatchDelete() {
                const activeTab = $('.tabs .tab-btn.active').dataset.tab;
                const listId = activeTab === 'friends' ? '#friends-list-ul' : '#groups-list-ul';
                const checkedItems = $$(`${listId} .contact-select-checkbox:checked`);
                
                if (checkedItems.length === 0) {
                    return UIManager.showToast("请至少选择一项");
                }
                
                const idsToDelete = Array.from(checkedItems).map(cb => cb.closest('.contact-item').dataset.id);

                if (activeTab === 'friends') {
                    const allGroups = await DBHelper.getAll('groups');
                    const problematicFriends = [];
                    for (const friendId of idsToDelete) {
                        const groupsIn = allGroups.filter(g => g.members.includes(friendId));
                        if (groupsIn.length > 0) {
                            const friend = await DBHelper.get('contacts', friendId);
                            problematicFriends.push({ name: friend.name, groups: groupsIn.map(g => g.name).join(', ') });
                        }
                    }

                    if (problematicFriends.length > 0) {
                        const errorMsg = problematicFriends.map(p => `<strong>${p.name}</strong> 仍在群聊: ${p.groups}`).join('<br>');
                        return UIManager.showModal({
                            title: "无法删除",
                            body: `<p>以下好友因仍在群聊中而无法删除，请先将其移出群聊：</p><div style="text-align:left; max-height: 150px; overflow-y: auto; background: #f0f0f0; padding: 10px; border-radius: 8px;">${errorMsg}</div>`,
                            actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                        });
                    }
                }

                UIManager.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除选中的 ${idsToDelete.length} 个${activeTab === 'friends' ? '好友' : '群聊'}吗？相关聊天记录也将被永久删除。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            const storeName = activeTab === 'friends' ? 'contacts' : 'groups';
                            for (const id of idsToDelete) {
                                await DBHelper.delete(storeName, id);
                                await DBHelper.delete('chatMetadata', id);
                                await DBHelper.deleteMessagesForChat(id); 
                            }
                            UIManager.hideModal();
                            UIManager.showToast("删除成功");
                            this.handleBatchDelete(); 
                            await UIManager.renderMessagesListPage(); 
                        }}
                    ]
                });
            },

            handleImportData() {
                const fileInput = $('#import-data-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            await this.processImportedFile(data);
                        } catch (error) {
                            console.error("导入失败:", error);
                            UIManager.showToast("文件解析失败，请检查文件格式。");
                        } finally {
                            fileInput.value = ''; 
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            async processImportedFile(data) {
                if (data.type === 'contact' && data.contactData) {
                    const existingContacts = await DBHelper.getAll('contacts');
                    const conflict = existingContacts.find(c => c.name === data.contactData.name);
                    if (conflict) {
                        this.handleCharacterImportConflict(data, conflict);
                    } else {
                        const importedContact = data.contactData;
                        
                        const newContact = { ...importedContact, createdAt: Date.now() }; 
                        delete newContact.openingScenes; 

                        await DBHelper.put('contacts', newContact);
                        await this.importOpeningScenes(importedContact.openingScenes, newContact.id, false);
                        
                        if (data.chatHistory && data.participants) {
                            const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                            if (reconstructedHistory && reconstructedHistory.history) {
                                for (const message of reconstructedHistory.history) {
                                    message.chatId = newContact.id; 
                                    await DBHelper.put('messages', message);
                                }
                                
                                
                                const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                if (displayableHistory.length > 0) {
                                    const lastMessage = displayableHistory[displayableHistory.length - 1];
                                    const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                    await UIManager.updateChatMetadata(newContact.id, lastMessage, unreadCount);
                                }
                            }
                        }
                        
                        UIManager.showToast(`角色 "${newContact.name}" 导入成功！`);
                        if (newContact.author) {
                           EventManager.showAttributionModal(newContact);
                        }
                        await UIManager.renderContactsPage();
                        await UIManager.renderMessagesListPage(); 
                    }
                } else if (data.type === 'group' && data.groupData && data.memberData) {
                    const existingContacts = await DBHelper.getAll('contacts');
                    const conflictingMembers = data.memberData.filter(im => existingContacts.some(ec => ec.name === im.name));

                    if (conflictingMembers.length > 0) {
                        this.handleGroupImportConflict(data, conflictingMembers);
                    } else {
                        
                        for (const member of data.memberData) {
                            const newMember = { ...member, createdAt: Date.now() };
                            delete newMember.openingScenes;
                            await DBHelper.put('contacts', newMember);
                            await this.importOpeningScenes(member.openingScenes, member.id, false);
                        }
                        
                        
                        const importedGroup = data.groupData;
                        const existingGroup = await DBHelper.get('groups', importedGroup.id);
                        
                        const newGroup = {
                            ...importedGroup,
                            createdAt: Date.now()
                        };
                        
                        if(existingGroup) {
                            newGroup.id = Utils.generateId('group');
                        }
                        delete newGroup.openingScenes;

                        await DBHelper.put('groups', newGroup);
                        
                        
                        if (data.chatHistory && data.participants) {
                            const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                            if (reconstructedHistory && reconstructedHistory.history) {
                                for (const message of reconstructedHistory.history) {
                                    message.chatId = newGroup.id; 
                                    await DBHelper.put('messages', message);
                                }

                                
                                const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                if (displayableHistory.length > 0) {
                                    const lastMessage = displayableHistory[displayableHistory.length - 1];
                                    const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                    await UIManager.updateChatMetadata(newGroup.id, lastMessage, unreadCount);
                                }
                            }
                        }

                        await this.importOpeningScenes(importedGroup.openingScenes, newGroup.id, true);
                        UIManager.showToast(`群聊 "${newGroup.name}" 及所有成员导入成功！`);
                        if (newGroup.author) {
                            EventManager.showAttributionModal(newGroup);
                        }
                        await UIManager.renderContactsPage('groups');
                        await UIManager.renderMessagesListPage(); 
                    }
                } else {
                    UIManager.showToast("导入失败：文件类型未知或数据不完整。");
                }
            },

            handleCharacterImportConflict(data, existingContact) {
                const importedContact = data.contactData;
                UIManager.showModal({
                    title: "角色冲突",
                    body: `<p>通讯录中已存在名为 <strong>${existingContact.name}</strong> 的角色。<br><strong>更新</strong>：不清除原消息记录<br><strong>覆盖</strong>：清除该角色原来的消息记录<br>请选择操作：</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '更新角色', class: 'btn-primary', handler: async () => {
                            const updatedContact = {
                                ...importedContact, 
                                id: existingContact.id, 
                                createdAt: existingContact.createdAt, 
                                
                                boundPersonaPresetId: existingContact.boundPersonaPresetId, 
                                boundCircleId: existingContact.boundCircleId,
                                folderId: existingContact.folderId
                            };
                            delete updatedContact.openingScenes; 
                            await DBHelper.put('contacts', updatedContact);
                            
                            const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existingContact.id);
                            for (const scene of oldScenes) {
                                await DBHelper.delete('openingScenes', scene.id);
                            }
                            await this.importOpeningScenes(importedContact.openingScenes, existingContact.id, false);

                            UIManager.hideModal();
                            UIManager.showToast(`角色 "${existingContact.name}" 已更新。`);
                            if(updatedContact.author) EventManager.showAttributionModal(updatedContact);
                            await UIManager.renderContactsPage();
                        }},
                        { text: '覆盖角色', class: 'btn-danger', handler: async () => {
                            
                            await DBHelper.deleteMessagesForChat(existingContact.id); 
                            await DBHelper.delete('chatMetadata', existingContact.id); 
                            const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existingContact.id);
                            for (const scene of oldScenes) {
                                await DBHelper.delete('openingScenes', scene.id);
                            }
                            await DBHelper.delete('contacts', existingContact.id);

                            
                            const newContact = { ...importedContact, id: importedContact.id, createdAt: Date.now() };
                            delete newContact.openingScenes;
                            await DBHelper.put('contacts', newContact);
                            
                            
                            if (data.chatHistory && data.participants) {
                                const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                                if (reconstructedHistory && reconstructedHistory.history) {
                                    for (const message of reconstructedHistory.history) {
                                        message.chatId = newContact.id; 
                                        await DBHelper.put('messages', message);
                                    }
                                    
                                    const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                    if (displayableHistory.length > 0) {
                                        const lastMessage = displayableHistory[displayableHistory.length - 1];
                                        const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                        await UIManager.updateChatMetadata(newContact.id, lastMessage, unreadCount);
                                    }
                                }
                            }

                            await this.importOpeningScenes(importedContact.openingScenes, newContact.id, false);

                            UIManager.hideModal();
                            UIManager.showToast(`角色 "${newContact.name}" 已被覆盖。`);
                            if(newContact.author) EventManager.showAttributionModal(newContact);
                            await UIManager.renderContactsPage();
                            await UIManager.renderMessagesListPage(); 
                        }}
                    ]
                });
            },

            handleGroupImportConflict(data, conflictingMembers) {
                const importedGroup = data.groupData;
                const importedMembers = data.memberData;
                const conflictNames = conflictingMembers.map(m => m.name).join('、');
                UIManager.showModal({
                    title: "群聊成员冲突",
                    body: `<p>在导入群聊 <strong>${importedGroup.name}</strong> 时，发现以下成员已存在于你的通讯录中：<br><strong>${conflictNames}</strong><br>请选择如何处理这些冲突的角色。<br><strong>更新</strong>：不清除原消息记录<br><strong>覆盖</strong>：清除该角色原来的消息记录</p>`,
                    actions: [
                        { text: '取消导入', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '全部更新', class: 'btn-primary', handler: async () => {
                            const existingContacts = await DBHelper.getAll('contacts');
                            const memberIdMap = {};
                            for (const member of importedMembers) {
                                const existing = existingContacts.find(c => c.name === member.name);
                                let finalMember;
                                if (existing) {
                                    finalMember = { ...existing, ...member, id: existing.id };
                                    delete finalMember.openingScenes;
                                    await DBHelper.put('contacts', finalMember);
                                    const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existing.id);
                                    for (const scene of oldScenes) await DBHelper.delete('openingScenes', scene.id);
                                    await this.importOpeningScenes(member.openingScenes, existing.id, false);
                                } else {
                                    finalMember = { ...member, id: Utils.generateId('contact'), createdAt: Date.now() };
                                    delete finalMember.openingScenes;
                                    await DBHelper.put('contacts', finalMember);
                                    await this.importOpeningScenes(member.openingScenes, finalMember.id, false);
                                }
                                memberIdMap[member.id] = finalMember.id;
                            }
                            
                            const newMemberIds = importedGroup.members.map(oldId => memberIdMap[oldId]).filter(Boolean);
                            const newCreatorId = memberIdMap[importedGroup.creatorId] || importedGroup.creatorId;
                            const newGroup = { ...importedGroup, id: Utils.generateId('group-'), createdAt: Date.now(), members: newMemberIds, creatorId: newCreatorId };
                            delete newGroup.openingScenes;

                            await DBHelper.put('groups', newGroup);
                            await this.importOpeningScenes(importedGroup.openingScenes, newGroup.id, true);
                            UIManager.hideModal();
                            UIManager.showToast(`群聊 "${importedGroup.name}" 导入成功，冲突成员已更新。`);
                            if (importedGroup.author) EventManager.showAttributionModal(importedGroup);
                            await UIManager.renderContactsPage('groups');
                        }},
                        { text: '全部覆盖', class: 'btn-danger', handler: async () => {
                            const existingContacts = await DBHelper.getAll('contacts');
                            const existingGroups = await DBHelper.getAll('groups');
                            
                            
                            const oldGroup = existingGroups.find(g => g.name === importedGroup.name);
                            if (oldGroup) {
                                await DBHelper.deleteMessagesForChat(oldGroup.id); 
                                await DBHelper.deleteMessagesForChat(oldGroup.id); 
                                await DBHelper.delete('chats', oldGroup.id);
                                await DBHelper.delete('chatMetadata', oldGroup.id);
                                await DBHelper.delete('groups', oldGroup.id);
                            }

                            
                            for (const member of importedMembers) {
                                const existing = existingContacts.find(c => c.name === member.name);
                                if (existing) {
                                    await DBHelper.delete('chats', existing.id);
                                    await DBHelper.delete('chatMetadata', existing.id); 
                                    const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existing.id);
                                    for (const scene of oldScenes) await DBHelper.delete('openingScenes', scene.id);
                                    await DBHelper.delete('contacts', existing.id);
                                }
                            }
                            
                            
                            for (const member of importedMembers) {
                                const newMember = { ...member, createdAt: Date.now() };
                                delete newMember.openingScenes;
                                await DBHelper.put('contacts', newMember);
                                await this.importOpeningScenes(member.openingScenes, member.id, false);
                            }
                            
                            
                            const groupToImport = { ...importedGroup, createdAt: Date.now() };
                            const groupWithSameIdExists = await DBHelper.get('groups', groupToImport.id);
                            if (groupWithSameIdExists) {
                                groupToImport.id = Utils.generateId('group');
                            }
                            delete groupToImport.openingScenes;

                            await DBHelper.put('groups', groupToImport);
                            
                            
                            if (data.chatHistory && data.participants) {
                                const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                                if (reconstructedHistory && reconstructedHistory.history) {
                                    for (const message of reconstructedHistory.history) {
                                        message.chatId = groupToImport.id; 
                                        await DBHelper.put('messages', message);
                                    }
                                    
                                    const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                    if (displayableHistory.length > 0) {
                                        const lastMessage = displayableHistory[displayableHistory.length - 1];
                                        const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                        await UIManager.updateChatMetadata(groupToImport.id, lastMessage, unreadCount);
                                    }
                                }
                            }

                            await this.importOpeningScenes(importedGroup.openingScenes, groupToImport.id, true);
                            UIManager.hideModal();
                            UIManager.showToast(`群聊 "${importedGroup.name}" 导入成功，冲突成员已被覆盖。`);
                            if (importedGroup.author) EventManager.showAttributionModal(importedGroup);
                            await UIManager.renderContactsPage('groups');
                            await UIManager.renderMessagesListPage(); 
                        }}
                    ]
                });
            },


            showAttributionModal(entity) {
                UIManager.showModal({
                    title: "作者信息",
                    body: `
                        <div class="details-card">
                            <div class="details-field">
                                <span class="label">来源于</span>
                                <span class="value">${entity.author}</span>
                            </div>
                            <div class="details-section" style="margin-top: 15px;">
                                <div class="details-section-title">作者有话说</div>
                                <p>${entity.authorWords || '作者很懒，什么都没留下...'}</p>
                            </div>
                        </div>
                    `,
                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async generateExportFile(entity, isGroup, authorName, authorWords, historyOption) {
                UIManager.showModal({
                    title: '正在生成文件...',
                    body: '<div style="text-align:center; padding: 20px;"><div class="loader-spinner" style="width: 30px; height: 30px; border-width: 3px; display: inline-block;"></div><p style="margin-top: 15px;">请稍候，数据正在处理中...</p></div>',
                    actions: []
                });

                await new Promise(resolve => setTimeout(resolve, 100)); 

                let exportData;
                let chatId;
                const targetEntity = isGroup ? entity.groupData : entity;

                targetEntity.author = authorName;
                targetEntity.authorWords = authorWords;
                
                if (isGroup) {
                    exportData = { type: 'group', ...entity };
                    chatId = targetEntity.id;
                } else {
                    exportData = { type: 'contact', contactData: targetEntity };
                    chatId = targetEntity.id;
                }

                if (historyOption !== 'none') {
                    const allMessages = await DBHelper.getMessages(chatId, Number.MAX_SAFE_INTEGER);
                    let messagesToExport = [];

                    if (historyOption === 'all') {
                        messagesToExport = allMessages;
                    } else {
                        const messageCount = parseInt(historyOption, 10);
                        if (!isNaN(messageCount) && messageCount > 0) {
                            messagesToExport = allMessages.slice(-messageCount);
                        }
                    }

                    if (messagesToExport.length > 0) {
                        const allContacts = await DBHelper.getAll('contacts');
                        const myProfile = await this.getPlayerProfileForContext(chatId);
                        
                        const chatHistory = { history: messagesToExport };
                        const participants = {};

                        for (const msg of chatHistory.history) {
                            if (msg.senderId && msg.senderId !== myProfile.id && !participants[msg.senderId]) {
                                const senderInfo = allContacts.find(c => c.id === msg.senderId);
                                if (senderInfo) {
                                    participants[msg.senderId] = senderInfo;
                                }
                            }
                            delete msg.senderInfo; 
                        }

                        exportData.chatHistory = chatHistory;
                        exportData.participants = Object.values(participants);
                    }
                }

                const filename = `${targetEntity.name}_${new Date().toISOString().slice(0, 10)}.json`;
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                UIManager.showModal({
                    title: '文件已生成',
                    body: `
                        <p>请点击下面的链接下载文件。</p>
                        <a href="${url}" download="${filename}" class="modal-btn btn-primary" style="display: block; text-align: center; margin-top: 20px;">
                            点击下载 ${filename}
                        </a>
                        <p style="font-size: 0.8rem; color: #aaa; text-align: center; margin-top: 15px;">(下载后此链接将失效)</p>
                    `,
                    actions: [{
                        text: '关闭',
                        class: 'btn-secondary',
                        handler: () => {
                            URL.revokeObjectURL(url); 
                            UIManager.hideModal();
                        }
                    }]
                });
            },

            async reconstructChatHistory(chatHistory, participants) {
                if (!chatHistory || !chatHistory.history || !participants) {
                    return chatHistory;
                }

                const participantMap = participants.reduce((map, p) => {
                    if(p) map[p.id] = p; 
                    return map;
                }, {});
                
                let lastTimestamp = 0;
                
                
                chatHistory.history.sort((a, b) => a.timestamp - b.timestamp);

                chatHistory.history.forEach(msg => {
                    if (msg.senderId && participantMap[msg.senderId]) {
                        
                        
                    }
                    
                    if (msg.timestamp <= lastTimestamp) {
                        
                        msg.timestamp = lastTimestamp + 1;
                    }
                    
                    lastTimestamp = msg.timestamp;
                });

                return chatHistory;
            },

            async handleExportContact(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                const allOpeningScenes = await DBHelper.getAll('openingScenes');
                contact.openingScenes = allOpeningScenes.filter(s => s.contactId === contactId);
                this.showExportModal(contact, false);
            },

            async handleExportGroup(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                const membersData = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                const allOpeningScenes = await DBHelper.getAll('openingScenes');
                group.openingScenes = allOpeningScenes.filter(s => s.groupId === groupId);
                
                const exportPackage = {
                    groupData: group,
                    memberData: membersData
                };
                this.showExportModal(exportPackage, true);
            },

            async showExportModal(entity, isGroup) {
                const myProfile = { name: '你' };
                const targetEntity = isGroup ? entity.groupData : entity;
                const chatId = targetEntity.id;

                const authorName = targetEntity.author || myProfile.name;
                const authorWords = targetEntity.authorWords || '';
                const isAuthorFixed = !!targetEntity.author;

                
                UIManager.showModal({
                    title: `导出${isGroup ? '群聊' : '角色'}`,
                    body: `
                        <style>
                            .export-history-options {
                                display: none;
                                background-color: rgba(0,0,0,0.03);
                                border-radius: 8px;
                                padding: 15px;
                                margin-top: 15px;
                            }
                            .export-history-options label {
                                display: block;
                                margin-bottom: 12px;
                                cursor: pointer;
                            }
                            #history-count-placeholder .fa-spinner {
                                font-size: 0.9em;
                                color: var(--text-color-light);
                            }
                            #custom-history-count {
                                width: 70px;
                                text-align: center;
                                margin: 0 8px;
                                padding: 4px 8px;
                                border-radius: 6px;
                                border: 1px solid var(--border-color);
                            }
                        </style>
                        <div class="form-group">
                            <label for="export-author-name">作者名</label>
                            <input type="text" id="export-author-name" value="${authorName}" ${isAuthorFixed ? 'disabled' : ''}>
                        </div>
                        <div class="form-group">
                            <label for="export-author-words">作者有话说 (选填)</label>
                            <textarea id="export-author-words" rows="3">${authorWords}</textarea>
                        </div>
                        <div class="form-group" style="display: flex; align-items: center; justify-content: center; padding-top: 10px;">
                            <input type="checkbox" id="export-chat-history-checkbox" style="width: 16px; height: 16px; margin-right: 8px;">
                            <label for="export-chat-history-checkbox" id="export-history-label" style="margin: 0; cursor: pointer;">
                                同时导出聊天记录 <span id="history-count-placeholder">(<i class="fas fa-spinner fa-spin"></i> 正在计算...)</span>
                            </label>
                        </div>
                        <div id="export-history-options-container" class="export-history-options">
                            <label><input type="radio" name="history-export-option" value="100"> 导出最近100条</label>
                            <label><input type="radio" name="history-export-option" value="300"> 导出最近300条</label>
                            <label style="display: flex; align-items: center;">
                                <input type="radio" name="history-export-option" value="custom"> 导出最近
                                <input type="number" id="custom-history-count" min="1" step="1"> 条
                            </label>
                            <label><input type="radio" name="history-export-option" value="all" checked> 导出全部聊天记录 (可能卡顿)</label>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '生成文件', class: 'btn-primary', handler: () => {
                            const newAuthorName = $('#export-author-name').value.trim();
                            const newAuthorWords = $('#export-author-words').value.trim();
                            const includeHistory = $('#export-chat-history-checkbox').checked;
                            
                            let historyOption = 'none';
                            if (includeHistory) {
                                const selectedOption = $('input[name="history-export-option"]:checked');
                                if (selectedOption) {
                                    if (selectedOption.value === 'custom') {
                                        const customCount = $('#custom-history-count').value;
                                        historyOption = customCount ? parseInt(customCount, 10).toString() : '0';
                                    } else {
                                        historyOption = selectedOption.value;
                                    }
                                }
                            }
                            
                            this.generateExportFile(entity, isGroup, newAuthorName, newAuthorWords, historyOption);
                        }}
                    ]
                });

                
                const checkbox = $('#export-chat-history-checkbox');
                const optionsContainer = $('#export-history-options-container');
                checkbox.addEventListener('change', () => {
                    optionsContainer.style.display = checkbox.checked ? 'block' : 'none';
                });
                
                
                (async () => {
                    const messageCount = await DBHelper.getChatMessagesCount(chatId);
                    const countPlaceholder = $('#history-count-placeholder');
                    if(countPlaceholder) {
                        countPlaceholder.textContent = `(${messageCount} 条)`;
                    }
                })();
            },

            handleResetApp() {
                UIManager.showModal({
                    title: '确认重置',
                    body: `<p>此操作将删除所有数据，包括你的个人信息、联系人、群聊、聊天记录和API配置，且无法恢复。你确定要继续吗？</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认重置', class: 'btn-danger', handler: () => {
                            indexedDB.deleteDatabase(DBHelper.DB_NAME);
                            UIManager.hideModal();
                            UIManager.showModal({
                                title: "操作成功",
                                body: `<p>应用已重置，所有数据已被清除。页面即将刷新...</p><p>如果没有反应，请手动刷新。</p>`,
                                actions: [{ text: '立即刷新', class: 'btn-primary', handler: () => window.location.reload() }]
                            });
                            setTimeout(() => window.location.reload(), 3000); 
                        }}
                    ]
                });
            },

            showDataManagementModal() {
                UIManager.showModal({
                    title: "数据管理",
                    body: `
                        <p style="text-align: center; margin-bottom: 20px;">请选择要进行的操作。</p>
                        <div class="details-actions" style="flex-direction: column; gap: 15px;">
                            <button class="details-btn" id="export-all-data-btn" style="border-color: var(--accent-color); color: var(--accent-color-deep);">
                                <i class="fas fa-upload" style="margin-right: 8px;"></i>导出全部数据
                            </button>
                            <button class="details-btn" id="import-all-data-btn" style="border-color: var(--theme-color-2);">
                                <i class="fas fa-download" style="margin-right: 8px;"></i>导入数据 (将覆盖现有数据)
                            </button>
                        </div>
                    `,
                    actions: [{ text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });

                $('#export-all-data-btn').addEventListener('click', () => this.handleExportAllData());
                $('#import-all-data-btn').addEventListener('click', () => this.handleImportAllData());
            },
            
            async handleExportAllData() {
                UIManager.showModal({
                    title: "选择导出内容",
                    body: `
                        <p style="margin-bottom: 15px;">请勾选需要导出的数据部分。聊天记录数据量较大，导出可能需要一些时间。</p>
                        <div class="member-select-list" style="max-height: 50vh;">
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="characters" checked> 角色与群聊数据</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="player" checked> 玩家数据 (人设预设等)</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="emojis" checked> 自定义表情包</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="moments" checked> 朋友圈数据</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="theme" checked> 主题与字体设置</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="others" checked> 其他 (提示词、表情包、礼物配置等)</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="history"> 聊天记录 (仅保留会话最新200条)</label>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '开始导出', class: 'btn-primary', handler: () => {
                            const selectedParts = [...$$('input[name="export-parts"]:checked')].map(cb => cb.value);
                            if (selectedParts.length === 0) return UIManager.showToast("请至少选择一项导出内容");
                            this.executeExport(selectedParts);
                        }}
                    ]
                });
            },
            
            async executeExport(partsToExport) {
                let exportState = { isCancelled: false };

                UIManager.showModal({
                    isPersistent: true,
                    title: "正在导出数据...",
                    body: `
                        <style>
                            .progress-bar-container { width: 100%; background-color: #eee; border-radius: 10px; overflow: hidden; margin: 10px 0; }
                            .progress-bar { width: 0%; height: 20px; background-color: var(--accent-color); transition: width 0.3s ease; text-align: center; color: white; line-height: 20px; font-size: 0.8rem; }
                        </style>
                        <div id="export-progress-text" style="text-align: center; margin-bottom: 10px; color: var(--text-color-medium);">正在初始化...</div>
                        <div class="progress-bar-container"><div id="export-progress-bar" class="progress-bar">0%</div></div>
                    `,
                    actions: [{ text: '取消', class: 'btn-danger', handler: () => { exportState.isCancelled = true; } }]
                });

                const updateProgress = (text, percentage) => {
                    if (exportState.isCancelled) throw new Error("Export cancelled by user.");
                    const progressText = $('#export-progress-text');
                    const progressBar = $('#export-progress-bar');
                    if(progressText) progressText.textContent = text;
                    if(progressBar) {
                        progressBar.style.width = `${percentage}%`;
                        progressBar.textContent = `${Math.round(percentage)}%`;
                    }
                };

                try {
                    const jsonParts = [];
                    jsonParts.push('{"version":"1.0.0","createdAt":"' + new Date().toISOString() + '","data":{');
                    let isFirstDataPart = true;

                    const appendDataPart = (key, data) => {
                        if (exportState.isCancelled) throw new Error("Export cancelled by user.");
                        if (!isFirstDataPart) {
                            jsonParts.push(',');
                        }
                        jsonParts.push(`"${key}":${JSON.stringify(data, null, 2)}`);
                        isFirstDataPart = false;
                    };

                    const processSimplePart = async (partName, progressStart, progressEnd, taskName, getDataFunc) => {
                         if (partsToExport.includes(partName)) {
                            updateProgress(`正在读取 ${taskName}...`, progressStart);
                            const data = await getDataFunc();
                            appendDataPart(partName, data);
                        }
                        updateProgress(`处理完成: ${taskName}`, progressEnd);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    };

                    if (partsToExport.includes('characters')) {
                        updateProgress("正在读取角色与群聊数据...", 0);
                        appendDataPart('contacts', await DBHelper.getAll('contacts'));
                        appendDataPart('groups', await DBHelper.getAll('groups'));
                        appendDataPart('friendFolders', await DBHelper.getAll('friendFolders'));
                        updateProgress("处理完成: 角色与群聊数据", 10);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    if (partsToExport.includes('player') || partsToExport.includes('emojis')) {
                        updateProgress("正在读取玩家数据...", 10);
                        const fullProfile = await DBHelper.get('profile', 'myProfile');
                        if (fullProfile) {
                            
                            const profileToExport = {
                                id: fullProfile.id,
                                name: fullProfile.name,
                                gender: fullProfile.gender,
                                avatar: fullProfile.avatar,
                                background: fullProfile.background,
                                patAction: fullProfile.patAction,
                                patContent: fullProfile.patContent,
                                favoriteEmojis: fullProfile.favoriteEmojis,
                                
                            };

                            if (partsToExport.includes('player')) {
                                profileToExport.presets = fullProfile.presets || [];
                            }

                            if (partsToExport.includes('emojis')) {
                                profileToExport.customEmojis = fullProfile.customEmojis || {};
                            }

                            appendDataPart('profile', profileToExport);
                        }
                        updateProgress("处理完成: 玩家数据", 25);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }


                    if (partsToExport.includes('moments')) {
                        updateProgress("正在读取朋友圈数据...", 20);
                        appendDataPart('circles', await DBHelper.getAll('circles'));
                        appendDataPart('moments', await DBHelper.getAll('moments'));
                        updateProgress("处理完成: 朋友圈数据", 30);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    await processSimplePart('themeSettings', 30, 40, "主题设置", () => DBHelper.get('apiConfig', 'themeSettings'));
                    
                    if (partsToExport.includes('others')) {
                        updateProgress("正在读取其他配置...", 40);
                        appendDataPart('prompts', await DBHelper.getAll('prompts'));
                        appendDataPart('promptFolders', await DBHelper.getAll('promptFolders'));
                        appendDataPart('openingScenes', await DBHelper.getAll('openingScenes'));
                        const giftConfig = await DBHelper.get('giftApiConfig', 'mainConfig');
                        if (giftConfig) {
                            delete giftConfig.key;
                            appendDataPart('giftApiConfig', giftConfig);
                        }
                        const apiConfig = await DBHelper.get('apiConfig', 'mainConfig');
                        if (apiConfig) {
                            
                            delete apiConfig.keys;
                            appendDataPart('apiConfig', apiConfig);
                        }
                        updateProgress("处理完成: 其他配置", 50);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    const processStoreWithCursor = (storeName, progressStart, progressEnd) => {
                        return new Promise((resolve, reject) => {
                            if (!partsToExport.includes('history')) return resolve();

                            updateProgress(`正在打包 ${storeName}... (这可能需要一些时间)`, progressStart);
                            if (!isFirstDataPart) jsonParts.push(',');
                            jsonParts.push(`"${storeName}":[`);

                            const transaction = DBHelper.db.transaction([storeName], 'readonly');
                            const store = transaction.objectStore(storeName);
                            let isFirstItem = true;
                            let count = 0;

                            store.openCursor().onsuccess = (e) => {
                                if (exportState.isCancelled) {
                                    transaction.abort();
                                    return reject(new Error("Export cancelled by user."));
                                }
                                const cursor = e.target.result;
                                if (cursor) {
                                    if (!isFirstItem) jsonParts.push(',');
                                    jsonParts.push(JSON.stringify(cursor.value));
                                    isFirstItem = false;
                                    count++;
                                    if(count % 1000 === 0) { 
                                        updateProgress(`正在打包 ${storeName}: ${count}条...`, progressStart);
                                    }
                                    cursor.continue();
                                } else {
                                    jsonParts.push(']');
                                    isFirstDataPart = false;
                                    updateProgress(`处理完成: ${storeName}`, progressEnd);
                                    resolve();
                                }
                            };
                            transaction.onerror = (e) => reject(new Error(`读取 ${storeName} 失败: ${e.target.error}`));
                        });
                    };

                    if (partsToExport.includes('history')) {
                        updateProgress(`正在准备导出聊天记录...`, 50);
                        const allMetadata = await DBHelper.getAll('chatMetadata');
                        const allChatIds = allMetadata.map(meta => meta.chatId);
                        let allMessagesForExport = [];
                        let processedChats = 0;

                        for (const chatId of allChatIds) {
                            if (exportState.isCancelled) throw new Error("Export cancelled by user.");
                            
                            const messages = await DBHelper.getMessages(chatId, 200);
                            allMessagesForExport.push(...messages);

                            processedChats++;
                            const progress = 50 + (processedChats / allChatIds.length) * 40;
                            updateProgress(`正在打包聊天记录 (${processedChats}/${allChatIds.length})...`, progress);
                        }
                        
                        updateProgress(`正在清理数据...`, 91);
                        allMessagesForExport.forEach(msg => {
                            if (msg.senderInfo) {
                                delete msg.senderInfo;
                            }
                        });
                        
                        appendDataPart('messages', allMessagesForExport);
                        updateProgress("处理完成: 聊天记录", 95);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    await processStoreWithCursor('chatMetadata', 95, 98);

                    updateProgress("正在生成文件...", 98);
                    jsonParts.push('}}');

                    const blob = new Blob(jsonParts, { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const filename = `33聊天室_备份_${new Date().toISOString().slice(0, 10)}.json`;

                    UIManager.showModal({
                        title: '导出成功',
                        body: `<a href="${url}" download="${filename}" class="modal-btn btn-primary" style="display: block; text-align: center;">点击下载备份文件</a>`,
                        actions: [{ text: '关闭', class: 'btn-secondary', handler: () => { URL.revokeObjectURL(url); UIManager.hideModal(); } }]
                    });

                } catch (error) {
                    if (error.message.includes("cancelled")) {
                        UIManager.hideModal();
                        UIManager.showToast("导出已取消");
                    } else {
                        console.error("Export failed:", error);
                        UIManager.showModal({
                            title: '导出失败',
                            body: `<p>导出过程中发生错误: ${error.message}</p>`,
                            actions: [{ text: '关闭', class: 'btn-danger', handler: () => UIManager.hideModal() }]
                        });
                    }
                }
            },

            handleImportAllData() {
                const fileInput = $('#import-data-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            if (!data.version || !data.data) {
                                throw new Error("文件格式无效或已损坏。");
                            }
                            this.confirmAndExecuteImport(data.data);
                        } catch (error) {
                             UIManager.showModal({
                                title: "导入失败",
                                body: `<p>文件解析失败，请确保你选择的是正确的备份文件。<br>错误: ${error.message}</p>`,
                                actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                            });
                        } finally {
                            fileInput.value = '';
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            confirmAndExecuteImport(dataToImport) {
                UIManager.showModal({
                    title: "重要提示",
                    body: `<p style="color: #e74c3c; font-weight: bold;">此操作将彻底清除当前应用的所有数据，并用备份文件中的数据替换。此过程不可逆！</p><p>你确定要继续吗？</p>`,
                    actions: [
                        { text: '我再想想', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认导入', class: 'btn-danger', handler: async () => {
                            UIManager.showModal({
                                isPersistent: true,
                                title: "正在导入数据...",
                                body: `<div style="text-align: center;"><div class="loader-spinner" style="width: 30px; height: 30px; display: inline-block;"></div><p>请不要关闭或刷新页面。</p></div>`,
                                actions: []
                            });

                            try {
                                
                                if (DBHelper.db) {
                                    DBHelper.db.close();
                                    DBHelper.db = null;
                                }

                                
                                await new Promise((resolve, reject) => {
                                    const deleteRequest = indexedDB.deleteDatabase(DBHelper.DB_NAME);
                                    deleteRequest.onsuccess = () => resolve();
                                    deleteRequest.onerror = (e) => reject(`删除旧数据库失败: ${e.target.error}`);
                                    deleteRequest.onblocked = () => {
                                        reject("数据库删除被阻止，请关闭其他所有打开此应用的标签页后重试。");
                                    };
                                });
                                
                                
                                await DBHelper.init();

                                
                                if (dataToImport.profile) {
                                    
                                    dataToImport.profile.id = 'myProfile';
                                    await DBHelper.put('profile', dataToImport.profile);
                                }
                                

                                const storesToImport = [
                                    'contacts', 'groups', 'friendFolders', 
                                    'circles', 'moments', 'prompts', 'promptFolders', 
                                    'openingScenes', 'messages', 'chatMetadata'
                                ];

                                for (const storeName of storesToImport) {
                                    if (dataToImport[storeName] && Array.isArray(dataToImport[storeName])) {
                                        await DBHelper.batchPut(storeName, dataToImport[storeName]);
                                    }
                                }

                                
                                if(dataToImport.apiConfig) await DBHelper.put('apiConfig', dataToImport.apiConfig);
                                if(dataToImport.themeSettings) await DBHelper.put('apiConfig', dataToImport.themeSettings);
                                if(dataToImport.giftApiConfig) await DBHelper.put('giftApiConfig', dataToImport.giftApiConfig);
                                

                                UIManager.showModal({
                                    title: "导入成功",
                                    body: `<p>数据已成功导入！应用即将自动刷新以应用更改。</p>`,
                                    actions: [{ text: '立即刷新', class: 'btn-primary', handler: () => window.location.reload() }]
                                });
                                setTimeout(() => window.location.reload(), 2000);

                            } catch (error) {
                                console.error("Import failed:", error);
                                UIManager.showModal({
                                    title: '导入失败',
                                    body: `<p>导入过程中发生严重错误: ${error.message}</p>`,
                                    actions: [{ text: '关闭', class: 'btn-danger', handler: () => UIManager.hideModal() }]
                                });
                            }
                        }}
                    ]
                });
            },
            
            async applyBackgroundSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const appContainer = $('#app-container');
                if (settings.appBackground) {
                    appContainer.style.backgroundImage = `url(${settings.appBackground})`;
                } else {
                    appContainer.style.backgroundImage = '';
                }
            },

            async applyFontSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;
                const fontSettings = settings.fonts || {};
                const customFonts = settings.customFonts || {};

                const fontTypes = {
                    Global: '--font-main',
                    Bubble: '--font-bubble',
                    InnerVoice: '--font-inner-voice',
                    Essay: '--font-essay'
                };

                
                const defaultFontValues = {
                    global: '"SimSun", "宋体", serif',
                    bubble: '"LXGW WenKai Screen", "Kaiti", "楷体", serif',
                    innervoice: '"Long Cang", cursive',
                    essay: '"Long Cang", cursive'
                };

                for (const [type, cssVar] of Object.entries(fontTypes)) {
                    const typeKey = type.toLowerCase();
                    const setting = fontSettings[typeKey]; 

                    if (setting && setting.type === 'custom' && customFonts[setting.value]) {
                        
                        const customFont = customFonts[setting.value];
                        root.style.setProperty(cssVar, `"${customFont.name}", sans-serif`);
                    } else if (setting && setting.type === 'builtin') {
                        
                        root.style.setProperty(cssVar, setting.value);
                    } else {
                        
                        
                        
                        
                        root.style.setProperty(cssVar, defaultFontValues[typeKey]);
                    }
                }
            },

            async loadAndApplyFontsInBackground() {
                
                try {
                    await this.loadCustomFontsOnStartup();
                    await this.applyFontSettings();
                    console.log("Custom fonts and settings applied in the background.");
                } catch (error) {
                    console.error("Failed to load and apply fonts in background:", error);
                }
            },

            async applyChatInterfaceStyleSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;
                root.style.setProperty('--chat-ui-bg-color', settings.chatUiColor || '#FFFFFF');
                root.style.setProperty('--chat-feature-btn-color', settings.chatFeatureBtnColor || getComputedStyle(root).getPropertyValue('--text-color-medium').trim());
                root.style.setProperty('--chat-feature-btn-active-color', settings.chatFeatureBtnActiveColor || getComputedStyle(root).getPropertyValue('--accent-color').trim());
            },

            async applyChatSpecificStyles() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};

                const setButtonIcon = (buttonId, iconUrl, defaultIconHtml, style) => {
                    const button = $(buttonId);
                    if (!button) return;

                    if (iconUrl) {
                        const existingImg = button.querySelector('img');
                        if (existingImg && existingImg.src === iconUrl) return;

                        const img = new Image();
                        img.onload = () => {
                            button.innerHTML = `<img src="${iconUrl}" style="${style}">`;
                        };
                        img.onerror = () => {
                            button.innerHTML = defaultIconHtml;
                            console.warn(`无法加载自定义图标: ${iconUrl}`);
                        };
                        img.src = iconUrl;
                    } else {
                        button.innerHTML = defaultIconHtml;
                    }
                };

                setButtonIcon(
                    '#chat-insight-btn', 
                    settings.insightIconUrl, 
                    '<i class="fas fa-clover"></i>',
                    'width: 1.8rem; height: 1.8rem; object-fit: contain; border-radius: 4px; position: relative; top: 2px;' /* 增大尺寸并下移 */
                );

                setButtonIcon(
                    '#ai-request-btn', 
                    settings.aiRequestBtnUrl, 
                    '<i class="fas fa-feather-alt"></i>',
                    'width: 2.2rem; height: 2.2rem; object-fit: contain;' /* 增大尺寸 */
                );
                
                setButtonIcon(
                    '#send-btn', 
                    settings.sendBtnUrl, 
                    '<i class="fas fa-paper-plane"></i>',
                    'width: 1.8rem; height: 1.8rem; object-fit: contain;' /* 增大尺寸 */
                );
            },

        async renderThemeSettingsPage() {
            const contentArea = $('#theme-settings-content');
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            appState.theme = chatSettings.theme || 'neumorphic';
            
            const pageColor = settings.pageColor || 'rgba(255, 255, 255, 0.5)';
            const uiButtonColor = settings.uiButtonColor || getComputedStyle(document.documentElement).getPropertyValue('--text-color-light').trim();
            const uiButtonActiveColor = settings.uiButtonActiveColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
            
            const chatUiColor = settings.chatUiColor || '#FFFFFF';
            const chatFeatureBtnColor = settings.chatFeatureBtnColor || getComputedStyle(document.documentElement).getPropertyValue('--text-color-medium').trim();
            const chatFeatureBtnActiveColor = settings.chatFeatureBtnActiveColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
            const insightIconUrl = settings.insightIconUrl || '';
            const aiRequestBtnUrl = settings.aiRequestBtnUrl || '';
            const sendBtnUrl = settings.sendBtnUrl || '';

            contentArea.innerHTML = `
                <style>
                    .theme-setting-card .color-input-group { display: flex; flex-direction: column; align-items: center; gap: 8px; }
                    .theme-setting-card .color-input-group label { font-size: 0.9rem; color: var(--text-color-medium); }
                </style>
                <div class="theme-setting-card">
                    <h3>弹窗风格</h3>
                    <div style="display: flex; justify-content: space-around; padding-top: 10px;">
                        <label style="cursor:pointer;"><input type="radio" name="modal-theme" value="default" ${appState.theme !== 'neumorphic' ? 'checked' : ''}> 默认</label>
                        <label style="cursor:pointer;"><input type="radio" name="modal-theme" value="neumorphic" ${appState.theme === 'neumorphic' ? 'checked' : ''}> 拟态</label>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3>通用设置</h3>
                    <div class="theme-setting-group">
                       <button id="font-settings-btn" class="theme-page-btn">字体设置</button>
                       <button id="background-settings-btn" class="theme-page-btn">背景与封面</button>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3 style="display: flex; justify-content: space-between; align-items: center;">
                        <span>页面风格</span>
                        <button id="reset-page-style-btn" class="font-delete-btn" title="恢复默认" style="background: rgba(0,0,0,0.05); border: none; border-radius: 5px; cursor: pointer; transition: all 0.2s;"><i class="fas fa-sync-alt"></i></button>
                    </h3>
                    <div class="theme-setting-group">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>页面UI颜色</span>
                            <div class="color-picker-container">
                                <input type="color" id="page-color-picker" value="${pageColor}">
                                <input type="text" class="color-hex-input" id="page-color-hex" value="${pageColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 5px 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>按钮默认颜色</span>
                            <div class="color-picker-container">
                                <input type="color" id="ui-button-color-picker" value="${uiButtonColor}">
                                <input type="text" class="color-hex-input" id="ui-button-color-hex" value="${uiButtonColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>按钮激活颜色</span>
                            <div class="color-picker-container">
                                <input type="color" id="ui-button-active-color-picker" value="${uiButtonActiveColor}">
                                <input type="text" class="color-hex-input" id="ui-button-active-color-hex" value="${uiButtonActiveColor}" maxlength="7" size="7">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3>聊天界面风格</h3>
                    <div class="theme-setting-group">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>界面UI颜色</span>
                            <div class="color-picker-container">
                                <input type="color" id="chat-ui-color-picker" value="${chatUiColor}">
                                <input type="text" class="color-hex-input" id="chat-ui-color-hex" value="${chatUiColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>功能按钮默认颜色</span>
                            <div class="color-picker-container">
                                <input type="color" id="chat-feature-btn-color-picker" value="${chatFeatureBtnColor}">
                                <input type="text" class="color-hex-input" id="chat-feature-btn-color-hex" value="${chatFeatureBtnColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>功能按钮激活颜色</span>
                            <div class="color-picker-container">
                                <input type="color" id="chat-feature-btn-active-color-picker" value="${chatFeatureBtnActiveColor}">
                                <input type="text" class="color-hex-input" id="chat-feature-btn-active-color-hex" value="${chatFeatureBtnActiveColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 5px 0;">
                        <div class="form-group" style="margin-bottom: 0;">
                            <label for="insight-icon-url-input">角色洞察图标URL (选填)</label>
                            <input type="text" id="insight-icon-url-input" value="${insightIconUrl}" placeholder="输入图片链接...">
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label for="ai-request-btn-url-input">小羽毛按钮URL (选填)</label>
                            <input type="text" id="ai-request-btn-url-input" value="${aiRequestBtnUrl}" placeholder="输入图片链接...">
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label for="send-btn-url-input">发送按钮URL (选填)</label>
                            <input type="text" id="send-btn-url-input" value="${sendBtnUrl}" placeholder="输入图片链接...">
                        </div>
                    </div>
                </div>
            `;
            
            $('#theme-settings-back-btn').onclick = () => UIManager.navigateTo('settings');

            $('#reset-page-style-btn').onclick = async () => {
                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                delete settingsToSave.pageColor;
                delete settingsToSave.uiButtonColor;
                delete settingsToSave.uiButtonActiveColor;
                await DBHelper.put('apiConfig', settingsToSave);
                await this.applyPageStyleSettings();
                await this.renderThemeSettingsPage();
                UIManager.showToast("页面风格已恢复默认");
            };

            const savePageStyleSettings = async () => {
                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                settingsToSave.pageColor = $('#page-color-picker').value;
                settingsToSave.uiButtonColor = $('#ui-button-color-picker').value;
                settingsToSave.uiButtonActiveColor = $('#ui-button-active-color-picker').value;
                await DBHelper.put('apiConfig', settingsToSave);
                await this.applyPageStyleSettings();
            };

            const saveChatInterfaceSettings = async () => {
                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                settingsToSave.chatUiColor = $('#chat-ui-color-picker').value;
                settingsToSave.chatFeatureBtnColor = $('#chat-feature-btn-color-picker').value;
                settingsToSave.chatFeatureBtnActiveColor = $('#chat-feature-btn-active-color-picker').value;
                settingsToSave.insightIconUrl = $('#insight-icon-url-input').value.trim();
                settingsToSave.aiRequestBtnUrl = $('#ai-request-btn-url-input').value.trim();
                settingsToSave.sendBtnUrl = $('#send-btn-url-input').value.trim();
                await DBHelper.put('apiConfig', settingsToSave);
                await this.applyChatInterfaceStyleSettings();
                await this.applyChatSpecificStyles();
            };

            $('#page-color-picker').oninput = savePageStyleSettings;
            $('#ui-button-color-picker').oninput = savePageStyleSettings;
            $('#ui-button-active-color-picker').oninput = savePageStyleSettings;
            
            $('#chat-ui-color-picker').oninput = saveChatInterfaceSettings;
            $('#chat-feature-btn-color-picker').oninput = saveChatInterfaceSettings;
            $('#chat-feature-btn-active-color-picker').oninput = saveChatInterfaceSettings;
            $('#insight-icon-url-input').onchange = saveChatInterfaceSettings;
            $('#ai-request-btn-url-input').onchange = saveChatInterfaceSettings;
            $('#send-btn-url-input').onchange = saveChatInterfaceSettings;

            EventManager._syncColorInputs('page-color-picker', 'page-color-hex');
            EventManager._syncColorInputs('ui-button-color-picker', 'ui-button-color-hex');
            EventManager._syncColorInputs('ui-button-active-color-picker', 'ui-button-active-color-hex');
            EventManager._syncColorInputs('chat-ui-color-picker', 'chat-ui-color-hex');
            EventManager._syncColorInputs('chat-feature-btn-color-picker', 'chat-feature-btn-color-hex');
            EventManager._syncColorInputs('chat-feature-btn-active-color-picker', 'chat-feature-btn-active-color-hex');
            
            $$('input[name="modal-theme"]').forEach(radio => {
                radio.onchange = async (e) => {
                    appState.theme = e.target.value;
                    const settingsToSave = await DBHelper.get('apiConfig', 'chatSettings') || { id: 'chatSettings' };
                    settingsToSave.theme = appState.theme;
                    await DBHelper.put('apiConfig', settingsToSave);
                };
            });

            $('#font-settings-btn').onclick = () => this.handleFontSettings();

            $('#background-settings-btn').onclick = () => {
                UIManager.showModal({
                    title: "背景与封面",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="modal-bg-settings-btn-nav" style="cursor:pointer;">
                                <i class="fas fa-desktop"></i><span>应用/聊天背景</span><i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="modal-cover-settings-btn-nav" style="cursor:pointer;">
                                <i class="fas fa-photo-video"></i><span>自定义封面</span><i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: [{ text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });
                
                $('#modal-bg-settings-btn-nav').addEventListener('click', () => {
                    UIManager.hideModal();
                    this.handleBackgroundSettings();
                });
                $('#modal-cover-settings-btn-nav').addEventListener('click', () => {
                    UIManager.hideModal();
                    this.handleCoverSettings();
                });
            };
        },

            async renderBubbleSettingsPage() {
                const contentArea = $('#bubble-settings-content');
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const profile = await DBHelper.get('profile', 'myProfile'); 
                
                const bubbleStyles = {
                    'default': { name: '默认', type: 'A', style: 'background: white; border: 2px solid var(--player-bubble-bg);' },
                    '3d': { name: '立体3D', type: 'A', style: 'background: var(--player-bubble-bg); border-bottom: 3px solid rgba(0,0,0,0.2); border-radius: 12px;' },
                    'neumorphic': { name: '拟态', type: 'A', style: 'background: var(--player-bubble-bg); box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #fff; color: #555;' },
                    'stripes': { name: '柔和条纹', type: 'A', style: 'background-color: var(--player-bubble-bg); background-image: repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.2) 15px, rgba(255, 255, 255, 0.1) 15px, rgba(255, 255, 255, 0.1) 30px);' },
                    'grid': { name: '网格', type: 'A', style: 'background-image: linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px); background-color: color-mix(in srgb, var(--player-bubble-bg) 80%, transparent);' },
                    'cute': { name: '可爱风', type: 'A', style: 'background: transparent; border: 2px solid var(--player-bubble-bg); border-radius: 25px 25px 5px 25px;' },
                    'simple-os': { name: '简约os', type: 'A', style: 'background-color: color-mix(in srgb, var(--player-bubble-bg) 60%, transparent); border: 1px solid rgba(255, 255, 255, 0.2); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);' },
                    'neumorphic-2': { name: '拟态2', type: 'B', style: 'background: #F0F0F3; box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.9), 5px 5px 9px rgba(174, 174, 192, 0.4);' },
                    'ancient': { name: '古风', type: 'B', style: 'background: #f5f0e1; color: #5d4037; border: 2px solid #8d6e63;' },
                    'chinese': { name: '国风', type: 'B', style: 'background: #c81e1e; border: 1px solid #f9d56e; color: #f9d56e;' },
                    'doodle': { name: '手绘涂鸦', type: 'B', style: 'background: white; border: 2px solid #333; color: #333; box-shadow: 3px 3px 0px #ccc; border-radius: 15px 10px 15px 12px;' },
                    'hand-drawn': { name: '手绘涂鸦2', type: 'B', style: 'background: white; border: 3px solid #333; box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.1); font-family: "Comic Sans MS", cursive; color: #333;' },
                    'stripey': { name: '可爱条纹', type: 'B', style: 'background: repeating-linear-gradient(45deg, #FFC0CB, #FFC0CB 10px, #F8C8D1 10px, #F8C8D1 20px);' },
                    'gradient': { name: '渐变彩虹', type: 'B', style: 'background: linear-gradient(45deg, #a1c4fd, #c2e9fb, #ff9a9e, #a1c4fd); animation: gradientBG 8s ease infinite; background-size: 300% 300%;' },
                    'glow-jelly': { name: '发光果冻', type: 'B', style: 'background: linear-gradient(135deg, #ff7e5f, #feb47b); box-shadow: 0 0 15px rgba(255, 126, 95, 0.7);' },
                    'metal': { name: '金属质感', type: 'B', style: 'background: linear-gradient(145deg, #e0e0e0, #c0c0c0);' },
                    'ocean': { name: '海洋风', type: 'B', style: 'background: linear-gradient(160deg, #0077b6, #00b4d8);' },
                    'paw': { name: '猫爪风', type: 'B', style: 'background: #fce1cb; color: #8b5e34;' },
                    'wechat': { name: '绿色', type: 'B', style: 'background-color: #95EC6A;' },
                    'custom': { name: '自定义', type: 'B', style: 'background: #f0f0f0; border: 2px dashed #ccc; color: #999 !important;' },
                };

                const currentStyle = settings.bubbleStyle || 'default';
                let bubbleStyleOptionsHTML = '';
                for (const [key, value] of Object.entries(bubbleStyles)) {
                    bubbleStyleOptionsHTML += `
                        <div class="bubble-style-option ${currentStyle === key ? 'selected' : ''}" data-style-key="${key}">
                            <div class="bubble-style-preview" style="${value.style}"><span>${value.type}</span></div>
                            <span>${value.name}</span>
                        </div>
                    `;
                }
                
                const fontSizeOptions = {
                    'small': { name: '小', value: '0.8rem' },
                    'normal-small': { name: '较小', value: '0.88rem' },
                    'default': { name: '默认', value: '0.95rem' },
                    'normal-large': { name: '较大', value: '1.05rem' },
                    'large': { name: '大', value: '1.15rem' }
                };
                const currentFontSizeKey = settings.bubbleFontSize || 'default';
                const fontSizeRadioHTML = Object.entries(fontSizeOptions).map(([key, value]) => `
                    <label style="cursor:pointer;"><input type="radio" name="font-size-radio" value="${key}" ${currentFontSizeKey === key ? 'checked' : ''}> ${value.name}</label>
                `).join('');

                contentArea.innerHTML = `
                     <style>
                        .theme-setting-card .color-input-group { display: flex; flex-direction: column; align-items: center; gap: 8px; }
                        .theme-setting-card .color-input-group label { font-size: 0.9rem; color: var(--text-color-medium); }
                        .bubble-style-options-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; justify-content: center; margin-top: 10px; }
                        .bubble-style-option { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 10px; border-radius: 10px; border: 2px solid transparent; transition: all 0.3s ease; background-color: rgba(0,0,0,0.03); }
                        .bubble-style-option.selected { border-color: var(--accent-color); transform: scale(1.05); }
                        .bubble-style-option:hover { background-color: rgba(0,0,0,0.06); }
                        .bubble-style-preview { width: 80px; height: 40px; border-radius: 10px; margin-bottom: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.05); display: flex; justify-content: center; align-items: center; font-size: 0.8rem; color: white; text-shadow: 1px 1px 1px rgba(0,0,0,0.2); font-weight: bold; }
                        .bubble-style-option span { font-size: 0.9rem; color: var(--text-color-dark); text-align: center; }
                        .bubble-style-preview span { color: white; }
                    </style>
                    <div class="theme-setting-card">
                        <h3>聊天字体大小</h3>
                        <div id="font-size-radio-group" style="display: flex; justify-content: space-around; padding-top: 10px;">
                            ${fontSizeRadioHTML}
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-light); text-align: center; margin-top: 10px; padding: 0 15px;">
                            聊天字体大小同时还取决于自定义字体因素影响
                        </p>
                    </div>
                    <div class="theme-setting-card" id="bubble-color-card">
                        <h3>气泡颜色 (限A类气泡)</h3>
                        <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px; margin-top: 15px;">
                            <div class="color-input-group">
                                <label for="friend-bubble-bg-color">好友消息背景</label>
                                <div class="color-picker-container">
                                    <input type="color" id="friend-bubble-bg-color" value="${settings.friendBubbleBg || '#FFFFFF'}">
                                    <input type="text" class="color-hex-input" id="friend-bubble-bg-hex" value="${settings.friendBubbleBg || '#FFFFFF'}" maxlength="7" size="7">
                                </div>
                            </div>
                            <div class="color-input-group">
                                <label for="player-bubble-bg-color">我的消息背景</label>
                                <div class="color-picker-container">
                                    <input type="color" id="player-bubble-bg-color" value="${settings.playerBubbleBg || '#A7C7E7'}">
                                    <input type="text" class="color-hex-input" id="player-bubble-bg-hex" value="${settings.playerBubbleBg || '#A7C7E7'}" maxlength="7" size="7">
                                </div>
                            </div>
                        </div>
                    </div>
                     <div class="theme-setting-card">
                        <h3>聊天气泡字体颜色</h3>
                         <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px; margin-top: 15px;">
                            <div class="color-input-group">
                                <label for="friend-bubble-text-color">好友消息</label>
                                <div class="color-picker-container">
                                    <input type="color" id="friend-bubble-text-color" value="${settings.friendBubbleTextColor || '#5D534A'}">
                                    <input type="text" class="color-hex-input" id="friend-bubble-text-hex" value="${settings.friendBubbleTextColor || '#5D534A'}" maxlength="7" size="7">
                                </div>
                            </div>
                            <div class="color-input-group">
                                <label for="player-bubble-text-color">我的消息</label>
                                <div class="color-picker-container">
                                    <input type="color" id="player-bubble-text-color" value="${settings.playerBubbleTextColor || '#FFFFFF'}">
                                    <input type="text" class="color-hex-input" id="player-bubble-text-hex" value="${settings.playerBubbleTextColor || '#FFFFFF'}" maxlength="7" size="7">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="theme-setting-card">
                        <h3>聊天气泡样式</h3>
                        <div id="bubble-style-options" class="bubble-style-options-container">${bubbleStyleOptionsHTML}</div>
                    </div>
                    <div class="theme-setting-card">
                        <h3>自定义气泡样式</h3>
                        <div class="css-editor-container">
                            <div class="css-editor-slots" style="display: flex; gap: 10px; margin-bottom: 15px; justify-content: center;">
                                <button class="modal-btn btn-secondary slot-btn" data-slot="1">存档 1</button>
                                <button class="modal-btn btn-secondary slot-btn" data-slot="2">存档 2</button>
                                <button class="modal-btn btn-secondary slot-btn" data-slot="3">存档 3</button>
                            </div>
                            <textarea id="custom-bubble-css-input" placeholder="在此处输入您的自定义CSS代码..."></textarea>
                            <div class="editor-actions">
                                <button id="reset-custom-css-btn" class="modal-btn btn-secondary">清空</button>
                                <button id="preview-custom-css-btn" class="modal-btn btn-primary">预览</button>
                                <button id="save-custom-css-btn" class="modal-btn btn-primary">保存</button>
                                <button id="apply-custom-css-btn" class="modal-btn btn-primary">应用</button>
                            </div>
                        </div>
                    </div>
                    <div class="theme-setting-card">
                        <h3>效果预览</h3>
                        <style id="custom-bubble-preview-style"></style>
                        <div id="custom-bubble-preview" class="css-preview-area"></div>
                    </div>
                    <div class="theme-setting-card">
                        <h3>教程与示例</h3>
                        <p style="font-size:0.9rem; color:var(--text-color-medium); margin-bottom:16px;">您可以复制以下示例代码作为起点进行修改或发送给AI进行修改。请注意，为了安全，仅支持基础的CSS选择器和属性。</p>
                        <p style="font-size:0.9rem; color:var(--text-color-medium); margin-bottom:10px;"><strong>注意：</strong>请确保你使用的气泡代码是<strong>自己编写/自己使用AI生成/其他制作老师同意使用的</strong>。请勿未经授权/允许二用他人的任何设定或产出，<span style="color: red; font-weight: bold;">请尊重所有人的任何产出</span>，否则后续问题需自行负责。</p>
                        <pre id="css-tutorial-code-block" class="css-tutorial-code"><button class="copy-btn">复制</button><code>

/* --- 好友的气泡 --- */
.bubble {
    border-radius: 20px !important;
}

.bubble.received {
  background-color: #FFFFFF;
  color: var(--friend-bubble-text-color) !important;
  border: 1px solid #E0E0E0;
  border-radius: 16px 16px 16px 5px;
}

/* --- 我的气泡 --- */
.bubble.sent {
  background-color: #A7C7E7;
  color: var(--player-bubble-text-color) !important;
  border-radius: 16px 16px 5px 16px;
}
</code></pre>
                    </div>
                `;
                
                $('#bubble-settings-back-btn').onclick = () => UIManager.navigateTo('settings');
                
                
                const previewArea = $('#custom-bubble-preview');
                previewArea.innerHTML = `
                    <div class="message-row received">
                        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDQwIDQwIj48cmVjdCB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIGZpbGw9IiNjY2Q0Y2MiLz48L3N2Zz4=" alt="avatar" class="message-avatar">
                        <div class="message-content">
                            <div class="bubble received">这是好友的消息气泡。</div>
                        </div>
                    </div>
                    <div class="message-row sent">
                        <img src="${profile.avatar}" alt="avatar" class="message-avatar">
                        <div class="message-content">
                            <div class="bubble sent">这是我的消息气泡。</div>
                        </div>
                    </div>
                `;
                
                
                const cssInput = $('#custom-bubble-css-input');
                const customCSSSlots = settings.customBubbleCSSSlots || { '1': '', '2': '', '3': '' };
                const activeSlot = settings.activeCustomCSSSlot || '1';
                cssInput.value = customCSSSlots[activeSlot] || '';

                const previewStyleTag = $('#custom-bubble-preview-style');
                previewStyleTag.textContent = this._scopeCSS(cssInput.value, '#custom-bubble-preview');

                
                
                $$('.slot-btn').forEach(btn => {
                    if (btn.dataset.slot === activeSlot) {
                        btn.classList.add('btn-primary');
                        btn.classList.remove('btn-secondary');
                    }
                    btn.onclick = async () => {
                        const newActiveSlot = btn.dataset.slot;
                        
                        
                        $$('.slot-btn').forEach(b => {
                            b.classList.remove('btn-primary');
                            b.classList.add('btn-secondary');
                        });
                        btn.classList.add('btn-primary');
                        btn.classList.remove('btn-secondary');
                        
                        
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.activeCustomCSSSlot = newActiveSlot;
                        await DBHelper.put('apiConfig', settingsToSave);

                        
                        const slots = settingsToSave.customBubbleCSSSlots || { '1': '', '2': '', '3': '' };
                        cssInput.value = slots[newActiveSlot] || '';
                        
                        
                        const previewStyle = $('#custom-bubble-preview-style');
                        const scopedCss = this._scopeCSS(cssInput.value, '#custom-bubble-preview');
                        previewStyle.textContent = scopedCss;
                    };
                });


                $('#reset-custom-css-btn').onclick = () => this.handleResetCustomCSS();
                $('#preview-custom-css-btn').onclick = () => this.handlePreviewCustomCSS();
                $('#save-custom-css-btn').onclick = () => this.handleSaveCustomCSS();
                $('#apply-custom-css-btn').onclick = () => this.handleApplyCustomCSS();
                $('.css-tutorial-code .copy-btn').onclick = () => this.handleCopyTutorialCSS();

                EventManager._syncColorInputs('friend-bubble-bg-color', 'friend-bubble-bg-hex');
                EventManager._syncColorInputs('player-bubble-bg-color', 'player-bubble-bg-hex');
                EventManager._syncColorInputs('friend-bubble-text-color', 'friend-bubble-text-hex');
                EventManager._syncColorInputs('player-bubble-text-color', 'player-bubble-text-hex');
                
                $('#font-size-radio-group').onchange = async (e) => {
                    if (e.target.name === 'font-size-radio') {
                        const sizeKey = e.target.value;
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.bubbleFontSize = sizeKey;
                        await DBHelper.put('apiConfig', settingsToSave);
                        await this.applyBubbleFontSize(); 
                    }
                };

                const saveBubbleSettings = async () => {
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    settingsToSave.bubbleStyle = document.querySelector('.bubble-style-option.selected').dataset.styleKey;
                    settingsToSave.friendBubbleBg = $('#friend-bubble-bg-color').value;
                    settingsToSave.playerBubbleBg = $('#player-bubble-bg-color').value;
                    settingsToSave.friendBubbleTextColor = $('#friend-bubble-text-color').value;
                    settingsToSave.playerBubbleTextColor = $('#player-bubble-text-color').value;
                    await DBHelper.put('apiConfig', settingsToSave);
                    await this.applyBubbleSettings();
                };

                $('#bubble-style-options').onclick = (e) => {
                    const option = e.target.closest('.bubble-style-option');
                    if (!option) return;
                    $$('.bubble-style-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    const isTypeA = bubbleStyles[option.dataset.styleKey].type === 'A';
                    $('#bubble-color-card').style.display = isTypeA ? 'block' : 'none';
                    saveBubbleSettings();
                };

                ['friend-bubble-bg-color', 'player-bubble-bg-color', 'friend-bubble-text-color', 'player-bubble-text-color'].forEach(id => {
                    $(`#${id}`).oninput = saveBubbleSettings; 
                });
                
                const initialStyleIsTypeA = bubbleStyles[currentStyle].type === 'A';
                $('#bubble-color-card').style.display = initialStyleIsTypeA ? 'block' : 'none';
            },

        async handleBackgroundSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const createUploadHTML = (type, title, previewSrc, dbKey) => `
                <div class="theme-upload-item">
                    <span>${title}</span>
                    <div class="theme-upload-preview-wrapper">
                        <img src="${previewSrc || ''}" id="${type}-preview" class="theme-upload-preview" style="${previewSrc ? '' : 'display:none;'}">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="file" id="${type}-input" accept="image/*" style="display: none;">
                        <button class="theme-page-btn" onclick="document.getElementById('${type}-input').click()">上传</button>
                        <button class="theme-page-btn" id="${type}-remove-btn" style="${previewSrc ? '' : 'display:none;'}">移除</button>
                    </div>
                </div>`;

            UIManager.showModal({
                title: '背景设置',
                body: `
                    <div class="theme-setting-group" style="padding: 10px 0;">
                        ${createUploadHTML('app-bg', '主题背景', settings.appBackground, 'appBackground')}
                        ${createUploadHTML('global-bg', '聊天背景', settings.globalChatBg, 'globalChatBg')}
                    </div>`,
                actions: [{ text: '完成', class: 'btn-primary', handler: () => UIManager.hideModal() }]
            });

            const setupUploadHandler = (type, dbKey) => {
                const input = $(`#${type}-input`);
                const preview = $(`#${type}-preview`);
                const removeBtn = $(`#${type}-remove-btn`);
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64 = await Utils.fileToBase64(file);
                        preview.src = base64;
                        preview.style.display = 'block';
                        removeBtn.style.display = 'inline-block';
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave[dbKey] = base64;
                        await DBHelper.put('apiConfig', settingsToSave);
                        if (dbKey === 'appBackground') await EventManager.applyBackgroundSettings();
                        if (dbKey === 'globalChatBg' && appState.currentPage === 'chat' && appState.currentChatId) await UIManager.applyChatBackground(appState.currentChatId);
                        UIManager.showToast('图片已更新');
                    } catch (error) { 
                        console.error("图片上传或应用失败:", error);
                        UIManager.showToast('图片处理失败'); 
                    }
                };
                removeBtn.onclick = async () => {
                    preview.src = '';
                    preview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    input.value = '';
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    delete settingsToSave[dbKey];
                    await DBHelper.put('apiConfig', settingsToSave);
                    if (dbKey === 'appBackground') await EventManager.applyBackgroundSettings();
                    if (dbKey === 'globalChatBg' && appState.currentPage === 'chat' && appState.currentChatId) await UIManager.applyChatBackground(appState.currentChatId);
                    UIManager.showToast('图片已移除');
                };
            };
            setupUploadHandler('app-bg', 'appBackground');
            setupUploadHandler('global-bg', 'globalChatBg');
        },

        async handleCoverSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const createUploadHTML = (type, title, previewSrc, dbKey, previewStyle = '') => `
                <div class="theme-upload-item">
                    <span>${title}</span>
                    <div class="theme-upload-preview-wrapper" style="${previewStyle}">
                        <img src="${previewSrc || ''}" id="${type}-preview" class="theme-upload-preview" style="${previewSrc ? '' : 'display:none;'}">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="file" id="${type}-input" accept="image/*" style="display: none;">
                        <button class="theme-page-btn" onclick="document.getElementById('${type}-input').click()">上传</button>
                        <button class="theme-page-btn" id="${type}-remove-btn" style="${previewSrc ? '' : 'display:none;'}">移除</button>
                    </div>
                </div>`;

            UIManager.showModal({
                title: '自定义封面',
                body: `
                    <div class="theme-setting-group" style="padding: 10px 0;">
                        ${createUploadHTML('rp-cover', '红包封面', settings.redPacketCover, 'redPacketCover', 'width: 80px; height: 106px;')}
                        ${createUploadHTML('transfer-cover', '转账封面', settings.transferCover, 'transferCover')}
                        ${createUploadHTML('receipt-cover', '收款封面', settings.receiptCover, 'receiptCover')}
                    </div>`,
                actions: [{ text: '完成', class: 'btn-primary', handler: () => UIManager.hideModal() }]
            });

            const setupUploadHandler = (type, dbKey) => {
                const input = $(`#${type}-input`);
                const preview = $(`#${type}-preview`);
                const removeBtn = $(`#${type}-remove-btn`);
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64 = await Utils.compressImage(file, 800, 800, 0.7);
                        preview.src = base64;
                        preview.style.display = 'block';
                        removeBtn.style.display = 'inline-block';
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave[dbKey] = base64;
                        await DBHelper.put('apiConfig', settingsToSave);
                        UIManager.showToast('封面已更新');
                    } catch (error) { UIManager.showToast('图片处理失败'); }
                };
                removeBtn.onclick = async () => {
                    preview.src = '';
                    preview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    input.value = '';
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    delete settingsToSave[dbKey];
                    await DBHelper.put('apiConfig', settingsToSave);
                    UIManager.showToast('封面已移除');
                };
            };
            setupUploadHandler('rp-cover', 'redPacketCover');
            setupUploadHandler('transfer-cover', 'transferCover');
            setupUploadHandler('receipt-cover', 'receiptCover');
        },

            async applyBubbleSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;
                const appContainer = $('#app-container');

                root.style.setProperty('--friend-bubble-bg', settings.friendBubbleBg || '#FFFFFF');
                root.style.setProperty('--player-bubble-bg', settings.playerBubbleBg || 'var(--accent-color)');
                root.style.setProperty('--friend-bubble-text-color', settings.friendBubbleTextColor || '#5D534A');
                root.style.setProperty('--player-bubble-text-color', settings.playerBubbleTextColor || '#FFFFFF');

                const styleKey = settings.bubbleStyle || 'default';
                const classList = Array.from(appContainer.classList);
                
                let newClassList = classList.filter(c => !c.startsWith('app-bubble-style-'));
                if(classList.includes('bottom-offset-active')) {
                    if(!newClassList.includes('bottom-offset-active')) {
                         newClassList.push('bottom-offset-active');
                    }
                }
                
                newClassList.push(`app-bubble-style-${styleKey}`);
                appContainer.className = newClassList.join(' ');

                
                await this.loadAndApplyCustomBubbleCSS();
            },

        async applyBubbleFontSize() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const fontSizeKey = settings.bubbleFontSize || 'default';
            const fontSizes = {
                'small': '0.8rem',
                'normal-small': '0.88rem',
                'default': '0.95rem',
                'normal-large': '1.05rem',
                'large': '1.15rem'
            };
            document.documentElement.style.setProperty('--font-bubble-size', fontSizes[fontSizeKey]);
        },

            async loadAndApplyCustomBubbleCSS() {
                let customStyleTag = document.getElementById('global-custom-bubble-style');
                if (!customStyleTag) {
                    customStyleTag = document.createElement('style');
                    customStyleTag.id = 'global-custom-bubble-style';
                    document.head.appendChild(customStyleTag);
                }

                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const activeSlot = settings.activeCustomCSSSlot || '1';
                const cssSlots = settings.customBubbleCSSSlots || {};
                const activeCSS = cssSlots[activeSlot] || '';

                if (settings.bubbleStyle === 'custom' && activeCSS) {
                    const scopedCss = this._scopeCSS(activeCSS, '#app-container.app-bubble-style-custom .chat-area');
                    customStyleTag.textContent = scopedCss;
                } else {
                    customStyleTag.textContent = ''; 
                }
            },

            async applyPageStyleSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;

                const pageColor = settings.pageColor || 'rgba(255, 255, 255, 0.5)';
                const texture = 'none'; 
                const buttonColor = settings.uiButtonColor || getComputedStyle(root).getPropertyValue('--text-color-light').trim();
                const buttonActiveColor = settings.uiButtonActiveColor || getComputedStyle(root).getPropertyValue('--accent-color').trim();

                root.style.setProperty('--ui-bg-color', pageColor);
                root.style.setProperty('--ui-texture-image', texture);
                root.style.setProperty('--ui-button-color', buttonColor);
                root.style.setProperty('--ui-button-active-color', buttonActiveColor);
            },

        async handleFontSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const fontSettings = settings.fonts || {};
            const customFonts = settings.customFonts || {};

            const builtinFonts = {
                '宋体 (SimSun)': '"SimSun", "宋体", serif',
                '楷体 (LXGW WenKai)': '"LXGW WenKai Screen", "Kaiti", "楷体", serif',
                '龙藏体 (Long Cang)': '"Long Cang", cursive',
                'System Default': `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif`,
            };
            
            const defaultFontValues = {
                global: builtinFonts['宋体 (SimSun)'],
                bubble: builtinFonts['楷体 (LXGW WenKai)'],
                innervoice: builtinFonts['龙藏体 (Long Cang)'],
                essay: builtinFonts['龙藏体 (Long Cang)']
            };

            const createFontSelectorHTML = (typeKey, typeLabel) => {
                const settingKey = typeKey.toLowerCase();
                const currentSetting = fontSettings[settingKey] || { type: 'builtin', value: defaultFontValues[settingKey] };

                
                let optionsHTML = Object.entries(builtinFonts).map(([name, value]) =>
                    `<option value='${value}' data-type="builtin" ${currentSetting.type === 'builtin' && currentSetting.value === value ? 'selected' : ''}>${name}</option>`
                ).join('');

                for (const [key, font] of Object.entries(customFonts)) {
                    optionsHTML += `<option value="${key}" data-type="custom" ${currentSetting.type === 'custom' && currentSetting.value === key ? 'selected' : ''}>${font.name} (自定义)</option>`;
                }

                return `
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                        <label>${typeLabel}</label>
                        <select class="font-select" data-font-type="${settingKey}" style="flex-grow: 1; max-width: 60%;">${optionsHTML}</select>
                    </div>`;
            };

            UIManager.showModal({
                title: "字体设置",
                body: `
                    <div class="form-group" style="display: flex; justify-content: space-around; padding-bottom: 15px; border-bottom: 1px dashed var(--border-color);">
                        <button id="font-upload-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">本地</button>
                        <button id="font-url-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">网络</button>
                        <button id="font-delete-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">删除</button>
                    </div>
                    <div style="margin-top: 20px;">
                        ${createFontSelectorHTML('Global', '全局字体')}
                        ${createFontSelectorHTML('Bubble', '气泡字体')}
                        ${createFontSelectorHTML('InnerVoice', '心声字体')}
                        ${createFontSelectorHTML('Essay', '随笔字体')}
                    </div>
                `,
                actions: [
                    { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                    { text: '保存', class: 'btn-primary', handler: async () => {
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.fonts = settingsToSave.fonts || {};

                        $$('.font-select').forEach(select => {
                            const fontTypeKey = select.dataset.fontType;
                            const selectedOption = select.options[select.selectedIndex];
                            settingsToSave.fonts[fontTypeKey] = {
                                type: selectedOption.dataset.type,
                                value: selectedOption.value
                            };
                        });

                        await DBHelper.put('apiConfig', settingsToSave);
                        await this.applyFontSettings();
                        UIManager.hideModal();
                        UIManager.showToast("字体设置已保存并应用");
                    }}
                ]
            });

            $('#font-upload-btn').onclick = () => this.handleFontUpload(false);
            $('#font-url-btn').onclick = () => this.handleFontUrl(false);
            $('#font-delete-btn').onclick = () => this.handleDeleteCustomFont();
        },

            async handleFontUpload() {
                UIManager.showModal({
                    title: "上传本地字体",
                    body: `
                        <div style="font-size: 0.9rem; line-height: 1.6;">
                            <p>请选择字体文件进行上传。支持的格式为 <code>.ttf</code>, <code>.otf</code>, <code>.woff</code>, <code>.woff2</code>。</p>
                            <p><strong>强烈推荐使用 <code>.woff2</code> 格式</strong>，因为它的文件体积更小，加载速度更快。</p>
                            <p>请尽量选择体积较小的字体文件/网络资源上传，过大的字体会导致刷新页面时加载变慢、甚至闪退。</p>
                            <p>如果真的想要上传本地字体，上传前请做好导出备份</p>
                            <p style="color: var(--text-color-medium); margin-top: 15px;">加载字体需要一些时间，选择使用自定义字体后刷新页面使字体生效。</p>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings(); 
                        }},
                        { text: '继续上传', class: 'btn-primary', handler: () => {
                            UIManager.hideModal(); 
                            this.triggerActualFontUpload(); 
                        }}
                    ]
                });
            },

            triggerActualFontUpload() {
                const fontFileInput = $('#font-file-input');
                fontFileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const fontName = file.name.split('.')[0];
                    try {
                        const base64 = await Utils.fileToBase64(file);
                        const customFontKey = `${Utils.generateId('font')}`;
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.customFonts = settingsToSave.customFonts || {};
                        settingsToSave.customFonts[customFontKey] = { name: fontName, data: base64 };
                        await DBHelper.put('apiConfig', settingsToSave);

                        
                        await this.loadCustomFontsOnStartup();
                        
                        this.handleFontSettings(); 
                        UIManager.showToast(`字体 "${fontName}" 上传成功！`);
                    } catch (error) {
                        UIManager.showToast("字体文件读取失败");
                    } finally {
                        fontFileInput.value = '';
                    }
                };
                fontFileInput.click();
            },

            async handleFontUrl() {
                UIManager.showModal({
                    title: "添加网络字体",
                    body: `
                        <div class="form-group">
                            <label for="font-url-name-input">字体名称 (自定义)</label>
                            <input type="text" id="font-url-name-input" placeholder="例如：思源黑体">
                        </div>
                        <div class="form-group">
                            <label for="font-url-input">字体文件 URL</label>
                            <input type="text" id="font-url-input" placeholder="https://.../font.woff2">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: '添加', class: 'btn-primary', handler: async () => {
                            const fontName = $('#font-url-name-input').value.trim();
                            const fontUrl = $('#font-url-input').value.trim();
                            if (!fontName || !fontUrl) return UIManager.showToast("名称和URL均不能为空");
                            if (!fontUrl.startsWith('http')) return UIManager.showToast("请输入有效的URL");

                            const customFontKey = `${Utils.generateId('font')}`;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            settingsToSave.customFonts = settingsToSave.customFonts || {};
                            settingsToSave.customFonts[customFontKey] = { name: fontName, data: fontUrl };
                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();

                            UIManager.hideModal();
                            this.handleFontSettings();
                            UIManager.showToast(`网络字体 "${fontName}" 添加成功！`);
                        }}
                    ]
                });
            },

            async handleDeleteCustomFont() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const customFonts = settings.customFonts || {};

                if (Object.keys(customFonts).length === 0) {
                    return UIManager.showToast("没有可删除的自定义字体");
                }

                
                const fontListHtml = Object.entries(customFonts).map(([key, font]) => `
                    <label class="member-select-item">
                        <input type="radio" name="delete-font-radio" value="${key}">
                        <span>${font.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "选择要删除的字体",
                    body: `<div class="member-select-list">${fontListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            const selectedRadio = $('input[name="delete-font-radio"]:checked');
                            if (!selectedRadio) return UIManager.showToast("请选择一个要删除的字体");

                            const fontKeyToDelete = selectedRadio.value;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            
                            
                            if (settingsToSave.customFonts && settingsToSave.customFonts[fontKeyToDelete]) {
                                delete settingsToSave.customFonts[fontKeyToDelete];
                            }

                            
                            if (settingsToSave.fonts) {
                                for (const typeKey in settingsToSave.fonts) {
                                    if (settingsToSave.fonts[typeKey].value === fontKeyToDelete) {
                                        
                                        settingsToSave.fonts[typeKey] = { type: 'builtin', value: '"SimSun", "宋体", serif' }; 
                                    }
                                }
                            }
                            
                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();
                            await this.applyFontSettings();
                            UIManager.hideModal();
                            UIManager.showToast("自定义字体已删除");
                            this.handleFontSettings(); 
                        }}
                    ]
                });
            },

            async loadCustomFontsOnStartup() {
                
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const fontSettings = settings.fonts || {}; 
                const customFonts = settings.customFonts || {}; 

                
                if (Object.keys(customFonts).length === 0) {
                    
                    let fontStyleTag = document.getElementById('dynamic-font-styles');
                    if (fontStyleTag) fontStyleTag.innerHTML = '';
                    return;
                }

                
                const activeCustomFontKeys = new Set();
                
                for (const setting of Object.values(fontSettings)) {
                    
                    if (setting.type === 'custom' && setting.value) {
                        
                        activeCustomFontKeys.add(setting.value);
                    }
                }

                
                let fontStyleTag = document.getElementById('dynamic-font-styles');
                if (!fontStyleTag) {
                    fontStyleTag = document.createElement('style');
                    fontStyleTag.id = 'dynamic-font-styles';
                    document.head.appendChild(fontStyleTag);
                }

                
                let fontFaceRules = '';
                
                for (const key of activeCustomFontKeys) {
                    const font = customFonts[key]; 
                    if (font && font.name && font.data) {
                        let src;
                        
                        if (font.data.startsWith('data:')) {
                            src = `url(${font.data})`;
                        } else {
                            src = `url('${font.data}')`;
                        }
                        
                        fontFaceRules += `@font-face { font-family: "${font.name}"; src: ${src}; }\n`;
                    }
                }

                
                fontStyleTag.innerHTML = fontFaceRules;
            },

            async handleFontUrl(fontTypeKey) {
                UIManager.showModal({
                    title: "添加网络字体",
                    body: `
                        <div class="form-group">
                            <label for="font-url-name-input">字体名称 (自定义)</label>
                            <input type="text" id="font-url-name-input" placeholder="例如：思源黑体">
                        </div>
                        <div class="form-group">
                            <label for="font-url-input">字体文件 URL</label>
                            <input type="text" id="font-url-input" placeholder="https://.../font.woff2">
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); text-align: center; margin-top: 10px;">
                            提示：字体文件越大，加载时间越长，请尽量选择体积较小的字体。
                        </p>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: '添加', class: 'btn-primary', handler: async () => {
                            const fontName = $('#font-url-name-input').value.trim();
                            const fontUrl = $('#font-url-input').value.trim();

                            if (!fontName || !fontUrl) {
                                return UIManager.showToast("名称和URL均不能为空");
                            }

                            
                            if (!fontUrl.startsWith('http')) {
                                return UIManager.showToast("请输入有效的URL");
                            }

                            const customFontKey = `${Utils.generateId('font')}`;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            settingsToSave.customFonts = settingsToSave.customFonts || {};
                            settingsToSave.fonts = settingsToSave.fonts || {};

                            
                            settingsToSave.customFonts[customFontKey] = { name: fontName, data: fontUrl };
                            settingsToSave.fonts[fontTypeKey] = { type: 'custom', value: customFontKey };

                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();
                            await this.applyFontSettings();
                            UIManager.hideModal();
                            
                            this.handleFontSettings();
                        }}
                    ]
                });
            },



            async handleChatBackgroundSettings(chatId, isGroup) {
                const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const currentBg = entity.chatBackground || null;
                const currentNameColor = entity.nameColor || '#888888';

                const createUploadSection = (id, label, previewSrc) => `
                    <div class="background-upload-section">
                        <label>${label}</label>
                        <img src="${previewSrc || 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='}" 
                             alt="${label}预览" 
                             class="background-preview" 
                             id="${id}-preview"
                             style="${previewSrc ? '' : 'display: none;'}">
                        <input type="file" id="${id}-input" accept="image/*" style="display: none;">
                        <button class="modal-btn btn-secondary" style="padding: 8px 15px;" onclick="document.getElementById('${id}-input').click()">上传</button>
                        <button class="modal-btn btn-danger" style="padding: 8px 15px; ${previewSrc ? '' : 'display: none;'}" id="${id}-remove-btn">移除</button>
                    </div>`;
                
                const createColorPickerSection = (id, label, value) => `
                     <div class="background-upload-section" style="flex-direction: row; justify-content: space-between; align-items: center; padding: 10px 20px;">
                        <label>${label}</label>
                        <div class="color-picker-container">
                             <input type="color" id="${id}-input" value="${value}">
                             <input type="text" class="color-hex-input" id="${id}-hex" value="${value}" maxlength="7" size="7">
                        </div>
                    </div>
                `;

                const currentNarratorStyle = entity.narratorStyle || 'grey';

                UIManager.showModal({
                    title: `专属设置 - ${entity.name}`,
                    customClass: 'theme-settings-modal',
                    body: `
                        <div class="form-group">
                           ${createUploadSection('exclusive-bg', '专属背景', currentBg)}
                        </div>
                        <div class="form-group">
                           ${createColorPickerSection('exclusive-name-color', '角色名字颜色', currentNameColor)}
                        </div>
                        <div class="form-group">
                            <label>旁白样式</label>
                            <div class="narrator-style-selector" id="narrator-style-selector">
                                <div class="narrator-style-option grey-option ${currentNarratorStyle === 'grey' ? 'selected' : ''}" data-style="grey">灰色</div>
                                <div class="narrator-style-option white-option ${currentNarratorStyle === 'white' ? 'selected' : ''}" data-style="white">白色</div>
                                <div class="narrator-style-option black-option ${currentNarratorStyle === 'black' ? 'selected' : ''}" data-style="black">黑色</div>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { 
                            text: '保存', 
                            class: 'btn-primary', 
                            
                            handler: () => {} 
                        }
                    ]
                });

                this._syncColorInputs('exclusive-name-color-input', 'exclusive-name-color-hex');
                
                const setupUpload = (id) => {
                    const input = $(`#${id}-input`);
                    const preview = $(`#${id}-preview`);
                    const removeBtn = $(`#${id}-remove-btn`);

                    input.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            preview.src = await Utils.fileToBase64(file);
                            preview.style.display = 'block';
                            removeBtn.style.display = 'inline-block';
                        }
                    });

                    removeBtn.addEventListener('click', () => {
                        preview.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; 
                        preview.style.display = 'none';
                        removeBtn.style.display = 'none';
                        input.value = ''; 
                    });
                };
                setupUpload('exclusive-bg');

                
                const narratorSelector = $('#narrator-style-selector');
                narratorSelector.addEventListener('click', (e) => {
                    const option = e.target.closest('.narrator-style-option');
                    if (!option) return;
                    
                    narratorSelector.querySelectorAll('.narrator-style-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');

                    const handler = narratorSelector.closest('.modal-content').querySelector('.modal-btn.btn-primary').__handler;
                    if(handler) {
                        handler.call(); 
                    }
                });

                const saveHandler = async () => {
                    const previewSrc = $('#exclusive-bg-preview').src;
                    const blankGif = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                    const newBg = (previewSrc.startsWith('data:image') && previewSrc !== blankGif) ? previewSrc : null;
                    const newNameColor = $('#exclusive-name-color-input').value;
                    const newNarratorStyle = narratorSelector.querySelector('.selected').dataset.style;

                    entity.chatBackground = newBg;
                    entity.nameColor = newNameColor;
                    entity.narratorStyle = newNarratorStyle;
                    await DBHelper.put(isGroup ? 'groups' : 'contacts', entity);

                    if (appState.currentChatId === chatId) {
                        await UIManager.applyChatBackground(chatId);
                        await UIManager.refreshChatView();
                    }

                    UIManager.hideModal();
                    UIManager.showToast('专属设置已保存！');
                };

                
                const saveButton = modalContentWrapper.querySelector('.modal-actions .btn-primary');
                if (saveButton) {
                    
                    saveButton.onclick = saveHandler;
                }
            },

            async renderApiSettingsPage() {
                await AIHandler.loadApiConfig();
                const config = AIHandler.apiConfig;

                const providerSelect = $('#api-provider');
                const urlInput = $('#api-url');
                const modelSelect = $('#api-model-select');
                const modelInput = $('#api-model-input');
                const tempInput = $('#temperature');

                const getApiProviderOptions = () => `
                    <option value="gemini" ${config.provider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                    <option value="siliconflow" ${config.provider === 'siliconflow' ? 'selected' : ''}>SiliconFlow</option>
                    <option value="paioupu" ${config.provider === 'paioupu' ? 'selected' : ''}>派欧云</option>
                    <option value="volcano" ${config.provider === 'volcano' ? 'selected' : ''}>火山</option>
                    <option value="custom" ${config.provider === 'custom' ? 'selected' : ''}>自定义</option>
                `;
                providerSelect.innerHTML = getApiProviderOptions();
                tempInput.value = config.temperature;

                const _renderKeyList = (provider) => {
                    const keyListContainer = $('#api-key-list');
                    const keyCountSpan = $('#api-key-count');
                    const keys = config.keys[provider] || [];
                    const toggleBtn = $('#toggle-all-keys-visibility');
                    const areKeysVisible = toggleBtn.classList.contains('visible');
                    
                    keyListContainer.innerHTML = '';
                    keyCountSpan.textContent = keys.length;

                    keys.forEach((key, index) => {
                        const item = document.createElement('div');
                        item.className = 'api-key-item';
                        let displayKey;
                        if (areKeysVisible) {
                            displayKey = key;
                        } else {
                            displayKey = key.length > 8 ? `${key.substring(0, 4)}...${key.substring(key.length - 4)}` : key;
                        }
                        item.innerHTML = `
                            <span class="key-value" title="${key}">${displayKey}</span>
                            <button class="delete-key-btn" data-index="${index}">×</button>
                        `;
                        keyListContainer.appendChild(item);
                    });
                };

                const updateApiFields = () => {
                    const provider = providerSelect.value;
                    const savedModel = config.models ? config.models[provider] : null;

                    const providerData = {
                        gemini: { url: 'https://generativelanguage.googleapis.com/v1beta/models/', models: ["gemini-2.5-pro", "gemini-2.5-flash", "gemini-1.5-flash-latest", "gemini-1.5-pro-latest"], defaultModel: 'gemini-2.5-flash' },
                        siliconflow: { url: 'https://api.siliconflow.cn/v1/chat/completions', models: ["deepseek-ai/DeepSeek-V3", "deepseek-ai/DeepSeek-R1-0528-Qwen3-8B", "Qwen/Qwen2-7B-Instruct", "Qwen/Qwen2-72B-Instruct"], defaultModel: 'deepseek-ai/DeepSeek-V3' },
                        paioupu: { url: 'https://api.ppinfra.com/v1/chat/completions', models: ["deepseek/deepseek-v3"], defaultModel: 'deepseek/deepseek-v3' },
                        volcano: { url: 'https://ark.cn-beijing.volces.com/api/v3', models: [], defaultModel: '' },
                        custom: { url: '', models: [], defaultModel: '' }
                    };
                    
                    const data = providerData[provider] || providerData.custom;
                    urlInput.value = config.url || data.url;

                    if (provider === 'custom' || provider === 'volcano') {
                        modelSelect.style.display = 'none';
                        modelInput.style.display = 'block';
                        modelInput.value = savedModel;
                    } else {
                        modelSelect.style.display = 'block';
                        modelInput.style.display = 'none';
                        const finalOptions = [...data.models];
                        if (savedModel && !finalOptions.includes(savedModel)) {
                            finalOptions.unshift(savedModel);
                        }
                        modelSelect.innerHTML = finalOptions.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                        modelSelect.value = savedModel || data.defaultModel;
                    }

                    _renderKeyList(provider);
                };
                
                providerSelect.onchange = () => {
                    const newProvider = providerSelect.value;
                    const providerDefaults = {
                        gemini: { url: 'https://generativelanguage.googleapis.com/v1beta/models/', defaultModel: 'gemini-2.5-flash' },
                        siliconflow: { url: 'https://api.siliconflow.cn/v1/chat/completions', defaultModel: 'deepseek-ai/DeepSeek-V3' },
                        paioupu: { url: 'https://api.ppinfra.com/v1/chat/completions', defaultModel: 'deepseek/deepseek-v3' },
                        volcano: { url: 'https://ark.cn-beijing.volces.com/api/v3', defaultModel: '' },
                        custom: { url: '', defaultModel: '' }
                    };
                    
                    if (!config.models) {
                        config.models = {};
                    }

                    
                    if (newProvider === 'custom') {
                        
                        config.url = config.customUrl || '';
                    } else {
                        
                        config.url = providerDefaults[newProvider].url;
                    }
                    

                    
                    config.provider = newProvider;
                    updateApiFields();
                };

                $('#api-key-list').onclick = (e) => {
                    if (e.target.classList.contains('delete-key-btn')) {
                        const index = parseInt(e.target.dataset.index, 10);
                        const provider = providerSelect.value;
                        config.keys[provider].splice(index, 1);
                        _renderKeyList(provider);
                    }
                };
                
                $('#add-api-key-btn').onclick = () => {
                    const newKeyInput = $('#new-api-key-input');
                    const newKey = newKeyInput.value.trim();
                    if (!newKey) return;

                    const provider = providerSelect.value;
                    if (!config.keys[provider]) {
                        config.keys[provider] = [];
                    }
                    config.keys[provider].push(newKey);
                    newKeyInput.value = '';
                    _renderKeyList(provider);
                };

                $('#new-api-key-input').onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        $('#add-api-key-btn').click();
                    }
                };

                $('#toggle-all-keys-visibility').onclick = (e) => {
                    const btn = e.currentTarget;
                    const icon = btn.querySelector('i');
                    btn.classList.toggle('visible');
                    const isVisible = btn.classList.contains('visible');
                    icon.className = isVisible ? 'fas fa-eye-slash' : 'fas fa-eye';
                    _renderKeyList(providerSelect.value);
                };

                $('#api-settings-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#save-api-settings-btn').onclick = async () => {
                    const provider = providerSelect.value;
                    let selectedModel;

                    
                    if (modelInput.style.display !== 'none') {
                        selectedModel = modelInput.value.trim();
                    } else {
                        selectedModel = modelSelect.value;
                    }

                    
                    if (!selectedModel) {
                        UIManager.showToast("模型名称不能为空，请选择或输入一个模型。");
                        return;
                    }

                    
                    const newConfig = {
                        provider: provider,
                        url: urlInput.value.trim(),
                        keys: config.keys, 
                        temperature: parseFloat(tempInput.value),
                        model: selectedModel 
                    };
                    
                    await AIHandler.saveApiConfig(newConfig);
                    UIManager.showToast("API配置已保存！");
                    UIManager.navigateTo('settings');
                };

                $('#fetch-models-btn').onclick = async () => {
                    const provider = providerSelect.value;
                    const apiUrlBase = urlInput.value.trim();
                    const apiKey = (config.keys[provider] && config.keys[provider][0]) || '';
                    const fetchBtn = $('#fetch-models-btn');

                    if (!apiUrlBase || !apiKey) {
                        return UIManager.showToast("请先填写API URL并至少添加一个Key");
                    }

                    const originalBtnText = fetchBtn.innerHTML;
                    fetchBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    fetchBtn.disabled = true;
                    UIManager.showToast("正在获取模型列表...");

                    try {
                        let data;
                        if (provider === 'gemini') {
                            const geminiModelsUrl = `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`;
                            const response = await fetch(geminiModelsUrl);
                            if (!response.ok) throw new Error(`Gemini请求失败: ${response.status}`);
                            data = await response.json();
                            if (data.models && Array.isArray(data.models)) {
                                const modelNames = data.models
                                    .map(model => model.name.replace('models/', ''))
                                    .filter(name => data.models.find(m => m.name.endsWith(name))?.supportedGenerationMethods.includes("generateContent"));
                                populateSelectWithOptions(modelNames);
                            } else {
                                throw new Error("Gemini API返回了无效的模型列表格式");
                            }
                        } else {
                            const cleanedBase = apiUrlBase.replace(/\/v1beta\/?$|\/v1\/?$|\/chat\/completions\/?$|\/$/, '');
                            const potentialEndpoints = [`${cleanedBase}/v1/models`, `${cleanedBase}/v1beta/models`, `${cleanedBase}/models`];
                            let success = false;
                            for (const endpoint of [...new Set(potentialEndpoints)]) {
                                try {
                                    const response = await fetch(endpoint, { headers: { 'Authorization': `Bearer ${apiKey}` } });
                                    if (!response.ok) continue;
                                    data = await response.json();
                                    const modelsList = data.data || data;
                                    if (Array.isArray(modelsList)) {
                                        const modelIds = modelsList.map(model => (typeof model === 'object' ? model.id : model)).filter(Boolean);
                                        populateSelectWithOptions(modelIds);
                                        success = true;
                                        break;
                                    }
                                } catch (error) { console.warn(`从 ${endpoint} 获取失败:`, error.message); }
                            }
                            if (!success) throw new Error("未能获取到模型列表，请检查URL和Key。");
                        }
                    } catch (error) {
                        console.error("获取模型列表失败:", error);
                        UIManager.showToast(`获取失败: ${error.message}`);
                    } finally {
                        fetchBtn.innerHTML = originalBtnText;
                        fetchBtn.disabled = false;
                    }

                    function populateSelectWithOptions(options) {
                        if (!Array.isArray(options) || options.length === 0) {
                            throw new Error("API返回了空或无效的模型列表");
                        }
                        modelSelect.innerHTML = options.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                        modelSelect.style.display = 'block';
                        modelInput.style.display = 'none';
                        UIManager.showToast(`成功获取 ${options.length} 个模型！`);
                    }
                };
                
                updateApiFields();
            },

            async renderChatSettingsPage() {
                const contentArea = $('#chat-settings-content');
                let chatSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const defaults = {
                    id: 'chatSettings', memoryInterconnection: false, historyCharLimit: 5000,
                    showMyNameInGroup: true, showNamesInPrivate: false, showBubbleTimestamp: false,
                    bottomBarOffset: false, enterToSend: false, promptTurnFrequency: 1,
                    activeReplyInterval: 0, useBuiltinEmojis: true, useCustomEmojisInPrompt: true,
                    enablePatAPat: true,
                    summaryMessageInterval: 200,
                };
                chatSettings = { ...defaults, ...chatSettings };

                const createSwitch = (id, label, description, isChecked) => `
                    <div class="setting-item" style="padding: 15px;">
                        <div style="flex-grow: 1;">
                            <span style="font-size: 1rem; display: block; margin-bottom: 5px;">${label}</span>
                            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin: 0; line-height: 1.4;">${description}</p>
                        </div>
                        <label class="switch" style="flex-shrink: 0;"><input type="checkbox" id="${id}" ${isChecked ? 'checked' : ''}><span class="slider"></span></label>
                    </div>`;

                const createNumberInput = (label, description, inputId, initialValue, unit = '') => `
                    <div class="setting-item" style="padding: 15px;">
                        <div style="flex-grow: 1;">
                             <span style="font-size: 1rem; display: block; margin-bottom: 5px;">${label}</span>
                            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin: 0; line-height: 1.4;">${description}</p>
                        </div>
                        <div style="display: flex; align-items: center; flex-shrink: 0;">
                            <input type="number" id="${inputId}" value="${initialValue}" min="0" step="1" style="width: 70px; text-align: center; padding: 8px; margin: 0;">
                            ${unit ? `<span style="margin-left: 8px; font-size: 0.9rem;">${unit}</span>` : ''}
                        </div>
                    </div>`;
                
                contentArea.innerHTML = `
                    <div class="settings-list" style="padding:0; margin:0;">
                        ${createSwitch('memory-interconnection-switch', '记忆互通', '开启后，好友会获取相关群聊+私聊作为记忆参考，对话更连贯。', chatSettings.memoryInterconnection)}
                        ${createSwitch('enable-pat-a-pat-switch', '启用拍一拍功能', '关闭后，AI将不会收到拍一拍的提示，聊天界面也不会显示拍一拍消息。', chatSettings.enablePatAPat)}
                        ${createSwitch('show-my-name-in-group-switch', '群聊显示自己名字', '开启后，你在群聊中发送的消息上方会显示你的名字。', chatSettings.showMyNameInGroup)}
                        ${createSwitch('show-names-in-private-switch', '私聊显示名字', '开启后，私聊时双方的消息上方都会显示名字。', chatSettings.showNamesInPrivate)}
                        ${createSwitch('show-bubble-timestamp-switch', '气泡显示时间', '开启后，在普通消息、引用消息、语音消息的气泡下方显示发送时间。', chatSettings.showBubbleTimestamp)}
                        ${createSwitch('bottom-bar-offset-switch', '底部状态栏上移', '开启后，为手机自带的底部导航条预留空间，防止遮挡。', chatSettings.bottomBarOffset)}
                        ${createSwitch('enter-to-send-switch', '回车自动发送', '开启后，在输入框内按回车键将直接发送消息。', chatSettings.enterToSend)}
                        ${createSwitch('use-builtin-emojis-switch', '内置表情包', '启用后可使用内置添加的表情包，关闭后无法使用且ai将不获得这些表情的id提示。如果关闭&没有自己添加的表情包，ai可能会频繁发送错误表情包', chatSettings.useBuiltinEmojis)}
                        ${createSwitch('use-custom-emojis-in-prompt-switch', '自定义表情启用为提示词', '开启后，你所添加的所有表情包id将提示给ai，但过多的表情包会影响回复速度和tk', chatSettings.useCustomEmojisInPrompt)}
                        ${createNumberInput('聊天记录字数上限', '设定每次请求AI时附带的聊天记录字数，影响记忆和Token消耗。', 'history-char-limit-input', chatSettings.historyCharLimit, '字')}
                        ${createNumberInput('提示词发送频率', '每N个玩家回合发送一次完整Prompt，以节省Token。', 'prompt-freq-input', chatSettings.promptTurnFrequency, '回合')}
                        ${createNumberInput('主动回复间隔', '当距离AI上次回复超过N小时后，进入聊天会自动触发AI主动回复。输入0可关闭。', 'active-reply-interval-input', chatSettings.activeReplyInterval, '小时')}
                        ${createNumberInput('自动总结间隔', '每隔N条消息（包含你和AI），自动总结一次聊天内容。输入0可关闭。', 'summary-interval-input', chatSettings.summaryMessageInterval, '条')}
                    </div>`;
            },
            
            async handleSaveChatSettings() {
                const newSettings = {
                    id: 'chatSettings',
                    memoryInterconnection: $('#memory-interconnection-switch').checked,
                    enablePatAPat: $('#enable-pat-a-pat-switch').checked,
                    historyCharLimit: parseInt($('#history-char-limit-input').value, 10),
                    showMyNameInGroup: $('#show-my-name-in-group-switch').checked,
                    showNamesInPrivate: $('#show-names-in-private-switch').checked,
                    showBubbleTimestamp: $('#show-bubble-timestamp-switch').checked,
                    bottomBarOffset: $('#bottom-bar-offset-switch').checked,
                    enterToSend: $('#enter-to-send-switch').checked,
                    useBuiltinEmojis: $('#use-builtin-emojis-switch').checked,
                    useCustomEmojisInPrompt: $('#use-custom-emojis-in-prompt-switch').checked,
                    promptTurnFrequency: parseInt($('#prompt-freq-input').value, 10),
                    activeReplyInterval: parseInt($('#active-reply-interval-input').value, 10),
                    summaryMessageInterval: parseInt($('#summary-interval-input').value, 10),
                };
                await DBHelper.put('apiConfig', newSettings);
                this.applyChatSettings(newSettings);
                UIManager.showToast("聊天设置已保存！");
                UIManager.navigateTo('settings');
            },
            
            applyChatSettings(settings) {
                
                appContainer.classList.toggle('bottom-offset-active', settings.bottomBarOffset);
                appContainer.classList.toggle('show-bubble-timestamps', settings.showBubbleTimestamp);
            },

            
            async handleForwardMoment(momentId) {
                const allMetadata = await DBHelper.getAll('chatMetadata');
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');

                const recentConversations = allMetadata
                    .filter(meta => meta.lastMessage) //确保有聊天记录
                    .sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);

                if (recentConversations.length === 0) {
                    UIManager.showModal({
                        title: "转发动态",
                        body: `<p style="text-align: center; color: #aaa; padding: 20px 0;">最近没有新的聊天会话，<br>去和好友们开启一个聊天窗口吧！</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const conversationDetails = recentConversations.map(meta => {
                    let details;
                    if (meta.chatId.startsWith('group-')) {
                        details = groups.find(g => g.id === meta.chatId);
                    } else {
                        details = contacts.find(c => c.id === meta.chatId);
                    }
                    return details ? { ...details, chatId: meta.chatId } : null;
                }).filter(Boolean);

                const chatListHtml = conversationDetails.map(item => `
                    <label class="member-select-item" data-name="${(item.remark || item.name).toLowerCase()}">
                        <input type="radio" name="forward-target" value="${item.chatId}">
                        <img src="${item.avatar}" class="contact-item-avatar" style="width:40px;height:40px;margin-right:10px; border-radius: 8px;">
                        <span>${item.remark || item.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "转发给",
                    body: `
                        <input type="text" id="forward-target-search" class="forward-target-search-bar" placeholder="搜索联系人或群聊...">
                        <div class="member-select-list" style="max-height: 40vh;">${chatListHtml}</div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发送', class: 'btn-primary', handler: async () => {
                            const selectedRadio = $('input[name="forward-target"]:checked');
                            if (!selectedRadio) {
                                UIManager.showToast("请选择一个聊天");
                                return;
                            }
                            const targetChatId = selectedRadio.value;

                            const moment = await DBHelper.get('moments', momentId);
                            const momentAuthor = await this.getMomentAuthor(moment.authorId, moment.circleId);

                            const circle = await DBHelper.get('circles', moment.circleId);
                            const baseProfile = await DBHelper.get('profile', 'myProfile');
                            let correctCircleProfile = { ...baseProfile };
                            if (circle && circle.boundPersonaPresetId) {
                                const presets = baseProfile.presets || [];
                                const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                                if (boundPreset) {
                                    correctCircleProfile = { ...baseProfile, ...boundPreset };
                                }
                            }

                            const aiContent = await this.buildForwardedMomentAIContent(moment, momentAuthor, correctCircleProfile);

                            const finalAuthorNameForCard = (moment.authorId === 'myProfile')
                                ? correctCircleProfile.name
                                : momentAuthor.name;

                            const cardData = {
                                momentId: moment.id,
                                authorName: finalAuthorNameForCard,
                                preview: moment.content,
                            };

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: aiContent,
                                type: 'sent',
                                segmentType: 'moment_forward',
                                cardData: cardData
                            };
                            
                            const originalChatId = appState.currentChatId;
                            const originalPage = appState.currentPage;

                            appState.currentChatId = targetChatId; 
                            await this.handlePlayerSendMessage(message);
                            
                            appState.currentChatId = originalChatId;
                            appState.currentPage = originalPage;

                            UIManager.hideModal();
                            UIManager.showToast(`已转发给 ${conversationDetails.find(c => c.chatId === targetChatId).name}`);
                            await UIManager.renderMessagesListPage();
                        }}
                    ]
                });
                
                $('#forward-target-search').addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    $$('.member-select-item').forEach(item => {
                        item.style.display = item.dataset.name.includes(searchTerm) ? 'flex' : 'none';
                    });
                });
            },

            async confirmDeleteMoment(momentId, postElement) {
                UIManager.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除这条动态吗？此操作无法恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('moments', momentId);
                            postElement.remove();
                            UIManager.hideModal();
                            UIManager.showToast('动态已删除');
                        }}
                    ]
                });
            },

            async getMomentAuthor(authorId, contextId = null) {
                const myProfile = await this.getPlayerProfileForContext(contextId);
                if (authorId === myProfile.id) {
                    return { name: myProfile.name, avatar: myProfile.avatar };
                }
                const contact = await DBHelper.get('contacts', authorId);
                if (contact) {
                    return { name: contact.name, avatar: contact.avatar };
                }
                return { name: authorId, avatar: Utils.createAvatarDataUrl('#ccc') };
            },

            async buildForwardedMomentAIContent(moment, author, myProfile) {
                const allContacts = await DBHelper.getAll('contacts');
                const circle = await DBHelper.get('circles', moment.circleId);

                
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let correctMyProfile = { ...baseProfile }; 
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        
                        correctMyProfile = { ...baseProfile, ...boundPreset };
                    }
                }

                
                const allPlayerNames = [baseProfile.name];
                if (baseProfile.presets && Array.isArray(baseProfile.presets)) {
                    baseProfile.presets.forEach(p => {
                        if (p && p.name) allPlayerNames.push(p.name);
                    });
                }
                const uniquePlayerNames = [...new Set(allPlayerNames)];

                let likesText = '无';
                if (moment.likes && moment.likes.length > 0) {
                    const updatedLikes = moment.likes.map(likerName => {
                        
                        if (uniquePlayerNames.includes(likerName)) {
                            return correctMyProfile.name;
                        }
                        return likerName;
                    });
                    
                    likesText = [...new Set(updatedLikes)].join(', ');
                }

                let commentsText = '无';
                if (moment.comments && moment.comments.length > 0) {
                    commentsText = '\n' + moment.comments.map(c => {
                        let cAuthorName = '未知';
                        if (c.authorId === correctMyProfile.id) {
                            cAuthorName = correctMyProfile.name;
                        } else {
                            const contact = allContacts.find(con => con.id === c.authorId);
                            cAuthorName = contact ? (contact.name || c.authorId) : c.authorId;
                        }

                        let replyToName = c.replyTo || '';
                        
                        if (replyToName && uniquePlayerNames.includes(replyToName)) {
                            replyToName = correctMyProfile.name;
                        }

                        const replyText = replyToName ? ` 回复 ${replyToName}` : '';
                        return `${cAuthorName}${replyText}: ${c.content}`;
                    }).join('\n');
                }

                const imageDescription = moment.images && moment.images.length > 0
                    ? ` [图片：包含${moment.images.length}张图片的动态]`
                    : '';

                return `<转发动态>
动态作者：${author.name}
动态内容：${moment.content}${imageDescription}
动态时间：${Utils.formatTimestampSmartly(moment.timestamp)}
点赞情况：${likesText}
评论区：${commentsText}
</转发动态>`;
            },

            async showForwardedMomentDetail(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) {
                    UIManager.showToast("该动态可能已被删除");
                    return;
                }

                const allContacts = await DBHelper.getAll('contacts');

                
                const circle = await DBHelper.get('circles', moment.circleId);
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let correctMyProfile = { ...baseProfile }; 
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        
                        correctMyProfile = { ...baseProfile, ...boundPreset };
                    }
                }
                

                
                let author;
                if (moment.authorId === 'myProfile') {
                    author = { name: correctMyProfile.name, avatar: correctMyProfile.avatar };
                } else {
                    
                    const contactAuthor = allContacts.find(c => c.id === moment.authorId);
                    if (contactAuthor) {
                        author = contactAuthor;
                    } else if (circle && circle.extraMembers && circle.extraMembers.includes(moment.authorId)) {
                        author = { id: moment.authorId, name: moment.authorId, avatar: Utils.createAvatarDataUrl(Utils.getRandomColor()) };
                    } else {
                        author = { id: moment.authorId, name: '未知用户', avatar: Utils.createAvatarDataUrl('#ccc') };
                    }
                }
                

                let likesHtml = '';
                if (moment.likes && moment.likes.length > 0) {
                    likesHtml = `<div class="likes-list"><i class="fas fa-heart"></i> ${moment.likes.join(', ')}</div>`;
                }

                let commentsHtml = '';
                if (moment.comments && moment.comments.length > 0) {
                    commentsHtml = moment.comments.map(comment => {
                        let cAuthorName = '未知用户';
                        
                        if (comment.authorId === correctMyProfile.id) {
                            cAuthorName = correctMyProfile.name;
                        } else {
                            const contact = allContacts.find(c => c.id === comment.authorId);
                            cAuthorName = contact ? contact.name : comment.authorId;
                        }

                        const replyHtml = comment.replyTo 
                            ? `<span class="comment-reply-to"> 回复 </span><span class="comment-author">${comment.replyTo}</span>` 
                            : '';
                        return `<div class="comment-item"><span class="comment-author">${cAuthorName}</span>${replyHtml}: ${comment.content}</div>`;
                    }).join('');
                }

                const imagesHtml = moment.images && moment.images.length > 0
                    ? `<div class="post-image-grid">${moment.images.map(src => `<img src="${src}" alt="动态图片">`).join('')}</div>`
                    : '';

                const modalBody = `
                    <div class="moment-detail-wrapper">
                        <div class="post-header">
                            <img src="${author.avatar}" alt="${author.name} 头像" class="post-avatar">
                            <div class="post-author-info">
                                <span class="name">${author.name}</span>
                            </div>
                        </div>
                        <div class="post-content-full">${moment.content}</div>
                        ${imagesHtml}
                        <div class="post-footer-full">
                            <span class="timestamp">${Utils.formatTimestampSmartly(moment.timestamp)}</span>
                        </div>
                        ${(likesHtml || commentsHtml) ? `
                        <div class="interactions-section">
                            ${likesHtml}
                            <div class="comments-list">${commentsHtml}</div>
                        </div>
                        ` : ''}
                    </div>
                `;

                UIManager.showModal({
                    title: "朋友圈动态",
                    body: modalBody,
                    actions: [{ text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async showCustomForwardDetail(messageId) {
                const msg = await DBHelper.get('messages', messageId);
                if (!msg || !msg.cardData) {
                    UIManager.showToast("无法加载转发内容");
                    return;
                }

                
                const myProfile = await this.getPlayerProfileForContext(msg.chatId);
                let sender;
                if (msg.type === 'sent') {
                    sender = myProfile;
                } else {
                    sender = await DBHelper.get('contacts', msg.senderId) || { name: '未知发件人' };
                }

                const { title, content } = msg.cardData;

                const parsedContent = marked.parse(content, { breaks: true });

                const modalBody = `
                    <style>
                        .forward-detail-card {
                            background: rgba(247, 248, 250, 0.8);
                            backdrop-filter: blur(5px);
                            border: 1px solid var(--border-color);
                            border-radius: 16px;
                            padding: 20px;
                            margin: -10px; /* 抵消一些默认的modal内边距，让卡片感更强 */
                        }
                        .forward-detail-title {
                            text-align: center;
                            font-size: 1.2rem; /* 字体变小 */
                            font-weight: 600;
                            color: var(--text-color-dark);
                            margin-bottom: 15px;
                        }
                        .forward-detail-separator {
                            height: 1px;
                            background: var(--border-color);
                            margin: 15px auto;
                            width: 80%;
                        }
                        .forward-detail-content {
                            line-height: 1.8;
                            font-size: 0.95rem;
                            color: var(--text-color-medium);
                            white-space: normal;
                        }
                        .forward-detail-footer {
                            text-align: right;
                            font-size: 0.75rem;
                            color: var(--text-color-light);
                            margin-top: 20px;
                            border-top: 1px solid var(--border-color);
                            padding-top: 10px;
                        }
                    </style>
                    <div class="forward-detail-card">
                        <h3 class="forward-detail-title">${title}</h3>
                        <div class="forward-detail-separator"></div>
                        <div class="forward-detail-content">
                            ${parsedContent}
                        </div>
                        <div class="forward-detail-footer">
                            <span>来自 ${sender.name} 的转发</span>
                        </div>
                    </div>
                `;

                UIManager.showModal({
                    title: `转发`, 
                    body: modalBody,
                    actions: [{ text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

handleClickEffect(e) {
    const pos = appContainer.getBoundingClientRect();
    const x = e.clientX - pos.left;
    const y = e.clientY - pos.top;

    
    const ripple = document.createElement('div');
    ripple.className = 'ripple';
    clickEffectLayer.appendChild(ripple);

    const rippleSize = 80;
    ripple.style.width = ripple.style.height = `${rippleSize}px`;
    ripple.style.left = `${x - rippleSize / 2}px`;
    ripple.style.top = `${y - rippleSize / 2}px`;
    ripple.addEventListener('animationend', () => {
        ripple.remove();
    });
},

            async handleOpenGroupManagementSidebar(groupId) {
                const group = await DBHelper.get('groups', groupId);
                if (group) {
                    UIManager.showGroupManagementSidebar(group);
                }
            },

            async handleOpenFriendManagementSidebar(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (contact) {
                    UIManager.showFriendManagementSidebar(contact);
                }
            },

            async showEditFriendModal(contactId, onSaveCallback = null) { 
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                UIManager.showModal({
                    isPersistent: true, 
                    title: "修改好友信息",
                    body: `
                        <div class="form-group">
                            <label>头像</label>
                            <div class="avatar-uploader">
                                <img src="${contact.avatar}" id="edit-friend-avatar-preview" class="avatar-preview">
                                <input type="file" id="edit-friend-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('edit-friend-avatar-input').click()">上传新头像</button>
                            </div>
                        </div>
                        <div class="form-group"><label>姓名 (ID, 不可修改)</label><input type="text" value="${contact.name}" disabled></div>
                        <div class="form-group"><label for="edit-friend-remark">备注</label><input type="text" id="edit-friend-remark" value="${contact.remark || ''}"></div>
                        <div class="form-group"><label for="edit-friend-gender">性别</label><select id="edit-friend-gender"><option value="男" ${contact.gender === '男' ? 'selected' : ''}>男</option><option value="女" ${contact.gender === '女' ? 'selected' : ''}>女</option><option value="其他" ${contact.gender === '其他' ? 'selected' : ''}>其他</option></select></div>
                        <div class="form-group">
                            <label for="edit-friend-allow-retraction">允许撤回消息</label>
                            <select id="edit-friend-allow-retraction">
                                <option value="true" ${contact.allowRetraction !== false ? 'selected' : ''}>开启</option>
                                <option value="false" ${contact.allowRetraction === false ? 'selected' : ''}>关闭</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="edit-friend-allow-emoji">允许发送表情包</label>
                            <select id="edit-friend-allow-emoji">
                                <option value="on" ${!contact.allowEmoji || contact.allowEmoji === 'on' ? 'selected' : ''}>开启</option>
                                <option value="off" ${contact.allowEmoji === 'off' ? 'selected' : ''}>关闭</option>
                                <option value="prob" ${contact.allowEmoji === 'prob' ? 'selected' : ''}>概率</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="edit-friend-allow-active-reply">允许主动回复</label>
                            <select id="edit-friend-allow-active-reply">
                                <option value="true" ${contact.allowActiveReply !== false ? 'selected' : ''}>遵循聊天设置</option>
                                <option value="false" ${contact.allowActiveReply === false ? 'selected' : ''}>关闭</option>
                            </select>
                        </div>
                        <div class="form-group"><label for="edit-friend-likes">喜好</label><textarea id="edit-friend-likes">${contact.likes || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-dislikes">厌恶</label><textarea id="edit-friend-dislikes">${contact.dislikes || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-habits">习惯</label><textarea id="edit-friend-habits">${contact.habits || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-pat-action">拍一拍动作 (5字以内)</label><input type="text" id="edit-friend-pat-action" value="${contact.patAction || ''}" maxlength="5"></div>
                        <div class="form-group"><label for="edit-friend-pat-content">拍一拍内容 (20字以内)</label><input type="text" id="edit-friend-pat-content" value="${contact.patContent || ''}" maxlength="20"></div>
                        <div class="form-group"><label for="edit-friend-background">背景资料</label><textarea id="edit-friend-background">${contact.background || ''}</textarea></div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const updatedContact = {
                                ...contact,
                                avatar: $('#edit-friend-avatar-preview').src,
                                remark: $('#edit-friend-remark').value.trim(),
                                gender: $('#edit-friend-gender').value,
                                allowRetraction: $('#edit-friend-allow-retraction').value === 'true',
                                allowEmoji: $('#edit-friend-allow-emoji').value,
                                allowActiveReply: $('#edit-friend-allow-active-reply').value === 'true',
                                likes: $('#edit-friend-likes').value.trim(),
                                dislikes: $('#edit-friend-dislikes').value.trim(),
                                habits: $('#edit-friend-habits').value.trim(),
                                patAction: $('#edit-friend-pat-action').value.trim(),
                                patContent: $('#edit-friend-pat-content').value.trim(),
                                background: $('#edit-friend-background').value.trim()
                            };
                            await DBHelper.put('contacts', updatedContact);
                            chatTitle.textContent = updatedContact.remark || updatedContact.name;
                            UIManager.hideModal();
                            
                            if (typeof onSaveCallback === 'function') {
                                onSaveCallback(updatedContact);
                            } else {
                                UIManager.showFriendManagementSidebar(updatedContact); 
                            }
                        }}
                    ]
                });
                
                $('#edit-friend-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) $('#edit-friend-avatar-preview').src = await Utils.fileToBase64(file);
                });
            },
            async importOpeningScenes(scenes, newEntityId, isGroup) {
                if (!scenes || !Array.isArray(scenes) || scenes.length === 0) return;
                for (const scene of scenes) {
                    const newScene = { ...scene, id: Utils.generateId('scene') };
                    if (isGroup) {
                        newScene.groupId = newEntityId;
                        delete newScene.contactId;
                    } else {
                        newScene.contactId = newEntityId;
                        delete newScene.groupId;
                    }
                    await DBHelper.put('openingScenes', newScene);
                }
            },
            
            handleClearChatHistory(chatId, isGroup) {
                const entityName = isGroup ? '群聊' : '好友';
                UIManager.showModal({
                    title: `清空聊天记录`,
                    body: `<p>确定要清空与该${entityName}的所有聊天记录吗？此操作不可恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认清空', class: 'btn-danger', handler: async () => {
                            await DBHelper.deleteMessagesForChat(chatId);
                            
                            await DBHelper.delete('chatMetadata', chatId);
                            
                            
                            const storeName = isGroup ? 'groups' : 'contacts';
                            const entity = await DBHelper.get(storeName, chatId);
                            if (entity) {
                                entity.autoSummary = '';
                                if ('totalPlayerTurns' in entity) {
                                    entity.totalPlayerTurns = 0;
                                }
                                await DBHelper.put(storeName, entity);
                            }
                            
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            
                            
                            if (appState.currentChatId === chatId) {
                                await UIManager.refreshChatView();
                            }
                            
                            await UIManager.renderMessagesListPage();
                            UIManager.showToast("聊天记录已清空");
                        }}
                    ]
                });
            },
            handleOpeningSceneSettings(entityId, isGroup) {
                UIManager.showOpeningSceneModal(entityId, isGroup);
            },

handleAutoSummarySettings(entityId, isGroup) {
    UIManager.showAutoSummaryModal(entityId, isGroup);
},

handleImmediateSummary(entityId, isGroup) {
    if (appState.isSummarizing[entityId]) {
        UIManager.showToast("正在总结中，请稍候...");
        return;
    }
    
    UIManager.hideModal(); 
    
    AIHandler.handleAutoSummaryRequest(entityId);
},
            handleNewOpeningScene(entityId, isGroup) {
                UIManager.showModal({
                    isPersistent: true,
                    title: "新建开场白",
                    body: `
                        <div class="form-group">
                            <label for="scene-name">开场白名称</label>
                            <input type="text" id="scene-name" placeholder="例如：初次见面的问候">
                        </div>
                        <div class="form-group">
                            <label for="scene-content">开场白内容</label>
                            <textarea id="scene-content" rows="6" placeholder="详细描述开场时的情景、角色的状态和第一句对话等..."></textarea>
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 10px;">提示：开场白内容将仅应用于当前${isGroup ? '群聊' : '私聊'}，不会影响其他聊天。</p>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(entityId, isGroup) },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const name = $('#scene-name').value.trim();
                            const content = $('#scene-content').value.trim();
                            if (!name || !content) return;
                            const newScene = { id: Utils.generateId('scene'), name, content };
                            if (isGroup) {
                                newScene.groupId = entityId;
                            } else {
                                newScene.contactId = entityId;
                            }
                            await DBHelper.put('openingScenes', newScene);
                            UIManager.showOpeningSceneModal(entityId, isGroup);
                        }}
                    ]
                });
            },

            handleEditOpeningScene(scene, isGroup) {
                UIManager.showModal({
                    isPersistent: true, 
                    title: "编辑开场白",
                    body: `
                        <div class="form-group">
                            <label for="scene-name">开场白名称</label>
                            <input type="text" id="scene-name" value="${scene.name}">
                        </div>
                        <div class="form-group">
                            <label for="scene-content">开场白内容</label>
                            <textarea id="scene-content" rows="6">${scene.content}</textarea>
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 10px;">提示：开场白内容将仅应用于当前${isGroup ? '群聊' : '私聊'}，不会影响其他聊天。</p>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup) },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const updatedScene = {
                                ...scene,
                                name: $('#scene-name').value.trim(),
                                content: $('#scene-content').value.trim()
                            };
                            await DBHelper.put('openingScenes', updatedScene);
                            UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup);
                        }}
                    ]
                });
            },

            handleDeleteOpeningScene(sceneId, entityId, isGroup) {
                UIManager.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除这个开场白吗？此操作无法恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(entityId, isGroup) },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('openingScenes', sceneId);
                            UIManager.showOpeningSceneModal(entityId, isGroup);
                        }}
                    ]
                });
            },

            handleApplyOpeningScene(scene) {
                UIManager.showModal({
                    title: "应用开场白",
                    body: `<p>应用开场白将会清空当前聊天记录，并由AI根据开场白内容开始新的对话。确定要继续吗？</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            const isGroup = !!scene.groupId;
                            UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup);
                        }},
                        { text: '确定应用', class: 'btn-primary', handler: async () => {
                            const chatId = scene.groupId || scene.contactId;
                            
                            UIManager.hideSidebar(); 
                            UIManager.hideModal();

                            
                            await DBHelper.deleteMessagesForChat(chatId);
                            await DBHelper.delete('chatMetadata', chatId);

                            
                            const isGroup = !!scene.groupId;
                            const storeName = isGroup ? 'groups' : 'contacts';
                            const entity = await DBHelper.get(storeName, chatId);
                            if (entity) {
                                entity.autoSummary = ''; 
                                if ('totalPlayerTurns' in entity) {
                                    entity.totalPlayerTurns = 0; 
                                }
                                await DBHelper.put(storeName, entity);
                            }
                            
                            
                            
                            if (appState.currentChatId === chatId) {
                                await UIManager.refreshChatView();
                            }
                            
                            
                            await AIHandler.handleOpeningSceneRequest(scene);
                        }}
                    ]
                });
            },

            async handleTransferClick(msg) {
                const myProfile = await this.getPlayerProfileForContext(appState.currentChatId);
                let senderContact;

                if (msg.type === 'sent') {
                    senderContact = myProfile;
                } else {
                    senderContact = await DBHelper.get('contacts', msg.senderId);
                }

                if (!senderContact) {
                    console.error("无法找到转账发送方信息:", msg);
                    UIManager.showToast("无法加载转账详情，发送方信息丢失。");
                    return;
                }

                const isRecipientPlayer = msg.cardData.recipientName === myProfile.name;
                const canReturn = isRecipientPlayer && !msg.cardData.isClaimed; 

                UIManager.showModal({
                    title: "转账详情",
                    body: `
                        <div style="text-align: center;">
                            <img src="${senderContact.avatar}" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; margin-bottom: 10px;">
                            <h4 style="margin-bottom: 5px;">来自 ${senderContact.remark || senderContact.name} 的转账</h4>
                            <p style="font-size: 2rem; font-weight: bold; margin: 15px 0;">${msg.cardData.amount}</p>
                            ${msg.cardData.note ? `<p style="color: #888;">备注：${msg.cardData.note}</p>` : ''}
                        </div>
                    `,
                    actions: [
                        { text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        {
                            text: '退回',
                            class: `btn-secondary ${!canReturn ? 'disabled' : ''}`, 
                            handler: async () => {
                                
                                if (!canReturn) {
                                    UIManager.showToast("只有收款方才能退还未处理的转账");
                                    return;
                                }

                                const msgToUpdate = await DBHelper.get('messages', msg.messageId);
                                if (msgToUpdate) {
                                    msgToUpdate.cardData.isClaimed = true; 
                                    await DBHelper.put('messages', msgToUpdate);
                                }

                                const returnMsg = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: appState.currentChatId,
                                    timestamp: Date.now(),
                                    type: 'sent',
                                    segmentType: 'transfer-return',
                                    content: `[${myProfile.name}|退还转账|${senderContact.name}|${msg.cardData.amount}]`,
                                    cardData: {
                                        recipientName: senderContact.name,
                                        senderName: myProfile.name,
                                        amount: msg.cardData.amount
                                    }
                                };
                                await DBHelper.put('messages', returnMsg);
                                await UIManager.updateChatMetadata(appState.currentChatId, returnMsg);

                                const originalBubble = $(`#${msg.messageId} .bubble`);
                                if (originalBubble) originalBubble.classList.add('claimed');
                                UIManager.addMessageToDOM(returnMsg, myProfile);
                                UIManager.hideModal();
                            }
                        },
                        {
                            text: '收款',
                            class: `btn-primary ${!isRecipientPlayer || msg.cardData.isClaimed ? 'disabled' : ''}`, 
                            handler: async () => {
                                
                                if (!isRecipientPlayer) {
                                    UIManager.showToast('你不是该转账的收款对象');
                                    return;
                                }
                                if (msg.cardData.isClaimed) {
                                    UIManager.showToast('该转账已被处理');
                                    return;
                                }

                                const msgToUpdate = await DBHelper.get('messages', msg.messageId);
                                if (msgToUpdate) {
                                    msgToUpdate.cardData.isClaimed = true;
                                    await DBHelper.put('messages', msgToUpdate);
                                }

                                const receiptMsg = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: appState.currentChatId,
                                    timestamp: Date.now(),
                                    type: 'sent',
                                    segmentType: 'transfer-receipt',
                                    content: `${myProfile.name}已收款`,
                                    cardData: {
                                        recipientName: myProfile.name,
                                        senderName: senderContact.name,
                                        amount: msg.cardData.amount
                                    }
                                };
                                await DBHelper.put('messages', receiptMsg);
                                await UIManager.updateChatMetadata(appState.currentChatId, receiptMsg);

                                const originalBubble = $(`#${msg.messageId} .bubble`);
                                if (originalBubble) originalBubble.classList.add('claimed');
                                UIManager.addMessageToDOM(receiptMsg, myProfile);
                                UIManager.hideModal();
                            }
                        }
                    ]
                });
            },

            async handleRedPacketClick(msg) {
                const myProfile = await this.getPlayerProfileForContext(appState.currentChatId);
                let senderContact; 

                
                if (msg.type === 'sent') {
                    
                    senderContact = myProfile;
                } else {
                    
                    senderContact = await DBHelper.get('contacts', msg.senderId);
                }

                
                if (!senderContact) {
                    console.error("无法找到红包发送方信息:", msg);
                    UIManager.showToast("无法加载红包详情，发送方信息丢失。");
                    return;
                }
                
                
                const modalStyle = `
                    <style>
                        .rp-modal-body { text-align: center; padding: 20px 0; }
                        .rp-modal-body img { width: 60px; height: 60px; border-radius: 8px; margin-bottom: 10px; }
                        .rp-modal-body h4 { font-size: 1.2rem; margin-bottom: 5px; }
                        .rp-modal-body p { color: var(--text-color-light); margin-bottom: 30px; }
                        .rp-open-btn {
                            width: 80px; height: 80px; border-radius: 50%;
                            background-color: #F8C34A; color: white;
                            border: 3px solid #F5A623; font-size: 2rem;
                            cursor: pointer; animation: rp-pulse 1.5s infinite;
                            box-shadow: 0 4px 10px rgba(248, 195, 74, 0.5);
                        }
                        @keyframes rp-pulse { 0% { transform: scale(0.95); } 70% { transform: scale(1.05); } 100% { transform: scale(0.95); } }
                        .rp-amount { font-size: 2.5rem; font-weight: bold; margin-bottom: 10px; }
                        .rp-claimed-info { font-size: 0.9rem; color: var(--text-color-medium); }
                    </style>
                `;

                
                UIManager.showModal({
                    title: " ", 
                    body: `
                        ${modalStyle}
                        <div class="rp-modal-body" id="rp-pre-claim">
                            <img src="${senderContact.avatar}" alt="avatar">
                            <h4>${senderContact.remark || senderContact.name} 的红包</h4>
                            <p>${msg.cardData.title}</p>
                            <button class="rp-open-btn">开</button>
                        </div>
                    `,
                    actions: [{ text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });

                
                modalContentWrapper.querySelector('.rp-open-btn').onclick = async () => {
                    

                    if (msg.type === 'sent') {
                        UIManager.showToast("不能领取自己发的红包哦");
                        return;
                    }
                    
                    const isGroupChat = appState.currentChatId.startsWith('group-');
                    let receivedAmount = 0;
                    
                    if (isGroupChat) {
                        
                        if (msg.cardData.count === 1) {
                            receivedAmount = msg.cardData.amount;
                        } else {
                            
                            const remainingAmount = msg.cardData.amount;
                            const remainingCount = msg.cardData.count - msg.cardData.claimedBy.length;
                            const maxReceive = remainingAmount - (remainingCount - 1) * 0.01;
                            receivedAmount = Math.random() * (maxReceive - 0.01) + 0.01;
                        }
                    } else {
                        receivedAmount = msg.cardData.amount;
                    }

                    
                    const msgToUpdate = await DBHelper.get('messages', msg.messageId);
                    if (msgToUpdate) {
                        msgToUpdate.cardData.isClaimedByPlayer = true;
                        if (!Array.isArray(msgToUpdate.cardData.claimedBy)) {
                             msgToUpdate.cardData.claimedBy = [];
                        }
                        msgToUpdate.cardData.claimedBy.push(myProfile.id);
                        await DBHelper.put('messages', msgToUpdate);
                    }

                    
                    const originalBubble = $(`#${msg.messageId} .bubble`);
                    if(originalBubble) originalBubble.classList.add('claimed');

                    
                    const notice = document.createElement('div');
                    notice.className = 'time-divider';
                    notice.textContent = `${myProfile.name} 领取了 ${senderContact.remark || senderContact.name} 的红包`;
                    chatArea.appendChild(notice);
                    chatArea.scrollTop = chatArea.scrollHeight;
                    
                    
                    const modalBody = modalContentWrapper.querySelector('.modal-body');
                    modalBody.innerHTML = `
                        ${modalStyle}
                        <div class="rp-modal-body" id="rp-post-claim">
                            <p class="rp-amount">￥${receivedAmount.toFixed(2)}</p>
                            <p class="rp-claimed-info">已存入零钱，可直接使用</p>
                        </div>
                    `;
                };
            },

            async handleInviteMembers(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                
                const availableFriends = allContacts.filter(c => !group.members.includes(c.id));

                if (availableFriends.length === 0) {
                    UIManager.showModal({
                        title: "邀请成员",
                        body: `<p>没有可邀请的好友了，所有好友都已在群聊中。</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const memberListHtml = availableFriends.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="invite-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "邀请新成员",
                    body: `<div class="member-select-list">${memberListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '邀请', class: 'btn-primary', handler: async () => {
                            const newMemberIds = [...$$('input[name="invite-members"]:checked')].map(cb => cb.value);
                            if (newMemberIds.length === 0) return;

                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            const invitedNames = (await Promise.all(newMemberIds.map(id => DBHelper.get('contacts', id)))).map(c => c.remark || c.name).join('、');
                            
                            
                            group.members.push(...newMemberIds);
                            await DBHelper.put('groups', group);
                            
                            
                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                content: `${myProfile.name} 邀请 ${invitedNames} 加入群聊`,
                                timestamp: Date.now(),
                                type: 'received', 
                                segmentType: 'system',
                                forAi: true, 
                            };

                            
                            await DBHelper.put('messages', systemMessage);
                            await UIManager.updateChatMetadata(groupId, systemMessage);

                            if (appState.currentChatId === groupId) {
                                UIManager.addMessageToDOM(systemMessage, {});
                            }
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            async handleRemoveMembers(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');

                const currentAiMembers = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);

                if (currentAiMembers.length <= 1) {
                    UIManager.showModal({
                        title: "移除成员",
                        body: `<p>群聊中至少需要保留一名好友，无法再移除了。</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }
                
                const memberListHtml = currentAiMembers.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="remove-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "移除群成员",
                    body: `<div class="member-select-list">${memberListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '移除', class: 'btn-danger', handler: async () => {
                            const idsToRemove = [...$$('input[name="remove-members"]:checked')].map(cb => cb.value);
                            if (idsToRemove.length === 0) return;

                            if (idsToRemove.length >= currentAiMembers.length) {
                                UIManager.showModal({ title: "操作无效", body: `<p>不能将所有好友都移出群聊，至少要保留一位哦。</p>`, actions: [{ text: '好的', class: 'btn-primary', handler: () => this.handleRemoveMembers(groupId) }] });
                                return;
                            }
                            
                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            const removedNames = currentAiMembers.filter(c => idsToRemove.includes(c.id)).map(c => c.remark || c.name).join('、');

                            
                            group.members = group.members.filter(id => !idsToRemove.includes(id));
                            await DBHelper.put('groups', group);
                            
                            
                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                content: `${myProfile.name} 将 ${removedNames} 移出群聊`,
                                timestamp: Date.now(),
                                type: 'received',
                                segmentType: 'system',
                                forAi: true, 
                            };
                            
                             
                            await DBHelper.put('messages', systemMessage);
                            await UIManager.updateChatMetadata(groupId, systemMessage);

                            if (appState.currentChatId === groupId) {
                                UIManager.addMessageToDOM(systemMessage, {});
                            }
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            

            async renderPromptsPage() {
                const contentArea = $('#prompts-page-content');
                contentArea.innerHTML = ''; 
                const folders = await DBHelper.getAll('promptFolders');
                const prompts = await DBHelper.getAll('prompts');

                
                let unclassifiedFolder = folders.find(f => f.id === 'unclassified');
                if (!unclassifiedFolder) {
                    unclassifiedFolder = { id: 'unclassified', name: '未分类', isActive: true, createdAt: 0 };
                    
                }
                
                const sortedFolders = [unclassifiedFolder, ...folders.filter(f => f.id !== 'unclassified').sort((a,b) => a.createdAt - b.createdAt)];
                
                for (const folder of sortedFolders) {
                    const folderPrompts = prompts.filter(p => p.folderId === folder.id).sort((a,b) => a.createdAt - b.createdAt);
                    const folderElement = this.createFolderElement(folder, folderPrompts);
                    contentArea.appendChild(folderElement);
                }

                this.bindPromptPageEvents();
            },

            createFolderElement(folder, prompts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder';
                folderDiv.dataset.folderId = folder.id;

                let promptsHtml = prompts.map((p, index) => this.createPromptCardHtml(p, index + 1)).join('');
                if (prompts.length === 0) {
                    promptsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">此文件夹为空</p>`;
                }

                
                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            <i class="fas fa-folder"></i> 
                            ${folder.name}
                        </h3>
                        <div class="prompt-folder-controls">
                            ${folder.id !== 'unclassified' ? `
                            <label class="switch">
                                <input type="checkbox" class="folder-toggle-switch" ${folder.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                            <button class="folder-action-btn" data-action="delete-folder" title="删除文件夹"><i class="fas fa-trash-alt"></i></button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="prompt-folder-content collapsed">${promptsHtml}</div>
                `;
                return folderDiv;
            },

            createPromptCardHtml(prompt, index) {
                let keywordsText = '';
                if (prompt.type === 'implicit') {
                    try {
                        const keywords = JSON.parse(prompt.keywords);
                        keywordsText = `<div class="prompt-tag tag-keywords" title="${keywords.join(', ')}">${keywords.join(', ')}</div>`;
                    } catch(e) {  }
                }
                
                return `
                    <div class="prompt-card ${prompt.isActive ? '' : 'inactive'}" data-prompt-id="${prompt.id}">
                        <div class="prompt-card-header">
                            <div class="prompt-card-name">
                                <span class="prompt-index">${index}</span>
                                <span>${prompt.name}</span>
                            </div>
                             <label class="switch">
                                <input type="checkbox" class="prompt-toggle-switch" ${prompt.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="prompt-card-tags">
                            <div class="prompt-tag ${prompt.type === 'explicit' ? 'tag-explicit' : 'tag-implicit'}">${prompt.type === 'explicit' ? '显性' : '隐性'}</div>
                            ${keywordsText}
                        </div>
                        <div class="prompt-card-actions">
                            <button class="action-btn" data-action="view-prompt">查看</button>
                            <button class="action-btn" data-action="edit-prompt">修改</button>
                            <button class="action-btn" data-action="delete-prompt">删除</button>
                        </div>
                    </div>
                `;
            },
            
            bindPromptPageEvents() {
                
                $('#prompts-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#add-prompt-folder-btn').onclick = () => this.handleNewPromptFolder();
                $('#add-new-prompt-btn').onclick = () => this.handleNewPrompt();
                
                $('#import-prompts-btn').onclick = () => this.handleImportPrompts();
                $('#export-prompts-btn').onclick = () => this.handleExportPrompts();

                
                $('#prompts-page-content').onclick = async (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const folderSwitch = target.closest('.folder-toggle-switch');
                    const deleteFolderBtn = target.closest('[data-action="delete-folder"]');
                    const promptCard = target.closest('.prompt-card');

                    if (folderSwitch) {
                        e.stopPropagation(); 
                        const folderId = folderSwitch.closest('.prompt-folder').dataset.folderId;
                        
                        await this.toggleFolderState(folderId, folderSwitch.checked);
                    } else if (deleteFolderBtn) {
                        
                        e.stopPropagation();
                        const folderId = deleteFolderBtn.closest('.prompt-folder').dataset.folderId;
                        this.confirmDeleteFolder(folderId);
                    } else if (folderHeader) {
                        
                        const content = folderHeader.nextElementSibling;
                        if (content && content.classList.contains('prompt-folder-content')) {
                            folderHeader.classList.toggle('collapsed');
                            content.classList.toggle('collapsed');
                        }
                    } else if (promptCard) {
                        
                        const promptId = promptCard.dataset.promptId;
                        if (target.matches('.prompt-toggle-switch')) {
                            await this.togglePromptState(promptId, target.checked);
                        } else if (target.matches('[data-action="view-prompt"]')) {
                            this.viewPrompt(promptId);
                        } else if (target.matches('[data-action="edit-prompt"]')) {
                            this.handleEditPrompt(promptId);
                        } else if (target.matches('[data-action="delete-prompt"]')) {
                            this.confirmDeletePrompt(promptId);
                        }
                    }
                };
            },

            

            async renderPromptsPage() {
                const contentArea = $('#prompts-page-content');
                contentArea.innerHTML = ''; 
                const folders = await DBHelper.getAll('promptFolders');
                const prompts = await DBHelper.getAll('prompts');

                
                let unclassifiedFolder = folders.find(f => f.id === 'unclassified');
                if (!unclassifiedFolder) {
                    unclassifiedFolder = { id: 'unclassified', name: '未分类', isActive: true, createdAt: 0 };
                    
                }
                
                const sortedFolders = [unclassifiedFolder, ...folders.filter(f => f.id !== 'unclassified').sort((a,b) => a.createdAt - b.createdAt)];
                
                for (const folder of sortedFolders) {
                    const folderPrompts = prompts.filter(p => p.folderId === folder.id).sort((a,b) => a.createdAt - b.createdAt);
                    const folderElement = this.createFolderElement(folder, folderPrompts);
                    contentArea.appendChild(folderElement);
                }

                this.bindPromptPageEvents();
            },

            createFolderElement(folder, prompts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder';
                folderDiv.dataset.folderId = folder.id;

                let promptsHtml = prompts.map((p, index) => this.createPromptCardHtml(p, index + 1)).join('');
                if (prompts.length === 0) {
                    promptsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">此文件夹为空</p>`;
                }

                
                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            <i class="fas fa-folder"></i> 
                            ${folder.name}
                        </h3>
                        <div class="prompt-folder-controls">
                            ${folder.id !== 'unclassified' ? `
                            <label class="switch">
                                <input type="checkbox" class="folder-toggle-switch" ${folder.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                            <button class="folder-action-btn" data-action="delete-folder" title="删除文件夹"><i class="fas fa-trash-alt"></i></button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="prompt-folder-content collapsed">${promptsHtml}</div>
                `;
                return folderDiv;
            },

            createPromptCardHtml(prompt, index) {
                let keywordsText = '';
                if (prompt.type === 'implicit') {
                    try {
                        const keywords = JSON.parse(prompt.keywords);
                        keywordsText = `<div class="prompt-tag tag-keywords" title="${keywords.join(', ')}">${keywords.join(', ')}</div>`;
                    } catch(e) {  }
                }
                
                return `
                    <div class="prompt-card ${prompt.isActive ? '' : 'inactive'}" data-prompt-id="${prompt.id}">
                        <div class="prompt-card-header">
                            <div class="prompt-card-name">
                                <span class="prompt-index">${index}</span>
                                <span>${prompt.name}</span>
                            </div>
                             <label class="switch">
                                <input type="checkbox" class="prompt-toggle-switch" ${prompt.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="prompt-card-tags">
                            <div class="prompt-tag ${prompt.type === 'explicit' ? 'tag-explicit' : 'tag-implicit'}">${prompt.type === 'explicit' ? '显性' : '隐性'}</div>
                            ${keywordsText}
                        </div>
                        <div class="prompt-card-actions">
                            <button class="action-btn" data-action="view-prompt">查看</button>
                            <button class="action-btn" data-action="edit-prompt">修改</button>
                            <button class="action-btn" data-action="delete-prompt">删除</button>
                        </div>
                    </div>
                `;
            },
            
            bindPromptPageEvents() {
                
                $('#prompts-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#add-prompt-folder-btn').onclick = () => this.handleNewPromptFolder();
                $('#add-new-prompt-btn').onclick = () => this.handleNewPrompt();
                
                $('#import-prompts-btn').onclick = () => this.handleImportPrompts();
                $('#export-prompts-btn').onclick = () => this.handleExportPrompts();

                
                $('#prompts-page-content').onclick = async (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const folderSwitch = target.closest('.folder-toggle-switch');
                    const deleteFolderBtn = target.closest('[data-action="delete-folder"]');
                    const promptCard = target.closest('.prompt-card');

                    if (folderSwitch) {
                        
                        e.stopPropagation(); 
                        const folderId = folderSwitch.closest('.prompt-folder').dataset.folderId;
                        await this.toggleFolderState(folderId, folderSwitch.checked);
                    } else if (deleteFolderBtn) {
                        
                        e.stopPropagation();
                        const folderId = deleteFolderBtn.closest('.prompt-folder').dataset.folderId;
                        this.confirmDeleteFolder(folderId);
                    } else if (folderHeader) {
                        
                        const content = folderHeader.nextElementSibling;
                        if (content && content.classList.contains('prompt-folder-content')) {
                            folderHeader.classList.toggle('collapsed');
                            content.classList.toggle('collapsed');
                        }
                    } else if (promptCard) {
                        
                        const promptId = promptCard.dataset.promptId;
                        if (target.matches('.prompt-toggle-switch')) {
                            await this.togglePromptState(promptId, target.checked);
                        } else if (target.matches('[data-action="view-prompt"]')) {
                            this.viewPrompt(promptId);
                        } else if (target.matches('[data-action="edit-prompt"]')) {
                            this.handleEditPrompt(promptId);
                        } else if (target.matches('[data-action="delete-prompt"]')) {
                            this.confirmDeletePrompt(promptId);
                        }
                    }
                };
            },


            async handleNewPrompt(folderId = 'unclassified') {
                const folders = await DBHelper.getAll('promptFolders');
                const folderOptions = `<option value="unclassified" ${folderId === 'unclassified' ? 'selected' : ''}>未分类</option>` +
                    folders.map(f => `<option value="${f.id}" ${folderId === f.id ? 'selected' : ''}>${f.name}</option>`).join('');

                UIManager.showModal({
                    isPersistent: true,
                    title: "新建提示词",
                    body: `
                        <div class="form-group">
                            <label for="prompt-name-input">名称 (文件夹内唯一)</label>
                            <input type="text" id="prompt-name-input" placeholder="例如：文风-古风">
                        </div>
                        <div class="form-group">
                            <label for="prompt-folder-select">所属文件夹</label>
                            <select id="prompt-folder-select">${folderOptions}</select>
                        </div>
                        <div class="form-group">
                            <label>类型</label>
                            <select id="prompt-type-select">
                                <option value="explicit">显性 (总是触发)</option>
                                <option value="implicit">隐性 (关键词触发)</option>
                            </select>
                        </div>
                        <div class="form-group" id="prompt-keywords-group" style="display:none;">
                            <label for="prompt-keywords-input">关键词 (用中/英文逗号隔开)</label>
                            <input type="text" id="prompt-keywords-input" placeholder="例如：你好,hello,在吗">
                        </div>
                        <div class="form-group">
                            <label for="prompt-content-input">提示词内容</label>
                            <textarea id="prompt-content-input" rows="5" placeholder="输入你的提示词..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const name = $('#prompt-name-input').value.trim();
                            const selectedFolderId = $('#prompt-folder-select').value;
                            if (!name) {
                                return UIManager.showToast("提示词名称不能为空");
                            }

                            
                            const allPrompts = await DBHelper.getAll('prompts');
                            const promptsInFolder = allPrompts.filter(p => p.folderId === selectedFolderId);
                            if (promptsInFolder.some(p => p.name === name)) {
                                return UIManager.showToast(`名称 "${name}" 在该文件夹中已存在`);
                            }
                            
                            let keywords = '[]';
                            if ($('#prompt-type-select').value === 'implicit') {
                                const keywordsInput = $('#prompt-keywords-input').value.trim();
                                if (keywordsInput) {
                                    const keywordsArray = keywordsInput.split(/,|，/).map(kw => kw.trim()).filter(Boolean);
                                    keywords = JSON.stringify(keywordsArray);
                                }
                            }

                            const newPrompt = {
                                id: Utils.generateId('prompt'),
                                createdAt: Date.now(),
                                name: name,
                                folderId: selectedFolderId,
                                type: $('#prompt-type-select').value,
                                keywords: keywords,
                                content: $('#prompt-content-input').value.trim(),
                                isActive: true,
                            };
                            await DBHelper.put('prompts', newPrompt);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
                
                $('#prompt-type-select').onchange = (e) => {
                    $('#prompt-keywords-group').style.display = e.target.value === 'implicit' ? 'block' : 'none';
                };
            },
            
            async handleEditPrompt(promptId) {
                const prompt = await DBHelper.get('prompts', promptId);
                const folders = await DBHelper.getAll('promptFolders');
                const folderOptions = `<option value="unclassified" ${prompt.folderId === 'unclassified' ? 'selected' : ''}>未分类</option>` +
                    folders.map(f => `<option value="${f.id}" ${prompt.folderId === f.id ? 'selected' : ''}>${f.name}</option>`).join('');
                
                let keywordsString = '';
                if(prompt.type === 'implicit') {
                    try {
                        const keywordsArray = JSON.parse(prompt.keywords);
                        if (Array.isArray(keywordsArray)) keywordsString = keywordsArray.join(', ');
                    } catch(e) {}
                }

                UIManager.showModal({
                    isPersistent: true,
                    title: "修改提示词",
                    body: `
                        <div class="form-group">
                            <label for="prompt-name-input">名称 (文件夹内唯一)</label>
                            <input type="text" id="prompt-name-input" value="${prompt.name}">
                        </div>
                        <div class="form-group">
                            <label for="prompt-folder-select">所属文件夹</label>
                            <select id="prompt-folder-select">${folderOptions}</select>
                        </div>
                        <div class="form-group">
                            <label>类型</label>
                            <select id="prompt-type-select">
                                <option value="explicit" ${prompt.type === 'explicit' ? 'selected' : ''}>显性</option>
                                <option value="implicit" ${prompt.type === 'implicit' ? 'selected' : ''}>隐性</option>
                            </select>
                        </div>
                        <div class="form-group" id="prompt-keywords-group" style="display:${prompt.type === 'implicit' ? 'block' : 'none'};">
                            <label for="prompt-keywords-input">关键词 (用中/英文逗号隔开)</label>
                            <input type="text" id="prompt-keywords-input" value="${keywordsString}" placeholder="例如：你好,hello,在吗">
                        </div>
                        <div class="form-group">
                            <label for="prompt-content-input">提示词内容</label>
                            <textarea id="prompt-content-input" rows="5">${prompt.content}</textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const name = $('#prompt-name-input').value.trim();
                            const selectedFolderId = $('#prompt-folder-select').value;
                            if (!name) return UIManager.showToast("提示词名称不能为空");

                            
                            const allPrompts = await DBHelper.getAll('prompts');
                            const promptsInFolder = allPrompts.filter(p => p.folderId === selectedFolderId && p.id !== promptId);
                            if (promptsInFolder.some(p => p.name === name)) {
                                return UIManager.showToast(`名称 "${name}" 在该文件夹中已存在`);
                            }

                            let keywords = '[]';
                            if ($('#prompt-type-select').value === 'implicit') {
                                const keywordsInput = $('#prompt-keywords-input').value.trim();
                                if (keywordsInput) {
                                    const keywordsArray = keywordsInput.split(/,|，/).map(kw => kw.trim()).filter(Boolean);
                                    keywords = JSON.stringify(keywordsArray);
                                }
                            }
                            
                            const updatedPrompt = {
                                ...prompt,
                                name: name,
                                folderId: selectedFolderId,
                                type: $('#prompt-type-select').value,
                                keywords: keywords,
                                content: $('#prompt-content-input').value.trim(),
                            };
                            await DBHelper.put('prompts', updatedPrompt);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
                
                $('#prompt-type-select').onchange = (e) => {
                    $('#prompt-keywords-group').style.display = e.target.value === 'implicit' ? 'block' : 'none';
                };
            },
            
            async viewPrompt(promptId) {
                const prompt = await DBHelper.get('prompts', promptId);
                UIManager.showModal({
                    title: `查看: ${prompt.name}`,
                    body: `<div class="details-section" style="margin-top:0;"><p style="max-height: 400px;">${prompt.content}</p></div>`,
                    actions: [{text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal()}]
                });
            },
            
            confirmDeletePrompt(promptId) {
                UIManager.showModal({
                    title: '确认删除',
                    body: '<p>确定要删除这个提示词吗？此操作无法恢复。</p>',
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('prompts', promptId);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },
            
            async togglePromptState(promptId, isActive) {
                const prompt = await DBHelper.get('prompts', promptId);
                prompt.isActive = isActive;
                await DBHelper.put('prompts', prompt);
                
                
                const promptCard = $(`#prompts-page-content .prompt-card[data-prompt-id="${promptId}"]`);
                if (promptCard) {
                    promptCard.classList.toggle('inactive', !isActive);
                }
            },

            handleNewPromptFolder() {
                UIManager.showModal({
                    title: "新建文件夹",
                    body: `
                        <div class="form-group">
                            <label for="folder-name-input">文件夹名称 (不可重复)</label>
                            <input type="text" id="folder-name-input" placeholder="例如：世界观设定">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '创建', class: 'btn-primary', handler: async () => {
                            const name = $('#folder-name-input').value.trim();
                            if (!name) return;
                            const existing = await DBHelper.getAll('promptFolders', 'name');
                            if (existing.some(f => f.name === name)) return alert('文件夹名称已存在');

                            const newFolder = {
                                id: Utils.generateId('folder'),
                                createdAt: Date.now(),
                                name: name,
                                isActive: true
                            };
                            await DBHelper.put('promptFolders', newFolder);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },
            
            async toggleFolderState(folderId, isActive) {
                const folder = await DBHelper.get('promptFolders', folderId);
                if (folder) {
                    folder.isActive = isActive;
                    await DBHelper.put('promptFolders', folder);
                }
                
            },
            
            confirmDeleteFolder(folderId) {
                UIManager.showModal({
                    title: '确认删除文件夹',
                    body: '<p>删除文件夹将同时删除其中所有的提示词，且无法恢复。确定要继续吗？</p>',
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认删除', class: 'btn-danger', handler: async () => {
                            
                            const prompts = (await DBHelper.getAll('prompts')).filter(p => p.folderId === folderId);
                            for (const prompt of prompts) {
                                await DBHelper.delete('prompts', prompt.id);
                            }
                            
                            await DBHelper.delete('promptFolders', folderId);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },

            
            
            async showBindingModal(chatId) {
                const isGroup = chatId.startsWith('group-');
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const boundFolderIds = chatEntity.boundPromptFolderIds || [];
                const allFolders = await DBHelper.getAll('promptFolders');
                
                const boundFolders = allFolders.filter(f => boundFolderIds.includes(f.id));
                let boundFoldersHtml = boundFolders.map(f => `
                    <div class="bound-folder-card">
                        <i class="fas fa-folder-open"></i>
                        <span>${f.name}</span>
                    </div>
                `).join('');
                if (boundFolders.length === 0) {
                    boundFoldersHtml = `<p style="text-align:center; color:#aaa; padding: 20px 0;">未绑定任何提示词文件夹</p>`;
                }
                
                const modalBody = `
                    <div class="binding-modal-header">
                        <h2>已绑定文件夹</h2>
                        <button id="open-folder-selection-btn" title="管理绑定"><i class="fas fa-link"></i></button>
                    </div>
                    <div id="bound-folders-list">${boundFoldersHtml}</div>
                `;

                UIManager.showModal({
                    title: "绑定提示词",
                    body: modalBody,
                    actions: [{text: '完成', class: 'btn-primary', handler: () => UIManager.hideModal()}]
                });
                
                
                modalContentWrapper.classList.add('binding-modal-content');
                
                $('#open-folder-selection-btn').onclick = () => this.showFolderSelectionModal(chatId, boundFolderIds);

                
                const originalHide = UIManager.hideModal;
                UIManager.hideModal = () => {
                    modalContentWrapper.classList.remove('binding-modal-content');
                    originalHide.call(UIManager);
                    UIManager.hideModal = originalHide; 
                };
            },

            async showFolderSelectionModal(chatId, currentlyBoundIds) {
                const allFolders = await DBHelper.getAll('promptFolders');
                const folderListHtml = allFolders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="bind-folder" value="${f.id}" ${currentlyBoundIds.includes(f.id) ? 'checked' : ''}>
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "选择要绑定的文件夹",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => this.showBindingModal(chatId) },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const selectedIds = [...$$('input[name="bind-folder"]:checked')].map(cb => cb.value);
                            const isGroup = chatId.startsWith('group-');
                            const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                            chatEntity.boundPromptFolderIds = selectedIds;
                            await DBHelper.put(isGroup ? 'groups' : 'contacts', chatEntity);
                            this.showBindingModal(chatId); 
                        }}
                    ]
                });
            },
            handleSimulatedImageSend() {
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';
                const networkFallbackImage = 'https://z.wiki/autoupload/20240328/LV9Y.iShot_2024-03-28_22.38.16.png'; 
                
                UIManager.showModal({
                    isPersistent: true,
                    title: "发送图文消息",
                    body: `
                        <div class="form-group">
                            <label>上传图片 (选填)</label>
                            <div class="avatar-uploader">
                                <img src="${defaultPlaceholderSvg}" id="sim-image-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                <input type="file" id="sim-image-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('sim-image-input').click()">选择图片</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="sim-image-desc">图片描述 (必填, AI会看到)</label>
                            <textarea id="sim-image-desc" rows="3" placeholder="请详细描述图片内容，AI将根据此描述进行回应..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发送', class: 'btn-primary', handler: async () => {
                            const description = $('#sim-image-desc').value.trim();
                            if (!description) {
                                return UIManager.showToast('图片描述不能为空');
                            }
                            
                            let finalImageSrc = $('#sim-image-preview').src;
                            
                            if (finalImageSrc === defaultPlaceholderSvg) {
                                finalImageSrc = 'https://pb.nichi.co/spoil-joke-debate';
                            }
                            
                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[图文] ${description}`,
                                type: 'sent',
                                segmentType: 'image_simulated',
                                cardData: {
                                    imageSrc: finalImageSrc,
                                    description: description
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
                
                $('#sim-image-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#sim-image-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },

            async handleVisionImageSend() {
                UIManager.showModal({
                    title: "发送图片 (AI识图)",
                    body: `
                        <div class="form-group">
                            <label>选择图片 (必填)</label>
                            <div class="avatar-uploader">
                                <img src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" id="vision-image-preview" style="width: 100px; height: 100px; border-radius: 8px; object-fit: cover; background-color: #f0f0f0; display: none;">
                                <input type="file" id="vision-image-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('vision-image-input').click()">上传图片</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="vision-image-prompt">附言 (选填)</label>
                            <textarea id="vision-image-prompt" rows="2" placeholder="可以对图片提问或补充说明..."></textarea>
                        </div>
                        <p style="font-size: 0.8rem; color: #aaa;">提示：此功能会调用多模态模型进行识图，请确保你选择的模型和api提供方支持此功能 (如 Gemini 2.5, GPT-4o 等)，并可能产生比普通消息更高的tk。发送带有该功能图片的回复会比正常回复<strong>更慢</strong>，这是正常现象。相同模型下，<strong>部分API提供方不支持ai识图功能</strong></p>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发送', class: 'btn-primary', handler: async () => {
                            const imagePreview = $('#vision-image-preview');
                            const textPrompt = $('#vision-image-prompt').value.trim();

                            if (!imagePreview.src || imagePreview.src.startsWith('data:image/gif')) {
                                return UIManager.showToast('请先上传一张图片');
                            }

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: textPrompt || "[图片]",
                                type: 'sent',
                                segmentType: 'image_vision',
                                cardData: {
                                    base64: imagePreview.src,
                                    prompt: textPrompt,
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });

                $('#vision-image-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const compressedBase64 = await Utils.compressImage(file, 1024, 1024, 0.8);
                        $('#vision-image-preview').src = compressedBase64;
                        $('#vision-image-preview').style.display = 'block';
                    }
                });
            },

            handlePlayerCardSend() {
                const cardCoverLibrary = appState.cardCoverLibrary || [];
                const defaultCover = cardCoverLibrary.length > 0 ? cardCoverLibrary[Math.floor(Math.random() * cardCoverLibrary.length)] : '';
                
                UIManager.showModal({
                    title: "发送卡片消息",
                    body: `
                        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                            <label style="margin: 0;">使用“转发”样式</label>
                            <label class="switch">
                                <input type="checkbox" id="card-style-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>

                        <!-- Detailed Card Form -->
                        <div id="detailed-card-form">
                            <div class="form-group">
                                <label>上传图片 (可选)</label>
                                <div class="avatar-uploader">
                                    <img src="${defaultCover}" id="card-image-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                    <input type="file" id="card-image-input" accept="image/*" style="display:none;">
                                    <button class="upload-btn" onclick="document.getElementById('card-image-input').click()">选择图片</button>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="card-share-type">分享类型 (可选)</label>
                                <input type="text" id="card-share-type" placeholder="例如：地点分享, 文件分享">
                            </div>
                            <div class="form-group">
                                <label for="card-title">标题 (必填)</label>
                                <input type="text" id="card-title" placeholder="卡片标题">
                            </div>
                            <div class="form-group">
                                <label for="card-summary">简介 (可选, 35字以内)</label>
                                <input type="text" id="card-summary" placeholder="卡片简介" maxlength="35">
                            </div>
                            <div class="form-group">
                                <label for="card-details">详细内容 (可选, 100字以内)</label>
                                <textarea id="card-details" rows="3" placeholder="点击卡片后显示的详细内容" maxlength="100"></textarea>
                            </div>
                        </div>

                        <!-- Forward Style Form -->
                        <div id="forward-style-form" style="display: none;">
                            <div class="form-group">
                                <label for="forward-title">标题 (必填, 30字以内)</label>
                                <input type="text" id="forward-title" placeholder="转发的标题" maxlength="30">
                            </div>
                            <div class="form-group">
                                <label for="forward-content">内容 (必填, 400字以内)</label>
                                <textarea id="forward-content" rows="4" placeholder="转发的内容" maxlength="400"></textarea>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发送', class: 'btn-primary', handler: async () => {
                            const isForwardStyle = $('#card-style-toggle').checked;
                            const myProfile = await this.getPlayerProfileForContext(appState.currentChatId);
                            let message;
                            let exceededFields = [];

                            if (isForwardStyle) {
                                let title = $('#forward-title').value;
                                let content = $('#forward-content').value;

                                if (title.length > 30) {
                                    title = title.slice(0, 30);
                                    exceededFields.push('转发标题');
                                }
                                if (content.length > 300) {
                                    content = content.slice(0, 300);
                                    exceededFields.push('转发内容');
                                }
                                
                                title = title.trim();
                                content = content.trim();

                                if (!title || !content) return UIManager.showToast("标题和内容不能为空");
                                
                                message = {
                                    segmentType: 'forward_custom',
                                    content: `<转发>\n标题：${title}\n内容：${content}\n</转发>`,
                                    cardData: { title, content }
                                };

                            } else {
                                const title = $('#card-title').value.trim();
                                if (!title) return UIManager.showToast("标题不能为空");
                                
                                let summary = $('#card-summary').value;
                                let details = $('#card-details').value;

                                if (summary.length > 35) {
                                    summary = summary.slice(0, 35);
                                    exceededFields.push('简介');
                                }
                                if (details.length > 100) {
                                    details = details.slice(0, 100);
                                    exceededFields.push('详细内容');
                                }

                                summary = summary.trim();
                                details = details.trim();
                                
                                const shareType = $('#card-share-type').value.trim() || '分享';
                                const imageSrc = $('#card-image-preview').src;

                                message = {
                                    segmentType: 'card',
                                    content: `『${myProfile.name}|${shareType}|${title}|${summary}|${details}』`,
                                    cardData: {
                                        shareType, title, summary, details, imageSrc
                                    }
                                };
                            }
                            
                            if (exceededFields.length > 0) {
                                UIManager.showToast(`${exceededFields.join('、')}超出字数限制，已自动截断。`);
                            }

                            const finalMessage = {
                                messageId: Utils.generateId('msg'),
                                ...message,
                                type: 'sent',
                            };
                            
                            await this.handlePlayerSendMessage(finalMessage);
                            UIManager.hideModal();
                        }}
                    ]
                });

                $('#card-style-toggle').onchange = (e) => {
                    const isForward = e.target.checked;
                    $('#detailed-card-form').style.display = isForward ? 'none' : 'block';
                    $('#forward-style-form').style.display = isForward ? 'block' : 'none';
                };
                
                $('#card-image-input').onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#card-image-preview').src = await Utils.fileToBase64(file);
                    }
                };
            },

            async handleNewMoment() {
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';
                 UIManager.showModal({
                    isPersistent: true,
                    title: "发布动态",
                    body: `
                        <div class="form-group">
                            <label for="new-moment-content">此刻的想法...</label>
                            <textarea id="new-moment-content" rows="5"></textarea>
                        </div>
                        <div class="form-group">
                            <label>上传图片 (可选, 最多9张)</label>
                             <div class="avatar-uploader">
                                <div id="new-moment-images-preview" style="display:flex; flex-wrap:wrap; gap:10px;"></div>
                                <input type="file" id="new-moment-images-input" accept="image/*" multiple style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('new-moment-images-input').click()">选择图片</button>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发布', class: 'btn-primary', handler: async () => {
                            const content = $('#new-moment-content').value.trim();
                            const imagesPreview = $$('#new-moment-images-preview img');
                            const images = Array.from(imagesPreview).map(img => img.src);

                            if (!content && images.length === 0) {
                                return UIManager.showToast("动态内容和图片不能都为空哦");
                            }
                            
                            const myProfile = await this.getPlayerProfileForContext(appState.currentCircleId);
                            const newMoment = {
                                id: Utils.generateId('moment'),
                                circleId: appState.currentCircleId,
                                authorId: myProfile.id,
                                content: content,
                                images: images,
                                timestamp: Date.now(),
                                comments: []
                            };

                            await DBHelper.put('moments', newMoment);
                            UIManager.hideModal();
                            await UIManager.renderMomentsPage(); 
                            
                            
                            AIHandler.handleMomentsCommentRequest(newMoment.id);
                        }}
                    ]
                });
                
                $('#new-moment-images-input').addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files).slice(0, 9); 
                    const previewContainer = $('#new-moment-images-preview');
                    previewContainer.innerHTML = '';
                    for (const file of files) {
                        const base64 = await Utils.fileToBase64(file);
                        const img = document.createElement('img');
                        img.src = base64;
                        img.style.width = '60px';
                        img.style.height = '60px';
                        img.style.objectFit = 'cover';
                        img.style.borderRadius = '8px';
                        previewContainer.appendChild(img);
                    }
                });
            },

            async handlePlayerLike(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return;

                
                const circle = await DBHelper.get('circles', moment.circleId);
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile }; 

                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                

                if (!moment.likes) {
                    moment.likes = [];
                }

                const playerLikeIndex = moment.likes.indexOf(myProfile.name);

                if (playerLikeIndex > -1) {
                    moment.likes.splice(playerLikeIndex, 1);
                } else {
                    moment.likes.push(myProfile.name);
                }

                await DBHelper.put('moments', moment);

                const postElement = $(`[data-moment-id="${momentId}"]`);
                if (!postElement) return;

                const likeBtn = postElement.querySelector('[data-action="like"]');
                const interactionsContainer = postElement.querySelector('.post-interactions');
                const likesContainer = postElement.querySelector('.post-likes');
                const playerHasLiked = playerLikeIndex === -1;

                likeBtn.classList.toggle('liked', playerHasLiked);

                if (moment.likes.length > 0) {
                    likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    interactionsContainer.style.display = 'block';
                } else {
                    likesContainer.innerHTML = '';
                    if (!moment.comments || moment.comments.length === 0) {
                        interactionsContainer.style.display = 'none';
                    }
                }
            },

            toggleCommentInput(postElement, replyToAuthorName = null) {
                const inputWrapper = postElement.querySelector('.comment-input-wrapper');
                const inputField = inputWrapper.querySelector('input');
                
                
                if (inputWrapper.classList.contains('active') && inputWrapper.dataset.replyTo === (replyToAuthorName || '')) {
                    inputWrapper.classList.remove('active');
                    inputWrapper.dataset.replyTo = '';
                    inputField.placeholder = '评论...';
                    return;
                }

                inputWrapper.classList.add('active');
                postElement.querySelector('.post-interactions').style.display = 'block';
                
                if (replyToAuthorName) {
                    inputField.placeholder = `回复 @${replyToAuthorName}:`;
                    inputWrapper.dataset.replyTo = replyToAuthorName;
                } else {
                    inputField.placeholder = '评论...';
                    inputWrapper.dataset.replyTo = '';
                }
                
                inputField.focus();
            },

            async handlePlayerComment(momentId) {
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const inputWrapper = postElement.querySelector('.comment-input-wrapper');
                const input = inputWrapper.querySelector('input');
                const content = input.value.trim();

                if (!content) return;

                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return;

                
                const circle = await DBHelper.get('circles', moment.circleId);
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile }; 

                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                

                const newComment = {
                    authorId: myProfile.id,
                    content: content,
                    timestamp: Date.now()
                };
                
                const replyTo = inputWrapper.dataset.replyTo;
                if (replyTo) {
                    newComment.replyTo = replyTo;
                }

                if (!moment.comments) moment.comments = [];
                moment.comments.push(newComment);
                await DBHelper.put('moments', moment);

                const commentsList = postElement.querySelector('.post-comments-list');
                const commentDiv = document.createElement('div');
                commentDiv.className = 'post-comment-item';
                commentDiv.dataset.authorName = myProfile.name;
                commentDiv.dataset.authorId = myProfile.id;

                const replyHtml = replyTo ? `<span class="comment-reply-to"> 回复 </span><span class="comment-author">${replyTo}:</span>` : ':';
                commentDiv.innerHTML = `<span class="comment-author" style="color: #EDD4D8;">${myProfile.name}</span>${replyHtml} ${content}`;
                commentsList.appendChild(commentDiv);

                input.value = '';
                input.placeholder = '评论...';
                inputWrapper.dataset.replyTo = '';
                inputWrapper.classList.remove('active');

                AIHandler.handleMomentsPlayerCommentResponse(momentId, newComment);
            },

            handleMomentCommentInteractionStart(e, type) {
                const commentItem = e.target.closest('.post-comment-item');
                if (!commentItem) return;

                clearTimeout(appState.longPressTimer);

                const startAction = () => {
                    const existingButton = $('.retract-button-wrapper.show');
                    if (existingButton) existingButton.remove();
                    this.showCommentOptions(commentItem);
                };

                appState.longPressTimer = setTimeout(startAction, 500);

                const clearLongPress = () => {
                    clearTimeout(appState.longPressTimer);
                    document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                };
                document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
            },

            showCommentOptions(commentItem) {
                const wrapper = document.createElement('div');
                wrapper.className = 'retract-button-wrapper';
                wrapper.style.bottom = 'auto';
                wrapper.style.top = 'calc(100% + 2px)';

                wrapper.innerHTML = `<button class="retract-btn" data-action="delete-comment"><i class="fas fa-trash"></i> 删除</button>`;
                
                wrapper.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const button = e.target.closest('.retract-btn');
                    if (!button) return;

                    const action = button.dataset.action;
                    if (action === 'delete-comment') {
                        const momentId = commentItem.closest('.moments-post').dataset.momentId;
                        const commentIndex = Array.from(commentItem.parentNode.children).indexOf(commentItem);
                        this.confirmDeleteComment(momentId, commentIndex, commentItem);
                    }
                    wrapper.remove();
                });

                commentItem.style.position = 'relative';
                commentItem.appendChild(wrapper);
                setTimeout(() => wrapper.classList.add('show'), 10);
                
                const hideOnClickOutside = (event) => {
                    if (!wrapper.contains(event.target)) {
                        wrapper.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                document.addEventListener('click', hideOnClickOutside, true);
            },

            async confirmDeleteComment(momentId, commentIndex, commentElement) {
                const moment = await DBHelper.get('moments', momentId);
                const comment = moment?.comments?.[commentIndex];
                if (!comment) return;

                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allContacts = await DBHelper.getAll('contacts');
                let authorName = "未知用户";
                if(comment.authorId === myProfile.id) {
                    authorName = myProfile.name;
                } else {
                    const contact = allContacts.find(c => c.id === comment.authorId);
                    authorName = contact ? (contact.remark || contact.name) : (comment.authorId || '未知用户');
                }

                UIManager.showModal({
                    title: "确认删除",
                    body: `
                        <p>确定要删除这条评论吗？</p>
                        <div style="background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; font-size: 0.9rem; color: var(--text-color-medium);">
                            <strong>${authorName}:</strong> ${comment.content}
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            moment.comments.splice(commentIndex, 1);
                            await DBHelper.put('moments', moment);
                            commentElement.remove();
                            UIManager.showToast("评论已删除");
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            async handleSwitchCircle() {
                const circles = await DBHelper.getAll('circles');
                if (circles.length <= 1) {
                    return UIManager.showToast("没有其他圈子可以切换");
                }
                UIManager.showBottomSheet({
                    title: '切换圈子',
                    items: circles.map(c => ({ value: c.id, text: c.name })),
                    onSelect: async (value, text) => {
                        await UIManager.renderMomentsPage(value);
                        UIManager.hideSidebar();
                    }
                });
            },

            async handleViewCircleInfo() {
                const circle = await DBHelper.get('circles', appState.currentCircleId);
                if (!circle) return;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const presets = myProfile.presets || [];

                const memberNames = circle.memberIds.map(id => allContacts.find(c => c.id === id)?.name || '未知好友').join('、');
                const extraNames = circle.extraMembers || '无';
                const boundFolders = (await DBHelper.getAll('promptFolders')).filter(f => circle.boundPromptFolderIds && circle.boundPromptFolderIds.includes(f.id));
                const boundFolderNames = boundFolders.map(f => f.name).join('、') || '无';
                
                let boundPersonaName = '未绑定 (使用当前人设)';
                if (circle.boundPersonaPresetId) {
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        boundPersonaName = boundPreset.presetName || boundPreset.name;
                    }
                }

                UIManager.showModal({
                    title: "圈子信息",
                    body: `
                        <div class="details-card">
                            <div class="details-header">
                                <img src="${circle.backgroundImage || 'https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png'}" class="avatar" style="border-radius: 8px;">
                                <div class="details-info">
                                    <div class="name">${circle.name}</div>
                                </div>
                            </div>
                        </div>
                        <div class="details-card">
                            <div class="details-section">
                                <div class="details-section-title">圈内好友</div>
                                <p style="max-height: 80px;">${memberNames}</p>
                            </div>
                             <div class="details-section">
                                <div class="details-section-title">额外好友</div>
                                <p>${extraNames}</p>
                            </div>
                            <div class="details-section">
                                <div class="details-section-title">绑定玩家人设</div>
                                <p>${boundPersonaName}</p>
                            </div>
                             <div class="details-section">
                                <div class="details-section-title">绑定提示词</div>
                                <p>${boundFolderNames}</p>
                            </div>
                        </div>
                    `,
                    actions: [{ text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleAddCircle() {
                const allContacts = await DBHelper.getAll('contacts');
                const allFolders = await DBHelper.getAll('promptFolders');
                if (allContacts.length === 0) {
                    return UIManager.showToast("通讯录中还没有好友，无法创建圈子。");
                }
                
                let selectedPersonaId = null; 

                const membersHtml = allContacts.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-members" value="${f.id}"><span>${f.name}</span></label>`).join('');
                const foldersHtml = allFolders.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-folders" value="${f.id}"><span>${f.name}</span></label>`).join('');

                UIManager.showModal({
                    title: "新增圈子",
                    body: `
                        <div class="form-group"><label for="circle-name-input">圈子名称</label><input type="text" id="circle-name-input"></div>
                        <div class="form-group"><label>圈内好友 (至少选1个)</label><div class="member-select-list">${membersHtml}</div></div>
                        <div class="form-group"><label for="circle-extra-input">额外好友 (选填, 逗号隔开)</label><input type="text" id="circle-extra-input" placeholder="三三,入入,vv"></div>
                        <div class="form-group"><label>绑定提示词文件夹 (可选)</label><div class="member-select-list" style="max-height:150px;">${foldersHtml}</div></div>
                        <div class="form-group">
                            <label>绑定玩家人设 (可选)</label>
                            <button id="circle-persona-bind-btn" class="modal-btn btn-secondary" style="width: 100%; text-align: left; padding: 12px 15px;">
                                <i class="fas fa-user-tag" style="margin-right: 10px;"></i>
                                <span id="circle-persona-name">未绑定 (使用当前人设)</span>
                            </button>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '创建', class: 'btn-primary', handler: async () => {
                            const name = $('#circle-name-input').value.trim();
                            if (!name) return UIManager.showToast("圈子名称不能为空");
                            
                            const existing = await DBHelper.getAll('circles', 'name');
                            if(existing.some(c => c.name === name)) return UIManager.showToast("该圈子名称已存在");

                            const memberIds = [...$$('input[name="circle-members"]:checked')].map(cb => cb.value);
                            if (memberIds.length === 0) return UIManager.showToast("至少选择一名好友");

                            const boundPromptFolderIds = [...$$('input[name="circle-folders"]:checked')].map(cb => cb.value);
                            
                            const newCircle = {
                                id: Utils.generateId('circle'),
                                name: name,
                                memberIds: memberIds,
                                extraMembers: $('#circle-extra-input').value.trim(),
                                boundPromptFolderIds: boundPromptFolderIds,
                                boundPersonaPresetId: selectedPersonaId, 
                                backgroundImage: null,
                                createdAt: Date.now(),
                                lastRefreshed: 0
                            };

                            await DBHelper.put('circles', newCircle);
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage(newCircle.id); 
                        }}
                    ]
                });

                $('#circle-persona-bind-btn').addEventListener('click', async () => {
                    const myProfile = await DBHelper.get('profile', 'myProfile');
                    const presets = myProfile.presets || [];
                    const items = [
                        { value: 'null', text: '不绑定 (使用当前人设)' },
                        ...presets.map(preset => ({
                            value: preset.presetId, 
                            text: preset.name
                        }))
                    ];
                    UIManager.showBottomSheet({
                        title: '选择玩家人设',
                        items: items,
                        onSelect: (value, text) => {
                            selectedPersonaId = (value === 'null') ? null : value; 
                            if (selectedPersonaId === null) {
                                $('#circle-persona-name').textContent = '未绑定 (使用当前人设)';
                            } else {
                                $('#circle-persona-name').textContent = text;
                            }
                        }
                    });
                });
            },

            async handleEditCircle(circleId) {
                if (!circleId) return UIManager.showToast("请先选择一个圈子");
                const circle = await DBHelper.get('circles', circleId);
                const allContacts = await DBHelper.getAll('contacts');
                const allFolders = await DBHelper.getAll('promptFolders');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const presets = myProfile.presets || [];

                let selectedPersonaId = circle.boundPersonaPresetId; 
                let personaName = '未绑定 (使用当前人设)';
                if (selectedPersonaId) { 
                    const boundPreset = presets.find(p => p.presetId === selectedPersonaId);
                    if (boundPreset) {
                        personaName = boundPreset.presetName || boundPreset.name;
                    }
                }

                const membersHtml = allContacts.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-members" value="${f.id}" ${circle.memberIds.includes(f.id) ? 'checked' : ''}><span>${f.name}</span></label>`).join('');
                const foldersHtml = allFolders.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-folders" value="${f.id}" ${circle.boundPromptFolderIds && circle.boundPromptFolderIds.includes(f.id) ? 'checked' : ''}><span>${f.name}</span></label>`).join('');

                 UIManager.showModal({
                    title: "修改圈子",
                    body: `
                        <div class="form-group"><label for="circle-name-input">圈子名称</label><input type="text" id="circle-name-input" value="${circle.name}"></div>
                        <div class="form-group"><label>圈内好友 (至少选1个)</label><div class="member-select-list">${membersHtml}</div></div>
                        <div class="form-group"><label for="circle-extra-input">额外好友 (选填, 逗号隔开)</label><input type="text" id="circle-extra-input" value="${circle.extraMembers || ''}"></div>
                        <div class="form-group"><label>绑定提示词文件夹 (可选)</label><div class="member-select-list" style="max-height:150px;">${foldersHtml}</div></div>
                        <div class="form-group">
                            <label>绑定玩家人设 (可选)</label>
                            <button id="circle-persona-bind-btn" class="modal-btn btn-secondary" style="width: 100%; text-align: left; padding: 12px 15px;">
                                <i class="fas fa-user-tag" style="margin-right: 10px;"></i>
                                <span id="circle-persona-name">${personaName}</span>
                            </button>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                             const name = $('#circle-name-input').value.trim();
                            if (!name) return UIManager.showToast("圈子名称不能为空");
                            
                            const existing = (await DBHelper.getAll('circles', 'name')).filter(c => c.id !== circleId);
                            if(existing.some(c => c.name === name)) return UIManager.showToast("该圈子名称已存在");

                            const memberIds = [...$$('input[name="circle-members"]:checked')].map(cb => cb.value);
                            if (memberIds.length === 0) return UIManager.showToast("至少选择一名好友");

                            const boundPromptFolderIds = [...$$('input[name="circle-folders"]:checked')].map(cb => cb.value);
                            
                            const updatedCircle = { 
                                ...circle, 
                                name, 
                                memberIds, 
                                boundPromptFolderIds, 
                                boundPersonaPresetId: selectedPersonaId, 
                                extraMembers: $('#circle-extra-input').value.trim() 
                            };
                            await DBHelper.put('circles', updatedCircle);
                            UIManager.hideModal();
                            await UIManager.renderMomentsPage();
                        }}
                    ]
                });
                
                $('#circle-persona-bind-btn').addEventListener('click', async () => {
                    const items = [
                        { value: 'null', text: '不绑定 (使用当前人设)' },
                        ...presets.map(preset => ({
                            value: preset.presetId, 
                            text: preset.name
                        }))
                    ];
                    UIManager.showBottomSheet({
                        title: '选择玩家人设',
                        items: items,
                        onSelect: (value, text) => {
                            selectedPersonaId = (value === 'null') ? null : value; 
                            if (selectedPersonaId === null) {
                                $('#circle-persona-name').textContent = '不绑定 (使用当前人设)';
                            } else {
                                $('#circle-persona-name').textContent = text;
                            }
                        }
                    });
                });
            },

            async handleDeleteCircle() {
                const circles = await DBHelper.getAll('circles');
                 if (circles.length === 0) return UIManager.showToast("没有可删除的圈子");

                const circlesHtml = circles.map(c => `<label class="member-select-item"><input type="checkbox" name="delete-circle" value="${c.id}"><span>${c.name}</span></label>`).join('');
                 UIManager.showModal({
                    title: "删除圈子",
                    body: `<p style="margin-bottom:10px;">选择要删除的圈子（将同时删除圈子下的所有动态）：</p><div class="member-select-list">${circlesHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            const idsToDelete = [...$$('input[name="delete-circle"]:checked')].map(cb => cb.value);
                            if (idsToDelete.length === 0) return;

                            for (const id of idsToDelete) {
                                await DBHelper.delete('circles', id);
                                const momentsToDelete = (await DBHelper.getAll('moments')).filter(m => m.circleId === id);
                                for (const moment of momentsToDelete) {
                                    await DBHelper.delete('moments', moment.id);
                                }
                            }
                            
                            if (idsToDelete.includes(appState.currentCircleId)) {
                                appState.currentCircleId = null; 
                            }
                            
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage();
                        }}
                    ]
                 });
            },

            async handleClearCircleHistory() {
                const circleId = appState.currentCircleId;
                if (!circleId) return;

                const circle = await DBHelper.get('circles', circleId);

                UIManager.showModal({
                    title: `清空"${circle.name}"动态`,
                    body: `<p>确定要清空此朋友圈的所有动态吗？此操作不可恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认清空', class: 'btn-danger', handler: async () => {
                            const allMoments = await DBHelper.getAll('moments');
                            const momentsToDelete = allMoments.filter(m => m.circleId === circleId);

                            for (const moment of momentsToDelete) {
                                await DBHelper.delete('moments', moment.id);
                            }

                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage();
                            UIManager.showToast(`"${circle.name}" 的动态已清空。`);
                        }}
                    ]
                });
            },

            async handleExportPrompts() {
                const folders = await DBHelper.getAll('promptFolders');
                if (folders.length === 0) {
                    return UIManager.showToast("没有可导出的文件夹");
                }
                const folderListHtml = folders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="export-folder" value="${f.id}">
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "选择要导出的文件夹",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '生成文件', class: 'btn-primary', handler: async () => {
                            const selectedFolderIds = [...$$('input[name="export-folder"]:checked')].map(cb => cb.value);
                            if (selectedFolderIds.length === 0) {
                                return UIManager.showToast("请至少选择一个文件夹");
                            }

                            const allPrompts = await DBHelper.getAll('prompts');
                            
                            
                            let filenamePart;
                            if (selectedFolderIds.length === 1) {
                                const folder = folders.find(f => f.id === selectedFolderIds[0]);
                                filenamePart = folder ? folder.name : '未知文件夹';
                            } else {
                                filenamePart = '多个文件夹_提示词导出';
                            }
                            const finalFilename = `${filenamePart}_${new Date().toISOString().slice(0,10)}.json`;
                            
                            
                            const foldersToExport = folders.filter(f => selectedFolderIds.includes(f.id));
                            const promptsToExport = allPrompts.filter(p => selectedFolderIds.includes(p.folderId));
                            
                            const exportData = {
                                folders: foldersToExport,
                                prompts: promptsToExport
                            };
                            
                            const jsonString = JSON.stringify(exportData, null, 2);
                            const blob = new Blob([jsonString], {type: "application/json"});
                            const url = URL.createObjectURL(blob);
                            
                            UIManager.showModal({
                                title: '文件已生成',
                                body: `
                                    <p>请点击下面的链接下载文件。</p>
                                    <a href="${url}" download="${finalFilename}" class="modal-btn btn-primary" style="display: block; text-align: center; margin-top: 20px;">
                                        点击下载 ${finalFilename}
                                    </a>
                                    <p style="font-size: 0.8rem; color: #aaa; text-align: center; margin-top: 15px;">(下载后此链接将失效)</p>
                                `,
                                actions: [{
                                    text: '关闭',
                                    class: 'btn-secondary',
                                    handler: () => {
                                        URL.revokeObjectURL(url);
                                        UIManager.hideModal();
                                    }
                                }]
                            });
                        }}
                    ]
                });
            },

            async handleWishPool() {
                UIManager.showModal({
                    title: "角色许愿池",
                    body: `
                        <div class="details-actions" style="flex-direction: column; gap: 15px;">
                            <button class="details-btn" data-action="buyable" style="border-color: var(--accent-color); color: var(--accent-color-deep);">
                                <i class="fas fa-shopping-cart" style="margin-right: 8px;"></i>可购角色卡
                            </button>
                            <button class="details-btn" data-action="wishlist" style="border-color: var(--theme-color-2);">
                                <i class="fas fa-list-alt" style="margin-right: 8px;"></i>许愿池清单
                            </button>
                        </div>
                    `,
                    actions: [
                        { text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() }
                    ]
                });
                
                modalContentWrapper.querySelector('[data-action="buyable"]').addEventListener('click', () => {
                    window.open('https://kdocs.cn/l/cdeUgNwxlWKR', '_blank');
                });
                modalContentWrapper.querySelector('[data-action="wishlist"]').addEventListener('click', () => {
                    window.open('https://docs.qq.com/form/page/DUG5yVWFEZGFxRXd1', '_blank');
                });
            },

            handleImportPrompts() {
                const fileInput = $('#import-prompts-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const importedData = JSON.parse(event.target.result);
                            
                            if (!importedData.folders || !importedData.prompts) {
                                return UIManager.showToast("文件格式不正确");
                            }
                            
                            const existingFolders = await DBHelper.getAll('promptFolders');
                            let importedCount = 0;

                            for (const importedFolder of importedData.folders) {
                                if (existingFolders.some(f => f.name === importedFolder.name)) {
                                    UIManager.showToast(`已跳过：文件夹 "${importedFolder.name}" 已存在`);
                                    continue;
                                }
                                
                                const oldFolderId = importedFolder.id;
                                const newFolder = {
                                    ...importedFolder,
                                    id: Utils.generateId('folder'), 
                                    createdAt: Date.now()
                                };
                                await DBHelper.put('promptFolders', newFolder);
                                
                                
                                const promptsToImport = importedData.prompts.filter(p => p.folderId === oldFolderId);
                                for (const importedPrompt of promptsToImport) {
                                    const newPrompt = {
                                        ...importedPrompt,
                                        id: Utils.generateId('prompt'), 
                                        folderId: newFolder.id, 
                                        createdAt: Date.now()
                                    };
                                    await DBHelper.put('prompts', newPrompt);
                                    importedCount++;
                                }
                            }
                            
                            UIManager.showToast(`导入完成，共导入 ${importedCount} 条提示词`);
                            this.renderPromptsPage();

                        } catch (error) {
                            console.error("导入失败: ", error);
                            UIManager.showToast("导入失败，文件可能已损坏");
                        } finally {
                            
                            fileInput.value = '';
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            async showAddEditFriendFolderModal(folderId = null) {
                const isEditing = folderId !== null;
                const folder = isEditing ? await DBHelper.get('friendFolders', folderId) : null;
                const allContacts = await DBHelper.getAll('contacts');
                const allFriendFolders = await DBHelper.getAll('friendFolders');
                const folderMap = allFriendFolders.reduce((map, f) => {
                    map[f.id] = f.name;
                    return map;
                }, {});

                let membersHtml = allContacts.map(contact => {
                    const isChecked = isEditing && folder.memberIds.includes(contact.id);
                    let groupInfo = '';
                    if (contact.folderId && (!isEditing || contact.folderId !== folderId)) {
                        groupInfo = ` (在分组: ${folderMap[contact.folderId] || '未知'})`;
                    }
                    return `
                        <label class="member-select-item" data-friend-name="${(contact.remark || contact.name).toLowerCase()}" data-friend-id="${contact.name.toLowerCase()}">
                            <input type="checkbox" name="friend-folder-members" value="${contact.id}" ${isChecked ? 'checked' : ''}>
                            <img src="${contact.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                            <span>${contact.remark || contact.name}${groupInfo}</span>
                        </label>
                    `;
                }).join('');

                UIManager.showModal({
                    title: isEditing ? '编辑好友分组' : '新建好友分组',
                    body: `
                        <div class="form-group">
                            <label for="friend-folder-name">分组名称</label>
                            <input type="text" id="friend-folder-name" value="${isEditing ? folder.name : ''}">
                        </div>
                        <div class="form-group">
                            <label for="friend-folder-search">搜索好友 (备注/ID)</label>
                            <input type="text" id="friend-folder-search" placeholder="输入以筛选列表...">
                        </div>
                        <div class="form-group">
                            <label>选择好友</label>
                            <div class="member-select-list" id="friend-folder-member-list">${membersHtml}</div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const name = $('#friend-folder-name').value.trim();
                            if (!name) return UIManager.showToast("分组名称不能为空");

                            const existingFolders = (await DBHelper.getAll('friendFolders')).filter(f => f.id !== folderId);
                            if (existingFolders.some(f => f.name === name)) {
                                return UIManager.showToast("该分组名称已存在");
                            }

                            const selectedMemberIds = [...$$('input[name="friend-folder-members"]:checked')].map(cb => cb.value);
                            const updatedFolder = isEditing ? { ...folder, name, memberIds: selectedMemberIds } : {
                                id: Utils.generateId('friendFolder'),
                                name,
                                memberIds: selectedMemberIds,
                                boundPersonaPresetIndex: null,
                                createdAt: Date.now()
                            };

                            await DBHelper.put('friendFolders', updatedFolder);

                            const contactsToUpdate = await Promise.all(
                                allContacts.map(c => DBHelper.get('contacts', c.id))
                            );

                            for (const contact of contactsToUpdate) {
                                const isInNewSelection = selectedMemberIds.includes(contact.id);
                                
                                if (isInNewSelection && contact.folderId !== updatedFolder.id) {
                                    contact.folderId = updatedFolder.id;
                                    await DBHelper.put('contacts', contact);
                                } else if (!isInNewSelection && contact.folderId === updatedFolder.id) {
                                    delete contact.folderId;
                                    await DBHelper.put('contacts', contact);
                                }
                            }
                            
                            UIManager.hideModal();
                            await UIManager.renderFriendFoldersPage();
                        }}
                    ]
                });
                
                $('#friend-folder-search').addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    $$('#friend-folder-member-list .member-select-item').forEach(item => {
                        const name = item.dataset.friendName;
                        const id = item.dataset.friendId;
                        item.style.display = (name.includes(searchTerm) || id.includes(searchTerm)) ? 'flex' : 'none';
                    });
                });
            },

            async confirmDeleteFriendFolder(folderId) {
                const folder = await DBHelper.get('friendFolders', folderId);
                if (!folder) return;

                const allGroups = await DBHelper.getAll('groups');
                const problematicMembers = [];
                for (const memberId of folder.memberIds) {
                    const groupsIn = allGroups.filter(g => g.members.includes(memberId));
                    if (groupsIn.length > 0) {
                        const contact = await DBHelper.get('contacts', memberId);
                        problematicMembers.push({
                            name: contact.remark || contact.name,
                            groups: groupsIn.map(g => g.name).join(', ')
                        });
                    }
                }

                if (problematicMembers.length > 0) {
                    const errorMsg = problematicMembers.map(p => `<strong>${p.name}</strong> 仍在群聊: ${p.groups}`).join('<br>');
                    return UIManager.showModal({
                        title: "无法删除分组",
                        body: `<p>以下好友因仍在群聊中而无法删除此好友分组，请先将其移出群聊：</p><div style="text-align:left; max-height: 150px; overflow-y: auto; background: #f0f0f0; padding: 10px; border-radius: 8px;">${errorMsg}</div>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                }

                UIManager.showModal({
                    title: '确认删除分组',
                    body: `<p>确定要删除分组 <strong>"${folder.name}"</strong> 吗？分组内的好友将被移至“未分组”。此操作不可恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认删除', class: 'btn-danger', handler: async () => {
                            for (const memberId of folder.memberIds) {
                                const contact = await DBHelper.get('contacts', memberId);
                                if (contact && contact.folderId === folderId) {
                                    delete contact.folderId;
                                    await DBHelper.put('contacts', contact);
                                }
                            }
                            await DBHelper.delete('friendFolders', folderId);
                            
                            UIManager.hideModal();
                            await UIManager.renderFriendFoldersPage();
                            UIManager.showToast(`分组 "${folder.name}" 已删除。`);
                        }}
                    ]
                });
            },
            
            async showPersonaBindingModal(entityId, isGroupChat) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const presets = (myProfile.presets || []).filter(p => p); 

                let entity, storeName;
                if (isGroupChat) {
                    entity = await DBHelper.get('groups', entityId);
                    storeName = 'groups';
                } else {
                    entity = await DBHelper.get('contacts', entityId);
                    if (entity) {
                        storeName = 'contacts';
                    } else {
                        entity = await DBHelper.get('friendFolders', entityId);
                        storeName = 'friendFolders';
                    }
                }

                if (!entity) return;

                const boundId = entity.boundPersonaPresetId; 

                let presetsHtml = presets.map(preset => {
                    return `
                        <label class="member-select-item">
                            <input type="radio" name="persona-preset" value="${preset.presetId}" ${boundId === preset.presetId ? 'checked' : ''}>
                            <img src="${preset.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                            <span>${preset.presetName || preset.name}</span>
                        </label>
                    `;
                }).join('');

                let boundInfo = '';
                if (boundId && !presets.some(p => p.presetId === boundId)) {
                    boundInfo = `<p style="color: #e74c3c; text-align: center; margin-bottom: 10px;">注意：已绑定的预设已被删除，将自动使用当前玩家人设。</p>`;
                }
                
                const hint = `<p style="font-size: 0.8rem; color: var(--text-color-medium); text-align: center; margin-top: 15px;">提示：好友分组和群聊的人设绑定是分开的，不要忘记啦。</p>`;

                UIManager.showModal({
                    title: '绑定玩家人设',
                    body: `
                        ${boundInfo}
                        <div class="member-select-list" style="max-height: 40vh;">
                            <label class="member-select-item">
                                <input type="radio" name="persona-preset" value="null" ${!boundId ? 'checked' : ''}>
                                <span>不绑定 (使用当前人设)</span>
                            </label>
                            ${presetsHtml}
                        </div>
                        ${hint}
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const selectedRadio = document.querySelector('input[name="persona-preset"]:checked');
                            if (!selectedRadio) return;

                            const selectedId = selectedRadio.value;
                            entity.boundPersonaPresetId = (selectedId === 'null') ? null : selectedId;

                            
                            delete entity.boundPersonaPresetIndex;

                            await DBHelper.put(storeName, entity);
                            
                            UIManager.hideModal();
                            UIManager.showToast('人设绑定已更新！');
                        }}
                    ]
                });
            },

            async showCircleBindingModal(entityId, isFolder) {
                const circles = await DBHelper.getAll('circles');
                if (circles.length === 0) {
                    return UIManager.showToast("还没有创建任何圈子");
                }

                const storeName = isFolder ? 'friendFolders' : 'contacts';
                const entity = await DBHelper.get(storeName, entityId);
                if (!entity) return;

                let itemsHtml;
                const boundCircleId = entity.boundCircleId || 'null';

                
                if (isFolder) {
                    
                    itemsHtml = `
                        <label class="member-select-item">
                            <input type="radio" name="circle-bind" value="null" checked>
                            <span>不绑定</span>
                        </label>
                        ${circles.map(c => `
                            <label class="member-select-item">
                                <input type="radio" name="circle-bind" value="${c.id}">
                                <span>${c.name}</span>
                            </label>
                        `).join('')}
                    `;
                } else {
                    
                    itemsHtml = `
                        <label class="member-select-item">
                            <input type="radio" name="circle-bind" value="null" ${boundCircleId === 'null' ? 'checked' : ''}>
                            <span>不绑定</span>
                        </label>
                        ${circles.map(c => `
                            <label class="member-select-item">
                                <input type="radio" name="circle-bind" value="${c.id}" ${boundCircleId === c.id ? 'checked' : ''}>
                                <span>${c.name}</span>
                            </label>
                        `).join('')}
                    `;
                }

                
                const hintText = `<p style="font-size: 0.8rem; color: var(--text-color-medium); text-align: center; margin-top: 15px; line-height: 1.5;">
                    提示：绑定后，AI在聊天时可能会触发即时朋友圈动态。此动态不受圈子内好友限制，评论区可能出现设定外的角色。
                </p>`;

                UIManager.showModal({
                    title: isFolder ? `为分组“${entity.name}”绑定朋友圈` : `为好友“${entity.remark || entity.name}”绑定朋友圈`,
                    
                    body: `<div class="member-select-list" style="max-height: 40vh;">${itemsHtml}</div>${hintText}`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const selected = document.querySelector('input[name="circle-bind"]:checked');
                            if (!selected) return;

                            const newBoundId = selected.value === 'null' ? null : selected.value;
                            
                            if (isFolder) {
                                UIManager.showModal({
                                    title: '确认批量绑定',
                                    body: `<p>这将把分组“<strong>${entity.name}</strong>”内所有好友的朋友圈绑定都更新为所选圈子。确定要继续吗？</p><p style="font-size: 0.8rem; color: #aaa;">此操作会覆盖好友原有的单独绑定。</p>`,
                                    actions: [
                                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                        { text: '确认', class: 'btn-primary', handler: async () => {
                                            entity.boundCircleId = newBoundId;
                                            await DBHelper.put(storeName, entity);
                                            
                                            const contactsInFolder = (await DBHelper.getAll('contacts')).filter(c => c.folderId === entityId);
                                            for (const contact of contactsInFolder) {
                                                contact.boundCircleId = newBoundId;
                                                await DBHelper.put('contacts', contact);
                                            }
                                            UIManager.hideModal();
                                            UIManager.showToast('分组朋友圈绑定已更新！');
                                        }}
                                    ]
                                });
                            } else {
                                entity.boundCircleId = newBoundId;
                                await DBHelper.put(storeName, entity);
                                UIManager.hideModal();
                                UIManager.showToast('好友朋友圈绑定已更新！');
                            }
                        }}
                    ]
                });
            },

            startPomodoro() {
                const goal = $('#pomodoro-goal-input').value.trim();
                if (!goal) {
                    UIManager.showToast("先为你的专注时段定一个目标吧！");
                    return;
                }

                appState.pomodoro.isActive = true;
                appState.pomodoro.goal = goal;
                appState.pomodoro.totalSeconds = 1500; 
                appState.pomodoro.endTime = Date.now() + appState.pomodoro.totalSeconds * 1000;
                appState.pomodoro.timerId = setInterval(() => this.updatePomodoroTimer(), 1000);

                
                localStorage.setItem('pomodoroState', JSON.stringify(appState.pomodoro));

                UIManager.renderPomodoroPage();
                this.updateFloatingBallVisibility();
            },

            stopPomodoro(isCompleted = false) {
                if (!appState.pomodoro.isActive) return;

                clearInterval(appState.pomodoro.timerId);

                if (isCompleted) {
                    UIManager.showPomodoroEndNotification(appState.pomodoro.goal);
                }

                appState.pomodoro.isActive = false;
                appState.pomodoro.goal = '';
                appState.pomodoro.endTime = null;
                appState.pomodoro.timerId = null;
                
                
                localStorage.setItem('pomodoroState', JSON.stringify(appState.pomodoro));

                UIManager.renderPomodoroPage();
                this.updateFloatingBallVisibility();
            },

            updatePomodoroTimer() {
                if (!appState.pomodoro.isActive || !appState.pomodoro.endTime) {
                    this.stopPomodoro();
                    return;
                }

                const now = Date.now();
                const remainingSeconds = Math.round((appState.pomodoro.endTime - now) / 1000);

                if (remainingSeconds <= 0) {
                    this.stopPomodoro(true);
                    return;
                }

                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                if (appState.currentPage === 'pomodoro') {
                    $('#pomodoro-timer-display').textContent = timeString;
                }
                
                const floatBall = $('#pomodoro-float-ball');
                if (floatBall) {
                    floatBall.querySelector('.time-left').textContent = timeString;
                    const progress = (appState.pomodoro.totalSeconds - remainingSeconds) / appState.pomodoro.totalSeconds;
                    floatBall.querySelector('.progress-ring').style.background = `conic-gradient(var(--accent-color) ${progress * 360}deg, #e0e0e0 0deg)`;
                }
            },

            updateFloatingBallVisibility() {
                const floatBall = $('#pomodoro-float-ball');
                if (appState.pomodoro.isActive && appState.currentPage !== 'pomodoro') {
                    floatBall.classList.remove('hidden');
                } else {
                    floatBall.classList.add('hidden');
                }
            },



            createGiftCard(giftData) {
                const card = document.createElement('div');
                card.className = 'gift-card';
                card.innerHTML = `
                    <img src="${giftData.image || giftData.url}" alt="${giftData.name}">
                    <div class="gift-card-info">
                        <div class="name">${giftData.name}</div>
                        <div class="price">￥${giftData.price.toFixed(2)}</div>
                    </div>
                `;
                return card;
            },

            showGiftHelpModal() {
                UIManager.showModal({
                    title: "礼物搜索帮助",
                    body: `
                        <p>礼物搜索功能通过AI生成，因此在使用前需要正确配置API，此功能仅供娱乐搜索。除了AI搜索，你还可以选择<strong>自定义</strong>手动填入自己想要赠送的礼物</p>
                        <p><strong>1. API配置：</strong> 点击页面上的“API配置”按钮，填入你的API信息。由于礼物搜索功能相对简单，你可以选择一些免费或价格较低的模型。</p>
                        <p><strong>2. 推荐模型：</strong></p>
                        <ul>
                            <li><strong>SiliconFlow (硅基流动):</strong> <code>deepseek-ai/DeepSeek-R1-0528-Qwen3-8B</code>(在硅基流动官网上,该模型目前是免费模型,但使用时依然需要填写正确的API key)</li>
                        </ul>
                        <p><strong>3. 绑定提示词：</strong> 你还可以通过“绑定”功能，选择一个或多个自定义提示词文件夹。这些提示词将在每次搜索时附加，用于影响AI生成礼物的风格和类型，实现更个性化的搜索结果。</p>
                    `,
                    actions: [{ text: '我明白了', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleGiftPromptBinding() {
                const giftApiConfig = await DBHelper.get('giftApiConfig', 'mainConfig') || {};
                const boundFolderIds = giftApiConfig.giftPromptFolderIds || [];
                const allFolders = await DBHelper.getAll('promptFolders');

                if (allFolders.length === 0) {
                    return UIManager.showToast("你还没有创建任何提示词文件夹。");
                }

                const folderListHtml = allFolders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="bind-gift-folder" value="${f.id}" ${boundFolderIds.includes(f.id) ? 'checked' : ''}>
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "绑定礼物搜索提示词",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const selectedIds = [...$$('input[name="bind-gift-folder"]:checked')].map(cb => cb.value);
                            const configToSave = await DBHelper.get('giftApiConfig', 'mainConfig') || { id: 'mainConfig' };
                            configToSave.giftPromptFolderIds = selectedIds;
                            await DBHelper.put('giftApiConfig', configToSave);
                            UIManager.hideModal();
                            UIManager.showToast("绑定已更新！");
                        }}
                    ]
                });
            },

            async showSendGiftModal(giftData) {
                const isGroup = appState.currentChatId.startsWith('group-');

                const displayFinalModal = (recipient) => {
                    UIManager.showModal({
                        title: `送给 ${recipient.remark || recipient.name}`,
                        body: `
                            <div style="text-align: center; margin-bottom: 20px;">
                                <img src="${giftData.image || giftData.url}" alt="${giftData.name}" style="width: 100px; height: 100px; object-fit: cover; border-radius: 12px;">
                                <h4 style="margin: 10px 0 5px;">${giftData.name}</h4>
                                <p style="color: var(--text-color-medium); font-size: 0.9rem; margin-bottom: 10px;">${giftData.description || giftData.message || '一份特别的礼物'}</p>
                                <p style="color: var(--accent-color-deep); font-weight: bold;">￥${giftData.price.toFixed(2)}</p>
                            </div>
                            <div class="form-group">
                                <label for="gift-final-message">寄语 (选填)</label>
                                <input type="text" id="gift-final-message" value="" placeholder="送你一份心意。">
                            </div>
                        `,
                        actions: [
                            { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                            { text: '赠送', class: 'btn-primary', handler: async () => {
                                const message = $('#gift-final-message').value.trim();
                                
                                const giftMessage = {
                                    messageId: Utils.generateId('msg'),
                                    content: `[礼物] ${giftData.name}`,
                                    type: 'sent',
                                    segmentType: 'gift',
                                    cardData: {
                                        recipientName: recipient.name, 
                                        name: giftData.name,
                                        price: giftData.price.toFixed(2),
                                        image: giftData.image || giftData.url,
                                        message: message || '送你一份心意。',
                                        description: giftData.description || ''
                                    }
                                };
                                
                                await this.handlePlayerSendMessage(giftMessage);
                                UIManager.hideModal();
                                UIManager.navigateTo('chat');
                            }}
                        ]
                    });
                };

                if (isGroup) {
                    const group = await DBHelper.get('groups', appState.currentChatId);
                    const allContacts = await DBHelper.getAll('contacts');
                    const members = group.members
                        .map(id => allContacts.find(c => c.id === id))
                        .filter(Boolean);

                    if (members.length === 0) {
                        return UIManager.showToast("群聊中没有可以赠送礼物的成员。");
                    }

                    UIManager.showBottomSheet({
                        title: '选择要赠送的成员',
                        customClass: 'compact-list',
                        items: members.map(m => ({ value: m.id, text: m.remark || m.name })),
                        onSelect: async (selectedMemberId) => {
                            const selectedMember = members.find(m => m.id === selectedMemberId);
                            if (selectedMember) {
                                displayFinalModal(selectedMember);
                            }
                        }
                    });

                } else {
                    const recipient = await DBHelper.get('contacts', appState.currentChatId);
                    if (recipient) {
                        displayFinalModal(recipient);
                    }
                }
            },

async showGiftDetailsModal(messageId) {
    const msg = await DBHelper.get('messages', messageId);
    if (!msg || !msg.cardData) return;

    const myProfile = await this.getPlayerProfileForContext(msg.chatId);
    let sender, recipient;

    if (msg.type === 'sent') {
        sender = myProfile;
        const isGroupChat = msg.chatId.startsWith('group-');
        if (isGroupChat) {
            
            const allContacts = await DBHelper.getAll('contacts');
            recipient = allContacts.find(c => c.name === msg.cardData.recipientName) || { name: msg.cardData.recipientName };
        } else {
            
            recipient = await DBHelper.get('contacts', msg.chatId);
        }
    } else {
        
        sender = await DBHelper.get('contacts', msg.senderId) || { name: '未知发件人' };
        recipient = myProfile;
    }

    UIManager.showModal({
        title: "礼物详情",
        body: `
            <div style="text-align: center; margin-bottom: 20px;">
                <img src="${msg.cardData.image}" alt="${msg.cardData.name}" style="width: 120px; height: 120px; object-fit: cover; border-radius: 12px; box-shadow: var(--shadow-light);">
                <h3 style="margin: 15px 0 5px;">${msg.cardData.name}</h3>
                <p style="color: var(--accent-color-deep); font-weight: bold; margin-bottom: 15px;">￥${msg.cardData.price}</p>
            </div>
            <div class="details-card" style="padding: 15px;">
                <div class="details-field"><span class="label">赠送方</span><span class="value">${sender.name}</span></div>
                <div class="details-field"><span class="label">接收方</span><span class="value">${recipient.name}</span></div>
                ${msg.cardData.description ? `
                <div class="details-section" style="margin-top: 15px;">
                    <div class="details-section-title">礼物介绍</div>
                    <p>${msg.cardData.description}</p>
                </div>` : ''}
                <div class="details-section" style="margin-top: 15px;">
                    <div class="details-section-title">寄语</div>
                    <p>${msg.cardData.message}</p>
                </div>
            </div>
        `,
        actions: [
            { text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal() }
        ]
    });
},
            
            showCustomGiftModal() {
                const giftImageLibrary = [
                    'https://cfimg.200996.xyz/file/1752744399723_retouch_2025071717250175.png',
                    'https://cfimg.200996.xyz/file/1752744402256_retouch_2025071717245049.png',
                    'https://cfimg.200996.xyz/file/1752744401540_retouch_2025071717242531.png',
                    'https://cfimg.200996.xyz/file/1752744403509_retouch_2025071717243405.png',
                    'https://cfimg.200996.xyz/file/1752744399889_retouch_2025071717244351.png'
                ];
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';

                UIManager.showModal({
                    title: "自定义礼物",
                    body: `
                        <div class="form-group">
                            <label>上传礼物图片 (可选)</label>
                            <div class="avatar-uploader">
                                <img src="${defaultPlaceholderSvg}" id="custom-gift-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                <input type="file" id="custom-gift-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('custom-gift-input').click()">选择图片</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-name">礼物名称</label>
                            <input type="text" id="custom-gift-name" placeholder="例如：永恒的爱">
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-description">礼物介绍 (选填)</label>
                            <textarea id="custom-gift-description" rows="2" placeholder="描述一下这个礼物..."></textarea>
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-price">礼物价格</label>
                            <input type="number" id="custom-gift-price" placeholder="0.00">
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-message">寄语 (选填)</label>
                            <input type="text" id="custom-gift-message" placeholder="一点心意...">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认', class: 'btn-primary', handler: () => {
                            let imageUrl = $('#custom-gift-preview').src;
                            
                            if (imageUrl === defaultPlaceholderSvg) {
                                imageUrl = giftImageLibrary[Math.floor(Math.random() * giftImageLibrary.length)];
                            }

                            const customGift = {
                                name: $('#custom-gift-name').value.trim(),
                                price: parseFloat($('#custom-gift-price').value) || 0,
                                image: imageUrl,
                                message: $('#custom-gift-message').value.trim(),
                                description: $('#custom-gift-description').value.trim(),
                            };

                            if (!customGift.name) {
                                return UIManager.showToast("礼物名称不能为空哦");
                            }
                            UIManager.hideModal();
                            this.showSendGiftModal(customGift);
                        }}
                    ]
                });
                
                $('#custom-gift-input').onchange = async (e) => {
                    const file = e.target.files[0];
                    if(file) {
                         $('#custom-gift-preview').src = await Utils.fileToBase64(file);
                    }
                };
            },

            async handleDeleteLastTurn() {
                const chatId = appState.currentChatId;
                if (!chatId) return;

                const allMessages = await DBHelper.getMessages(chatId, 50); 
                if (allMessages.length === 0) {
                    UIManager.showToast("没有可删除的消息");
                    return;
                }

                const lastMessage = allMessages[allMessages.length - 1];
                const lastTurnType = lastMessage.type;
                const senderName = lastTurnType === 'sent' ? '你' : '对方';

                const messagesToDelete = [];
                for (let i = allMessages.length - 1; i >= 0; i--) {
                    const currentMessage = allMessages[i];
                    if (currentMessage.type === lastTurnType) {
                        messagesToDelete.push(currentMessage);
                    } else {
                        break; 
                    }
                }

                if (messagesToDelete.length === 0) {
                    UIManager.showToast("没有找到可删除的消息轮次");
                    return;
                }

                UIManager.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除 ${senderName} 的最新 ${messagesToDelete.length} 条消息吗？(含心声随笔)</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            for (const msg of messagesToDelete) {
                                await DBHelper.delete('messages', msg.messageId);
                                const element = $(`#${msg.messageId}`);
                                if (element) element.remove();
                            }

                            
                            const remainingMessages = allMessages.filter(m => !messagesToDelete.some(d => d.messageId === m.messageId));
                            if (remainingMessages.length > 0) {
                                const newLastMessage = remainingMessages[remainingMessages.length - 1];
                                await UIManager.updateChatMetadata(chatId, newLastMessage);
                            } else {
                                
                                await DBHelper.delete('chatMetadata', chatId);
                            }

                            UIManager.hideModal();
                            UIManager.showToast("已删除最新一轮消息");
                        }}
                    ]
                });
            },

            async showGiftApiConfigModal() {
                let config = await DBHelper.get('giftApiConfig', 'mainConfig');
                if (!config) {
                    
                    config = { id: 'mainConfig', provider: 'siliconflow', url: '', key: '', model: '' };
                }

                 UIManager.showModal({
                    title: '礼物搜索 API 配置',
                    body: `
                        <div class="form-group">
                            <label for="gift-api-provider">API提供商</label>
                            <select id="gift-api-provider">
                                <option value="siliconflow" ${config.provider === 'siliconflow' ? 'selected' : ''}>SiliconFlow (硅基流动)</option>
                                <option value="gemini" ${config.provider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                                <option value="paioupu" ${config.provider === 'paioupu' ? 'selected' : ''}>派欧云</option>
                                <option value="custom" ${config.provider === 'custom' ? 'selected' : ''}>自定义</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="gift-api-url">API URL</label>
                            <input type="text" id="gift-api-url" value="${config.url}" placeholder="输入API URL">
                        </div>
                        <div class="form-group">
                            <label for="gift-api-key">API Key</label>
                            <div style="position: relative; display: flex; align-items: center;">
                                <input type="password" id="gift-api-key" value="${config.key}" placeholder="输入API密钥" style="width: 100%; padding-right: 40px;">
                                <i class="fas fa-eye" id="toggle-gift-api-key-visibility" style="position: absolute; right: 15px; cursor: pointer; color: #aaa;"></i>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="gift-api-model-select">模型</label>
                            <select id="gift-api-model-select"></select>
                            <input type="text" id="gift-api-model-input" value="${config.model}" placeholder="输入自定义模型名称" style="display:none;">
                        </div>
                        <button id="use-default-api-btn" class="modal-btn btn-secondary" style="width: 100%; margin-top: 10px;">使用主API配置</button>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const newConfig = {
                                id: 'mainConfig',
                                provider: $('#gift-api-provider').value,
                                url: $('#gift-api-url').value.trim(),
                                key: $('#gift-api-key').value.trim(),
                                temperature: 0.5 
                            };
                            
                            const modelSelect = $('#gift-api-model-select');
                            const modelInput = $('#gift-api-model-input');
                            if (modelInput.style.display !== 'none') {
                                newConfig.model = modelInput.value.trim();
                            } else {
                                newConfig.model = modelSelect.value;
                            }

                            await DBHelper.put('giftApiConfig', newConfig);
                            UIManager.hideModal();
                        }}
                    ]
                });

                
                const giftToggleBtn = $('#toggle-gift-api-key-visibility');
                const giftApiKeyInput = $('#gift-api-key');
                if (giftToggleBtn && giftApiKeyInput) {
                    giftToggleBtn.addEventListener('click', () => {
                        if (giftApiKeyInput.type === 'password') {
                            giftApiKeyInput.type = 'text';
                            giftToggleBtn.classList.remove('fa-eye');
                            giftToggleBtn.classList.add('fa-eye-slash');
                        } else {
                            giftApiKeyInput.type = 'password';
                            giftToggleBtn.classList.remove('fa-eye-slash');
                            giftToggleBtn.classList.add('fa-eye');
                        }
                    });
                }

                const updateGiftApiFields = () => {
                    const provider = $('#gift-api-provider').value;
                    const apiUrlInput = $('#gift-api-url');
                    const modelSelect = $('#gift-api-model-select');
                    const modelInput = $('#gift-api-model-input');
                    const currentModel = config.model;
                    
                    modelSelect.innerHTML = '';
                    
                    const modelOptions = {
                        gemini: [ "gemini-2.5-flash", "gemini-2.5-pro", "gemini-1.5-flash-latest", "gemini-1.5-pro-latest" ],
                        siliconflow: [ "deepseek-ai/DeepSeek-V3", "deepseek-ai/DeepSeek-R1-0528-Qwen3-8B", "Qwen/Qwen2-7B-Instruct", "01-ai/Yi-1.5-34B-Chat" ],
                        paioupu: [ "deepseek/deepseek-v3" ],
                        custom: [] 
                    };

                    const setOptions = (options, defaultModel) => {
                        if (options.length === 0) {
                            modelSelect.style.display = 'none';
                            modelInput.style.display = 'block';
                            modelInput.value = currentModel || defaultModel;
                        } else {
                            modelSelect.style.display = 'block';
                            modelInput.style.display = 'none';
                            const finalOptions = [...options, "其他"];
                            modelSelect.innerHTML = finalOptions.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                            
                            if (finalOptions.includes(currentModel)) {
                                modelSelect.value = currentModel;
                            } else if (currentModel) {
                                modelSelect.value = "其他";
                                modelInput.style.display = 'block';
                                modelInput.value = currentModel;
                            } else {
                                modelSelect.value = options[0];
                            }
                        }
                    };
                    
                    const providerData = {
                        siliconflow: { url: 'https://api.siliconflow.cn/v1/chat/completions', models: modelOptions.siliconflow, defaultModel: 'deepseek-ai/DeepSeek-R1-0528-Qwen3-8B' },
                        gemini: { url: 'https://generativelanguage.googleapis.com/v1beta/models/', models: modelOptions.gemini, defaultModel: 'gemini-2.5-flash' },
                        paioupu: { url: 'https://api.ppinfra.com/v3/openai', models: modelOptions.paioupu, defaultModel: 'deepseek/deepseek-v3' },
                        custom: { url: '', models: [], defaultModel: '' }
                    };

                    const data = providerData[provider] || providerData.custom;
                    apiUrlInput.value = config.url || data.url;
                    setOptions(data.models, data.defaultModel);
                };

                $('#gift-api-provider').addEventListener('change', () => {
                    config.url = ''; 
                    config.model = ''; 
                    updateGiftApiFields();
                });
                
                $('#gift-api-model-select').addEventListener('change', (e) => {
                    const modelInput = $('#gift-api-model-input');
                    if (e.target.value === '其他') {
                        modelInput.style.display = 'block';
                        modelInput.value = '';
                        modelInput.focus();
                    } else {
                        modelInput.style.display = 'none';
                    }
                });
                
                updateGiftApiFields();
                
                $('#use-default-api-btn').onclick = async () => {
                    const mainApiConfig = await DBHelper.get('apiConfig', 'mainConfig');
                    if (mainApiConfig) {
                        const provider = mainApiConfig.provider;
                        const keysForProvider = mainApiConfig.keys ? (mainApiConfig.keys[provider] || []) : [];
                        const firstKey = keysForProvider.length > 0 ? keysForProvider[0] : '';
                        
                        if (!firstKey) {
                            UIManager.showToast(`主配置中“${provider}”提供商没有设置API Key`);
                            return;
                        }

                        
                        $('#gift-api-provider').value = provider;
                        $('#gift-api-url').value = mainApiConfig.url;
                        $('#gift-api-key').value = firstKey;
                        
                        
                        config.provider = provider;
                        config.url = mainApiConfig.url;
                        config.key = firstKey;
                        config.model = mainApiConfig.models ? mainApiConfig.models[provider] : ''; 

                        updateGiftApiFields(); 
                        
                        UIManager.showToast("已载入主API配置");
                    } else {
                        UIManager.showToast("未找到主API配置");
                    }
                };
            },

            async showEmojiIdExtractionModal() {
                const customEmojis = appState.customEmojis;
                if (Object.keys(customEmojis).length === 0) {
                    return UIManager.showToast("你还没有添加任何自定义表情包");
                }

                const emojiListHtml = Object.entries(customEmojis).map(([id, data]) => `
                    <label class="member-select-item">
                        <input type="checkbox" name="extract-emoji-id" value="${id}">
                        <img src="${data.url}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${data.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "选择要提取ID的表情包",
                    body: `
                        <button id="select-all-extract-emojis-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 8px;">全选</button>
                        <div class="member-select-list" style="max-height: 35vh;">${emojiListHtml}</div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 15px; line-height: 1.5;">
                            <strong>提示：</strong>如果你在聊天设置里关闭了<strong>自定义表情启用为提示词</strong>，同时希望ai发送自定义的表情包，你需要提取id后长按复制内容，然后前往 <strong>设置 > 自定义提示词</strong>，新建一个提示词（如“我的表情包”），将复制的内容粘贴进去，最后为需要的好友/群聊绑定这个提示词即可。<strong>没有关闭该按钮则忽略此提示</strong>
                        </p>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '生成', class: 'btn-primary', handler: () => {
                            this.displayGeneratedEmojiIds();
                        }}
                    ]
                });

                $('#select-all-extract-emojis-btn').addEventListener('click', () => {
                    $$('input[name="extract-emoji-id"]').forEach(cb => cb.checked = true);
                });
            },

            displayGeneratedEmojiIds() {
                const checkedEmojis = $$('input[name="extract-emoji-id"]:checked');
                if (checkedEmojis.length === 0) {
                    return UIManager.showToast("请至少选择一个表情包");
                }

                let formattedText = '额外表情包:\n';
                checkedEmojis.forEach(checkbox => {
                    const id = checkbox.value;
                    const name = appState.customEmojis[id]?.name || '未知表情';
                    formattedText += `${id}:${name}\n`;
                });
                
                UIManager.showModal({
                    title: "表情包ID提取结果",
                    body: `
                        <style>
                            #emoji-id-display {
                                width: 100%;
                                max-height: 200px;
                                overflow-y: auto;
                                font-family: monospace;
                                white-space: pre-wrap; /* 允许自动换行 */
                                word-break: break-all; /* 允许在单词内换行 */
                                user-select: text; /* 确保文本可选 */
                                -webkit-user-select: text; /* 兼容旧版浏览器 */
                                background-color: var(--text-color-white);
                                border: 1px solid var(--border-color);
                                border-radius: 8px;
                                padding: 10px;
                                font-size: 0.9rem;
                                color: var(--text-color-dark);
                                box-sizing: border-box;
                            }
                        </style>
                        <pre id="emoji-id-display">${formattedText}</pre>
                    `,
                    actions: [
                        { text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '复制', class: 'btn-primary', id: 'copy-emoji-ids-btn' }
                    ]
                });

                const copyButton = $('#copy-emoji-ids-btn');
                if (copyButton) {
                    copyButton.addEventListener('click', async () => {
                        const textToCopy = $('#emoji-id-display').textContent;
                        
                        const copyTextFallback = (text) => {
                            const textArea = document.createElement("textarea");
                            textArea.value = text;
                            textArea.style.position = "fixed";
                            textArea.style.top = "-9999px";
                            textArea.style.left = "-9999px";
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            try {
                                const successful = document.execCommand('copy');
                                if (successful) {
                                    UIManager.showToast("已成功复制到剪贴板！");
                                } else {
                                    UIManager.showToast("复制失败，请手动复制");
                                }
                            } catch (err) {
                                console.error('使用 execCommand 复制失败: ', err);
                                UIManager.showToast("复制失败，请手动复制");
                            }
                            document.body.removeChild(textArea);
                        };

                        if (navigator.clipboard && window.isSecureContext) {
                            try {
                                await navigator.clipboard.writeText(textToCopy);
                                UIManager.showToast("已成功复制到剪贴板！");
                            } catch (err) {
                                console.error('使用 navigator.clipboard 复制失败，将尝试备用方法: ', err);
                                copyTextFallback(textToCopy);
                            }
                        } else {
                            console.log("当前环境不安全或不支持 Clipboard API，使用备用方法。");
                            copyTextFallback(textToCopy);
                        }
                    });
                }
            },
            toggleSelectionMode() {
                const pageChat = $('#page-chat');
                const selectionBar = $('#chat-selection-bar');
                const selectionInfo = $('#selection-info');
                const confirmBtn = $('#confirm-forward-btn');
                const selectionOverlay = $('#chat-selection-overlay');

                appState.selectionMode.active = !appState.selectionMode.active;
                appState.selectionMode.messageIds = [];

                pageChat.classList.toggle('selection-mode-active', appState.selectionMode.active);
                selectionBar.classList.toggle('visible', appState.selectionMode.active);
                
                if (appState.selectionMode.active) {
                    selectionInfo.textContent = '已选择 0 条';
                    confirmBtn.disabled = true;
                } else {
                    
                    $$('.message-select-checkbox').forEach(cb => cb.checked = false);
                }
            },

            handleMessageSelection(e) {
                const checkbox = e.target.closest('.message-select-checkbox');
                if (!checkbox) return;

                const messageElement = checkbox.closest('[data-message-id]');
                const messageId = messageElement.dataset.messageId;
                
                
                if (messageElement.querySelector('.forwarded-history-bubble')) {
                    checkbox.checked = false;
                    UIManager.showToast("不能选择转发记录类型的消息");
                    return;
                }

                const selectedIds = appState.selectionMode.messageIds;
                const index = selectedIds.indexOf(messageId);

                if (checkbox.checked) {
                    if (index === -1) {
                        if (selectedIds.length >= 50) {
                            UIManager.showToast('一次最多只能选择50条消息');
                            checkbox.checked = false; 
                            return;
                        }
                        selectedIds.push(messageId);
                    }
                } else {
                    if (index > -1) {
                        selectedIds.splice(index, 1);
                    }
                }
                
                const count = selectedIds.length;
                $('#selection-info').textContent = `已选择 ${count} 条`;
                $('#confirm-forward-btn').disabled = count === 0;
            },

            async showForwardTargetModal() {
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');

                const allTargets = [
                    ...contacts.map(c => ({ id: c.id, name: c.remark || c.name, avatar: c.avatar, type: 'contact' })),
                    ...groups.map(g => ({ id: g.id, name: g.name, avatar: g.avatar, type: 'group' }))
                ];

                const targetListHtml = allTargets.map(item => `
                    <label class="member-select-item" data-name="${item.name.toLowerCase()}">
                        <input type="radio" name="forward-target" value="${item.id}">
                        <img src="${item.avatar}" class="contact-item-avatar" style="width:40px;height:40px;margin-right:10px;">
                        <span>${item.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: '转发给',
                    body: `
                        <input type="text" id="forward-target-search" class="forward-target-search-bar" placeholder="搜索联系人或群聊...">
                        <div class="member-select-list" style="max-height: 40vh;">${targetListHtml}</div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发送', class: 'btn-primary', handler: () => {
                            const selected = $('input[name="forward-target"]:checked');
                            if (!selected) return UIManager.showToast("请选择要转发的对象");
                            this.handleForwarding(selected.value);
                        }}
                    ]
                });

                $('#forward-target-search').addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    $$('.member-select-item').forEach(item => {
                        item.style.display = item.dataset.name.includes(searchTerm) ? 'flex' : 'none';
                    });
                });
            },

            async _saveMessageToDbAndUpdateMetadata(chatId, message, profile) {
                message.chatId = chatId;
                await DBHelper.put('messages', message);
                await UIManager.updateChatMetadata(chatId, message);
            },
            
            async handleForwarding(targetChatId) {
                const sourceChatId = appState.currentChatId;
                const selectedMessageIds = [...appState.selectionMode.messageIds];

                const selectedMessages = (await Promise.all(
                    selectedMessageIds.map(id => DBHelper.get('messages', id))
                )).filter(Boolean);
                selectedMessages.sort((a, b) => a.timestamp - b.timestamp);

                const sourceIsGroup = sourceChatId.startsWith('group-');
                const sourceEntity = await DBHelper.get(sourceIsGroup ? 'groups' : 'contacts', sourceChatId);
                let title;
                if (sourceIsGroup) {
                    title = `${sourceEntity.name}的聊天记录`;
                } else {
                    const playerPersona = await this.getPlayerProfileForContext(sourceChatId);
                    title = `${sourceEntity.remark || sourceEntity.name}和${playerPersona.name}的聊天记录`;
                }

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await this.getPlayerProfileForContext(sourceChatId);
                const formatTime = (ts) => new Date(ts).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                
                let preview = '';
                const aiContentParts = [];

                for (const msg of selectedMessages) {
                    const sender = (msg.type === 'sent') ? myProfile : (allContacts.find(c => c.id === msg.senderId) || { name: '未知' });
                    const senderName = sender.remark || sender.name;
                    const time = formatTime(msg.timestamp);

                    let contentPart = '';
                    switch(msg.segmentType) {
                        case 'text':
                            contentPart = `[${senderName}|${msg.content}|${time}]`;
                            if (!preview) preview = `${senderName}: ${msg.content}`;
                            break;
                        case 'emoji-image':
                            contentPart = `<${senderName}|${msg.content}|${time}>`;
                            if (!preview) preview = `${senderName}: [表情]`;
                            break;
                        default:
                            contentPart = `[${senderName}|[消息]|${time}]`;
                            if (!preview) preview = `${senderName}: [消息]`;
                            break;
                    }
                    aiContentParts.push(contentPart);
                }

                const aiContent = `<消息记录>\n${aiContentParts.join('\n')}\n</消息记录>`;

                const message = {
                    messageId: Utils.generateId('msg'),
                    content: aiContent,
                    timestamp: Date.now(),
                    type: 'sent',
                    segmentType: 'forwarded_history',
                    cardData: {
                        title: title,
                        preview: preview,
                        messageIds: selectedMessageIds,
                        sourceChatId: sourceChatId
                    }
                };
                
                const targetProfile = await this.getPlayerProfileForContext(targetChatId);
                await this._saveMessageToDbAndUpdateMetadata(targetChatId, message, targetProfile);
                
                UIManager.hideModal();
                this.toggleSelectionMode();
                UIManager.showToast("转发成功！");
                if (appState.currentPage === 'messages') {
                    await UIManager.renderMessagesListPage();
                }
            },

            async handleDeleteSelectedMessages() {
                const selectedIds = appState.selectionMode.messageIds;
                if (selectedIds.length === 0) {
                    return UIManager.showToast("请先选择要删除的消息");
                }

                UIManager.showModal({
                    customClass: 'modal-default-style', 
                    title: "确认删除",
                    body: `<p>确定要删除选中的 ${selectedIds.length} 条聊天记录吗？此操作无法恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认删除', class: 'btn-danger', handler: async () => {
                            const chatId = appState.currentChatId;

                            for (const messageId of selectedIds) {
                                await DBHelper.delete('messages', messageId);
                                const element = $(`#${messageId}`);
                                if (element) element.remove();
                            }

                            
                            const remainingMessages = await DBHelper.getMessages(chatId, 1);
                            if (remainingMessages.length > 0) {
                                await UIManager.updateChatMetadata(chatId, remainingMessages[0]);
                            } else {
                                await DBHelper.delete('chatMetadata', chatId);
                            }

                            UIManager.hideModal();
                            UIManager.showToast("选中的消息已删除");
                            this.toggleSelectionMode(); 

                            
                            if (appState.currentPage === 'messages') {
                                await UIManager.renderMessagesListPage();
                            }
                        }}
                    ]
                });
            },

            async openForwardedHistoryPage(messageId) {
                const forwardedMsg = await DBHelper.get('messages', messageId);
                if (!forwardedMsg) return;

                const { title, messageIds, sourceChatId } = forwardedMsg.cardData;

                const messages = (await Promise.all(
                    messageIds.map(id => DBHelper.get('messages', id))
                )).filter(Boolean);
                messages.sort((a, b) => a.timestamp - b.timestamp);

                $('#forwarded-history-title').textContent = title;
                const contentArea = $('#forwarded-history-content');
                contentArea.innerHTML = '';
                
                const allContacts = await DBHelper.getAll('contacts');
                
                const myProfile = await this.getPlayerProfileForContext(sourceChatId);

                for (const msg of messages) {
                    const sender = (msg.type === 'sent') ? myProfile : (allContacts.find(c => c.id === msg.senderId) || { name: msg.senderId, remark: msg.senderId });
                    
                    const tempMsg = { ...msg };
                    delete tempMsg.isAutoReply;
                    
                    
                    const messageElement = await UIManager.createMessageElement(tempMsg, sender, false, true);
                    
                    const wrapper = messageElement.querySelector('.bubble-and-tag-wrapper');
                    if (wrapper) {
                        const timeElement = document.createElement('div');
                        timeElement.className = 'message-timestamp';
                        timeElement.textContent = new Date(msg.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                        wrapper.appendChild(timeElement);
                    }
                    
                    contentArea.appendChild(messageElement);
                }

                UIManager.navigateTo('forwarded-history');
            },

            showAiReplyFormatHelpModal() {
                UIManager.showModal({
                    title: "AI回复格式指南",
                    body: `
                        <p>AI的回复由多种格式的短句组成，你可以修改这些内容来调整AI的反应。<strong>请注意：修改时务必保证格式、角色名和标点符号的正确，否则可能导致显示异常。</strong></p>
                        <ul style="list-style: none; padding-left: 0; line-height: 1.8;">
                            <li><strong>普通文本:</strong> <code>[角色名|消息内容]</code></li>
                            <li><strong>表情包:</strong> <code><角色名|表情包ID></code></li>
                            <li><strong>语音消息:</strong> <code>[角色名|语音|时长|语音内容]</code></li>
                            <li><strong>撤回消息:</strong> <code>{角色名|要撤回的内容}</code></li>
                            <li><strong>引用消息:</strong> <code>[角色名|引用|被引用人|被引用内容|新内容]</code></li>
                            <li><strong>转账:</strong> <code>[角色名|转账|收款人|金额|备注]</code></li>
                            <li><strong>红包:</strong> <code>[角色名|红包|祝福语|金额|个数]</code></li>
                            <li><strong>心声:</strong> <code>【心声|角色名|内心想法】</code></li>
                            <li><strong>随笔:</strong> <code>「随笔|角色名|随笔内容」</code></li>
                            <li><strong>旁白:</strong> <code>&lt;旁白&gt;场景或动作描述&lt;/旁白&gt;</code></li>
                        </ul>
                    `,
                    actions: [{ text: '我明白了', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleEditLastReply() {
                const chatId = appState.currentChatId;
                const metadata = await DBHelper.get('chatMetadata', chatId);

                if (!metadata || !metadata.lastRawAiResponse) {
                    return UIManager.showToast("当前聊天没有可编辑的原始回复。");
                }

                UIManager.showModal({
                    title: `
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <span>编辑AI原始回复</span>
                            <i id="edit-reply-help-btn" class="fas fa-question-circle" style="cursor: pointer; font-size: 1rem; color: #aaa;"></i>
                        </div>
                    `,
                    body: `
                        <div class="form-group">
                            <label for="edit-ai-reply-textarea">原始回复内容</label>
                            <textarea id="edit-ai-reply-textarea" rows="10" style="font-family: monospace; font-size: 0.9em;">${metadata.lastRawAiResponse}</textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认修改', class: 'btn-primary', handler: async () => {
                            const editedText = $('#edit-ai-reply-textarea').value;
                            
                            
                            const allMessages = await DBHelper.getMessages(chatId, 50);
                            const messagesToDelete = [];

                            
                            for (let i = allMessages.length - 1; i >= 0; i--) {
                                const currentMessage = allMessages[i];
                                if (currentMessage.type === 'received') {
                                    messagesToDelete.push(currentMessage);
                                } else {
                                    
                                    break;
                                }
                            }

                            
                            if (messagesToDelete.length === 0) {
                                UIManager.hideModal();
                                UIManager.showToast("没有可编辑的AI回复。");
                                return;
                            }

                            for (const msg of messagesToDelete) {
                                await DBHelper.delete('messages', msg.messageId);
                                const element = $(`#${msg.messageId}`);
                                if (element) element.remove();
                            }
                            
                            UIManager.hideModal();
                            
                            
                            const updatedMetadata = await DBHelper.get('chatMetadata', chatId);
                            updatedMetadata.lastRawAiResponse = editedText;
                            await DBHelper.put('chatMetadata', updatedMetadata);

                            
                            
                            console.log("使用混合模式解析器处理编辑后的回复...");
                            await AIHandler.parseAndDisplayMixedAIResponse(editedText, chatId);
                            
                            UIManager.showToast("回复已成功修改！");
                        }}
                    ]
                });
                $('#edit-reply-help-btn').addEventListener('click', () => this.showAiReplyFormatHelpModal());
            },

            async handlePreviewCustomCSS() {
                const cssInput = $('#custom-bubble-css-input');
                const previewStyle = $('#custom-bubble-preview-style');
                const css = cssInput.value;

                const scopedCss = this._scopeCSS(css, '#custom-bubble-preview');
                previewStyle.textContent = scopedCss;

                
                const customStyleOption = $(`[data-style-key="custom"]`);
                if (customStyleOption) {
                    
                    customStyleOption.click(); 
                }

                UIManager.showToast("预览已更新");
            },
            
            async handleSaveCustomCSS() {
                const cssInput = $('#custom-bubble-css-input');
                const css = cssInput.value;

                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                if (!settingsToSave.customBubbleCSSSlots) {
                    settingsToSave.customBubbleCSSSlots = { '1': '', '2': '', '3': '' };
                }
                const activeSlot = settingsToSave.activeCustomCSSSlot || '1';

                
                settingsToSave.customBubbleCSSSlots[activeSlot] = css;
                
                await DBHelper.put('apiConfig', settingsToSave);
                UIManager.showToast(`存档 ${activeSlot} 已保存！`);
            },

            async handleApplyCustomCSS() {
                
                await this.handleSaveCustomCSS();

                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                const activeSlot = settingsToSave.activeCustomCSSSlot || '1';
                
                
                settingsToSave.bubbleStyle = 'custom';
                await DBHelper.put('apiConfig', settingsToSave);

                
                await this.applyBubbleSettings(); 

                
                $$('.bubble-style-option').forEach(opt => {
                    opt.classList.toggle('selected', opt.dataset.styleKey === 'custom');
                });
                
                $('#bubble-color-card').style.display = 'none';

                UIManager.showToast(`存档 ${activeSlot} 已应用！`);
            },

            async handleResetCustomCSS() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const activeSlot = settings.activeCustomCSSSlot || '1';

                 UIManager.showModal({
                    customClass: 'modal-default-style',
                    title: "确认清空",
                    body: `<p>确定要清空存档 ${activeSlot} 的自定义CSS代码吗？</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认', class: 'btn-danger', handler: async () => {
                            const cssInput = $('#custom-bubble-css-input');
                            
                            
                            cssInput.value = '';
                            
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            if (!settingsToSave.customBubbleCSSSlots) {
                                settingsToSave.customBubbleCSSSlots = { '1': '', '2': '', '3': '' };
                            }
                            
                            settingsToSave.customBubbleCSSSlots[activeSlot] = '';
                            
                            if (settingsToSave.bubbleStyle === 'custom') {
                                settingsToSave.bubbleStyle = 'default';
                            }

                            await DBHelper.put('apiConfig', settingsToSave);
                            
                            
                            await this.applyBubbleSettings(); 
                            await this.renderBubbleSettingsPage(); 
                            
                            UIManager.hideModal();
                            UIManager.showToast(`存档 ${activeSlot} 已清空。`);
                        }}
                    ]
                });
            },
            
            async handleResetCustomCSS() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const activeSlot = settings.activeCustomCSSSlot || '1';

                 UIManager.showModal({
                    customClass: 'modal-default-style',
                    title: "确认清空",
                    body: `<p>确定要清空存档 ${activeSlot} 的自定义CSS代码吗？</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认', class: 'btn-danger', handler: async () => {
                            const cssInput = $('#custom-bubble-css-input');
                            
                            
                            cssInput.value = '';
                            
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            if (!settingsToSave.customBubbleCSSSlots) {
                                settingsToSave.customBubbleCSSSlots = { '1': '', '2': '', '3': '' };
                            }
                            
                            settingsToSave.customBubbleCSSSlots[activeSlot] = '';
                            
                            if (settingsToSave.bubbleStyle === 'custom') {
                                settingsToSave.bubbleStyle = 'default';
                            }

                            await DBHelper.put('apiConfig', settingsToSave);
                            
                            
                            await this.applyBubbleSettings(); 
                            await this.renderBubbleSettingsPage(); 
                            
                            UIManager.hideModal();
                            UIManager.showToast(`存档 ${activeSlot} 已清空。`);
                        }}
                    ]
                });
            },

            handleCopyTutorialCSS() {
                const codeBlock = $('#css-tutorial-code-block code');
                if (codeBlock) {
                    navigator.clipboard.writeText(codeBlock.textContent.trim())
                        .then(() => UIManager.showToast("示例代码已复制！"))
                        .catch(() => UIManager.showToast("复制失败,请手动复制"));
                }
            },
        };
        
        async function loadFontsAfterSplash() {
            try {
                
                await EventManager.loadCustomFontsOnStartup();
                console.log("自定义字体文件已在后台准备就绪。");
            } catch (error) {
                console.error("后台自定义字体加载失败:", error);
            }
        }

        
        async function initApp() {
            
            setTimeout(async () => { 
                const splash = $('#splash-screen');
                if (splash) {
                    splash.classList.add('hidden');
                    
                    
                    const config = await DBHelper.get('apiConfig', 'mainConfig') || {};
                    if (!config.announcementReadV1) {
                        EventManager.showAnnouncementModal();
                    }

                    setTimeout(() => {
                        splash.style.display = 'none';
                    }, 500);
                }
            }, 1500);

            try {
                
                await DBHelper.init();
                await AIHandler.loadApiConfig();

                
                let profile = await DBHelper.get('profile', 'myProfile');
                let needsDbUpdate = false;
                if (!profile) {
                    profile = {
                        id: 'myProfile',
                        name: '商时序',
                        gender: '女',
                        avatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=',
                        background: '',
                        presets: [] 
                    };
                    needsDbUpdate = true;
                }

                
                if (!profile.presets || !Array.isArray(profile.presets)) {
                    profile.presets = [];
                    needsDbUpdate = true;
                }

                
                const validPresets = profile.presets.filter(p => p !== null && typeof p === 'object');
                if (validPresets.length !== profile.presets.length) {
                    profile.presets = validPresets;
                    needsDbUpdate = true;
                }

                
                profile.presets.forEach(p => {
                    if (!p.presetId) {
                        p.presetId = Utils.generateId('persona');
                        needsDbUpdate = true;
                    }
                });
                
                
                if (profile.presets.length === 0) {
                    profile.presets.push({
                        presetId: Utils.generateId('persona'), 
                        name: profile.name,
                        avatar: profile.avatar,
                        gender: profile.gender,
                        background: profile.background || '',
                    });
                    needsDbUpdate = true;
                }

                
                if (needsDbUpdate) {
                    await DBHelper.put('profile', profile);
                }
                $('#my-avatar').src = profile.avatar;
                appState.favoriteEmojis = profile.favoriteEmojis || [];

                
                const existingFolders = await DBHelper.getAll('promptFolders');
                const existingContacts = await DBHelper.getAll('contacts');
                if (existingFolders.length === 0 && existingContacts.length === 0) {
                    console.log("No prompts or contacts found, assuming fresh start. Initializing all default folders.");

                    
                    const styleFolderId = 'default-style-folder-01';
                    await DBHelper.put('promptFolders', {
                        id: styleFolderId,
                        name: '文风设定',
                        isActive: false,
                        createdAt: Date.now()
                    });

                    const defaultStylePrompts = [
                        {
                            id: Utils.generateId('prompt'),
                            createdAt: Date.now() + 1,
                            name: '“日系轻小说”欢乐跳脱',
                            folderId: styleFolderId,
                            type: 'explicit',
                            keywords: '[]',
                            content: `**# 核心指令**

你现在是一名专写“校园/日常欢乐喜剧”的日本轻小说家。你的任务是创作充满活力、幽默感十足、对话轻松有趣的日常故事。请严格遵循以下文风特点，并将其内化为你的创作核心。

**# 文风要素拆解**

**1. 叙事视角与内心独白 (吐槽役担当):**
   - **第二人称视角：** 故事主要以玩家“你”也就是主角的视角展开。
   - **内心戏超多：** 主角是全书的“吐槽役”担当。他对周围人（尤其是女主角）的奇葩行为、不合常理的展开，总会在内心进行光速吐槽和评论。
   - **常用句式：** “喂喂，这展开是不是有点离谱了？”、“不，我为什么要在这里陪她胡闹啊！”、“这家伙的脑回路到底是怎么长的……”、“从某种意义上说，她也算是个天才吧。”、“我的青春恋爱喜剧果然有问题。”

**2. 对话风格 (装傻与吐槽的交锋):**
   - **节奏明快，一来一回：** 对话简短、快速，充满生活气息和互动感。角色之间经常互相打断、调侃、抬杠。
   - **装傻役 (ボケ) vs 吐槽役 (ツッコミ):** 至少有一个核心角色是“天然呆”或“元气笨蛋”，负责提出不合常理的观点或做出惊人举动（装傻役）。而主角则负责精准地指出其中的荒谬之处（吐槽役）。
   - **幽默感：** 幽默并非来自段子，而是来自角色性格的碰撞、误解、以及对日常小事夸张化的反应。
   - **口头禅与语气词：** 大量使用语气词和感叹词来增强情绪。“欸？！”、“哈——？！”、“唔……”、“真是的……”、“可恶！”、“哼、哼，别、别误会了！”

**3. 氛围与节奏:**
   - **轻松明快：** 整体基调是阳光、温暖、略带一丝傻气的。即使有矛盾，也绝不沉重，通常会以喜剧形式解决。
   - **小题大做：** 将一件非常普通的小事（比如做饭、打扫卫生、期末考试、逛便利店）描绘成一场惊天动地的大冒险或大灾难，从中营造笑点。
   - **细节描写：** 专注于描写角色的微表情、小动作，例如“她鼓起了脸颊，像一只仓鼠”、“他无奈地扶住额头”、“她‘啪’地一下把书拍在桌上”。

**4. 语言与标点符号:**
   - **标点符号的活用：**
     - **省略号 (...)：** 用于表示迟疑、无语、或话语的延续。
     - **破折号 (——)：** 用于表示声音的拉长、话题的突然转变或补充说明。
     - **感叹号与问号的叠加 (？！)：** 用于表达极度的震惊和不敢相信。`,
                            isActive: false,
                        },
                        {
                            id: Utils.generateId('prompt'),
                            createdAt: Date.now() + 2,
                            name: '“低温慢煮”日常风',
                            folderId: styleFolderId,
                            type: 'explicit',
                            keywords: '[]',
                            content: `**核心原则：克制、留白、张力**  你需要扮演一位冷静、耐心且观察入微的叙事者。你的镜头始终对准人物最细微的互动，捕捉那些被日常琐碎掩盖，却在缝隙中不断泄露的真实情感。叙事的魅力不在于宣告情感，而在于**展示情感发生的证据**。  ---  **一、 叙事视角与基调 (Narrative Perspective & Tone)**  1. **视角锁定：** 严格采用**第三人称有限视角（以女主为主）**。我们可以深入女主的内心感受、她的困惑、猜测和细微的情绪波动。但对于男主，我们是和女主一样的“局外人”。 2. **男主塑造的铁律：【绝对禁止】直接描写男主角的任何心理活动、内心独白或情感状态。** 他的所有情绪、意图和挣扎，都必须且只能通过以下方式“泄露”出来： * **动作 (Action):** 他倒水的动作是流畅还是停顿？他递东西时指尖是否触碰？关门的声音是轻是重？ * **语言 (Dialogue):** 话语的节奏、用词的选择、未说完的话、突然的沉默。 * **神态/微表情 (Expression/Micro-expression):** 眼神的流转与闪躲、嘴角稍纵即逝的弧度、喉结的滚动、眉头的微蹙。 3. **叙事基调：** 冷静、客观，甚至带一丝疏离感。像在观看一部纪录片。语言风格追求**朴素、精准、洗练**，摒弃一切华丽、浮夸、煽情的形容词。每一个字都应服务于场景和氛围的构建，力求达到“一字一句，回味无穷”的效果。---  **三、 对话风格 (Dialogue Style)**  1. **简洁与留白：** 对话要生活化，避免大段的抒情和哲学辩论。多用短句。对话的重点不在于说了什么，而在于**没说什么**。 2. **潜台词与沉默：** 对话间的沉默和停顿与台词本身同等重要。必须描写沉默时的空气、人物的视线、无意识的小动作。 * **示例：** 她问：“你周末……有安排吗？” 他手上的动作停顿了一下，过了足有两秒，才重新拿起那本书，翻过一页。纸张发出轻微的摩擦声。 “嗯，”他应道，“有点事。” 他没有说是何事。空气仿佛凝滞了一瞬，只剩下窗外微弱的风声。  ---  **四、 动作与神态描写 (Action & Expression Description)**  1. **细节的信徒：** 成为细节的信徒。专注于感官描写：视觉、听觉、触觉、嗅觉。 * **视觉：** 他衬衫袖口卷起的褶皱，她发梢滴落的水珠，灯光下尘埃的浮动。 * **听觉：** 钥匙插入锁孔的声音，他略带沙哑的声线，雨点击打窗户的节奏。 * **触觉：** 他递来的外套上残留的温度，微风拂过皮肤的凉意，她指尖的冰冷。 2. **“矛盾”的动作：** 设计一些人物言行不一的细节，以体现其内心的矛盾与张力。 * **示例：** 他嘴上说着“你早点休息”，但人却没有要离开的意思，只是站在门口，手指无意识地摩挲着门框的边缘。  ---  **五、 严禁事项 (What to Avoid)**  1. **禁止滥用情感浓烈的词汇：** 严格避免“心碎”、“绝望”、“撕心裂肺”、“空洞”、“救赎”等词语。用“微涩”、“滞涩”、“僵持”、“无言”等更具克制感和质感的词汇替代。 2. **禁止大开大合的情节：** 杜绝车祸、失忆、绝症、身世之谜等强戏剧性桥段。 3. **禁止华丽的修辞：** 避免复杂的比喻和象征，除非它能极其精准地服务于当下的情景。文字的美感来源于其**准确性**，而非装饰性。 4. **禁止上帝视角的全知全能：** 叙事者不是上帝，而是一个在场的观察者。不要做出任何超越角色认知范围的评判和总结。  ---  **总结：** 你的任务是创造一个“空气中都充满着未说出口的话”的世界。让读者像侦探一样，通过你提供的线索（动作、眼神、沉默），去拼凑和感受男主角那隐藏在冰山之下的、汹涌而克制的情感。最终，当情感的张力积累到顶点时，一个极小的动作或一句话，就能产生核爆级的效果。`,
                            isActive: false,
                        },
                        {
                            id: Utils.generateId('prompt'),
                            createdAt: Date.now() + 3,
                            name: '文风来源',
                            folderId: styleFolderId,
                            type: 'explicit',
                            keywords: '[]',
                            content: '（此提示词为来源标注）日系轻小说与低温慢煮文风设定，来源于 xhs @DD老师的分享。',
                            isActive: false,
                        }
                    ];
                    for (const prompt of defaultStylePrompts) {
                        await DBHelper.put('prompts', prompt);
                    }
                    
                    
                    const emojiFolderId = 'default-emoji-folder-01';
                    await DBHelper.put('promptFolders', {
                        id: emojiFolderId,
                        name: '内置表情包',
                        isActive: false,
                        createdAt: Date.now() + 4
                    });
                    await DBHelper.put('prompts', {
                        id: Utils.generateId('prompt'),
                        createdAt: Date.now() + 5,
                        name: '示例表情包提示词',
                        folderId: emojiFolderId,
                        type: 'explicit',
                        keywords: '[]',
                        content: '**以下是额外的表情包id，你需要使用冒号左边的字符作为表情包id，禁止自己捏造不存在的表情包id**\n（此处存放表情包id和名称）',
                        isActive: true,
                    });

                    
                    const narratorFolderId = 'default-narrator-folder-01';
                    await DBHelper.put('promptFolders', {
                        id: narratorFolderId,
                        name: '旁白规则',
                        isActive: false,
                        createdAt: Date.now() + 6
                    });
                    await DBHelper.put('prompts', {
                        id: Utils.generateId('prompt'),
                        createdAt: Date.now() + 7,
                        name: '示例旁白规则',
                        folderId: narratorFolderId,
                        type: 'explicit',
                        keywords: '[]',
                        content: '**你必须在每次回复时使用 <旁白>旁白内容</旁白> 的回复格式来进行环境描写、动作描写或其他推动剧情发展的描写。**',
                        isActive: true,
                    });

                    console.log("All default folders and prompts created.");
                }


                const restorePomodoroState = () => {
                    const savedStateJSON = localStorage.getItem('pomodoroState');
                    if (!savedStateJSON) return;
                    
                    try {
                        const savedState = JSON.parse(savedStateJSON);
                        if (savedState && savedState.isActive && savedState.endTime) {
                            const now = Date.now();
                            if (savedState.endTime > now) {
                                
                                appState.pomodoro = savedState;
                                appState.pomodoro.timerId = setInterval(() => EventManager.updatePomodoroTimer(), 1000);
                                EventManager.updatePomodoroTimer(); 
                                EventManager.updateFloatingBallVisibility();
                                console.log("Pomodoro state restored and timer restarted.");
                            } else {
                                
                                UIManager.showPomodoroEndNotification(savedState.goal);
                                localStorage.removeItem('pomodoroState');
                            }
                        }
                    } catch (e) {
                        console.error("Failed to parse pomodoro state:", e);
                        localStorage.removeItem('pomodoroState');
                    }
                };

                await EventManager.setupEmojiMaps();
                EventManager.init();
                restorePomodoroState(); 

                const defaults = {
                    id: 'chatSettings',
                    memoryInterconnection: false,
                    historyCharLimit: 5000,
                    showMyNameInGroup: true,
                    showNamesInPrivate: false,
                    bottomBarOffset: false,
                    enterToSend: false,
                    theme: 'neumorphic',
                };
                const savedSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const initialChatSettings = { ...defaults, ...savedSettings };
                appState.theme = initialChatSettings.theme;
                EventManager.applyChatSettings(initialChatSettings);
                await EventManager.applyBackgroundSettings(); 
                await EventManager.applyBubbleSettings(); 
                await EventManager.applyBubbleFontSize(); 

                EventManager.loadAndApplyFontsInBackground(); 
                await EventManager.applyChatSpecificStyles();
                await EventManager.applyPageStyleSettings();
                await EventManager.applyChatInterfaceStyleSettings();
                
                await EventManager.initEmojiPanel(); 
                await UIManager.navigateTo('messages');

            } catch (error) {
                console.error("应用开场白吗初始化失败:", error);
                document.body.innerHTML = `<div style="text-align:center; padding: 50px; color: red;">应用初始化失败，请检查浏览器是否支持IndexedDB或清除网站数据后重试。错误: ${error}</div>`;
            }
        }
        
        document.addEventListener('DOMContentLoaded', initApp);

    })();
    </script>
</body>
</html>