<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>33èŠå¤©å®¤</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Long+Cang&display=swap" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap');
        /* --- 1. å…¨å±€ä¸ä¸»é¢˜ --- */
        :root {
            --theme-color-1: #F4E8DD; /* å¥¶æ²¹æ */
            --theme-color-2: #EDD4D8; /* æŸ”ç²‰ */
            --theme-color-3: #CCD4CC; /* ç°ç»¿ */
            --theme-color-4: #B5BFCF; /* é›¾è“ */
            /* --- é¢œè‰²ä¿®æ”¹ --- */
            --accent-color: #A7C7E7; /* å¼ºè°ƒè‰²-æµ…è“ */
            --ui-button-color: var(--text-color-light); /* æŒ‰é’®é»˜è®¤é¢œè‰² */
            --ui-button-active-color: var(--accent-color); /* æŒ‰é’®æ¿€æ´»é¢œè‰² */
            --accent-color-deep: #88A9D1; /* æ·±ä¸€ç‚¹çš„æµ…è“ */
            /* --- é¢œè‰²ä¿®æ”¹ç»“æŸ --- */
            --text-color-dark: #5D534A; /* æ·±æ£• */
            --text-color-medium: #7E746D;
            --text-color-light: #A39B94;
            --text-color-white: #FFFFFF;
            --bg-main: #F7F8FA; /* æ”¹ä¸ºæŸ”å’Œçš„æµ…ç°è‰²èƒŒæ™¯ */
            --bg-light: rgba(255, 255, 255, 0.7);
            --border-color: rgba(0, 0, 0, 0.08);
            --shadow-light: 0 4px 15px rgba(0, 0, 0, 0.05);
            --shadow-medium: 0 6px 20px rgba(0, 0, 0, 0.1);
            --font-main: "SimSun", "å®‹ä½“", serif; /* å…¨å±€å­—ä½“ï¼Œé»˜è®¤æ¥·ä½“ */
            --font-title: "Kaiti", "æ¥·ä½“", serif;
            --font-bubble: "LXGW WenKai Screen", "Kaiti", "æ¥·ä½“", serif; /* æ°”æ³¡å­—ä½“ï¼Œé»˜è®¤æ¥·ä½“ */
            --font-inner-voice: "Long Cang", cursive; /* å¿ƒå£°å­—ä½“ï¼Œé»˜è®¤é¾™è—ä½“ */
            --font-essay: "Long Cang", cursive; /* éšç¬”å­—ä½“ï¼Œé»˜è®¤é¾™è—ä½“ */
            --font-bubble-size: 0.95rem; /* ä½¿ç”¨CSSå˜é‡ */
            --unread-bg: #ff4d4d;
            --red-packet-red: #DB5445;
            --red-packet-gold: #F8D69A;
            
            /* --- æ°”æ³¡ä¸»é¢˜åŒ–å˜é‡ --- */
            --player-bubble-bg: var(--accent-color); /* æˆ‘çš„æ¶ˆæ¯èƒŒæ™¯è‰² (Aç±»æ°”æ³¡) */
            --friend-bubble-bg: var(--text-color-white);  /* å¥½å‹æ¶ˆæ¯èƒŒæ™¯è‰² (Aç±»æ°”æ³¡) */
            --player-bubble-text-color: var(--text-color-dark); /* æˆ‘çš„æ¶ˆæ¯å­—ä½“é¢œè‰² */
            --friend-bubble-text-color: var(--text-color-dark);  /* å¥½å‹æ¶ˆæ¯å­—ä½“é¢œè‰² */
        }
        :root {
            /* ... existing variables ... */
            --ui-bg-color: rgba(255, 255, 255, 0.5); /* é¡µé¢UIèƒŒæ™¯è‰² */
            --ui-texture-image: none; /* UIçº¹ç†å›¾ç‰‡ */
        }
        @keyframes paw-pulse { /* æ–°å¢ */
            0% { transform: scale(1); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1); }
        }
/* --- å¼€å±åŠ¨ç”»æ ·å¼ (å‚è€ƒæ ·å¼) --- */
#splash-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-main);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    transition: opacity 0.5s ease-out;
}
#splash-screen.hidden {
    opacity: 0;
    pointer-events: none;
}
.splash-logo {
    font-family: 'ZCOOL KuaiLe', cursive; /* ä½¿ç”¨å‚è€ƒæ–‡ä»¶å­—ä½“ */
    font-size: 36px; /* å‚è€ƒæ–‡ä»¶å­—ä½“å¤§å° */
    color: var(--accent-color-2); /* ä½¿ç”¨å‚è€ƒæ–‡ä»¶é¢œè‰²é£æ ¼ï¼Œæ˜ å°„åˆ°å½“å‰ä¸»é¢˜ */
    margin-bottom: 20px;
}
.splash-loader {
    width: 50px;
    height: 50px;
    border: 3px solid var(--theme-color-2); /* è¾¹æ¡†é¢œè‰²æ˜ å°„ */
    border-top-color: var(--accent-color); /* é¡¶éƒ¨é¢œè‰²æ˜ å°„ */
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* ç§»é™¤ç§»åŠ¨ç«¯ç‚¹å‡»é«˜äº® */
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: var(--font-main);
            color: var(--text-color-dark);
        }

    body {
        background: var(--bg-main);
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: var(--font-main); /* åº”ç”¨å…¨å±€å­—ä½“ */
    }

        #app-container {
            width: 100%;
            height: 100%;
            max-width: 500px;
            background-color: var(--bg-light);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: var(--shadow-medium);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #main-content {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            display: flex;
        }

        /* --- 2. é¡µé¢åˆ‡æ¢ä¸å¸ƒå±€ --- */
        .page {
            display: none;
            flex-grow: 1;
            flex-direction: column;
            overflow: hidden;
            animation: fadeIn 0.4s ease-in-out;
        }
        .page.active {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        .page-header {
            padding: 15px 10px;
            display: grid;
            grid-template-columns: 50px 1fr auto; /* è°ƒæ•´å³ä¾§ä¸ºè‡ªé€‚åº”å®½åº¦ */
            align-items: center;
            background-color: var(--ui-bg-color);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative;
            overflow: hidden; /* éšè—æº¢å‡ºçš„å™ªç‚¹ */
        }
        .page-header h1 {
            font-family: var(--font-title);
            font-size: 1.3rem; /* å‡å°å­—ä½“å¤§å° */
            /* ç§»é™¤ç»å¯¹å®šä½å’Œå˜æ¢ï¼Œç”±çˆ¶çº§wrapperæ§åˆ¶ */
        }
        .page-header .header-icon {
            font-size: 1.3rem;
            cursor: pointer;
            color: var(--ui-button-color);
            z-index: 2;
        }

        .page-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            -webkit-overflow-scrolling: touch;
        }
        .page-content::-webkit-scrollbar {
            width: 4px;
        }
        .page-content::-webkit-scrollbar-thumb {
            background: var(--theme-color-4);
            border-radius: 2px;
        }
        
        /* --- 3. åº•éƒ¨å¯¼èˆªæ  --- */
        #bottom-nav {
            display: flex;
            width: 100%;
            background-color: var(--ui-bg-color);
            border-top: 1px solid var(--border-color);
            padding: 8px 0;
            flex-shrink: 0;
            position: relative; /* ä¸ºå™ªç‚¹åšå‡†å¤‡ */
            overflow: hidden; /* éšè—æº¢å‡ºçš„å™ªç‚¹ */
        }
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--ui-button-color);
            transition: color 0.3s, transform 0.3s;
        }
        .nav-item:hover {
            color: var(--accent-color);
        }
        .nav-item.active {
            color: var(--ui-button-active-color);
            transform: scale(1.1);
        }
        .nav-item i {
            font-size: 1.4rem;
            margin-bottom: 4px;
        }
        .nav-item span {
            font-size: 0.75rem;
        }

        /* --- 4. æ¶ˆæ¯åˆ—è¡¨é¡µé¢ --- */
        #page-messages .page-header {
            padding: 10px 15px;
        }
        #my-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            cursor: pointer;
            border: 2px solid var(--text-color-white);
            box-shadow: var(--shadow-light);
        }
        .message-list {
            list-style: none;
            padding: 0;
        }
        .message-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-bottom: 1px solid var(--border-color);
        }
        .message-item:hover {
            background-color: rgba(0,0,0,0.03);
        }
        .item-avatar {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            margin-right: 15px;
            background-color: var(--theme-color-3);
            flex-shrink: 0;
        }
        .item-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .item-name {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 6px;
        }
        .item-last-msg {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .item-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-left: 10px;
            flex-shrink: 0;
        }
        .item-time {
            font-size: 0.75rem;
            color: var(--text-color-light);
            margin-bottom: 8px;
        }
        .unread-badge {
            background-color: var(--unread-bg);
            color: white;
            font-size: 0.7rem;
            min-width: 20px;
            height: 20px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 6px;
        }
        /* --- 4.1 é¡µé¢å¤´éƒ¨å›¾æ ‡è°ƒæ•´ --- */
        #header-link-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.05);
            color: var(--text-color-medium);
            display: flex;
            justify-content: center;
            align-items: center;
            text-decoration: none;
            justify-self: end;
            margin-right: 15px;
            transition: all 0.2s;
        }
        #header-link-btn:hover {
            background-color: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }

        .page-header .header-icon {
            font-size: 1.2rem; /* ç¼©å°å›¾æ ‡ */
            padding: 0 10px; /* è°ƒæ•´ç‚¹å‡»åŒºåŸŸ */
        }
        /* å°†å³ä¾§å›¾æ ‡æ¨åˆ°æœ€å³è¾¹ */
        .page-header .header-icon:last-child {
            justify-self: end;
            padding-right: 15px; /* å¢åŠ å³è¾¹è· */
        }
        .header-icon-group {
            display: flex;
            gap: 5px; /* è¿›ä¸€æ­¥å‡å°é—´è· */
            align-items: center;
            justify-self: end;
            padding-right: 10px; /* å‘å·¦ç§»åŠ¨ä¸€ç‚¹ */
        }
        #batch-delete-btn:hover i,
        #batch-delete-btn:active i,
        #page-contacts.selection-mode #batch-delete-btn i {
             color: #e74c3c;
        }
        /* --- 4.2. åº•éƒ¨ä¸Šç§»æ ·å¼ --- */
        #app-container.bottom-offset-active {
            padding-bottom: 30px; /* ä¸ºç³»ç»Ÿå¯¼èˆªæ ç•™å‡ºç©ºé—´ */
            height: calc(100% - 30px); /* ç›¸åº”åœ°è°ƒæ•´é«˜åº¦ */
        }
        /* --- 5. é€šè®¯å½•é¡µé¢ --- */
        .tabs {
            display: flex;
            justify-content: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-btn {
            padding: 8px 20px;
            cursor: pointer;
            border-radius: 20px;
            background-color: transparent;
            border: 1px solid transparent;
            color: var(--text-color-medium);
            transition: all 0.3s;
            font-family: var(--font-main);
        }
        .tab-btn.active {
            background-color: var(--text-color-white);
            border-color: var(--theme-color-2);
            color: var(--accent-color-deep);
            font-weight: bold;
            box-shadow: var(--shadow-light);
        }
        .contact-section {
            display: none;
        }
        .contact-section.active {
            display: block;
        }
        .contact-list-header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 5px;
            color: var(--text-color-light);
        }
        .sort-btn {
            cursor: pointer;
            font-size: 0.9rem;
        }
        .contact-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .contact-item-avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            object-fit: cover;
            margin-right: 15px;
            background-color: var(--theme-color-4);
        }
        .contact-item-name {
            flex-grow: 1;
            font-size: 1.1rem;
        }
        .contact-info-btn {
            font-size: 1.2rem;
            color: var(--text-color-light);
            cursor: pointer;
            padding: 5px;
        }
        .contact-list .contact-select-checkbox {
            display: none;
            margin-right: 15px;
            width: 20px;
            height: 20px;
            accent-color: var(--accent-color);
        }
        .contact-list.selection-mode .contact-select-checkbox {
            display: block;
        }
        .contact-list.selection-mode .contact-item {
            cursor: pointer;
        }
        .contact-list.selection-mode .contact-info-btn {
            display: none; /* é€‰æ‹©æ¨¡å¼ä¸‹éšè—è¯¦æƒ…æŒ‰é’® */
        }

        #contacts-friend-folders .prompt-folder {
            margin-bottom: 8px; /* å‡å°åˆ†ç»„é—´è· */
        }
        #contacts-friend-folders .prompt-folder-header h3 {
            font-weight: normal; /* ç§»é™¤åˆ†ç»„åç§°åŠ ç²— */
        }

        /* --- 6. è®¾ç½®é¡µé¢ --- */
        .settings-list {
            padding-top: 10px;
        }
        .setting-item {
            display: flex;
            align-items: center;
            padding: 18px 15px;
            background-color: var(--text-color-white);
            margin: 0 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .setting-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-light);
        }
        .setting-item i {
            font-size: 1.3rem;
            color: var(--accent-color);
            margin-right: 15px;
            width: 25px;
            text-align: center;
        }
        .setting-item span {
            font-size: 1.1rem;
            flex-grow: 1;
        }
        .setting-item .fa-chevron-right {
            color: var(--text-color-light);
            font-size: 1rem;
        }

        /* --- 7. èŠå¤©é¡µé¢ --- */
        #page-chat .page-header .header-title {
            max-width: 80%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 1.1rem; /* ç¼©å°å­—ä½“å¤§å° */
        }
        .header-title-wrapper {
            grid-column: 2 / 3; /* å æ®ä¸­é—´æ  */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* é˜²æ­¢å†…å®¹æº¢å‡º */
        }
        .typing-indicator-container {
            font-size: 0.75rem; /* è¿›ä¸€æ­¥è°ƒå° */
            color: var(--text-color-medium);
            display: none; /* Initially hidden */
            margin-top: 1px; /* å¾®è°ƒä¸æ ‡é¢˜çš„é—´è· */
        }
        .chat-area {
            flex-grow: 1;
            padding: 20px 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            /* å…³é”®è®©èŠå¤©åŒºåŸŸæ‹¥æœ‰è‡ªå·±çš„èƒŒæ™¯ï¼Œè€Œä¸æ˜¯é€æ˜ */
            background-color: var(--theme-color-1); 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        /* --- èŠå¤©èƒŒæ™¯å®¹å™¨ --- */
        #app-container {
            /* ... (ä¿ç•™åŸæœ‰æ ·å¼) */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed; /* å…³é”®ï¼šä½¿èƒŒæ™¯å›ºå®šä¸æ»šåŠ¨ */
        }
        
        /* --- ä¸»é¢˜è®¾ç½®å¼¹çª—å†…æ ·å¼ (å‚è€ƒ èŠå¤©èƒŒæ™¯ä¸Šä¼ .html) --- */
        .theme-settings-modal .form-group {
            margin-bottom: 25px;
        }

        .theme-settings-modal .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--form-label-color, #555);
        }

        .theme-settings-modal .background-upload-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 15px;
            border: 1px dashed var(--border-color);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.5);
        }

        .theme-settings-modal .background-preview {
            width: 150px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            background-color: #e9e9e9;
        }

        .theme-settings-modal .cover-preview {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            background-color: #e9e9e9;
        }
        
        .theme-settings-modal .color-input-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .theme-settings-modal .color-input-group input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .theme-settings-modal .color-input-group input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .theme-settings-modal .color-input-group input[type="color"]::-webkit-color-swatch { border: 2px solid var(--border-color); border-radius: 8px; }

        .message-row {
            display: flex;
            max-width: 80%;
            width: -webkit-fit-content;
            width: -moz-fit-content;
            width: fit-content;
        }
        .message-row.sent {
            align-self: flex-end;
            flex-direction: row-reverse;
        }
        .message-row.received {
            align-self: flex-start;
        }
        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            background-color: var(--theme-color-3);
            flex-shrink: 0;
        }
        .message-avatar.group-avatar-style {
            border-radius: 12px; /* æ–¹å½¢åœ†è§’ */
        }
        .message-row.sent .message-avatar {
            margin-left: 10px;
        }
        .message-row.received .message-avatar {
            margin-right: 10px;
        }
        .message-content {
            display: flex;
            flex-direction: column;
        }
        .message-row.sent .message-content {
            align-items: flex-end;
        }
        .message-row.received .message-content {
            align-items: flex-start;
        }
        .message-name {
            font-size: 0.8rem;
            color: var(--text-color-light);
            margin-bottom: 5px;
            padding: 0 5px;
        }
    .bubble {
        /* --- æ ¸å¿ƒä¿®æ”¹ï¼šç¦æ­¢ç”¨æˆ·é€‰æ‹©æ–‡æœ¬ --- */
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        /* --- ä¿®æ”¹ç»“æŸ --- */

        padding: 8px 12px;
        border-radius: 16px;
        word-break: break-word;
        white-space: pre-wrap; /* æ–°å¢ï¼šè®©æ¢è¡Œç¬¦ç”Ÿæ•ˆ */
        font-family: var(--font-bubble); /* åº”ç”¨æ°”æ³¡å­—ä½“ */
        font-size: var(--font-bubble-size, 0.95rem); /* ä½¿ç”¨CSSå˜é‡ */
        line-height: 1.4;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        border: none; /* ç§»é™¤é»˜è®¤è¾¹æ¡†ï¼Œç”±å…·ä½“æ ·å¼æ§åˆ¶ */
    }
        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        /* --- é»˜è®¤æ°”æ³¡æ ·å¼ (Aç±», è¾¹æ¡†å˜è‰²) --- */
        #app-container.app-bubble-style-default .bubble {
            background: white; /* å›ºå®šèƒŒæ™¯ä¸ºç™½è‰² */
            color: var(--text-color-dark); /* å›ºå®šæ–‡å­—é¢œè‰²ä¸ºæ·±è‰² */
        }
        #app-container.app-bubble-style-default .bubble.received {
            border: 1px solid var(--friend-bubble-bg); /* è¾¹æ¡†é¢œè‰²ç”±å˜é‡æ§åˆ¶ */
            border-top-left-radius: 5px;
        }
        #app-container.app-bubble-style-default .bubble.sent {
            border: 1px solid var(--player-bubble-bg); /* è¾¹æ¡†é¢œè‰²ç”±å˜é‡æ§åˆ¶ */
            border-top-right-radius: 5px;
        }
        #app-container.app-bubble-style-default .message-row.sent .quote-block {
            background-color: rgba(0, 0, 0, 0.04);
            border-color: var(--player-bubble-bg); 
            color: var(--text-color-dark);
        }
        #app-container.app-bubble-style-default .message-row.received .quote-block {
            background-color: rgba(0, 0, 0, 0.04);
            border-color: var(--friend-bubble-bg);
            color: var(--text-color-dark);
        }
        #app-container.app-bubble-style-default .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        #app-container.app-bubble-style-default .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }


        /* --- ç«‹ä½“3Dæ°”æ³¡æ ·å¼ (Aç±») --- */
        #app-container.app-bubble-style-3d .bubble {
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            border-bottom-width: 3px;
            border-bottom-style: solid;
        }
        #app-container.app-bubble-style-3d .bubble.received {
            background: var(--friend-bubble-bg);
            color: var(--friend-bubble-text-color);
            border-color: rgba(0,0,0,0.1);
        }
        #app-container.app-bubble-style-3d .bubble.sent {
            background: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            border-color: rgba(0,0,0,0.2);
        }


        /* --- å¯çˆ±æ¡çº¹ (Bç±») --- */
        #app-container.app-bubble-style-stripey .bubble {
            background: repeating-linear-gradient(45deg, #FFC0CB, #FFC0CB 10px, #F8C8D1 10px, #F8C8D1 20px);
            color: #a3505f;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #app-container.app-bubble-style-stripey .voice-wave-bar { background-color: #a3505f; }

        /* --- æ¸å˜å½©è™¹ (Bç±», åŠ¨ç”») --- */
        @keyframes gradientBG {
            0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; }
        }
        #app-container.app-bubble-style-gradient .bubble {
            background: linear-gradient(45deg, #ff9a9e, #fad0c4, #a1c4fd, #c2e9fb, #ff9a9e);
            background-size: 300% 300%;
            animation: gradientBG 8s ease infinite;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        #app-container.app-bubble-style-gradient .voice-wave-bar { background-color: white; }

        /* --- æ‰‹ç»˜æ¶‚é¸¦ (Bç±») --- */
        #app-container.app-bubble-style-doodle .bubble {
            border: 2px solid #333;
            border-radius: 15px 10px 15px 12px;
            background: white;
            color: #333;
            box-shadow: 3px 3px 0px #ccc;
        }
        #app-container.app-bubble-style-doodle .bubble.sent {
            border-radius: 10px 15px 12px 15px;
        }
        #app-container.app-bubble-style-doodle .quote-block {
            border-left-width: 2px;
            border-left-style: dashed;
            background-color: #f7f7f7;
        }
        #app-container.app-bubble-style-doodle .voice-wave-bar { background-color: #333; }

        /* --- æ‰‹ç»˜æ¶‚é¸¦2 (Bç±») --- */
        #app-container.app-bubble-style-hand-drawn .bubble {
            background: white; border: 3px solid #333; position: relative;
            box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.1); font-family: 'Comic Sans MS', cursive;
            color: #333;
        }
        #app-container.app-bubble-style-hand-drawn .bubble.received { border-radius: 0 20px 20px 20px; }
        #app-container.app-bubble-style-hand-drawn .bubble.sent { border-radius: 20px 0 20px 20px; }
        #app-container.app-bubble-style-hand-drawn .voice-wave-bar { background-color: #333; }

        /* --- æ‹Ÿæ€ (Aç±») --- */
        #app-container.app-bubble-style-neumorphic .bubble {
            background: var(--friend-bubble-bg);
            border-radius: 20px;
            box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #fff;
            color: var(--friend-bubble-text-color);
            border: none;
        }
        #app-container.app-bubble-style-neumorphic .bubble.sent {
            background: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
        }
        #app-container.app-bubble-style-neumorphic .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        #app-container.app-bubble-style-neumorphic .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }

        /* --- æŸ”å’Œæ¡çº¹ (Aç±») --- */
        #app-container.app-bubble-style-stripes .bubble {
            background-color: var(--friend-bubble-bg);
            background-image: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.2),
                rgba(255, 255, 255, 0.2) 15px,
                rgba(255, 255, 255, 0.1) 15px,
                rgba(255, 255, 255, 0.1) 30px
            );
            color: var(--friend-bubble-text-color);
            border: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
         #app-container.app-bubble-style-stripes .bubble.sent {
            background-color: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
        }

        /* --- ç½‘æ ¼ (Aç±») - ä¿®å¤ --- */
        #app-container.app-bubble-style-grid .bubble {
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 15px 15px;
            background-color: color-mix(in srgb, var(--friend-bubble-bg) 80%, transparent); /* å¢åŠ é€æ˜åº¦ */
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: var(--friend-bubble-text-color);
        }
         #app-container.app-bubble-style-grid .bubble.sent {
            background-color: color-mix(in srgb, var(--player-bubble-bg) 80%, transparent); /* å¢åŠ é€æ˜åº¦ */
            color: var(--player-bubble-text-color);
        }

        /* --- å¯çˆ±é£ (Aç±», è¾¹æ¡†å˜è‰²) --- */
        #app-container.app-bubble-style-cute .bubble {
            background: transparent;
            color: var(--friend-bubble-text-color);
        }
        #app-container.app-bubble-style-cute .bubble.received {
            border: 2px solid var(--friend-bubble-bg);
            border-radius: 25px 25px 25px 5px;
        }
        #app-container.app-bubble-style-cute .bubble.sent {
            border: 2px solid var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            border-radius: 25px 25px 5px 25px;
        }

        /* --- ç®€çº¦os (Aç±») --- */
        #app-container.app-bubble-style-simple-os .bubble {
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        #app-container.app-bubble-style-simple-os .bubble.received {
            background-color: color-mix(in srgb, var(--friend-bubble-bg) 60%, transparent); /* å¢åŠ ä¸é€æ˜åº¦ */
            color: var(--friend-bubble-text-color);
        }
        #app-container.app-bubble-style-simple-os .bubble.sent {
            background-color: color-mix(in srgb, var(--player-bubble-bg) 60%, transparent); /* å¢åŠ ä¸é€æ˜åº¦ */
            color: var(--player-bubble-text-color);
        }

        /* --- å‘å…‰æœå†» (Bç±») --- */
        #app-container.app-bubble-style-glow-jelly .bubble.received {
            background: linear-gradient(135deg, #00c9ff, #92fe9d);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 201, 255, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }
        #app-container.app-bubble-style-glow-jelly .bubble.sent {
            background: linear-gradient(135deg, #ff7e5f, #feb47b);
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 126, 95, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        #app-container.app-bubble-style-glow-jelly .voice-wave-bar { background-color: white; }
        #app-container.app-bubble-style-glow-jelly .bubble.received .voice-wave-bar { background-color: black; }

        /* --- é‡‘å±è´¨æ„Ÿ (Bç±») --- */
        #app-container.app-bubble-style-metal .bubble {
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0); border: 1px solid #a0a0a0;
            color: #333; box-shadow: 0 2px 4px rgba(0,0,0,0.1), inset 0 1px 3px rgba(255,255,255,0.8);
            position: relative; overflow: hidden;
            border-radius: 16px; /* åŸºç¡€åœ†è§’ */
        }
        #app-container.app-bubble-style-metal .bubble.received { border-top-left-radius: 5px; } /* å°–è§’ */
        #app-container.app-bubble-style-metal .bubble.sent { border-top-right-radius: 5px; } /* å°–è§’ */

        #app-container.app-bubble-style-metal .bubble::before {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(to bottom right, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 45%, rgba(255,255,255,0) 55%, rgba(255,255,255,0.2) 100%);
            transform: rotate(30deg);
        }
        #app-container.app-bubble-style-metal .voice-wave-bar { background-color: #333; }
        
        /* --- æµ·æ´‹é£ (Bç±», å¸¦å°–è§’) --- */
        #app-container.app-bubble-style-ocean .bubble {
            background: linear-gradient(160deg, #0077b6, #00b4d8);
            color: white;
            border: 2px solid transparent; /* åŒ¹é…å¯çˆ±é£å°ºå¯¸ï¼Œä½†é€æ˜ */
            border-radius: 16px;
            position: relative;
        }
        #app-container.app-bubble-style-ocean .bubble.received { border-bottom-left-radius: 5px; }
        #app-container.app-bubble-style-ocean .bubble.sent { border-bottom-right-radius: 5px; }

        /* --- çŒ«çˆªé£ (Bç±») --- */
        #app-container.app-bubble-style-paw .bubble.received {
            background: #fce1cb;
            color: #8b5e34;
            border: none;
            border-radius: 20px 20px 20px 5px;
        }
        #app-container.app-bubble-style-paw .bubble.sent {
            background: #cbe7fc;
            color: #345c8b;
            border: none;
            border-radius: 20px 20px 5px 20px;
        }
        #app-container.app-bubble-style-paw .bubble::before {
            content: 'ğŸ¾';
            position: absolute;
            bottom: -10px;
            font-size: 1.5rem;
            opacity: 0.2;
        }
        #app-container.app-bubble-style-paw .bubble.received::before { left: 10px; }
        #app-container.app-bubble-style-paw .bubble.sent::before { right: 10px; }
        #app-container.app-bubble-style-paw .voice-wave-bar { background-color: #8b5e34; }
        #app-container.app-bubble-style-paw .bubble.sent .voice-wave-bar { background-color: #345c8b; }
        
        /* --- å¤é£ (Bç±») --- */
        #app-container.app-bubble-style-ancient .bubble.received {
            background: #f5f0e1; color: #5d4037; border: 2px solid #8d6e63;
            font-family: 'SimSun', serif; box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.1);
        }
        #app-container.app-bubble-style-ancient .bubble.sent {
            background: #d7ccc8; color: #4e342e; border: 2px solid #795548;
            font-family: 'SimSun', serif; box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.1);
        }

        /* --- å›½é£ (Bç±») --- */
        #app-container.app-bubble-style-chinese .bubble {
            border-radius: 0;
            clip-path: polygon(0 10px, 10px 0, calc(100% - 10px) 0, 100% 10px, 100% calc(100% - 10px), calc(100% - 10px) 100%, 10px 100%, 0 calc(100% - 10px));
        }
        #app-container.app-bubble-style-chinese .bubble.received {
            background: white; border: 1px solid #c81e1e; color: #c81e1e;
        }
        #app-container.app-bubble-style-chinese .bubble.sent {
            background: #c81e1e; border: 1px solid #f9d56e; color: #f9d56e;
        }
        #app-container.app-bubble-style-chinese .voice-wave-bar { background-color: #f9d56e; }
        #app-container.app-bubble-style-chinese .bubble.received .voice-wave-bar { background-color: #c81e1e; }

        /* --- æ‹Ÿæ€2 (Bç±», æ•ˆæœå›ºå®š) - æ–°å¢ --- */
        #app-container.app-bubble-style-neumorphic-2 .bubble {
            background: #F0F0F3;
            font-weight: 500;
            color: #888;
            text-shadow: 1px 1px 1px #fff;
            border: 1px solid rgba(0,0,0,0.05);
        }
        #app-container.app-bubble-style-neumorphic-2 .bubble.received {
            border-radius: 25px 25px 25px 5px; /* åº”ç”¨å°–è§’ */
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.9), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        #app-container.app-bubble-style-neumorphic-2 .bubble.sent {
            border-radius: 25px 25px 5px 25px; /* åº”ç”¨å°–è§’ */
             box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.9), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        /* --- ç»¿ç™½ (Bç±») --- */
        #app-container.app-bubble-style-wechat .bubble {
            position: relative;
            border-radius: 8px;
            color: #000000;
        }
        #app-container.app-bubble-style-wechat .bubble::after {
            content: '';
            position: absolute;
            top: 10px;
            border-width: 6px;
            border-style: solid;
        }
        #app-container.app-bubble-style-wechat .bubble.received {
            background-color: #FFFFFF;
        }
        #app-container.app-bubble-style-wechat .bubble.received::after {
            left: -12px;
            border-color: transparent #FFFFFF transparent transparent;
        }
        #app-container.app-bubble-style-wechat .bubble.sent {
            background-color: #95EC6A;
        }
        #app-container.app-bubble-style-wechat .bubble.sent::after {
            right: -12px;
            border-color: transparent transparent transparent #95EC6A;
        }
        #app-container.app-bubble-style-wechat .voice-wave-bar {
            background-color: #000000;
        }


        /* --- å¼•ç”¨å’Œè¯­éŸ³æ¶ˆæ¯çš„é€šç”¨é€‚é… --- */
        .quote-block {
            padding: 8px 12px;
            border-left: 3px solid; /* é¢œè‰²ç”±çˆ¶çº§æ ·å¼å†³å®š */
            background-color: rgba(0, 0, 0, 0.04); /* æµ…ç°è‰²èƒŒæ™¯ */
            line-height: 1.4;
            font-size: 0.85em;
            border-radius: 8px;
            color: color-mix(in srgb, currentColor 80%, transparent); /* ä¿®æ”¹ï¼šé¢œè‰²æ¯”å½“å‰å­—ä½“é¢œè‰²ç¨æµ… */
        }
        .quote-block .quoted-name { font-weight: bold; }

        .voice-duration {
            font-size: 0.8rem;
            color: currentColor;
            margin-right: 10px;
            font-weight: bold;
        }
        .voice-wave {
            display: flex;
            align-items: center;
            height: 20px;
            flex-grow: 1;
            justify-content: flex-end;
        }
        .voice-wave-bar {
            width: 3px;
            background-color: currentColor;
            margin: 0 2px;
            border-radius: 2px;
            animation: voiceWave 1.5s infinite ease-in-out;
            transform-origin: bottom;
        }
        @keyframes voiceWave {
            0%, 100% { transform: scaleY(0.4); }
            50% { transform: scaleY(1.0); }
        }
        .voice-wave-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .voice-wave-bar:nth-child(2) { height: 12px; animation-delay: 0.2s; }
        .voice-wave-bar:nth-child(3) { height: 16px; animation-delay: 0.4s; }
        .voice-wave-bar:nth-child(4) { height: 12px; animation-delay: 0.6s; }
        .voice-wave-bar:nth-child(5) { height: 8px; animation-delay: 0.8s; }

        .bubble-timestamp {
            font-size: 0.7rem;
            color: var(--text-color-light);
            margin-top: 4px; /* æ°”æ³¡ä¸æ—¶é—´æˆ³ä¹‹é—´çš„é—´è· */
            padding: 0 8px;  /* æ°´å¹³å¯¹é½ */
            user-select: none;
        }

        /* --- å‰©ä½™åŸºç¡€æ ·å¼ä¿æŒä¸å˜ --- */
        .bubble-emoji {
            background: none !important; border: none !important; box-shadow: none !important; padding: 0;
            max-width: 120px; overflow: hidden;
        }
        .bubble-emoji img { max-width: 100%; display: block; border-radius: 12px; }
        .bubble.quote-message-bubble { display: flex; flex-direction: column; gap: 8px; }
        .bubble.image-with-desc-bubble { max-width: 160px; /* ç¨å¾®å¢å¤§æœ€å¤§å®½åº¦ä»¥å®¹çº³é•¿å›¾ */ max-height: none; /* ç§»é™¤å›ºå®šçš„æœ€å¤§é«˜åº¦é™åˆ¶ */ padding: 5px; /* å¢åŠ ä¸€ç‚¹å†…è¾¹è· */ display: flex; flex-direction: column; gap: 8px; }
        .bubble.image-with-desc-bubble img { max-width: 100%; height: auto; /* å…³é”®ï¼šè®©é«˜åº¦è‡ªé€‚åº”å®½åº¦ */ border-radius: 8px; display: block; background-color: var(--theme-color-1); }
        .bubble.image-with-desc-bubble img { max-width: 100%; border-radius: 8px; display: block; background-color: var(--theme-color-1); }
        .bubble.image-with-desc-bubble .description-text { display: none; padding: 0 4px; font-size: 0.9rem; line-height: 1.5; color: var(--text-color-dark); }
        .bubble.voice-message-bubble {
            display: flex;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            z-index: 1;
            min-width: 80px;
        }
        .bubble.vision-image-bubble {
            max-width: 240px; /* è®©å›¾ç‰‡å¯ä»¥æ˜¾ç¤ºå¾—æ›´å¤§ä¸€äº› */
            max-height: none; /* ç§»é™¤é«˜åº¦é™åˆ¶ */
            padding: 5px;
        }
        .bubble.vision-image-bubble .description-text {
            display: block; /* æ€»æ˜¯æ˜¾ç¤ºé™„è¨€ */
            padding-top: 5px;
        }
        .bubble-and-tag-wrapper { position: relative; display: flex; flex-direction: column; align-items: flex-start; }
        .message-row.sent .bubble-and-tag-wrapper { align-items: flex-end; }
        .voice-transcript { position: absolute; top: calc(100% + 5px); left: 0; width: max-content; max-width: 250px; background: #e6f7ff; border: 1px dashed #91d5ff; color: #03a9f4; border-radius: 10px; padding: 8px 12px; font-size: 0.85rem; z-index: 5; display: none; word-wrap: break-word; }
        .voice-transcript.show { display: block; }
        .message-row.sent .voice-transcript { left: auto; right: 0; }
        .bubble-retracted { background: #e0e0e0; font-style: italic; color: #888; animation: retract 0.5s ease-in-out forwards; }
        .retract-button-wrapper { position: absolute; bottom: calc(100% + 5px); z-index: 5; animation: popIn 0.2s ease-out; background: rgba(0, 0, 0, 0.7); border-radius: 15px; padding: 4px; gap: 4px; display: none; }
        .message-row.sent .retract-button-wrapper { right: 0; }
        .message-row.received .retract-button-wrapper { left: 0; }
        .retract-button-wrapper.show { display: flex; }
        .retract-btn { background: transparent; color: white; border: none; border-radius: 12px; padding: 6px 12px; font-size: 0.8rem; cursor: pointer; transition: background 0.2s; display: flex; align-items: center; gap: 5px; }
        .retract-btn:hover { background: rgba(255, 255, 255, 0.2); }
        @keyframes retract { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.8); opacity: 0; } }
        /* AI Typing Indicator Bubble */
        .bubble-typing { display: flex; gap: 5px; align-items: center; padding: 10px 15px; background: var(--text-color-white); border: 1px solid var(--theme-color-2); border-top-left-radius: 5px; }
        .typing-dot { width: 8px; height: 8px; background-color: var(--text-color-light); border-radius: 50%; animation: typing-pulse 1.4s infinite ease-in-out both; }
        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing-pulse { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }

        .time-divider, .retracted-notice, .system-notice {
            align-self: center;
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 10px;
            margin: 5px 0;
        }

        .chat-area::-webkit-scrollbar {
            width: 6px;
        }
        .chat-area::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.02);
        }
        .chat-area::-webkit-scrollbar-thumb {
            background-color: var(--theme-color-4);
            border-radius: 3px;
        }
        .chat-area::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-color);
        }

        #history-loader {
            text-align: center;
            padding: 10px;
            display: none; /* Initially hidden */
        }
        #history-loader.visible {
            display: block;
        }
        #history-loader .loader-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--theme-color-2);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
        }

        .retracted-notice {
            cursor: pointer;
            transition: background 0.3s;
        }
        .retracted-notice:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        /* --- 4.3. æ¶ˆæ¯åˆ—è¡¨é•¿æŒ‰å¼¹çª— --- */
        .message-list-popover {
            position: absolute;
            z-index: 100;
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            padding: 5px;
            display: flex;
            gap: 5px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            opacity: 0;
            transform: scale(0.9);
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            color: white;
        }
        .message-list-popover-btn {
            background: transparent;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background-color 0.2s;
        }
        .message-list-popover-btn:hover {
            background-color: rgba(255,255,255,0.15);
        }
        .message-item .item-pin-icon {
            color: var(--accent-color);
            margin-right: 8px;
            font-size: 0.9rem;
        }

        .chat-input-area {
            display: flex;
            flex-direction: column; /* æ”¹ä¸ºçºµå‘å¸ƒå±€ */
            padding: 10px 15px;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative; /* ä¸ºè¡¨æƒ…é¢æ¿å®šä½ */
        }
        /* èŠå¤©é¡µé¢é¡¶éƒ¨*/
        #page-chat .page-header {
            background: white;
        }


        /* --- åŠŸèƒ½ï¼šå¼•ç”¨é¢„è§ˆæ ·å¼ --- */
        .quote-preview-area {
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-color-medium);
            margin-bottom: 8px; /* å’Œä¸‹æ–¹è¾“å…¥æ¡†çš„é—´è· */
            display: none; /* é»˜è®¤éšè— */
        }
        .quote-preview-content { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cancel-quote-btn { background: none; border: none; font-size: 1.2rem; color: #999; cursor: pointer; padding: 0 5px;}

        /* è¾“å…¥å’Œå‘é€æŒ‰é’®çš„å®¹å™¨ */
        .input-top-row {
            display: flex;
            align-items: flex-end;
            width: 100%;
        }
        
        /* åŒ…è£¹å±‚ï¼Œç”¨äºæ¨ªå‘æ»šåŠ¨ */
        .input-feature-row-wrapper {
            width: 100%;
            overflow-x: auto;
            padding-bottom: 5px; /* ä¸ºæ»šåŠ¨æ¡é¢„ç•™ç©ºé—´ï¼Œå¦‚æœå¯è§ */
            margin-bottom: -5px; /* è¡¥å¿å†…è¾¹è·ï¼Œé¿å…å¢åŠ é¢å¤–é«˜åº¦ */
        }
        .input-feature-row-wrapper::-webkit-scrollbar {
            display: none; /* éšè—æ»šåŠ¨æ¡ (Chrome, Safari) */
        }
        .input-feature-row-wrapper {
            -ms-overflow-style: none;  /* éšè—æ»šåŠ¨æ¡ (IE, Edge) */
            scrollbar-width: none;  /* éšè—æ»šåŠ¨æ¡ (Firefox) */
        }

        /* æ–°å¢çš„åŠŸèƒ½æŒ‰é’®è¡Œ */
        .input-feature-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-top: 8px;
            width: max-content; /* å…³é”®ï¼šè®©è¡Œå†…å®¹ä¸æ¢è¡Œï¼Œä»è€Œå¯ä»¥æ»šåŠ¨ */
        }
        .feature-btn {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            color: var(--text-color-medium);
            transition: all 0.2s;
        }
        .feature-btn:hover {
            background: white;
            color: var(--accent-color);
        }

        /* è¡¨æƒ…åŒ…é¢æ¿ */
        .emoji-card {
            position: absolute;
            bottom: 100%; /* ä½äºè¾“å…¥åŒºåŸŸæ­£ä¸Šæ–¹ */
            left: 10px; right: 10px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
            padding: 15px;
            z-index: 100;
            display: none;
            max-height: 250px;
            overflow-y: auto;
        }
        .emoji-card.active { display: block; }

        .emoji-item-add {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px;
            height: 60px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-color-light);
            font-size: 24px;
        }
        .emoji-item-add:hover {
            background-color: rgba(0,0,0,0.05);
            color: var(--accent-color);
            border-color: var(--accent-color);
        }

.emoji-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 4åˆ— */
    grid-template-rows: repeat(2, auto); /* 2è¡Œ */
    gap: 15px; /* å¢å¤§é—´è· */
    min-height: 140px; /* è°ƒæ•´æœ€å°é«˜åº¦ä»¥é€‚åº”æ–°å¸ƒå±€ */
}
        .emoji-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        .emoji-nav button {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-color-light);
            cursor: pointer;
            padding: 5px 15px;
        }
        .emoji-nav button:hover {
            color: var(--accent-color);
        }
        #emoji-page-indicator {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            min-width: 30px;
            text-align: center;
        }
        
        .emoji-item { cursor: pointer; text-align: center; transition: transform 0.2s; }
        .emoji-item:hover { transform: scale(1.1); }
        .emoji-item img { width: 60px; height: 60px; object-fit: contain; }
        .emoji-item { position: relative; } /* ä¸ºç»å¯¹å®šä½æä¾›åŸºå‡† */
        .favorite-emoji-toggle {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 22px;
            height: 22px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: #ccc;
            font-size: 0.8rem;
            transition: all 0.2s;
            opacity: 0.5; /* é™ä½é»˜è®¤é€æ˜åº¦ï¼Œé¿å…è§†è§‰å¹²æ‰° */
        }
        .favorite-emoji-toggle:hover {
            transform: scale(1.1);
            opacity: 1; /* æ‚¬æµ®æ—¶å®Œå…¨ä¸é€æ˜ */
        }
        .favorite-emoji-toggle.is-favorite {
            color: #ffc107; /* é»„è‰²æ˜Ÿæ˜Ÿ */
            background-color: white;
            border-color: #ffc107;
        }
        #ai-request-btn {
            background: none; border: none; font-size: 1.8rem; cursor: pointer; padding: 5px 10px 5px 0; transition: transform 0.2s;
        }
        #ai-request-btn:hover {
             transform: scale(1.1);
        }
        #message-input {
            flex-grow: 1;
            border: none;
            background: var(--text-color-white);
            padding: 12px;
            border-radius: 18px;
            resize: none;
            font-size: 1rem;
            font-family: var(--font-main);
            max-height: 100px;
            outline: none;
            margin-left: 10px; /* å’Œå·¦ä¾§AIæŒ‰é’®çš„é—´è· */
        }
        #send-btn {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--theme-color-2) 100%);
            border: none;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 1.2rem;
            margin-left: 10px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            flex-shrink: 0; /* é˜²æ­¢è¢«æŒ¤å‹ */
            box-shadow: 0 4px 10px rgba(167, 199, 231, 0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #send-btn:hover {
            background-color: var(--accent-color-deep);
            transform: scale(1.05);
        }
        #send-btn i {
            position: relative;
            top: 10px; /* å‘ä¸‹å¾®è°ƒå›¾æ ‡ä½ç½® */
        }
        
        /* --- 8. æ¨¡æ€æ¡†/å¼¹çª— --- */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2500; /* æå‡å±‚çº§ï¼Œé«˜äºä¾§è¾¹æ çš„ 2000 */
        }
        #modal-overlay.visible {
            display: flex;
            animation: fadeIn 0.3s;
        }
        .modal-content {
            background: var(--bg-main);
            padding: 25px;
            border-radius: 20px;
            width: 90%;
            max-width: 450px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-medium);
            animation: slideInUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes slideInUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal-header {
            font-family: var(--font-title);
            font-size: 1.6rem;
            margin-bottom: 20px;
            text-align: center;
            color: var(--text-color-dark);
        }

        /* --- è¯¦æƒ…é¡µæ ·å¼ (æ¥è‡ªå‚è€ƒæ–‡ä»¶) --- */
        .details-card {
            background-color: var(--text-color-white);
            border-radius: 12px;
            padding: 20px;
            box-shadow: var(--shadow-light);
            margin-bottom: 20px;
        }
        .details-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            position: relative; /* ä¸ºç»å¯¹å®šä½çš„å­å…ƒç´ æä¾›å®šä½å‚è€ƒ */
        }
        .details-header-attribution {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 2;
            flex-shrink: 0; /* é˜²æ­¢è¢«æ ‡é¢˜æŒ¤å‹ */
        }
        .details-header-attribution:hover {
            transform: scale(1.1);
            background-color: var(--accent-color);
        }
        .details-header .avatar {
            width: 64px;
            height: 64px;
            border-radius: 12px;
            margin-right: 20px;
            object-fit: cover;
        }
        .details-info .name {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-color-dark);
        }
        .details-info .id {
            font-size: 0.9rem;
            color: var(--text-color-light);
        }
        .details-section {
            margin-top: 20px;
        }
        .details-section-title {
            font-size: 1rem;
            color: var(--text-color-medium);
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .details-field {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 1rem;
        }
        .details-field .label { color: var(--text-color-medium); }
        .details-field .value { color: var(--text-color-dark); text-align: right; }
        .details-section p {
            white-space: pre-wrap; /* å…³é”®ï¼šè®©æ¢è¡Œç¬¦ç”Ÿæ•ˆ */
            max-height: 150px;     /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            overflow-y: auto;      /* å†…å®¹è¶…å‡ºæ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
            line-height: 1.6;
            color: var(--text-color-medium);
            background-color: rgba(0,0,0,0.02); /* åŠ ä¸€ç‚¹æ·¡æ·¡çš„åº•è‰²ä»¥åŒºåˆ† */
            padding: 10px;
            border-radius: 8px;
        }
        .details-section p::-webkit-scrollbar { width: 4px; }
        .details-section p::-webkit-scrollbar-thumb { background: var(--theme-color-4); border-radius: 2px; }
        .member-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
        }
        .member-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        .member-item .avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 0;
        }
        .member-item .name {
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .details-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .details-btn {
            width: 100%;
            padding: 14px;
            font-size: 1rem;
            font-weight: 500;
            border-radius: 8px; /* è°ƒæ•´åœ†è§’ */
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.2); /* é€æ˜èƒŒæ™¯ */
            border: 1px dashed var(--text-color-light); /* è™šçº¿è¾¹æ¡† */
            color: var(--text-color-dark); /* æ·±è‰²æ–‡å­— */
        }
        .details-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            border-color: var(--accent-color);
            color: var(--accent-color-deep);
        }
        /* ç§»é™¤ç‰¹å®šçš„èƒŒæ™¯è‰²ï¼Œä½¿å…¶é£æ ¼ç»Ÿä¸€ */
        .btn-details-primary {
            /* æ ·å¼å·²ç”± .details-btn ç»Ÿä¸€å¤„ç† */
        }
        .btn-details-danger {
            /* æ ·å¼å·²ç”± .details-btn ç»Ÿä¸€å¤„ç† */
        }
        .btn-details-danger:hover {
            border-color: #e74c3c;
            color: #c0392b;
        }
        /* --- ç»“æŸï¼šè¯¦æƒ…é¡µæ ·å¼ --- */

        .form-group {
            margin-bottom: 18px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-color-medium);
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            border-radius: 10px;
            font-size: 1rem;
            font-family: var(--font-main);
            outline-color: var(--accent-color);
        }
        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        .modal-content .form-group textarea {
    max-height: 25vh; /* é™åˆ¶æœ€å¤§é«˜åº¦ä¸ºè§†çª—çš„25% */
    overflow-y: auto; /* ç¡®ä¿å†…å®¹è¶…å‡ºæ—¶å¯æ»šåŠ¨ */
}
        .avatar-uploader {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            background-color: transparent; /* æ”¹ä¸ºé€æ˜ */
            border: 2px solid white;
        }
        .upload-btn {
            padding: 8px 15px;
            background: var(--theme-color-4);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 25px;
        }
        .modal-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: bold;
            transition: all 0.2s;
        }

        /* --- é¢œè‰²é€‰æ‹©å™¨æ ·å¼ --- */
        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 4px;
            background-color: var(--text-color-white);
        }
        .color-picker-container input[type="color"] {
            width: 30px;
            height: 30px;
            border: none;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .color-picker-container input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .color-picker-container input[type="color"]::-webkit-color-swatch { border: 1px solid var(--border-color); border-radius: 6px; }

        .color-picker-container .color-hex-input {
            border: none;
            outline: none;
            width: 70px;
            font-family: monospace;
            font-size: 0.9rem;
            background-color: transparent;
            color: var(--text-color-dark);
            text-align: center;
        }
        /* --- æ–°å¢ç»“æŸ --- */

        /* --- Neumorphic Modal Style --- */
        .modal-content.modal-neumorphic {
            background: #F0F0F3;
            border-radius: 20px;
            box-shadow: 
                -7px -7px 20px 0px #fff,
                7px 7px 20px 0px #d1d9e6;
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 25px;
        }
        .modal-neumorphic .modal-header {
            color: #555;
            font-family: var(--font-title);
            text-shadow: 1px 1px 1px #fff;
            text-align: center;
            margin-bottom: 25px;
        }
        .modal-neumorphic .form-group label {
            color: #888;
            font-weight: 500;
            text-shadow: 1px 1px 1px #fff;
        }
        .modal-neumorphic .form-group input,
        .modal-neumorphic .form-group select,
        .modal-neumorphic .form-group textarea {
            background: #F0F0F3;
            border: none;
            border-radius: 12px;
            padding: 12px 15px;
            box-shadow: 
                inset -5px -5px 9px rgba(255, 255, 255, 0.7),
                inset 5px 5px 9px rgba(174, 174, 192, 0.2);
            color: var(--text-color-dark);
            font-size: 1rem;
            outline: none;
        }
        .modal-neumorphic .modal-actions {
            display: flex;
            justify-content: space-around; /* Space them out */
            margin-top: 30px;
        }
        .modal-neumorphic .modal-btn {
            padding: 12px 0; /* Vertical padding, horizontal from flex */
            flex: 1; /* Take up equal space */
            margin: 0 10px; /* Spacing between buttons */
            border-radius: 12px;
            border: none;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-family: var(--font-main);
        }
        .modal-neumorphic .btn-primary {
            background: #5A8DEE;
            color: white;
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.7), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        .modal-neumorphic .btn-primary:hover {
            box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.7), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
            background: #4a7de0; /* Slightly darker on hover */
            color: #f0f0f0;
        }
        .modal-neumorphic .btn-secondary {
            background: #F0F0F3;
            color: #888;
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.7), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        .modal-neumorphic .btn-secondary:hover {
            box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.7), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--accent-color-deep);
            transform: translateY(-2px);
        }
        .btn-secondary {
            background-color: #ccc;
            color: #333;
        }
        .btn-secondary:hover {
            background-color: #bbb;
        }
        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .persona-modal-card {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: var(--shadow-light);
        }
        .persona-modal-card h4 {
            font-family: var(--font-title);
            color: var(--accent-color-deep);
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
    .persona-modal-card p {
        font-family: var(--font-inner-voice); /* åº”ç”¨å¿ƒå£°å­—ä½“ */
        line-height: 1.6;
        color: var(--text-color-dark);
    }
    .persona-modal-card.note-paper p {
        font-family: var(--font-essay); /* åº”ç”¨éšç¬”å­—ä½“ */
        white-space: pre-wrap; /* è®©æ¢è¡Œç¬¦ç”Ÿæ•ˆ */
    }
    .note-paper {
        background-color: #fdf5d3;
        background-image:
            linear-gradient(90deg, rgba(200, 180, 140, 0.15) 1px, transparent 1px),
            linear-gradient(rgba(200, 180, 140, 0.15) 1px, transparent 1px);
        background-size: 20px 20px;
        border: 1px solid #e0d9c3;
        position: relative;
        padding-top: 30px; /* ä¸ºå›¾é’‰ç•™å‡ºç©ºé—´ */
    }
        .note-paper::before {
            content: '';
            position: absolute;
            top: 5px;
            right: 15px;
            width: 20px;
            height: 20px;
            background: #ff7675;
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            border: 2px solid white;
        }
        .member-select-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 5px;
        }
        .member-select-item {
            display: flex;
            align-items: center; /* å‚ç›´å±…ä¸­å¯¹é½ */
            padding: 8px;
            cursor: pointer; /* è®©æ•´è¡Œéƒ½å¯ä»¥ç‚¹å‡» */
        }

        .member-select-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
        }

        /* --- åˆ›å»ºç¾¤èŠå¼¹çª—æ ·å¼ --- */
        .creation-mode-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .mode-btn {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            background-color: transparent;
            color: var(--text-color-medium);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .mode-btn.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        #group-creation-search {
            width: 100%;
            padding: 10px 15px;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            margin-bottom: 10px;
        }
        .selection-panel.hidden {
            display: none;
        }

        .group-info-modal-body .form-group {
            margin-bottom: 10px;
        }
        .group-info-modal-body .member-list-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 15px;
            max-height: 250px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0,0,0,0.02);
            border-radius: 8px;
        }
        .group-info-modal-body .member-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .group-info-modal-body .member-item img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid white;
        }
        .group-info-modal-body .member-item span {
            font-size: 0.8rem;
            color: var(--text-color-medium);
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* --- 8.5. é¡¶éƒ¨æµ®çª—é€šçŸ¥ --- */
        #top-notification-container {
            position: absolute;
            top: 15px; /* ä»é¡¶éƒ¨ç•™å‡ºä¸€äº›é—´è· */
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 480px; /* åŒ¹é…app-containerçš„æœ€å¤§å®½åº¦ */
            z-index: 5000;
            pointer-events: none; /* å…è®¸ç‚¹å‡»ç©¿é€å®¹å™¨æœ¬èº« */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .notification-banner {
            pointer-events: auto; /* ä»…bannerå¯ç‚¹å‡» */
            background-color: #FBFBFC; /* æŸ”å’Œçš„ç°ç™½è‰² */
            border: 1px solid var(--border-color); /* ä½¿ç”¨é€šç”¨è¾¹æ¡†è‰² */
            border-radius: 16px; /* åœ†è§’ */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1); /* å¢å¼ºé˜´å½±æ•ˆæœ */
            padding: 12px 18px; /* å¢å¤§å†…è¾¹è· */
            display: flex;
            align-items: center;
            gap: 15px; /* å¢å¤§é—´è· */
            width: fit-content;
            max-width: 95%; /* é™åˆ¶æœ€å¤§å®½åº¦ */
            min-width: 280px; /* å¢å¤§æœ€å°å®½åº¦ */
            cursor: pointer;
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            animation: notification-enter 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        
        @keyframes notification-enter {
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        @keyframes notification-exit {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        .notification-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }
        .notification-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 8px;
        }
        .notification-name {
            font-weight: bold;
            color: var(--text-color-dark);
            white-space: nowrap;
        }
        .notification-time {
            font-size: 0.7rem;
            color: var(--text-color-light);
            flex-shrink: 0;
        }
        .notification-message {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- 8.5.1 ç‰¹æ®Šï¼šéšç¬”æ›´æ–°æµ®çª— --- */
        .essay-notification-banner {
            pointer-events: auto;
            position: relative;
            width: 48px;
            height: 48px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            color: #fff;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: width 0.5s cubic-bezier(0.65, 0, 0.35, 1);
        }
        .essay-notification-banner.is-playing {
            animation: expand-toast 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        .essay-notification-banner .icon-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .essay-notification-banner.is-playing .icon-wrapper {
             animation: move-icon 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        .essay-notification-banner .text-content {
            opacity: 0;
            white-space: nowrap;
            padding-left: 52px; /* ç»™å›¾æ ‡ç•™å‡ºç©ºé—´ */
        }
        .essay-notification-banner.is-playing .text-content {
            animation: show-text 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        @keyframes expand-toast {
            0% { width: 48px; }
            50%, 100% { width: 220px; }
        }

        @keyframes move-icon {
            0% {
                left: 50%;
                transform: translate(-50%, -50%) scale(1);
            }
            40% {
                left: 24px;
                transform: translate(-50%, -50%) scale(0.9);
            }
            50%, 100% {
                left: 24px;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes show-text {
            0%, 50% { opacity: 0; transform: translateX(-10px); }
            100% { opacity: 1; transform: translateX(0); }
        }



        /* --- 8.7. Toast è½»é‡æç¤º --- */
        .toast-notification {
            position: fixed; /* ä½¿ç”¨fixedå®šä½ï¼Œç›¸å¯¹äºè§†å£ */
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 10000; /* ç¡®ä¿é«˜äºæ‰€æœ‰å…¶ä»–å…ƒç´  */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            animation: toast-in 0.3s forwards;
        }

        @keyframes toast-in {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .toast-notification.hiding {
            opacity: 0;
        }
        /* --- 8.8. Bottom Sheet --- */
        #bottom-sheet-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            z-index: 3000; /* é«˜äºæ¨¡æ€æ¡† */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out; /* åªå¯¹ opacity è¿‡æ¸¡ */
        }
        #bottom-sheet-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .bottom-sheet-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            max-height: 50vh;
            background: white;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            flex-direction: column;
        }
        #bottom-sheet-overlay.visible .bottom-sheet-content {
            transform: translateY(0);
        }
        .bottom-sheet-header {
            padding: 15px 20px;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .bottom-sheet-body {
            padding: 10px;
            overflow-y: auto;
            max-height: 40vh; /* è®¾ç½®æœ€å¤§é«˜åº¦ä»¥å¯ç”¨æ»šåŠ¨ */
        }
        .bottom-sheet-item {
            padding: 15px 20px;
            font-size: 1.1rem;
            cursor: pointer;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }
        .bottom-sheet-item:last-child {
            border-bottom: none;
        }
        .bottom-sheet-item:hover {
            background-color: rgba(0,0,0,0.03);
        }
        /* Neumorphic style for bottom sheet */
        .bottom-sheet-content.neumorphic {
            background: #F0F0F3;
            box-shadow: 
                -7px -7px 20px 0px #fff,
                7px 7px 20px 0px #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-header {
            color: #555;
            text-shadow: 1px 1px 1px #fff;
            border-bottom-color: #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-item {
            color: var(--text-color-dark);
            border-bottom-color: #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-item:hover {
            background: #e6e6e9;
        }
        .bottom-sheet-content.compact-list .bottom-sheet-item {
            padding: 10px 20px; /* Reduced vertical padding */
            font-size: 1rem; /* Slightly smaller font */
        }
/* --- 9. ç‚¹å‡»ç‰¹æ•ˆ --- */
#click-effect-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;
    z-index: 9999;
}
.ripple {
    position: absolute;
    border-radius: 50%;
    background-color: var(--accent-color);
    transform: scale(0);
    animation: ripple-effect 0.6s ease-out;
    opacity: 0.5;
}
@keyframes ripple-effect {
    to {
        transform: scale(1);
        opacity: 0;
    }
}
.heart {
    position: absolute;
    color: var(--accent-color);
    animation: heart-fly 1.2s ease-out forwards;
    opacity: 1;
    font-size: 16px;
}
@keyframes heart-fly {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}
/* --- 10. ä¾§è¾¹æ  --- */
#sidebar-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(5px);
    z-index: 2000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
#sidebar-overlay.visible {
    opacity: 1;
    visibility: visible;
}
#sidebar-content {
    position: absolute;
    top: 0;
    right: 0; /* æ”¹ä¸º right */
    left: auto; /* æ–°å¢ */
    width: 80%;
    max-width: 350px;
    height: 100%;
    background: var(--bg-main);
    box-shadow: var(--shadow-medium);
    transform: translateX(100%); /* æ”¹ä¸ºæ­£å€¼ */
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
}
#sidebar-overlay.visible #sidebar-content {
    transform: translateX(0);
}
#sidebar-content .form-group {
    margin-bottom: 20px;
}

        /* --- 10.1. å·¦ä¾§æ»‘å‡ºä¾§è¾¹æ  --- */
        #sidebar-content.sidebar-from-left {
            left: 0;
            right: auto;
            transform: translateX(-100%);
        }
        #sidebar-overlay.visible #sidebar-content.sidebar-from-left {
            transform: translateX(0);
        }

        /* --- 10.2. ä¾§è¾¹æ æ ·å¼è°ƒæ•´ --- */
        #sidebar-content .modal-header {
            font-size: 1.4rem; /* ç¼©å°æ ‡é¢˜å­—ä½“ */
            padding-bottom: 15px; /* ä¸ºåˆ†å‰²çº¿ç•™å‡ºç©ºé—´ */
            margin-bottom: 15px; /* è°ƒæ•´ä¸ä¸‹æ–¹å†…å®¹çš„é—´è· */
            border-bottom: 1px solid var(--border-color); /* æ·»åŠ åˆ†å‰²çº¿ */
            position: relative;
        }
        /* ä¼˜ç¾çš„åˆ†å‰²çº¿è£…é¥° */
        #sidebar-content .modal-header::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 2px;
            background: var(--accent-color);
            border-radius: 1px;
        }
        #sidebar-content .setting-item span {
            font-size: 1rem; /* ç¼©å°ä¾§è¾¹æ å†…æŒ‰é’®æ–‡å­—å¤§å° */
        }
        

        /* ä¾§è¾¹æ å†…çš„ç‰¹å®šæ ·å¼ */
        #sidebar-content .details-card {
             background-color: rgba(255,255,255,0.6);
             margin: 0 0 15px 0;
             padding: 15px;
        }
        #sidebar-content .details-header .avatar {
            width: 50px;
            height: 50px;
        }
        #sidebar-content .details-info .name {
            font-size: 1.3rem;
        }
        #sidebar-content .details-actions {
            margin-top: 20px;
        }
        
        /* ç¾¤æˆå‘˜åˆ—è¡¨å¼¹çª—æ ·å¼ */
        .member-list-modal-body {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px; /* ä¸ºæ»šåŠ¨æ¡ç•™å‡ºç©ºé—´ */
        }
        .member-list-modal-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .member-list-modal-item:last-child {
            border-bottom: none;
        }
        .member-list-modal-item img {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            margin-right: 15px;
        }
        .member-list-modal-item .owner-tag {
            font-size: 0.7rem;
            background-color: #f1c40f;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 10px;
        }

        /* --- 10.3. Neumorphic Sidebar Style --- */
        #sidebar-content.neumorphic {
            background: #F0F0F3;
            box-shadow: 
                -7px 0px 20px 0px #fff,
                7px 0px 20px 0px #d1d9e6;
            border-left: 1px solid rgba(255, 255, 255, 0.5); /* For right sidebar */
        }
        #sidebar-content.neumorphic.sidebar-from-left {
            box-shadow: 
                -7px 0px 20px 0px #d1d9e6,
                7px 0px 20px 0px #fff;
            border-left: none;
            border-right: 1px solid rgba(255, 255, 255, 0.5);
        }
        #sidebar-content.neumorphic .modal-header {
            color: #555;
            text-shadow: 1px 1px 1px #fff;
            border-bottom-color: #d1d9e6;
        }
        #sidebar-content.neumorphic .modal-header::after {
            background: #888;
            box-shadow: 1px 1px 1px #fff;
        }
        #sidebar-content.neumorphic .setting-item {
            background: transparent;
            box-shadow: 
                -5px -5px 9px rgba(255, 255, 255, 0.9), 
                5px 5px 9px rgba(174, 174, 192, 0.4);
            margin: 0 0 15px; /* Adjust margin */
        }
        #sidebar-content.neumorphic .setting-item:hover {
            box-shadow: 
                inset -5px -5px 9px rgba(255, 255, 255, 0.9), 
                inset 5px 5px 9px rgba(174, 174, 192, 0.4);
            transform: none; /* Override hover transform */
        }

        /* --- èŠå¤©é¡µé¢é¡¶éƒ¨/åº•éƒ¨ UI é¢œè‰² --- */
        #page-chat .page-header,
        .chat-input-area {
            background-color: var(--chat-ui-bg-color, white);
        }

        /* --- èŠå¤©é¡µé¢åŠŸèƒ½æŒ‰é’®é¢œè‰² --- */
        .chat-input-area .feature-btn {
            color: var(--chat-feature-btn-color, var(--text-color-medium));
        }
        .chat-input-area .feature-btn:hover {
            color: var(--chat-feature-btn-active-color, var(--accent-color));
        }

        /* --- èŠå¤©é¡µé¢ç‰¹æ®ŠæŒ‰é’®å›¾æ ‡ (å°ç¾½æ¯›å’Œå‘é€) --- */
        #ai-request-btn i,
        #send-btn i {
            display: inline-block; /* ç¡®ä¿ i æ ‡ç­¾å¯ä»¥è¢«èƒŒæ™¯å›¾æ›¿æ¢ */
            width: 100%;
            height: 100%;
            font-size: inherit; /* ç»§æ‰¿çˆ¶çº§å­—ä½“å¤§å° */
            line-height: inherit; /* ç»§æ‰¿çˆ¶çº§è¡Œé«˜ */
        }
        #ai-request-btn i {
            color: var(--chat-feature-btn-active-color, var(--accent-color));
            }
        #send-btn i {color:white}
        #ai-request-btn img,
        #send-btn img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* ç¡®ä¿å›¾ç‰‡å®Œæ•´æ˜¾ç¤º */
        }
        #send-btn:has(img) {
            background: none;
            box-shadow: none;
        }

        /* --- 10.4. æ´å¯Ÿå¼¹çª—æ ·å¼ (æ–°å¢) --- */
        #chat-insight-btn i {
            background: linear-gradient(135deg, #87CEEB, #98FB98); /* ä½¿ç”¨é¥±å’Œåº¦æ›´ä½çš„å¤©è“è‰²å’Œæ·¡ç»¿è‰² */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }
        .insight-member-list {
            max-height: 40vh;
            overflow-y: auto;
            padding-right: 5px;
        }
        .insight-member-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .insight-member-item:last-child {
            border-bottom: none;
        }
        .insight-member-item img {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            margin-right: 15px;
        }
        .insight-member-item span {
            flex-grow: 1;
            white-space: nowrap;      /* é˜²æ­¢æ–‡å­—æ¢è¡Œ */
            overflow: hidden;         /* éšè—è¶…å‡ºéƒ¨åˆ† */
            text-overflow: ellipsis;  /* æ˜¾ç¤ºçœç•¥å· */
            max-width: 150px;         /* è®¾ç½®ä¸€ä¸ªæœ€å¤§å®½åº¦ */
        }
        .insight-view-btn {
            padding: 4px 12px;     /* ç¼©å°å†…è¾¹è· */
            font-size: 0.6rem;     /* ç¼©å°å­—ä½“ */
            min-width: 50px;       /* ç¡®ä¿æŒ‰é’®ä¸ä¼šè¿‡å° */
            max-width: 50px;       /* ç¡®ä¿æŒ‰é’®ä¸ä¼šè¿‡å° */
            flex-shrink: 0;        /* é˜²æ­¢æŒ‰é’®è¢«æŒ¤å‹ */
        }

        /* --- 11. è‡ªå®šä¹‰æç¤ºè¯é¡µé¢ --- */
        #prompts-page-content {
            padding: 15px;
        }
        #prompt-header-actions {
            gap: 10px; /* å‡å°å›¾æ ‡é—´è· */
        }
        #prompt-header-actions .header-icon {
            font-size: 1.1rem; /* å‡å°å›¾æ ‡å¤§å° */
            padding: 0 5px; /* å‡å°å›¾æ ‡çš„æ°´å¹³å†…è¾¹è·ï¼Œè®©å…¶æ›´ç´§å‡‘ */
        }
        
        .prompt-folder {
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-light);
            transition: all 0.3s;
        }
        .prompt-folder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        .prompt-folder-header h3 {
            font-size: 1.1rem;
            color: var(--text-color-dark);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .prompt-folder-header h3 .folder-toggle-icon {
        transition: transform 0.3s ease-in-out;
         }
        .prompt-folder-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .prompt-folder-controls .folder-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-light);
            transition: color 0.2s;
        }
        .prompt-folder-controls .folder-action-btn:hover {
            color: var(--accent-color);
        }
        .prompt-folder-content {
            padding: 15px;
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }
        .prompt-folder-content.collapsed {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
    margin-top: -1px; /* ä¼˜åŒ–è¾¹æ¡†æ˜¾ç¤º */
    display: block; 
}
.prompt-folder-header.collapsed .folder-toggle-icon {
    transform: rotate(-90deg);
}
        .prompt-card {
            background-color: var(--text-color-white);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border-left: 5px solid var(--theme-color-4);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .prompt-card.inactive {
            border-left-color: #ccc;
            opacity: 0.7;
        }
        .prompt-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .prompt-card-name {
            font-weight: bold;
            font-size: 1rem;
            color: var(--text-color-dark);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .prompt-card-name .prompt-index {
            font-size: 0.8rem;
            background: var(--theme-color-4);
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
        }
        .prompt-card.inactive .prompt-card-name .prompt-index {
            background: #ccc;
        }
        .prompt-card-tags {
            display: flex;
            gap: 6px;
        }
        .prompt-tag {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 10px;
            color: white;
        }
        .tag-explicit { background-color: var(--accent-color); }
        .tag-implicit { background-color: var(--theme-color-4); }
        .tag-keywords {
            background-color: var(--theme-color-3);
            color: var(--text-color-dark);
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .prompt-card-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .prompt-card-actions .action-btn {
            background: rgba(0,0,0,0.05);
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .prompt-card-actions .action-btn:hover {
            background: var(--accent-color);
            color: white;
        }
        .font-delete-btn {
            padding: 8px 10px;
            font-size: 0.9rem;
            min-width: 40px;
        }
        
        /* --- 12. ç»‘å®šæç¤ºè¯å¼¹çª—æ ·å¼ --- */
        .binding-modal-content {
            background: var(--bg-light) !important; /* ä½¿ç”¨ä¸»é¡µé¢çš„æµ…è‰²èƒŒæ™¯ */
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
        }
        .binding-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .binding-modal-header h2 {
            margin: 0;
            font-size: 1.4rem;
            font-family: var(--font-title);
        }
        #open-folder-selection-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        #open-folder-selection-btn:hover {
            transform: scale(1.1) rotate(90deg);
            background: var(--accent-color-deep);
        }
        #bound-folders-list {
            min-height: 100px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .bound-folder-card {
            background: var(--text-color-white);
            padding: 15px;
            border-radius: 10px;
            box-shadow: var(--shadow-light);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .bound-folder-card i {
            font-size: 1.5rem;
            color: var(--theme-color-4);
        }
        .bound-folder-card span {
            font-size: 1.1rem;
            flex-grow: 1;
        }

        .folder-selection-list {
            max-height: 300px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .folder-selection-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background-color: rgba(255,255,255,0.5);
            border-radius: 8px;
            cursor: pointer;
        }
        .folder-selection-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 15px;
            accent-color: var(--accent-color);
        }
        .folder-selection-item i {
            margin-right: 10px;
            color: var(--text-color-medium);
        }
        
        /* --- å¼€å…³æ ·å¼ (å¯å¤ç”¨) --- */
        .switch { position: relative; display: inline-block; width: 52px; height: 30px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 30px; }
        .slider:before { position: absolute; content: ""; height: 24px; width: 24px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(22px); }


        /* --- 13. å‘ç°é¡µé¢ --- */
        #page-discover .settings-list {
            padding-top: 10px;
        }
        #page-discover .setting-item {
            margin: 0 10px 1px; /* ç´§å‡‘åˆ—è¡¨ */
            border-radius: 0;
            padding: 18px 15px;
            background: var(--text-color-white);
        }
        #page-discover .setting-item:first-child {
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            margin-top: 10px;
        }
        #page-discover .setting-item:last-child {
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            margin-bottom: 10px;
        }
        #page-discover .setting-item:hover {
            transform: none;
            box-shadow: none;
            background-color: #f7f7f7;
        }

        /* --- 14. æœ‹å‹åœˆé¡µé¢ --- */
        #page-moments {
            /* å…³é”®1ï¼šè®©å®ƒæˆä¸ºä¸€ä¸ªå‰ªè£å’Œå®šä½çš„å®¹å™¨ */
            overflow: hidden; 
            position: relative; /* ä¸ºå­å…ƒç´ çš„ç»å¯¹å®šä½æä¾›åŸºå‡† */
        }

        #moments-wrapper {
            /* å…³é”®2ï¼šä½¿ç”¨ç»å¯¹å®šä½æ¥ç¡®ä¿å°ºå¯¸å’Œä½ç½®çš„ç²¾ç¡®æ€§ */
            position: absolute;
            top: 0;
            left: 0;
            width: 125%; /* 100% / 0.8 = 125% */
            height: 125%;
            transform: scale(0.8);
            transform-origin: top left;
            
            /* å†…éƒ¨å¸ƒå±€ä¿æŒä¸å˜ï¼Œä¾ç„¶ä½¿ç”¨flexæ¥æ’åˆ—headerå’Œcontent */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* é˜²æ­¢å†…éƒ¨å‡ºç°æ„å¤–çš„æ»šåŠ¨æ¡ */
        }
        #page-moments .page-header {
            display: flex; /* ä½¿ç”¨flexå¸ƒå±€ä»¥é€‚åº”æŒ‰é’® */
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            position: absolute; /* æµ®åŠ¨åœ¨èƒŒæ™¯å›¾ä¸Š */
            top: 0;
            left: 0;
            right: 0;
            background: transparent;
            border-bottom: none;
            z-index: 10;
        }
        #page-moments .page-header .header-icon {
            color: var(--text-color-white);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            font-size: 1.4rem;
        }
        #moments-actions-group {
            display: flex;
            gap: 10px;
        }
        #page-moments .page-header .header-icon {
            color: var(--text-color-white);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            font-size: 1.4rem;
            padding: 5px 8px; /* è°ƒæ•´å†…è¾¹è·ä½¿æŒ‰é’®æ›´ç´§å‡‘ */
        }

        #page-moments .page-content {
            padding: 0; /* ç§»é™¤å†…è¾¹è·ï¼Œè®©å†…å®¹å¡«æ»¡ */
            background-color: var(--theme-color-1);
        }

        .moments-header-container {
            position: relative;
        }
        #moments-bg {
            width: 100%;
            height: 250px;
            object-fit: cover;
            display: block;
        }
        .moments-profile-info {
            position: absolute;
            bottom: 0;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .moments-profile-info .name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--text-color-white);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .moments-profile-info .avatar {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            border: 3px solid white;
            box-shadow: var(--shadow-light);
        }

        #moments-list {
            list-style: none;
            padding: 0;
            background-color: var(--bg-light);
        }

        .moments-post {
            display: flex;
            gap: 15px;
            padding: 20px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        .post-avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
        }
        .post-main-content {
            flex-grow: 1;
        }
        .post-author-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent-color-deep);
            margin-bottom: 8px;
        }
        .post-text {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        .post-images-grid {
            display: grid;
            gap: 5px;
            margin-bottom: 10px;
        }
        .post-images-grid.grid-1 { grid-template-columns: minmax(0, 2fr); }
        .post-images-grid.grid-2, .post-images-grid.grid-4 { grid-template-columns: repeat(2, 1fr); }
        .post-images-grid.grid-3, .post-images-grid.grid-5, .post-images-grid.grid-6, .post-images-grid.grid-7, .post-images-grid.grid-8, .post-images-grid.grid-9 { grid-template-columns: repeat(3, 1fr); }

        .post-images-grid img {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 6px;
            background-color: var(--theme-color-1);
        }
        .post-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .post-timestamp {
            font-size: 0.8rem;
            color: var(--text-color-light);
        }
        .post-actions-btn {
            background: transparent; /* å»æ‰èƒŒæ™¯è‰² */
            border: none;
            width: 30px;
            height: 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-medium);
            transition: background-color 0.2s; /* æ·»åŠ è¿‡æ¸¡æ•ˆæœ */
        }
        .post-actions-btn:hover, .post-action-icon-btn:hover {
            background-color: rgba(0, 0, 0, 0.05); /* æ·»åŠ æ‚¬æµ®æ•ˆæœ */
        }

        .post-comments-section {
            background-color: #f7f7f7;
            border-radius: 8px;
            padding: 5px;
            font-size: 0.9rem;
        }
        .post-interactions {
            background-color: #f7f7f7;
            border-radius: 8px;
            padding: 5px;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        .post-likes {
            padding: 8px 10px;
            line-height: 1.5;
            color: var(--accent-color-deep);
            font-weight: 500;
            border-bottom: 1px solid #ededed;
        }
        .post-likes .fa-heart {
            margin-right: 8px;
        }
        .post-likes:empty {
            display: none;
        }
        .post-likes:empty + .post-comments-list {
            border-top: none; /* å¦‚æœæ²¡æœ‰ç‚¹èµï¼Œè¯„è®ºåŒºå°±ä¸è¦æœ‰ä¸Šè¾¹æ¡† */
        }
        .post-footer .action-buttons-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .post-action-icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-medium);
        }
        .post-action-icon-btn.liked .fa-heart {
            color: var(--accent-color);
            font-weight: 900; /* 'fas' style */
        }
        .post-comment-item {
            padding: 8px 10px;
            line-height: 1.5;
        }
        .comment-author {
            color: var(--accent-color);
            font-weight: bold;
        }
        .comment-reply-to {
            color: var(--text-color-medium);
        }
        .post-comment-typing-indicator {
            padding: 8px 10px;
            color: var(--text-color-light);
            font-style: italic;
        }

        /* è¯„è®ºè¾“å…¥æ¡† */
        .comment-input-wrapper {
            display: none; /* é»˜è®¤éšè— */
            padding: 8px 10px;
            margin-top: 5px;
        }
        .comment-input-wrapper.active {
            display: flex; /* ç‚¹å‡»è¯„è®ºæŒ‰é’®åæ˜¾ç¤º */
            gap: 8px;
        }
        .comment-input-wrapper input {
            flex-grow: 1;
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 8px 12px;
            font-size: 0.9rem;
            outline: none;
        }
        .comment-input-wrapper button {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 0 15px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* --- 15. æœ‹å‹åœˆè½¬å‘å¡ç‰‡æ ·å¼ --- */
        .bubble.forwarded-moment-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 250px;
            min-width: 220px;
        }
        .bubble.forwarded-moment-bubble:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        /* --- æ ¸å¿ƒé’ˆå¯¹æ‰€æœ‰ä¸»é¢˜ï¼Œå¼ºåˆ¶é‡ç½®ç‰¹æ®Šæ¶ˆæ¯çš„æ°”æ³¡æ ·å¼ --- */
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.transfer-or-red-packet-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.card-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-moment-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.gift-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-history-bubble,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.bubble-emoji {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            margin: 0 !important;
            filter: none !important;
            white-space: normal !important; /* æ–°å¢ï¼šä¸ºç‰¹æ®Šæ°”æ³¡é‡ç½®æ¢è¡Œè¡Œä¸º */
        }
        
        /* --- æ ¸å¿ƒä¸“é—¨ç¦ç”¨è‡ªå®šä¹‰CSSåœ¨ç‰¹æ®Šæ°”æ³¡ä¸Šçš„ä¼ªå…ƒç´  --- */
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.transfer-or-red-packet-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.transfer-or-red-packet-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.card-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.card-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-moment-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-moment-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.gift-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.gift-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-history-bubble::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.forwarded-history-bubble::after,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.bubble-emoji::before,
        #app-container[class*="app-bubble-style-"] .chat-area .message-content .bubble.bubble-emoji::after {
            content: none !important;
        }
        

        /* --- é€šç”¨åŸºç¡€æ ·å¼ --- */
        .bubble.transfer-or-red-packet-bubble,
        .bubble.card-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 280px;
        }
        .bubble.transfer-or-red-packet-bubble:not(.claimed):hover,
        .bubble.card-bubble:hover .card-message-wrapper {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        .bubble.card-bubble {
            max-width: 280px; /* è°ƒæ•´ä¸º max-width */
        }

        .forwarded-moment-card-content {
            background-color: var(--text-color-white);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .forwarded-moment-card-content .card-title {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-color-dark) !important;
        }
        .forwarded-moment-card-content .card-preview {
            font-size: 0.8rem;
            color: var(--text-color-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .forwarded-moment-card-content .card-footer {
            font-size: 0.75rem;
            color: var(--text-color-light);
            border-top: 1px solid var(--border-color);
            padding-top: 8px;
            margin-top: 8px;
        }

        /* --- æœ‹å‹åœˆè½¬å‘å¡ç‰‡è¯¦æƒ…å¼¹çª—æ ·å¼ --- */
        .moment-detail-wrapper { padding: 20px 15px; }
        .moment-detail-wrapper .post-header { display: flex; align-items: center; gap: 15px; }
        .moment-detail-wrapper .post-avatar { width: 50px; height: 50px; border-radius: 8px; object-fit: cover; }
        .moment-detail-wrapper .post-author-info .name { font-size: 1.1rem; font-weight: 600; color: var(--accent-color-deep); }
        .moment-detail-wrapper .post-content-full { margin: 15px 0; font-size: 1rem; line-height: 1.7; white-space: pre-wrap; }
        .moment-detail-wrapper .post-image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 5px; margin: 15px 0; }
        .moment-detail-wrapper .post-image-grid img { width: 100%; height: 80px; object-fit: cover; border-radius: 6px; }
        .moment-detail-wrapper .post-footer-full { display: flex; justify-content: space-between; align-items: center; color: var(--text-color-light); font-size: 0.8rem; margin-bottom: 10px; }
        .moment-detail-wrapper .interactions-section { background-color: rgba(0,0,0,0.03); border-radius: 8px; font-size: 0.9rem; }
        .moment-detail-wrapper .likes-list { padding: 10px 12px; line-height: 1.5; color: var(--accent-color-deep); font-weight: 500; word-break: break-all; }
        .moment-detail-wrapper .likes-list .fa-heart { margin-right: 8px; }
        .moment-detail-wrapper .likes-list:empty + .comments-list { border-top: none; }
        .moment-detail-wrapper .comments-list { padding: 5px 0; border-top: 1px solid var(--border-color); }
        .moment-detail-wrapper .comment-item { padding: 8px 12px; line-height: 1.5; }
        .moment-detail-wrapper .comment-author { color: var(--accent-color); font-weight: bold; }
        .moment-detail-wrapper .comment-reply-to { color: var(--text-color-medium); }

        /* 
        =============================
        æ¶ˆæ¯æ°”æ³¡æ ·å¼ (æ¥è‡ªå‚è€ƒæ–‡ä»¶)
        =============================
        */

        /* --- é€šç”¨åŸºç¡€æ ·å¼ --- */
        .bubble.transfer-or-red-packet-bubble,
        .bubble.card-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 280px;
        }
        .bubble.transfer-or-red-packet-bubble:not(.claimed):hover,
        .bubble.card-bubble:hover .card-message-wrapper {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        .bubble.card-bubble {
            max-width: 280px; /* è°ƒæ•´ä¸º max-width */
        }

        /* --- å¡ç‰‡æ¶ˆæ¯å®¹å™¨æ ·å¼ --- */
        .card-message-wrapper {
            background-color: var(--text-color-white, white);
            border: 1px solid var(--border-color, #eee);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            color: var(--text-color-dark, #333);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card-message-wrapper h4,
        .card-message-wrapper p {
            margin: 0;
            padding: 0;
            line-height: 1.4;
        }
        .card-message-wrapper h4 {
            font-size: 1rem;
            font-weight: 600;
        }
        .card-message-wrapper p {
            font-size: 0.85rem;
            color: var(--text-color-light, #666);
        }

        /* --- å¡ç‰‡è¯¦æƒ…å±•å¼€æ ·å¼ (ä¿®æ”¹å) --- */
        .bubble.card-bubble {
            position: relative; /* ä¸ºç»å¯¹å®šä½çš„å­å…ƒç´ æä¾›å‚è€ƒ */
            overflow: visible;  /* å…è®¸ç»å¯¹å®šä½çš„å­å…ƒç´ æº¢å‡º */
            background: none; /* å¡ç‰‡æ¶ˆæ¯æœ¬èº«ä¸éœ€è¦èƒŒæ™¯ */
            padding: 0;       /* ç§»é™¤å†…è¾¹è·ï¼Œç”±å†…éƒ¨wrapperæ§åˆ¶ */
            box-shadow: none; /* ç§»é™¤é˜´å½±ï¼Œç”±å†…éƒ¨wrapperæ§åˆ¶ */
        }
        .card-detail-content {
            position: absolute; /* å…³é”®ä¿®æ”¹ï¼šè„±ç¦»æ–‡æ¡£æµ */
            top: 100%; /* å®šä½åˆ°å¯è§å¡ç‰‡çš„æ­£ä¸‹æ–¹ */
            left: 0;
            width: 100%;
            z-index: 10; /* ç¡®ä¿åœ¨å…¶ä»–å…ƒç´ ä¹‹ä¸Š */
            
            background-color: var(--text-color-white); /* å›ºå®šç™½è‰²èƒŒæ™¯ */
            color: var(--text-color-dark); /* å›ºå®šæ·±è‰²å­—ä½“ */
            border: 1px solid var(--border-color, #eee);
            border-radius: 12px; /* ç»™è‡ªå·±å®Œæ•´çš„åœ†è§’ */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); /* ç‹¬ç«‹çš„å¤–é˜´å½± */
            padding: 15px;

            max-height: 0; /* é»˜è®¤éšè— */
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.4s ease, padding-top 0.4s ease, padding-bottom 0.4s ease;
            box-sizing: border-box;
        }
        .card-detail-content.visible {
            max-height: 500px;
            opacity: 1;
        }
        /* ç¡®ä¿è¯¦æƒ…å†…çš„æ–‡å­—é¢œè‰²ä¸è¢«å¤–éƒ¨æ°”æ³¡æ ·å¼è¦†ç›– */
        .card-detail-content h5, .card-detail-content p {
            color: var(--text-color-dark) !important;
        }

        /* --- 1. æ–°ç‰ˆè½¬è´¦æ ·å¼ --- */
        .message-row.sent .transfer-content-v3 {
            background-color: #BEE3F8;
            color: #2A4365;
        }
        .message-row.received .transfer-content-v3 {
            background-color: #FFF0F5;
            color: var(--text-color-dark);
        }
        .transfer-content-v3 {
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            width: 100%;
            min-width: 200px; /* è®¾ç½®æœ€å°å®½åº¦ */
            position: relative; /* ä¸ºä¼ªå…ƒç´ å®šä½ */
            overflow: hidden; /* è£å‰ªä¼ªå…ƒç´  */
            z-index: 1; /* ç¡®ä¿å†…å®¹åœ¨èƒŒæ™¯ä¹‹ä¸Š */
        }
        /* ç¡®ä¿å†…å®¹åœ¨é®ç½©å±‚ä¹‹ä¸Š */
        .transfer-content-v3 > * {
            position: relative;
            z-index: 2;
        }
        /* åŠé€æ˜ç™½è‰²é®ç½©ï¼Œé™ä½èƒŒæ™¯å›¾é¥±å’Œåº¦ */
        .transfer-content-v3::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.65);
            z-index: 1;
        }
        .transfer-header-v3 {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 5px;
        }
        .transfer-icon-v3 {
            font-size: 22px;
        }
        .message-row.sent .transfer-icon-v3 { color: #3182CE; }
        .message-row.received .transfer-icon-v3 { color: #FF69B4; }

        .transfer-info-v3 h4 { margin: 0; font-size: 1em; font-weight: 500; }
        .transfer-info-v3 p { margin: 0; font-size: 1.2em; font-weight: 700; }
        .transfer-footer-v3 {
            border-top: 1px solid rgba(0,0,0,0.08);
            padding-top: 5px;
            margin-top: 5px;
            font-size: 0.75em;
            color: #777;
        }
        .bubble.claimed .transfer-content-v3 {
            background-color: #e0e0e0;
            opacity: 0.8;
        }

        /* --- 2. æ–°ç‰ˆçº¢åŒ…æ ·å¼ --- */
        .red-packet-v3-wrapper {
            width: 120px;
            height: 160px;
            position: relative;
        }
        .rp-cover-v3 {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            background-image: url('https://z.wiki/u/IDzEvp'); /* å·²æ›´æ¢ä¸ºæ–°çš„é»˜è®¤å°é¢ */
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* è®©å†…å®¹ä»åº•éƒ¨å¼€å§‹å¯¹é½ï¼Œä¸ºéšè—æ ‡é¢˜åšå‡†å¤‡ */
            padding: 10px;
            box-sizing: border-box;
        }
        .rp-title-v3 {
            display: none; /* å·²éšè—çº¢åŒ…å°é¢ä¸Šçš„æ ‡é¢˜ */
        }
        .open-button-v3 {
            width: 45px;
            height: 45px;
            background-color: var(--red-packet-gold);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            color: var(--red-packet-red);
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            animation: paw-pulse 2s infinite ease-in-out;
            align-self: center; /* ç¡®ä¿åœ¨ flex å¸ƒå±€ä¸­å±…ä¸­ */
            margin-bottom: 5px; /* è°ƒæ•´ä¸åº•éƒ¨è·ç¦» */
        }
        .claimed-overlay-v3 {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(2px);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--red-packet-red);
            font-weight: bold;
            font-size: 1rem;
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .bubble.claimed .claimed-overlay-v3 {
            opacity: 1;
        }
        .bubble.claimed .open-button-v3 {
            display: none; /* é¢†å–åéšè—æŒ‰é’® */
        }
        
        /* --- 3. å·¦å›¾å³æ–‡å¡ç‰‡ (é€šç”¨åˆ†äº«) --- */
        .card-type-2 { display: flex; align-items: center; }
        .card-type-2 .card-image { width: 80px; height: 80px; object-fit: cover; flex-shrink: 0; }
        .card-type-2 .card-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 8px;
            flex-grow: 1;
            overflow: hidden;
        }
        .card-type-2 h4 { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* --- 4. å›¾æ ‡èšç„¦å¡ç‰‡ (ä½ç½®åˆ†äº«) --- */
        .card-type-3 { display: flex; align-items: center; padding: 16px; gap: 15px; }
        .card-type-3 .card-icon-area {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--theme-color-1);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .card-type-3 .card-icon-area i { font-size: 1.8rem; color: var(--text-color-white, white); }
        .card-type-3 .card-content { flex-grow: 1; }

        /* --- 5. æ–‡ä»¶ä¸‹è½½å¡ç‰‡ --- */
        .card-type-9 { display: flex; align-items: center; padding: 15px; gap: 15px; }
        .card-type-9 .file-icon { font-size: 3rem; color: var(--theme-color-4); }
        .card-type-9 .file-info { flex-grow: 1; overflow: hidden; }
        .card-type-9 h4 { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card-type-9 .file-size { font-size: 0.8rem; color: var(--text-color-light); margin-top: 4px; }
        
        /* --- 6. ä¸»åŠ¨å›å¤ä¸æ—¶é—´æˆ³æ ·å¼ --- */

        .message-timestamp {
            font-size: 0.75rem;
            color: var(--text-color-light);
            margin-top: 5px;
            padding: 0 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .message-row.sent .message-timestamp {
            justify-content: flex-end;
        }
        .auto-reply-tag {
            font-size: 0.65rem;
            color: #1890FF;
            background-color: #E6F7FF;
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid #91D5FF;
        }
        /* --- 16. ä¸»é¢˜è®¾ç½®é¡µé¢ (æ–°) --- */
        #page-theme-settings .page-content {
            padding: 15px;
            background-color: rgba(0,0,0,0.02); /* ç»™é¡µé¢ä¸€ä¸ªæ·¡æ·¡çš„åº•è‰² */
        }

        .theme-setting-card {
            background-color: rgba(255, 255, 255, 0.85); /* ç§»é™¤æ¨¡ç³Šæ•ˆæœï¼Œé€‚å½“å¢åŠ ä¸é€æ˜åº¦ä»¥ä¿è¯å¯è¯»æ€§ */
            /* backdrop-filter: blur(5px); <-- ç§»é™¤æ€§èƒ½æ¶ˆè€—å·¨å¤§çš„æ¨¡ç³Šæ•ˆæœ */
            border: 1px solid var(--border-color); /* ä½¿ç”¨æ›´æŸ”å’Œçš„é€šç”¨è¾¹æ¡†é¢œè‰² */
            border-radius: 16px;
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* ä½¿ç”¨æ›´ç®€å•ã€æ€§èƒ½æ›´å¥½çš„é˜´å½± */
            transform: translateZ(0); /* æ–°å¢ï¼šå¼€å¯ç¡¬ä»¶åŠ é€Ÿï¼Œè®©æ»šåŠ¨æ›´ä¸æ»‘ */
        }
        .theme-setting-card h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--text-color-dark);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        .theme-setting-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .theme-page-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 12px; /* æŒ‰é’®åœ†è§’ */
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s;
            background-color: var(--text-color-white);
            color: var(--text-color-dark);
            border: 1px solid var(--border-color);
        }
        .theme-page-btn:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        /* é¢œè‰²é€‰æ‹©å¼¹çª— */
        .color-palette-modal-body {
            display: flex;
            justify-content: space-around; /* æ°´å¹³æ’åˆ— */
            align-items: center;
            gap: 15px;
            padding: 20px 0;
        }
        .color-picker-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .color-picker-wrapper input[type="color"] {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            padding: 0;
        }
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }

        /* ä¸Šä¼ ç»„ä»¶ */
        .theme-upload-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        .theme-upload-preview-wrapper {
            position: relative;
            width: 120px;
            height: 80px;
            flex-shrink: 0;
        }
        .theme-upload-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
            background-color: #e9e9e9;
            border: 1px solid var(--border-color);
        }
        /* ç¾½åŒ–æ•ˆæœ */
        .theme-upload-preview-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            box-shadow: inset 0 0 10px 5px rgba(255, 255, 255, 0.9);
            pointer-events: none;
        }
        /* --- 17. æ•™ç¨‹é¡µé¢ (æ–°) --- */
        #page-tutorial {
            background-color: #fff !important;
            background-image: none !important;
        }
        .tutorial-watermark {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.7rem;
            color: #d0d0d0;
            pointer-events: none;
            user-select: none;
            text-align: right; /* è®©æ–‡å­—å³å¯¹é½ */
        }

        /* --- 18. æ—ç™½æ¶ˆæ¯æ ·å¼ (æ–°) --- */
        .narrator-notice {
            align-self: center;
            padding: 4px 10px;
            border-radius: 10px;
            margin: 5px 0;
            max-width: 90%;
            word-wrap: break-word;
            text-align: left;
            line-height: 1.5;
            white-space: pre-wrap; /* è®©æ¢è¡Œç¬¦ç”Ÿæ•ˆ */
        }
        .narrator-style-grey {
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            font-size: 0.75rem;
        }
        .narrator-style-white {
            background: rgba(255, 255, 255, 0.9);
            color: var(--text-color-dark);
            font-size: 0.85rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
        }
        .narrator-style-black {
            background: rgba(0, 0, 0, 0.75);
            color: var(--text-color-white);
            font-size: 0.85rem;
        }

        /* --- æ‹ä¸€æ‹æ¶ˆæ¯æ ·å¼ (æ–°) --- */
        .pat-notice {
            align-self: center;
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 10px;
            margin: 5px 0;
            cursor: default;
            user-select: none;
        }

        /* --- 19. ç•ªèŒ„é’Ÿ (æ–°) --- */
        #page-pomodoro .page-content {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 30px;
        }

        .pomodoro-timer-display {
            font-size: 5rem;
            font-weight: bold;
            color: var(--text-color-dark);
            font-family: 'Courier New', Courier, monospace;
            letter-spacing: 2px;
        }

        .pomodoro-goal-input {
            width: 100%;
            max-width: 300px;
            text-align: center;
            border: none;
            border-bottom: 2px solid var(--border-color);
            background: transparent;
            padding: 10px;
            font-size: 1.2rem;
            outline: none;
            transition: border-color 0.3s;
        }
        .pomodoro-goal-input:focus {
            border-bottom-color: var(--accent-color);
        }

        .pomodoro-controls {
            display: flex;
            gap: 20px;
        }

        .pomodoro-btn {
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        .pomodoro-btn.start {
            background-color: var(--accent-color);
            color: white;
        }
        .pomodoro-btn.start:hover {
            background-color: var(--accent-color-deep);
            transform: translateY(-2px);
        }
        .pomodoro-btn.stop {
            background-color: #e74c3c;
            color: white;
        }
        .pomodoro-btn.stop:hover {
            background-color: #c0392b;
        }

        #pomodoro-float-ball {
            position: fixed;
            bottom: 150px; /* å‘ä¸Šç§»åŠ¨äº†ä¸€ç‚¹ */
            right: 20px;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.7); /* é™ä½äº†ä¸€ç‚¹ä¸é€æ˜åº¦ */
            backdrop-filter: blur(10px); /* å¢å¼ºæ¨¡ç³Šæ•ˆæœ */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* å¢åŠ äº†é«˜å…‰å’Œæ›´æŸ”å’Œçš„é˜´å½±ï¼Œè¥é€ æ³¡æ³¡æ„Ÿ */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15), inset 0 2px 4px rgba(255, 255, 255, 0.5);
            cursor: grab; /* æç¤ºå¯ä»¥æŠ“å– */
            z-index: 1500;
            transition: opacity 0.3s, transform 0.3s;
            user-select: none; /* é˜²æ­¢é•¿æŒ‰é€‰ä¸­æ–‡æœ¬ */
            -webkit-user-select: none; /* å…¼å®¹è€æµè§ˆå™¨ */
        }
        #pomodoro-float-ball.dragging {
            cursor: grabbing; /* æ‹–åŠ¨æ—¶çš„æ‰‹å‹ */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2); /* æ‹–åŠ¨æ—¶é˜´å½±å˜å¤§ï¼Œæœ‰æ‚¬æµ®æ„Ÿ */
            transform: scale(1.05);
        }
        #pomodoro-float-ball.hidden {
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
        }
        #pomodoro-float-ball .progress-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(var(--accent-color) 0deg, #e0e0e0 0deg);
            z-index: -1;
        }
        #pomodoro-float-ball .time-left {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--text-color-dark);
        }

        .pomodoro-notification-banner {
            pointer-events: auto;
            position: relative;
            width: 48px;
            height: 48px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            color: #fff;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: width 0.5s cubic-bezier(0.65, 0, 0.35, 1);
        }
        .pomodoro-notification-banner.is-playing {
            animation: expand-toast 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }
        .pomodoro-notification-banner .icon-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .pomodoro-notification-banner.is-playing .icon-wrapper {
             animation: move-icon 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }
        .pomodoro-notification-banner .text-content {
            opacity: 0;
            white-space: nowrap;
            padding-left: 52px; /* ç»™å›¾æ ‡ç•™å‡ºç©ºé—´ */
        }
        .pomodoro-notification-banner.is-playing .text-content {
            animation: show-text 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        /* --- æ—ç™½è®¾ç½®é€‰é¡¹æ ·å¼ --- */
        .narrator-style-selector {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            padding: 10px 0;
        }
        .narrator-style-option {
            flex: 1;
            padding: 15px 10px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            border: 2px solid var(--border-color);
            transition: all 0.2s ease-in-out;
        }
        .narrator-style-option.selected {
            border-color: var(--accent-color);
            transform: scale(1.05);
            box-shadow: var(--shadow-light);
        }
        .narrator-style-option.grey-option { background: #ccc; color: white; }
        .narrator-style-option.white-option { background: white; color: #333; }
        .narrator-style-option.black-option { background: #333; color: white; }

        /* --- 20. é€ç¤¼ç‰©é¡µé¢ (æ–°) --- */
        #page-gifts .page-content {
            padding: 15px;
            /* å°†èƒŒæ™¯è‰²æ”¹ä¸ºæ›´ç°çš„ä¸»èƒŒæ™¯è‰² */
            background-color: var(--bg-main); 
        }
        .gifts-search-container {
            /* æ”¹ä¸ºçºµå‘æ’åˆ— */
            display: flex;
            flex-direction: column; 
            gap: 15px; /* å¢åŠ è¡Œé—´è· */
            margin-bottom: 20px;
        }
        /* ä¸ºæœç´¢å’ŒæŒ‰é’®è¡Œåˆ›å»ºåŒ…è£¹å±‚ */
        .gifts-search-container .search-row,
        .gifts-search-container .action-row {
            display: flex;
            width: 100%;
            gap: 10px;
        }
        /* ä¸ºé•¿æ–¹å½¢æŒ‰é’®è®¾è®¡æ ·å¼ */
        .gifts-search-container .action-btn {
            flex: 1; /* è®©æŒ‰é’®å¹³åˆ†å®½åº¦ */
            width: auto; /* è¦†ç›– .gift-header-btn çš„å›ºå®šå®½åº¦ */
            height: auto; /* è¦†ç›– .gift-header-btn çš„å›ºå®šé«˜åº¦ */
            padding: 10px;
            border-radius: 12px; /* å¢åŠ åœ†è§’ */
            font-weight: 500;
            font-size: 0.9rem; /* è°ƒæ•´å­—ä½“å¤§å°ä»¥é€‚åº”æŒ‰é’® */
            background-color: rgba(255, 255, 255, 0.85); /* å¢åŠ é€æ˜åº¦ */
        }
        .gifts-search-container .search-bar-wrapper {
            flex-grow: 1;
            position: relative;
        }
        .gifts-search-container .search-bar-wrapper i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-color-light);
        }
        #gift-search-input {
            width: 100%;
            height: 45px;
            border-radius: 22.5px;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            padding: 0 20px 0 45px;
            font-size: 1rem;
            outline: none;
            transition: all 0.2s;
        }
        #gift-search-input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(167, 199, 231, 0.2);
        }
        #gift-search-refresh-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1rem;
            color: var(--text-color-medium);
            cursor: pointer;
        }
        #gift-search-refresh-btn:hover i {
            color: var(--accent-color);
        }
        .gift-header-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-color-medium);
            transition: all 0.2s;
        }
        .gift-header-btn:hover {
            background-color: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }
        .gifts-section-title {
            font-size: 1.2rem;
            color: var(--text-color-dark);
            margin-bottom: 15px;
            padding-left: 5px;
        }
        .gifts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
        }
        .gift-card {
            background-color: var(--text-color-white);
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .gift-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-medium);
        }
        .gift-card img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
            background-color: var(--theme-color-1);
        }
        .gift-card-info {
            padding: 10px;
        }
        .gift-card-info .name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 5px;
        }
        .gift-card-info .price {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--accent-color-deep);
        }
        .gift-loader {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px 0;
            color: var(--text-color-medium);
        }
        .gift-loader .loader-spinner {
            margin-bottom: 15px;
        }

        /* ç¤¼ç‰©æ¶ˆæ¯æ°”æ³¡æ ·å¼ */
        .bubble.gift-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            max-width: 250px;
            width: 250px;
        }
        #app-container[class*="app-bubble-style-"] .bubble.gift-bubble {
            padding: 0 !important;
            background: none !important;
            border: none !important;
            box-shadow: none !important;
        }
        .gift-message-content {
            background: linear-gradient(135deg, #FFF7E0 0%, #FFE9D1 100%);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(255, 220, 180, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.5);
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .gift-message-content .gift-image {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
            flex-shrink: 0;
        }
        .gift-message-content .gift-info {
            flex-grow: 1;
            color: #8D6E63;
        }
        .gift-message-content .gift-info .gift-name {
            font-weight: bold;
            font-size: 1rem;
        }
        .gift-message-content .gift-info .gift-message {
            font-size: 0.85rem;
            margin-top: 4px;
            font-style: italic;
        }
        .gift-message-content .gift-info .gift-price {
            font-size: 0.8rem;
            margin-top: 6px;
            color: #D32F2F;
        }

        /* --- 21. èŠå¤©è®°å½•è½¬å‘ (æ–°) --- */
        #page-chat.selection-mode-active .message-row,
        #page-chat.selection-mode-active .narrator-notice {
            padding-left: 45px;
            position: relative;
        }
        .message-selector {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            display: none;
        }
        #page-chat.selection-mode-active .message-selector {
            display: block;
        }
        .message-select-checkbox {
            width: 100%;
            height: 100%;
            accent-color: var(--accent-color);
        }

        #chat-selection-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-light);
            backdrop-filter: blur(5px);
            border-top: 1px solid var(--border-color);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 200;
            min-height: 100px; /* è®¾ç½®ä¸€ä¸ªæœ€å°é«˜åº¦æ¥è¦†ç›–è¾“å…¥åŒº */
            box-sizing: border-box; /* ç¡®ä¿å†…è¾¹è·ä¸ä¼šå½±å“æ€»é«˜åº¦ */
        }
        #chat-selection-bar.visible {
            transform: translateY(0);
        }
        #chat-selection-bar .selection-info {
            font-size: 0.9rem;
            color: var(--text-color-medium);
        }
        #chat-selection-bar .selection-actions {
            display: flex;
            gap: 10px;
        }

        .bubble.forwarded-history-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 250px;
        }
        .bubble.forwarded-history-bubble:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }

        .forwarded-history-card-content {
            background-color: var(--text-color-white);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .forwarded-history-card-content .card-title {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-color-dark) !important;
        }
        .forwarded-history-card-content .card-preview {
            font-size: 0.8rem;
            color: var(--text-color-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .forwarded-history-card-content .card-footer {
            font-size: 0.75rem;
            color: var(--text-color-light);
            border-top: 1px solid var(--border-color);
            padding-top: 8px;
            margin-top: 8px;
        }

        #page-forwarded-history .page-content {
            background-color: var(--theme-color-1);
            padding: 20px 15px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #page-forwarded-history .message-row {
            max-width: 80%;
        }
        #page-forwarded-history .bubble-and-tag-wrapper {
            padding-bottom: 20px; /* ä¸ºæ—¶é—´æˆ³ç•™å‡ºç©ºé—´ */
        }
        #page-forwarded-history .message-timestamp {
            position: absolute;
            bottom: 4px;
            left: 12px;
            font-size: 0.7rem;
            color: var(--text-color-light);
        }
        #page-forwarded-history .message-row.sent .message-timestamp {
            left: auto;
            right: 12px;
        }
        .forward-target-search-bar {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            margin-bottom: 10px;
            font-size: 1rem;
        }
        #chat-input-area {
            position: relative; /* ä¸ºé®ç½©å±‚æä¾›å®šä½åŸºå‡† */
        }
        #chat-selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(240, 240, 240, 0.85);
            backdrop-filter: blur(2px);
            z-index: 150;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            color: var(--text-color-medium);
            cursor: not-allowed;
        }
        #page-chat.selection-mode-active #chat-selection-overlay {
            display: flex;
        }
        #page-forwarded-history .message-name {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }
        #page-forwarded-history .message-name .sender-id {
            font-size: 0.7rem;
            color: var(--text-color-light);
            font-weight: normal;
        }
        
        #page-forwarded-history .page-content {
            background-color: var(--bg-main);
            background-image: none;
        }
        /* --- 22. é¡µé¢UIé£æ ¼ (æ–°) --- */
        .page-header > *,
        #bottom-nav > * {
            position: relative;
            z-index: 1;
        }

        .theme-setting-card .css-editor-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .theme-setting-card #custom-bubble-css-input {
            width: 100%;
            min-height: 200px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            background-color: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            resize: vertical;
            outline-color: var(--accent-color);
        }
        .theme-setting-card .editor-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .css-preview-area {
            padding: 20px;
            background-color: var(--theme-color-1);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .css-tutorial-code {
            background-color: #2d2d2d;
            color: #ccc;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            font-size: 0.85rem;
            position: relative;
            user-select: text;
            -webkit-user-select: text;
        }
        .css-tutorial-code .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #444;
            color: #eee;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .css-tutorial-code .copy-btn:hover {
            background-color: #555;
        }

        /* --- 23. è‡ªå®šä¹‰æ°”æ³¡åŸºç¡€æ ·å¼ (æ–°) --- */
#app-container.app-bubble-style-custom .bubble {
    /* è¿™æ˜¯ä¸€ä¸ªâ€œç©ºç™½â€æ ·å¼ï¼Œç”¨äºæ‰¿è½½ç”¨æˆ·çš„è‡ªå®šä¹‰CSSï¼Œé¿å…è¢«å…¶ä»–å†…ç½®æ ·å¼å¹²æ‰° */
    background: none;
    border: none;
    box-shadow: none;
    padding: 8px 12px; /* ä¿ç•™ä¸€ä¸ªåŸºç¡€çš„å†…è¾¹è·ï¼Œç”¨æˆ·å¯ä»¥è¦†ç›– */
    border-radius: 16px; /* ä¿ç•™ä¸€ä¸ªåŸºç¡€çš„åœ†è§’ï¼Œç”¨æˆ·å¯ä»¥è¦†ç›– */
}

        /* --- 24. å…¬å‘Šå¼¹çª—æ ·å¼ (æ–°) --- */
        .announcement-modal-content {
            max-width: 480px; /* å…¬å‘Šå¯ä»¥å®½ä¸€ç‚¹ */
            background: #f9f9f9;
            border: 1px solid #ddd;
        }
        .announcement-modal-content .modal-header {
            font-size: 1.4rem;
            color: var(--text-color-dark);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }
        .announcement-modal-content .modal-body {
            line-height: 1.8;
            font-size: 0.95rem;
            color: #444;
        }
        .announcement-modal-content .modal-body h4 {
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: var(--text-color-dark);
        }
        .announcement-modal-content .modal-body p {
            margin-bottom: 15px;
        }
        .announcement-page {
            display: none;
        }
        .announcement-page.active {
            display: block;
        }
        .announcement-auth-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px 15px;
            font-size: 0.9rem;
            color: var(--text-color-medium);
            padding: 10px;
            background-color: rgba(0,0,0,0.02);
            border-radius: 8px;
        }
        .announcement-warning {
            font-size: 0.85rem;
            color: #c0392b;
            margin-top: 15px;
            font-weight: bold;
        }
        .announcement-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }
        .announcement-nav .page-indicator {
            font-size: 0.9rem;
            color: var(--text-color-light);
        }
        .announcement-nav .nav-btn {
            padding: 6px 15px;
            font-size: 0.9rem;
        }

        /* --- APIé…ç½®é¡µé¢æ ·å¼ --- */
        #page-api-settings .form-group {
            background: white;
            padding: 18px 15px;
            margin: 0 0 1px;
        }
        #page-api-settings .settings-list {
            padding-top: 10px;
        }
        .api-key-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 10px 0;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
        }
        .api-key-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f9f9f9;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
        }
        .api-key-item .key-value {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 70%;
        }
        .api-key-item .delete-key-btn {
            background: none;
            border: none;
            color: #e74c3c;
            cursor: pointer;
            font-size: 1rem;
        }
        .api-key-add-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .api-key-add-form input {
            flex-grow: 1;
        }

        .api-key-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .api-key-header .header-icon {
            padding: 5px;
            cursor: pointer;
        }

        #announcement-close-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            color: #666;
        }

        /* --- èŠå¤©è®¾ç½®é¡µé¢ç¾åŒ– --- */
        #page-chat-settings .settings-list {
            padding: 10px;
            background-color: var(--bg-main);
        }
        #page-chat-settings .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.8); /* ç§»é™¤æ¨¡ç³Šæ•ˆæœï¼Œé€‚å½“å¢åŠ ä¸é€æ˜åº¦ä»¥ä¿è¯å¯è¯»æ€§ */
            /* backdrop-filter: blur(8px); <-- ç§»é™¤æ€§èƒ½æ¶ˆè€—å·¨å¤§çš„æ¨¡ç³Šæ•ˆæœ */
            border: 1px solid var(--border-color); /* ä½¿ç”¨æ›´æŸ”å’Œçš„é€šç”¨è¾¹æ¡†é¢œè‰² */
            box-shadow: var(--shadow-light); /* ä½¿ç”¨æ›´ç®€å•ã€æ€§èƒ½æ›´å¥½çš„é˜´å½± */
            margin-bottom: 15px;
            border-radius: 16px;
            gap: 15px;
            transform: translateZ(0); /* æ–°å¢ï¼šå¼€å¯ç¡¬ä»¶åŠ é€Ÿï¼Œè®©æ»šåŠ¨æ›´ä¸æ»‘ */
        }
        #page-chat-settings .setting-item span {
            font-size: 1rem; /* ç»Ÿä¸€æ ‡é¢˜å­—ä½“å¤§å° */
        }
        #page-chat-settings .setting-item input[type="number"] {
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            border-radius: 10px; /* å¢åŠ åœ†è§’ */
            font-size: 1rem;
            font-family: var(--font-main);
            outline-color: var(--accent-color);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05); /* å¢åŠ å†…é˜´å½± */
            transition: all 0.2s;
        }
        #page-chat-settings .setting-item input[type="number"]:focus {
            border-color: var(--accent-color);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05), 0 0 0 3px rgba(167, 199, 231, 0.3); /* èšç„¦æ•ˆæœ */
        }

</style>
</head>
<body>
    <!-- å¼€å±åŠ¨ç”» -->
    <div id="splash-screen">
        <div class="splash-logo">33èŠå¤©å®¤</div>
        <div class="splash-loader"></div>
        <p style="position: absolute; bottom: 20px; font-size: 12px; color: #aaa; user-select: none;">æ­¤èŠå¤©å®¤(v2.0.4)ç”±33åˆ¶ä½œï¼Œxhs:@å›é£</p>
    </div>
    <div id="app-container">
        <!-- é¡¶éƒ¨æµ®çª—é€šçŸ¥å®¹å™¨ -->
        <div id="top-notification-container"></div>
        <!-- ä¸»å†…å®¹åŒºåŸŸ -->
        <main id="main-content">
            <!-- æ¶ˆæ¯åˆ—è¡¨é¡µé¢ -->
            <div id="page-messages" class="page active">
                <div class="page-header">
                    <img id="my-avatar" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=" alt="My Avatar">
                    <h1>æ¶ˆæ¯</h1>
                    <a href="https://www.xiaohongshu.com/user/profile/5e65e0f00000000001002837?xsec_token=YBen3b8AVcwS9WjKSzS_xETWKfb3hsoxlS1uX8KTmQLSU%3D&xsec_source=app_share&xhsshare=CopyLink&appuid=5e65e0f00000000001002837&apptime=1751753800&share_id=a6aa049960ff46489ba8080e8cc476d0&share_channel=copy_link" target="_blank" id="header-link-btn">
                        <i class="fas fa-lightbulb"></i>
                    </a>
                </div>
                <div class="page-content">
                    <ul id="message-list-ul" class="message-list">
                        <!-- æ¶ˆæ¯é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                    </ul>
                </div>
            </div>

            <!-- é€šè®¯å½•é¡µé¢ -->
            <div id="page-contacts" class="page">
                <div class="page-header">
                    <div class="header-icon" style="visibility: hidden;"></div> <!-- å ä½ç¬¦ -->
                    <h1>é€šè®¯å½•</h1>
                    <div class="header-icon-group">
                        <div id="batch-delete-btn" class="header-icon" title="æ‰¹é‡åˆ é™¤"><i class="fas fa-minus-circle"></i></div>
                        <div id="add-menu-btn" class="header-icon" title="æ·»åŠ "><i class="fas fa-plus"></i></div>
                    </div>
                </div>
                <div class="tabs">
                    <button class="tab-btn active" data-tab="friends">å¥½å‹</button>
                    <button class="tab-btn" data-tab="groups">ç¾¤èŠ</button>
                    <button class="tab-btn" data-tab="friendFolders">åˆ†ç»„</button>
                </div>
                <div class="page-content" style="padding: 0 15px;">
                    <div id="contacts-friends" class="contact-section active">
                        <div class="contact-list-header">
                            <span id="sort-friends-btn" class="sort-btn">æ’åº <i class="fas fa-sort"></i></span>
                        </div>
                        <ul id="friends-list-ul" class="contact-list"></ul>
                    </div>
                    <div id="contacts-groups" class="contact-section">
                        <div class="contact-list-header">
                            <span id="sort-groups-btn" class="sort-btn">æ’åº <i class="fas fa-sort"></i></span>
                        </div>
                        <ul id="groups-list-ul" class="contact-list"></ul>
                    </div>
                    <div id="contacts-friend-folders" class="contact-section">
                        <!-- Content will be generated by JS -->
                    </div>
                </div>
                <div id="selection-action-bar" class="page-footer" style="display: none; justify-content: space-between; padding: 10px 15px; background: white; border-top: 1px solid var(--border-color);">
                    <button id="select-all-btn" class="modal-btn btn-secondary" style="padding: 8px 20px;">å…¨é€‰</button>
                    <button id="cancel-selection-btn" class="modal-btn btn-secondary" style="padding: 8px 20px;">å–æ¶ˆ</button>
                    <button id="delete-selected-btn" class="modal-btn btn-danger" style="padding: 8px 20px;">åˆ é™¤å·²é€‰</button>
                </div>
            </div>

            <!-- è®¾ç½®é¡µé¢ -->
            <div id="page-settings" class="page">
                <div class="page-header">
                    <h1>è®¾ç½®</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="setting-tutorial">
                            <i class="fas fa-question-circle"></i>
                            <span>33é£Ÿç”¨æŒ‡å—</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <!-- æ–°å¢çš„èŠå¤©è®¾ç½®é¡¹ -->
                        <div class="setting-item" id="setting-chat">
                            <i class="fas fa-comments"></i>
                            <span>èŠå¤©è®¾ç½®</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-api">
                            <i class="fas fa-server"></i>
                            <span>API é…ç½®</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-prompts">
                            <i class="fas fa-magic"></i>
                            <span>è‡ªå®šä¹‰æç¤ºè¯</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-theme">
                            <i class="fas fa-palette"></i>
                            <span>ä¸»é¢˜è®¾ç½®</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-bubble">
                            <i class="fas fa-comment-alt"></i>
                            <span>æ°”æ³¡è®¾ç½®</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-data-management">
                            <i class="fas fa-database"></i>
                            <span>å¯¼å…¥/å¯¼å‡ºå…¨éƒ¨æ•°æ®</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                         <div class="setting-item" id="setting-reset">
                            <i class="fas fa-trash-alt"></i>
                            <span>é‡ç½®åº”ç”¨</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
            </div>

            <!-- èŠå¤©è®¾ç½®é¡µé¢ (æ–°) -->
            <div id="page-chat-settings" class="page">
                <div class="page-header">
                    <div id="chat-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>èŠå¤©è®¾ç½®</h1>
                </div>
                <div class="page-content" id="chat-settings-content">
                    <!-- è®¾ç½®é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <div class="page-footer" style="padding: 10px; text-align: center; border-top: 1px solid var(--border-color); background: rgba(255,255,255,0.5);">
                    <button id="save-chat-settings-btn" class="modal-btn btn-primary" style="width: 90%;"><i class="fas fa-save"></i> ä¿å­˜è®¾ç½®</button>
                </div>
            </div>

            <!-- APIé…ç½®é¡µé¢ (æ–°) -->
            <div id="page-api-settings" class="page">
                <div class="page-header">
                    <div id="api-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>API é…ç½®</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="form-group" style="padding: 0 15px;">
                            <label for="api-provider">APIæä¾›å•†</label>
                            <select id="api-provider">
                                <!-- Options will be generated by JS -->
                            </select>
                        </div>
                        <div class="form-group" style="padding: 0 15px;">
                            <label for="api-url">API URL</label>
                            <input type="text" id="api-url" placeholder="è¾“å…¥API URL">
                        </div>

                        <div class="form-group" style="padding: 0 15px;">
                            <div class="api-key-header">
                                <label>API Keys (<span id="api-key-count">0</span>)</label>
                                <div id="toggle-all-keys-visibility" class="header-icon" title="æ˜¾ç¤º/éšè—"><i class="fas fa-eye"></i></div>
                            </div>
                            <div id="api-key-list" class="api-key-list">
                                <!-- Keys will be generated by JS -->
                            </div>
                            <div class="api-key-add-form">
                                <input type="password" id="new-api-key-input" placeholder="æ·»åŠ æ–°Key...">
                                <button id="add-api-key-btn" class="modal-btn btn-primary" style="padding: 8px 15px; border-radius: 8px;">æ·»åŠ </button>
                            </div>
                        </div>

                        <div class="form-group" style="padding: 0 15px;">
                            <label for="api-model-select">æ¨¡å‹</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="api-model-select" style="flex-grow: 1;"></select>
                                <input type="text" id="api-model-input" placeholder="è¾“å…¥è‡ªå®šä¹‰æ¨¡å‹åç§°" style="display:none; flex-grow: 1;">
                                <button id="fetch-models-btn" class="modal-btn btn-secondary" style="padding: 8px 15px; flex-shrink: 0;">è·å–</button>
                            </div>
                        </div>
                        <div class="form-group" style="padding: 0 15px;">
                            <label for="temperature">æ¸©åº¦ (0-1)</label>
                            <input type="number" id="temperature" min="0" max="1" step="0.1">
                        </div>
                    </div>
                </div>
                <div class="page-footer" style="padding: 10px; text-align: center; border-top: 1px solid var(--border-color); background: rgba(255,255,255,0.5);">
                    <button id="save-api-settings-btn" class="modal-btn btn-primary" style="width: 90%;"><i class="fas fa-save"></i> ä¿å­˜é…ç½®</button>
                </div>
            </div>
            
            <!-- èŠå¤©é¡µé¢ -->
            <div id="page-chat" class="page">
                <div class="page-header">
                    <div id="chat-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <div class="header-title-wrapper">
                        <h1 class="header-title" id="chat-title"></h1>
                        <div class="typing-indicator-container" id="chat-typing-indicator">
                            <span>å¯¹æ–¹æ­£åœ¨è¾“å…¥...</span>
                        </div>
                    </div>
                    <div class="header-icon-group">
                        <div id="chat-insight-btn" class="header-icon" title="è§’è‰²æ´å¯Ÿ"><i class="fas fa-clover"></i></div>
                        <div id="chat-manage-btn" class="header-icon"><i class="fas fa-ellipsis-v"></i></div> 
                    </div>
                </div>
                <div class="chat-area" id="chat-area">
                    <div id="history-loader"><div class="loader-spinner"></div></div>
                    <!-- æ¶ˆæ¯æ°”æ³¡å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <div class="chat-input-area" id="chat-input-area">
                    <!-- å¼•ç”¨é¢„è§ˆåŒºåŸŸ -->
                    <div class="quote-preview-area" id="quote-preview-area">
                        <div class="quote-preview-content" id="quote-preview-content"></div>
                        <button class="cancel-quote-btn" id="cancel-quote-btn" title="å–æ¶ˆå¼•ç”¨">Ã—</button>
                    </div>

                    <!-- è¾“å…¥å’Œå‘é€è¡Œ -->
                    <div class="input-top-row">
                        <button id="ai-request-btn"><i class="fas fa-feather-alt"></i></button>
                        <textarea id="message-input" placeholder="è¾“å…¥æ¶ˆæ¯..." rows="1"></textarea>
                        <button id="send-btn"><i class="fas fa-paper-plane"></i></button>
                    </div>

                    <!-- åŠŸèƒ½æŒ‰é’®è¡Œ -->
                    <div class="input-feature-row-wrapper">
                        <div class="input-feature-row">
                            <button class="feature-btn" id="emoji-btn" title="å‘é€è¡¨æƒ…"><i class="fas fa-smile"></i></button>
                            <button class="feature-btn" id="favorite-emoji-btn" title="æ”¶è—çš„è¡¨æƒ…"><i class="fas fa-star"></i></button>
                            <button class="feature-btn" id="voice-btn" title="å‘é€è¯­éŸ³"><i class="fas fa-microphone"></i></button>
                            <button class="feature-btn" id="transfer-btn" title="è½¬è´¦"><i class="fas fa-exchange-alt"></i></button>
                            <button class="feature-btn" id="red-packet-btn" title="å‘çº¢åŒ…"><i class="fas fa-wallet"></i></button>
                            <button class="feature-btn" id="simulated-image-btn" title="å›¾æ–‡æ¶ˆæ¯"><i class="fas fa-image"></i></button>
                            <button class="feature-btn" id="image-vision-btn" title="å‘é€å›¾ç‰‡ (AIè¯†å›¾)"><i class="fas fa-camera"></i></button>
                            <button class="feature-btn" id="gift-btn" title="é€ç¤¼ç‰©"><i class="fas fa-gift"></i></button>
                            <button class="feature-btn" id="card-btn" title="å‘é€å¡ç‰‡"><i class="fas fa-share-square"></i></button>
                            <button class="feature-btn" id="edit-last-reply-btn" title="ç¼–è¾‘æœ€æ–°AIå›å¤"><i class="fas fa-pencil-alt"></i></button>
                            <button class="feature-btn" id="delete-last-turn-btn" title="åˆ é™¤æœ€æ–°ä¸€è½®å›å¤"><i class="fas fa-eraser"></i></button>
                        </div>
                    </div>
                    <!-- è¡¨æƒ…åŒ…é¢æ¿ (é»˜è®¤éšè—) -->
                    <div class="emoji-card" id="emoji-card">
                        <div class="emoji-grid" id="emoji-grid"></div>
                        <div class="emoji-nav">
                            <button id="emoji-prev-btn"><i class="fas fa-chevron-left"></i></button>
                            <span id="emoji-page-indicator"></span>
                            <button id="emoji-next-btn"><i class="fas fa-chevron-right"></i></button>
                        </div>
                    </div>
                    <!-- æ”¶è—è¡¨æƒ…åŒ…é¢æ¿ (é»˜è®¤éšè—) -->
                    <div class="emoji-card" id="favorite-emoji-card">
                        <div class="emoji-grid" id="favorite-emoji-grid"></div>
                        <div class="emoji-nav" style="display: none;">
                            <button id="favorite-emoji-prev-btn"><i class="fas fa-chevron-left"></i></button>
                            <span id="favorite-emoji-page-indicator"></span>
                            <button id="favorite-emoji-next-btn"><i class="fas fa-chevron-right"></i></button>
                        </div>
                    </div>
                </div>
            </div>

                <div id="chat-selection-overlay">
                    <span>è¯·å…ˆå®Œæˆæˆ–å–æ¶ˆè½¬å‘</span>
                </div>

                <!-- èŠå¤©é€‰æ‹©æ“ä½œæ  (æ–°) -->
                <div id="chat-selection-bar">
                    <span id="selection-info" class="selection-info">å·²é€‰æ‹© 0 æ¡</span>
                    <div class="selection-actions">
                        <button id="cancel-forward-btn" class="modal-btn btn-secondary" style="padding: 8px 15px;">å–æ¶ˆ</button>
                        <button id="delete-selected-messages-btn" class="modal-btn btn-danger" style="padding: 8px 15px;">åˆ é™¤</button>
                        <button id="confirm-forward-btn" class="modal-btn btn-primary" style="padding: 8px 15px;">è½¬å‘</button>
                    </div>
                </div>

            <!-- è‡ªå®šä¹‰æç¤ºè¯é¡µé¢ -->
            <div id="page-prompts" class="page">
                <div class="page-header">
                    <div id="prompts-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>è‡ªå®šä¹‰æç¤ºè¯</h1>
                    <div id="prompt-header-actions" style="display: flex; gap: 15px; justify-self: end; padding-right: 15px;">
                        <div id="import-prompts-btn" class="header-icon" title="å¯¼å…¥"><i class="fas fa-download"></i></div>
                        <div id="export-prompts-btn" class="header-icon" title="å¯¼å‡º"><i class="fas fa-upload"></i></div>
                        <div id="add-prompt-folder-btn" class="header-icon" title="æ–°å»ºæ–‡ä»¶å¤¹"><i class="fas fa-folder-plus"></i></div>
                    </div>
                </div>
                <div class="page-content" id="prompts-page-content">
                    <!-- æ–‡ä»¶å¤¹å’Œæç¤ºè¯å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <div class="page-footer" style="padding: 10px; text-align: center; border-top: 1px solid var(--border-color); background: rgba(255,255,255,0.5);">
                    <button id="add-new-prompt-btn" class="modal-btn btn-primary" style="width: 90%;"><i class="fas fa-plus-circle"></i> æ–°å»ºæç¤ºè¯</button>
                </div>
            </div>

            <!-- å‘ç°é¡µé¢ -->
            <div id="page-discover" class="page">
                <div class="page-header">
                    <h1>å‘ç°</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="nav-to-moments">
                            <i class="fas fa-camera-retro"></i>
                            <span>æœ‹å‹åœˆ</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="nav-to-pomodoro">
                            <i class="fas fa-clock"></i>
                            <span>ç•ªèŒ„é’Ÿ</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>

                        <div class="setting-item" id="setting-wish-pool">
                            <i class="fas fa-heart"></i>
                            <span>è§’è‰²è®¸æ„¿æ± </span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ä¸»é¢˜è®¾ç½®é¡µé¢ (æ–°) -->
            <div id="page-theme-settings" class="page">
                <div class="page-header">
                    <div id="theme-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>ä¸»é¢˜è®¾ç½®</h1>
                </div>
                <div class="page-content" id="theme-settings-content">
                    <!-- å¡ç‰‡å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>

            <!-- æ°”æ³¡è®¾ç½®é¡µé¢ (æ–°) -->
            <div id="page-bubble-settings" class="page">
                <div class="page-header">
                    <div id="bubble-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>æ°”æ³¡è®¾ç½®</h1>
                </div>
                <div class="page-content" id="bubble-settings-content">
                    <!-- å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>

            <!-- æœ‹å‹åœˆé¡µé¢ -->
            <div id="page-moments" class="page">
                <!-- æ–°å¢çš„åŒ…è£¹å±‚ -->
                <div id="moments-wrapper">
                    <div class="page-header">
                        <div id="moments-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                        <div id="moments-actions-group">
                             <div id="moments-refresh-btn" class="header-icon"><i class="fas fa-sync-alt"></i></div>
                             <div id="moments-new-post-btn" class="header-icon"><i class="fas fa-camera"></i></div>
                             <div id="moments-manage-btn" class="header-icon"><i class="fas fa-bars"></i></div>
                        </div>
                    </div>
                    <div class="page-content">
                        <div class="moments-header-container">
                            <img id="moments-bg" src="https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png" alt="æœ‹å‹åœˆèƒŒæ™¯">
                            <div class="moments-profile-info">
                                <span id="moments-my-name" class="name">ä½ çš„åå­—</span>
                                <img id="moments-my-avatar" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=" alt="ä½ çš„å¤´åƒ" class="avatar">
                            </div>
                        </div>
                        <ul id="moments-list">
                            <!-- æœ‹å‹åœˆåŠ¨æ€å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                        </ul>
                    </div>
                </div> <!-- æ–°å¢çš„åŒ…è£¹å±‚é—­åˆæ ‡ç­¾ -->
            </div>
            <!-- æ•™ç¨‹é¡µé¢ (æ–°) -->
            <div id="page-tutorial" class="page">
                <div class="page-header">
                    <div id="tutorial-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>æ•™ç¨‹</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="setting-announcement">
                            <i class="fas fa-bullhorn"></i>
                            <span>æ¸¸ç©æé†’å…¬å‘Š</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-api">
                            <i class="fas fa-key"></i>
                            <span>å¦‚ä½•é…ç½®API</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-character">
                            <i class="fas fa-user-plus"></i>
                            <span>å¦‚ä½•åˆ›å»ºæ–°è§’è‰²</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-group">
                            <i class="fas fa-users"></i>
                            <span>å¦‚ä½•åˆ›å»ºç¾¤èŠ</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-chatting">
                            <i class="fas fa-comment-alt"></i>
                            <span>å¦‚ä½•è¿›è¡ŒèŠå¤©</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-opening-scene">
                            <i class="fas fa-scroll"></i>
                            <span>å¼€åœºç™½æ˜¯ä»€ä¹ˆï¼Ÿ</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-prompts">
                            <i class="fas fa-magic"></i>
                            <span>æç¤ºè¯æ˜¯ä»€ä¹ˆï¼Ÿ</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                         <div class="setting-item" id="tutorial-import-export">
                            <i class="fas fa-exchange-alt"></i>
                            <span>å¦‚ä½•å¯¼å…¥å¯¼å‡º</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-emoji">
                            <i class="fas fa-smile-wink"></i>
                            <span>å¦‚ä½•æ–°å¢/åˆ é™¤è¡¨æƒ…åŒ…</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-persona">
                            <i class="fas fa-user-tag"></i>
                            <span>ç©å®¶äººè®¾åŠç»‘å®š</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-narrator">
                            <i class="fas fa-theater-masks"></i>
                            <span>æ—ç™½å¦‚ä½•ä½¿ç”¨</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-moments">
                            <i class="fas fa-camera-retro"></i>
                            <span>æœ‹å‹åœˆå¦‚ä½•ä½¿ç”¨</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-theme">
                            <i class="fas fa-palette"></i>
                            <span>å¦‚ä½•è®¾ç½®ä¸»é¢˜</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                    <div class="tutorial-watermark">
                        <span>æ­¤èŠå¤©å®¤ç”±33åˆ¶ä½œï¼Œxhs:@å›é£ã€‚</span><br>
                        <span style="font-size: 0.9em; opacity: 0.8;">åŠŸèƒ½åé¦ˆä¸æ–°åŠŸèƒ½éœ€æ±‚å¯è”ç³»æˆ‘å™¢âŒ¯>á´—oâŒ¯ .áŸ.áŸ</span>
                    </div>
                </div>
            </div>
            
            <!-- ç•ªèŒ„é’Ÿé¡µé¢ (æ–°) -->
            <div id="page-pomodoro" class="page">
                <div class="page-header">
                    <div id="pomodoro-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>ç•ªèŒ„é’Ÿ</h1>
                </div>
                <div class="page-content">
                    <div id="pomodoro-timer-display" class="pomodoro-timer-display">25:00</div>
                    <input type="text" id="pomodoro-goal-input" class="pomodoro-goal-input" placeholder="è¾“å…¥æœ¬æ¬¡ä¸“æ³¨çš„ç›®æ ‡...">
                    <div class="pomodoro-controls">
                        <button id="pomodoro-start-btn" class="pomodoro-btn start">å¼€å§‹ä¸“æ³¨</button>
                        <button id="pomodoro-stop-btn" class="pomodoro-btn stop" style="display: none;">åœæ­¢</button>
                    </div>
                </div>
            </div>

            <!-- é€ç¤¼ç‰©é¡µé¢ (æ–°) -->
            <div id="page-gifts" class="page">
                <div class="page-header">
                    <div id="gifts-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>é€ç¤¼ç‰©</h1>
                </div>
                <div class="page-content" id="gifts-page-content">
                    <div class="gifts-search-container">
                        <!-- ç¬¬ä¸€è¡Œï¼šæœç´¢æ¡†å’Œåˆ·æ–° -->
                        <div class="search-row">
                             <div class="search-bar-wrapper">
                                <i class="fas fa-search"></i>
                                <input type="text" id="gift-search-input" placeholder="æœç´¢ç¤¼ç‰©é€ç»™TA...">
                                <button id="gift-search-refresh-btn" style="display: none;"><i class="fas fa-sync-alt"></i></button>
                            </div>
                        </div>
                        <!-- ç¬¬äºŒè¡Œï¼šåŠŸèƒ½æŒ‰é’® -->
                        <div class="action-row">
                             <button id="gift-api-config-btn" class="gift-header-btn action-btn"><i class="fas fa-cog" style="margin-right: 5px;"></i> APIé…ç½®</button>
                             <button id="custom-gift-btn" class="gift-header-btn action-btn"><i class="fas fa-magic" style="margin-right: 5px;"></i> è‡ªå®šä¹‰</button>
                             <button id="gift-bind-prompt-btn" class="gift-header-btn action-btn"><i class="fas fa-link" style="margin-right: 5px;"></i> ç»‘å®š</button>
                             <button id="gift-help-btn" class="gift-header-btn action-btn"><i class="fas fa-question-circle" style="margin-right: 5px;"></i> å¸®åŠ©</button>
                             <button id="gift-cancel-search-btn" class="gift-header-btn action-btn" style="display:none;"><i class="fas fa-times" style="margin-right: 5px;"></i> å–æ¶ˆæœç´¢</button>
                        </div>
                    </div>
                    <h3 class="gifts-section-title" id="gifts-section-title">å¤§å®¶éƒ½åœ¨é€</h3>
                    <div class="gifts-grid" id="gifts-grid">
                        <!-- ç¤¼ç‰©å¡ç‰‡å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                        <div class="gift-loader" style="display: none;">
                            <div class="loader-spinner"></div>
                            <p>æ­£åœ¨åŠªåŠ›å¯»æ‰¾ç¤¼ç‰©...</p>
                        </div>
                    </div>
                </div>
            </div>

        </main>

            <!-- è½¬å‘å†å²é¡µé¢ (æ–°) -->
            <div id="page-forwarded-history" class="page">
                <div class="page-header">
                    <div id="forwarded-history-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1 id="forwarded-history-title">èŠå¤©è®°å½•</h1>
                </div>
                <div class="page-content" id="forwarded-history-content">
                    <!-- è½¬å‘çš„æ¶ˆæ¯å°†åœ¨è¿™é‡Œæ¸²æŸ“ -->
                </div>
            </div>

        <!-- åº•éƒ¨å¯¼èˆª -->
        <nav id="bottom-nav">
            <div class="nav-item active" data-page="messages">
                <i class="fas fa-comment-dots"></i>
                <span>æ¶ˆæ¯</span>
            </div>
            <div class="nav-item" data-page="contacts">
                <i class="fas fa-address-book"></i>
                <span>é€šè®¯å½•</span>
            </div>
            <div class="nav-item" data-page="discover">
                <i class="fas fa-compass"></i>
                <span>å‘ç°</span>
            </div>
            <div class="nav-item" data-page="settings">
                <i class="fas fa-cog"></i>
                <span>è®¾ç½®</span>
            </div>
        </nav>
    </div>


    <!-- æ¨¡æ€æ¡† -->
    <input type="file" id="font-file-input" accept=".ttf,.otf,.woff,.woff2" style="display: none;">
    <input type="file" id="import-data-input" accept=".json" style="display: none;">
    <input type="file" id="import-presets-input" accept=".json" style="display: none;">
    <div id="modal-overlay">
        <div id="modal-content-wrapper" class="modal-content">
            <!-- æ¨¡æ€æ¡†å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>
    
    <!-- ç‚¹å‡»ç‰¹æ•ˆå±‚ -->
    <div id="click-effect-layer"></div>

    <!-- ç•ªèŒ„é’Ÿæ‚¬æµ®çƒ -->
    <div id="pomodoro-float-ball" class="hidden">
        <div class="progress-ring"></div>
        <span class="time-left">25:00</span>
    </div>
    
    <!-- ä¸ªäººä¿¡æ¯ä¾§è¾¹æ  -->
    <div id="sidebar-overlay">
        <div id="sidebar-content">
            <!-- ä¾§è¾¹æ å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <!-- åº•éƒ¨é€‰æ‹©å™¨ -->
    <div id="bottom-sheet-overlay">
        <div id="bottom-sheet-content-wrapper" class="bottom-sheet-content">
             <!-- å†…å®¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <input type="file" id="moments-bg-input" accept="image/*" style="display: none;">
    <input type="file" id="import-prompts-input" accept=".json" style="display: none;">

<script>
    
    (function() {
        'use strict';

        
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);
        
        const appContainer = $('#app-container');
        const mainContent = $('#main-content');
        const bottomNav = $('#bottom-nav');
        const modalOverlay = $('#modal-overlay');
        const modalContentWrapper = $('#modal-content-wrapper');
        const clickEffectLayer = $('#click-effect-layer');
        
        
        const pages = {
            messages: $('#page-messages'),
            contacts: $('#page-contacts'),
            discover: $('#page-discover'),
            moments: $('#page-moments'),
            tutorial: $('#page-tutorial'),
            pomodoro: $('#page-pomodoro'),
            gifts: $('#page-gifts'),
            'chat-settings': $('#page-chat-settings'),
            settings: $('#page-settings'),
            'api-settings': $('#page-api-settings'),
            'theme-settings': $('#page-theme-settings'),
            'bubble-settings': $('#page-bubble-settings'),
            chat: $('#page-chat'),
            prompts: $('#page-prompts'),
            'forwarded-history': $('#page-forwarded-history'),
        };

        
        const chatTitle = $('#chat-title');
        const chatTypingIndicator = $('#chat-typing-indicator');
        const chatArea = $('#chat-area');
        const aiRequestBtn = $('#ai-request-btn');
        const messageInput = $('#message-input');
        const sendBtn = $('#send-btn');
        const chatBackBtn = $('#chat-back-btn');
        
        const emojiBtn = $('#emoji-btn');
        const voiceBtn = $('#voice-btn');
        const emojiCard = $('#emoji-card');
        const emojiGrid = $('#emoji-grid');
        const quotePreviewArea = $('#quote-preview-area');
        const quotePreviewContent = $('#quote-preview-content');
        const cancelQuoteBtn = $('#cancel-quote-btn');
        const favoriteEmojiBtn = $('#favorite-emoji-btn');
        const favoriteEmojiCard = $('#favorite-emoji-card');
        const favoriteEmojiGrid = $('#favorite-emoji-grid');
        const chatInputArea = $('#chat-input-area');
        
        const BUILTIN_AI_EMOJIS = {
            'iazCCF': 'è°åœ¨å–Šæœ¬å¤§ç‹','xPHzNC': 'å°Šå˜Ÿå‡å˜Ÿ','7kVeZJ': 'æˆ‘æ“','pCQgk2': 'è€å­ç”Ÿæ°”äº†','IUg8vO': 'åƒç“œç¾¤ä¼—','Il6dL9': 'å¯¹ä¸èµ·','vjEl6R': 'èŠ±èŠ±é€ä½ ','werDxS': 'æŠ±æŠ±æˆ‘','Ms5AEa': 'å§”å±ˆ(å¯çˆ±)','QX7VnJ': 'å®‰æ…°','nHcfqI': 'å–èŒ(å¯çˆ±)','oztxES': 'æ¯”å¿ƒ(å¯çˆ±)','GOl2dp': 'è¯·å’Œæˆ‘çº¦ä¼š','BuD0Gy': 'ä½ æ˜¯ç‹—','jcisbx': 'æˆ‘åªæ˜¯ä¸€åªç‹—','Zo82H7': 'æ¯å¤©éƒ½æƒ³ä½ (å–èŒ)','CcIWXl': 'å‡è£…æ— è¾œ(å¯çˆ±)','zSBHMm': 'è‚¯å®š(å¯çˆ±)','CIWud3': 'è°æ„¿æ„æ”¶ç•™æˆ‘(å¯çˆ±)','HOAcPN': 'è°„åªš(å¯çˆ±)','GP1VJ3': 'å®¶é‡Œäº¤ç»™æˆ‘å§(å¯çˆ±)','BISbnP': 'æ³ªäº†','asnj6B': 'è¯•æ¢(å¯çˆ±)','htNZls': 'æ‡‚å¾—éƒ½æ‡‚','2q5VbM': 'å°±ä½ å°å­æ˜¯å§(åš£å¼ )','sd0yQX': 'æ”¾å¿ƒäº¤ç»™æˆ‘ï¼Œæˆ‘ä¼šæç ¸çš„(æ²™é›•)','E0PrxD': 'çš‡å¸é©¾åˆ°(æ²™é›•)','7vgm7D': 'çš‡å¸é©¾å´©(æ²™é›•)','lPgzpQ': 'è¯›ä½ ä¹æ—(é¾™å›¾)','j2d9di': 'éª‚æœ•ï¼Œæ»¡é—¨æŠ„æ–©ï¼','hKyKwP': 'å¥´æ‰è°¢ä¸»éš†æ©(é¾™å›¾)','IkZP8N': 'æˆ‘é¥¿äº†','osIpSG': 'æ€ä¹ˆä¸å›æˆ‘æ¶ˆæ¯','IgfF9w': 'å¿«ç†æˆ‘(å§”å±ˆå¯çˆ±)','wb63Ag': 'ç­‰ä¸‹è®²ä½ ä½ åˆä¸é«˜å…´(åæ§½)','8CCMsJ': 'æˆ‘é ï¼Œä½ çˆ±ä¸çˆ±æˆ‘','34LcOG': 'æŒ‡æŒ‡ç‚¹ç‚¹','hDpVH8': 'æˆ‘å—ï¼Ÿ(æ‡µé€¼)','1RcY8W': 'æ³¨æ„ä½ çš„æ€åº¦','6cIfGp': 'æ€¥å¾—è¹¬è…¿','m1zzxd': 'ä¸æƒ³æ´»äº†(æ²™é›•)','YqlPWK': 'ä½ å’Œæˆ‘è¿™ä¸ªç¥ç»ç—…è®¡è¾ƒä»€ä¹ˆ','LokqQT': 'ä½ å¾ˆç‰›å—ï¼Ÿ','qHSXVP': 'å¦ˆçš„ï¼Œè¢«çœ‹æ‰äº†','CUOA6Y': 'ä»¤äººç«å¤§','3jc0XI': 'ä¸æƒ³æ´»äº†(å¯çˆ±)','qZxeWV': 'ä½ å¿«å“„æˆ‘(å¯çˆ±)','3iYdgX': 'æˆ‘è¢«å“„å¥½äº†(å¯çˆ±)','ZNzgpY': 'ä½ å°±æ˜¯å¾ˆå¥½å¾ˆå¥½(å¯çˆ±)','PCLA8G': 'æˆ‘å¥½æƒ³ä½ å–(å§”å±ˆå¯çˆ±)','i0UYTS': 'ä½ ç§ä¸èµ·æˆ‘(å§”å±ˆ)','VWwt5c': 'æˆ‘æƒ³è¦è¿™ä¸ª(å¯çˆ±)','SIWqFT': 'å¾—æ„','ff8JWS': 'æˆ‘èäº†','oiMaM6': 'ä½ ç²¾ç¥æ­£å¸¸å—','LIQKcy': 'æƒ³æ­»','EhcgEa': 'è¢«çœ‹ç©¿äº†','vnDXiy': 'æ€ä¹ˆä½ è¦æ‰“æ­»æˆ‘å—(çŠ¯è´±)','71bINa': 'ä½ å°‘çœ‹æ‰æˆ‘(è‡ªå˜²ç†Š)','gcubY9': 'tui(åå£æ°´)','r1lada': 'ä½ å¤ªç²˜äººäº†_æŠŠä½ æ‹¿å»ç²˜è€é¼ ','y6ldmK': 'å¾ˆä¸é«˜å…´ä¸ºä½ æœåŠ¡','yrVneI': 'çœŸè´±å•Š','dP6HDY': 'ä½ è‡ªé¦–å§','jjyR6G': 'ä½ æ˜¯çŒª','WfSWCe': 'ä½ ä»–å¦ˆè°å•Š','B0S4LA': 'è’™åœˆ'
        };
        const BUILTIN_PLAYER_EMOJIS = {
            'iazCCF': 'è°åœ¨å–Šæœ¬å¤§ç‹','xPHzNC': 'å°Šå˜Ÿå‡å˜Ÿ','7kVeZJ': 'æˆ‘æ“','pCQgk2': 'è€å­ç”Ÿæ°”äº†','IUg8vO': 'åƒç“œç¾¤ä¼—','Il6dL9': 'å¯¹ä¸èµ·','vjEl6R': 'èŠ±èŠ±é€ä½ ','werDxS': 'æŠ±æŠ±æˆ‘','Ms5AEa': 'å§”å±ˆ(å¯çˆ±)','QX7VnJ': 'å®‰æ…°','nHcfqI': 'å–èŒ(å¯çˆ±)','oztxES': 'æ¯”å¿ƒ(å¯çˆ±)','GOl2dp': 'è¯·å’Œæˆ‘çº¦ä¼š','BuD0Gy': 'ä½ æ˜¯ç‹—','jcisbx': 'æˆ‘åªæ˜¯ä¸€åªç‹—','Zo82H7': 'æ¯å¤©éƒ½æƒ³ä½ (å–èŒ)','CcIWXl': 'å‡è£…æ— è¾œ(å¯çˆ±)','zSBHMm': 'è‚¯å®š(å¯çˆ±)','CIWud3': 'è°æ„¿æ„æ”¶ç•™æˆ‘(å¯çˆ±)','HOAcPN': 'è°„åªš(å¯çˆ±)','GP1VJ3': 'å®¶é‡Œäº¤ç»™æˆ‘å§(å¯çˆ±)','BISbnP': 'æ³ªäº†','asnj6B': 'è¯•æ¢(å¯çˆ±)','htNZls': 'æ‡‚å¾—éƒ½æ‡‚','2q5VbM': 'å°±ä½ å°å­æ˜¯å§(åš£å¼ )','sd0yQX': 'æ”¾å¿ƒäº¤ç»™æˆ‘ï¼Œæˆ‘ä¼šæç ¸çš„(æ²™é›•)','E0PrxD': 'çš‡å¸é©¾åˆ°(æ²™é›•)','7vgm7D': 'çš‡å¸é©¾å´©(æ²™é›•)','lPgzpQ': 'è¯›ä½ ä¹æ—(é¾™å›¾)','j2d9di': 'éª‚æœ•ï¼Œæ»¡é—¨æŠ„æ–©ï¼','hKyKwP': 'å¥´æ‰è°¢ä¸»éš†æ©(é¾™å›¾)','IkZP8N': 'æˆ‘æœ‰ç‚¹é¥¿äº†','osIpSG': 'æ€ä¹ˆä¸å›æˆ‘æ¶ˆæ¯','Lt1f9K': 'ç‰¹åˆ«ç‰¹åˆ«é¥¿','IgfF9w': 'å¿«ç†æˆ‘(å§”å±ˆ)','wb63Ag': 'ç­‰ä¸‹è®²ä½ ä½ åˆä¸é«˜å…´(åæ§½)','s9xWmu': 'ä½ æ˜¯ä¸ªåä¸œè¥¿','8CCMsJ': 'æˆ‘é ï¼Œä½ çˆ±ä¸çˆ±æˆ‘','34LcOG': 'æŒ‡æŒ‡ç‚¹ç‚¹','hDpVH8': 'æˆ‘å—ï¼Ÿ(æ‡µé€¼)','1RcY8W': 'æ³¨æ„ä½ çš„æ€åº¦','6cIfGp': 'æ€¥å¾—è¹¬è…¿','kRdQhe': 'å·å¬','3jc0XI': 'ä¸æƒ³æ´»äº†(å¯çˆ±)','m1zzxd': 'ä¸æƒ³æ´»äº†(æ²™é›•)','YqlPWK': 'ä½ å’Œæˆ‘è¿™ä¸ªç¥ç»ç—…è®¡è¾ƒä»€ä¹ˆ','LokqQT': 'ä½ å¾ˆç‰›å—ï¼Ÿ','4ZkXRx': 'ä»–ä»¬éƒ½æ¬ºè´Ÿæˆ‘','qZxeWV': 'ä½ å¿«å“„æˆ‘','3iYdgX': 'æˆ‘è¢«å“„å¥½äº†(å¯çˆ±)','qHSXVP': 'å¦ˆçš„ï¼Œè¢«çœ‹æ‰äº†','278MJW': 'ä¸åŠªåŠ›å°±ä¼šæˆä¸ºå¥³äººçš„ç©ç‰©','mzqDku': 'æˆ‘å–œæ¬¢ä½ (å®³ç¾)','dnzCAP': 'ä»€ä¹ˆéƒ½æƒ³å’Œä½ è¯´','ZNzgpY': 'ä½ å°±æ˜¯å¾ˆå¥½å¾ˆå¥½(å¯çˆ±)','PCLA8G': 'æˆ‘å¥½æƒ³ä½ å–(å§”å±ˆ)','sf7Egt': 'æˆ‘å»æ´—æ¾¡å•¦(å¯çˆ±)','i0UYTS': 'ä½ ç§ä¸èµ·æˆ‘(å§”å±ˆ)','VWwt5c': 'æˆ‘æƒ³è¦è¿™ä¸ª','hMTJRH': 'å’Œä½ è´´è´´','CUOA6Y': 'ä»¤äººç«å¤§','Y06FYQ': 'æˆ‘æ˜¯å°å­©ï¼Œè®©æˆ‘(å¯çˆ±)','lFpXLU': 'å†å«å‰ªäº†ä½ çš„å°é¸¡é¸¡','RaogpF': 'æ²¡åŠæ³•äººå®¶å°±æ˜¯å¥½è‰²å˜›','7a48eQ': 'ä½ æ€ä¹ˆé¸¡8å°å°çš„ï¼Œè¯´è¯åŠåŠçš„','N3ZzUs': 'æ‹¿æ¥å§ä½ ','oGFqYZ': 'å‡ºæ¥äº²å˜´','Z3glHK': 'åœæ­¢æ€è€ƒ','9RWtTB': 'ä½ äººçœŸå¥½ï¼Œéƒ½æƒ³å’Œä½ è°ˆæ‹çˆ±äº†','KNRPfQ': 'æ²¡äººçˆ±æˆ‘(æ°ç‘çŒ«è¡¨æƒ…)','bpyimG': 'èµ·äº†æ€å¿ƒ','DOwyrR': 'ç»™ä½ ç‚¹äº†(èµåŒ,æŠ½è±¡)','fd1o0q': 'æˆ‘æ˜¯å›½å®¶ä¸€çº§ä¿æŠ¤åºŸç‰©(çŒ«å’ªè‘›ä¼˜ç˜«)','0liCnk': 'ä¸­(è‚¯å®šçš„æ„æ€)','wTC4Ha': 'å®ŒåŠ›(å®Œäº†)','n0Ll5b': 'æ— åŠ›','SIWqFT': 'å¾—æ„','2up6Um': 'å˜å˜å¤§ç¬‘','tLsCTf': 'ä¸è®¸ç¬‘äº†','ff8JWS': 'æˆ‘èäº†','oiMaM6': 'ä½ ç²¾ç¥æ­£å¸¸å—','LIQKcy': 'æƒ³æ­»','EhcgEa': 'è¢«çœ‹ç©¿äº†','vnDXiy': 'æ€ä¹ˆä½ è¦æ‰“æ­»æˆ‘å—(çŠ¯è´±)','71bINa': 'ä½ å°‘çœ‹æ‰æˆ‘(è‡ªå˜²ç†Š)','eDzCRs': 'ç–‘æƒ‘','gcubY9': 'tui(åå£æ°´)','r1lada': 'ä½ å¤ªç²˜äººäº†_æŠŠä½ æ‹¿å»ç²˜è€é¼ ','y6ldmK': 'å¾ˆä¸é«˜å…´ä¸ºä½ æœåŠ¡','yrVneI': 'çœŸè´±å•Š','dP6HDY': 'ä½ è‡ªé¦–å§','OFcKsy': 'å‹¾å¼•æˆ‘æ˜¯å§','jjyR6G': 'ä½ æ˜¯çŒª','WfSWCe': 'ä½ ä»–å¦ˆè°å•Š','ZbqhUq': 'å·²è¯»ä¸å›','B0S4LA': 'è’™åœˆ','3sp60p': 'ä¸åšè¯„ä»·(é¾™å›¾)','VIbUBK': 'ä½ æ˜¯å°‘çˆ·å—','RjmyAc': 'ä¸‹çº¿äº†å…„å¼ŸèŒ(ä»¬)','y2w7BR': 'ä¸€è¾¹å»(é¾™å›¾)','fyYVhV': 'ç³Ÿç³•çš„è¯æ— éœ€å†è¯´(æŠ½è±¡)','PT4fq1': 'åœ¨å¹²å˜›_å‘¼å¸ä¹Ÿè¦å’Œæˆ‘è¯´ä¸€å£°å•Š','wBBj7q': 'è€å­æƒ¹ä½ æ²¡','3Yb2hM': 'èµ„æœ¬ä½ èµ¢äº†','9K6IPq': 'è„‘å­æœ‰é—®é¢˜','jHsXmD': 'æˆ‘ä»¬ä¸è¦å­¦ä»–','khoGur': 'åˆšç¡é†’(è‡ªå˜²ç†Š)','0svPHM': 'æƒ³å“­(è‡ªå˜²ç†Š)','39cQOS': 'å˜»å˜»(è‡ªå˜²ç†Š)','4wZWjY': 'å°´å°¬ä¸€ç¬‘(é»„è±†)','YaiPfJ': 'æˆ‘è¶…_ä»€ä¹ˆå¯„å§','mxDIwM': 'æ¬ºè´Ÿæ²¡åŠ›æ°”çš„æˆ‘ä½ å¼€å¿ƒå—','HIRelu': 'å¤šæ‰¾æ‰¾ä½ è‡ªå·±çš„åŸå› ','RNgGNY': 'ä»¥åä¸ä¼šå’Œä½ åˆ†äº«äº†(å§”å±ˆ)','GWn8O2': 'å˜¬å˜¬å˜¬','SwNPaw': 'ä½ ä»¬å¥½ä¼šè£…é€¼å•Š','tDB1Sp': 'å¤å©šå¥½å—ï¼Œå­©å­æ€»å“­','mWU2m4': 'ä½ æ´»è¿™ä¹ˆä¹…ï¼Œå’Œæˆ‘ç¡ä¸¤å¤©æ€ä¹ˆäº†','YCRn9a': 'æˆ‘åï¼Œå¥¹å¥½ï¼Œè¡Œäº†å§','t7vGt6': 'å½“æˆ‘æ„è¯†åˆ°ç”Ÿæ´»çš„ç¼©å†™æ˜¯SMï¼Œæˆ‘çš„ç—›è‹¦å°±å…¨è¯´å¾—æ¸…äº†','5AaDlW': 'æœ¬æ¥æŒºæƒ³ä½ çš„_åæ¥ç©æ‰‹æœºå¿˜äº†','a2gifR': 'å·å·è°ˆæ‹çˆ±æ²¡äº‹_åˆ«å·å·å‘è´¢å¥½å—','BI9YDr': 'è’å”','ScbsVz': 'æˆ‘è¦æŠ¥è­¦','yVU6HV': 'æœ‰è¶£ï¼Œè‰äº†','WRy68R': 'ä½å£°äº›_éš¾é“å…‰å½©å—','vHBtBv': 'åä¸ç¡(æŠ½è±¡è¡¨æƒ…)','IvfqD7': 'è£…å¯æ€œ(æŠ½è±¡)','E7e2MS': 'å¤Ÿäº†(æŠ½è±¡)','OWcn1K': 'å‡è£…æ‡‚äº†','pk06Iq': 'ä½ æ˜¯åç‹—(å¯çˆ±)'
        };
        
        const appState = {
            currentPage: 'messages',
            currentChatId: null,
            currentCircleId: null, 
            momentsLastRefresh: 0, 
            theme: 'neumorphic',
            contactsSortOrder: 'asc',
            groupsSortOrder: 'asc',
            quotingMessage: null,
            longPressTimer: null,
            friendSelectionMode: false,
            groupSelectionMode: false,
            selectionMode: { 
                active: false,
                messageIds: [],
            },
            cardCoverLibrary: [
                'https://z.wiki/u/fHMKzJ',
                'https://z.wiki/u/hmSAIR',
                'https://z.wiki/u/YWUcea',
                'https://z.wiki/u/dDuLcP',
                'https://z.wiki/u/JQtgF6',
                'https://z.wiki/u/bVpr6w',
                'https://z.wiki/u/dVvZ7t'
            ],
            emojiCurrentPage: 0,
            emojisPerPage: 8,
            favoriteEmojis: [],
            favoriteEmojiCurrentPage: 0,
            aiEmojiMap: {}, 
            playerEmojiMap: {}, 
            customEmojis: {}, 
            currentChat: {
                allMessages: [],
                renderedCount: 0,
                lastRefreshTimestamp: 0, 
            },
            messagesPerLoad: 20,
            isSummarizing: {},
            isHistoryLoading: false,
            pomodoro: {
                isActive: false,
                goal: '',
                endTime: null,
                timerId: null,
                totalSeconds: 1500, 
            },
        };
        
        const DBHelper = {
            DB_NAME: 'AIChatRoomDB',
            DB_VERSION: 1,
            db: null,

            async init() {
                
                this.DB_VERSION = 20;

                return new Promise((resolve, reject) => {
                    if (this.db) {
                        return resolve(this.db);
                    }
                    const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                    request.onerror = (event) => {
                        console.error("æ•°æ®åº“æ‰“å¼€å¤±è´¥", event);
                        reject("æ•°æ®åº“æ‰“å¼€å¤±è´¥");
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log("æ•°æ®åº“æ‰“å¼€æˆåŠŸ");
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        console.log("æ•°æ®åº“å‡çº§ä¸­... from version", event.oldVersion, "to", event.newVersion);
                        const db = event.target.result;
                        const transaction = event.target.transaction;
                        
                        if (event.oldVersion < 15) {
                            if (!db.objectStoreNames.contains('profile')) {
                                db.createObjectStore('profile', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('contacts')) {
                                const store = db.createObjectStore('contacts', { keyPath: 'id' });
                                store.createIndex('name', 'name', { unique: true });
                                store.createIndex('createdAt', 'createdAt', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('groups')) {
                                 const store = db.createObjectStore('groups', { keyPath: 'id' });
                                 store.createIndex('createdAt', 'createdAt', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('chats')) {
                                db.createObjectStore('chats', { keyPath: 'chatId' });
                            }
                            if (!db.objectStoreNames.contains('apiConfig')) {
                                db.createObjectStore('apiConfig', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('openingScenes')) {
                                const store = db.createObjectStore('openingScenes', { keyPath: 'id' });
                                store.createIndex('groupId', 'groupId', { unique: false });
                                store.createIndex('contactId', 'contactId', { unique: false }); 
                            }
                            if (!db.objectStoreNames.contains('prompts')) {
                                 const store = db.createObjectStore('prompts', { keyPath: 'id' });
                                 store.createIndex('name', 'name', { unique: false });
                                 store.createIndex('folderId', 'folderId', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('promptFolders')) {
                                 const store = db.createObjectStore('promptFolders', { keyPath: 'id' });
                                 store.createIndex('name', 'name', { unique: true });
                            }
                            if (!db.objectStoreNames.contains('circles')) {
                                 const store = db.createObjectStore('circles', { keyPath: 'id' });
                                 store.createIndex('name', 'name', { unique: true });
                            }
                            if (!db.objectStoreNames.contains('moments')) {
                                 const store = db.createObjectStore('moments', { keyPath: 'id' });
                                 store.createIndex('circleId', 'circleId', { unique: false });
                                 store.createIndex('timestamp', 'timestamp', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('friendFolders')) {
                                const store = db.createObjectStore('friendFolders', { keyPath: 'id' });
                                store.createIndex('name', 'name', { unique: true });
                                store.createIndex('createdAt', 'createdAt', { unique: false });
                            }

                            if (db.objectStoreNames.contains('contacts') && !transaction.objectStore('contacts').indexNames.contains('folderId')) {
                                transaction.objectStore('contacts').createIndex('folderId', 'folderId', { unique: false });
                            }
                            if (db.objectStoreNames.contains('openingScenes') && !transaction.objectStore('openingScenes').indexNames.contains('contactId')) {
                                transaction.objectStore('openingScenes').createIndex('contactId', 'contactId', { unique: false });
                            }
                            
                            
                            console.log("å¼€å§‹è¿›è¡Œç‰ˆæœ¬15çš„æ•°æ®è¿ç§»ï¼šåˆ›å»º chatMetadata...");
                            const chatMetadataStore = db.createObjectStore('chatMetadata', { keyPath: 'chatId' });
                            chatMetadataStore.createIndex('lastMessageTimestamp', 'lastMessageTimestamp', { unique: false });
                            
                            chatMetadataStore.createIndex('isPinned', 'isPinned', { unique: false });

                            const chatsStore = transaction.objectStore('chats');
                            chatsStore.openCursor().onsuccess = (e) => {
                                const cursor = e.target.result;
                                if (cursor) {
                                    const chat = cursor.value;
                                    if (chat.history && chat.history.length > 0) {
                                        const displayableHistory = chat.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                        if (displayableHistory.length > 0) {
                                            const lastMessage = displayableHistory[displayableHistory.length - 1];
                                            const unreadCount = chat.history.filter(m => m.isUnread).length;

                                            const metadata = {
                                                chatId: chat.chatId,
                                                lastMessage: lastMessage,
                                                unreadCount: unreadCount,
                                                lastMessageTimestamp: lastMessage.timestamp
                                            };
                                            transaction.objectStore('chatMetadata').put(metadata);
                                        }
                                    }
                                    cursor.continue();
                                } else {
                                    console.log("chatMetadata è¿ç§»å®Œæˆã€‚");
                                }
                            };
                        }
                        
                        
                        if (event.oldVersion < 16) {
                            console.log("æ•°æ®åº“å‡çº§è‡³ç‰ˆæœ¬ 16ï¼šåˆ›å»º messages è¡¨...");

                            const messagesStore = db.createObjectStore('messages', { keyPath: 'messageId' });
                            messagesStore.createIndex('by_chat_and_time', ['chatId', 'timestamp'], { unique: false });
                            messagesStore.createIndex('by_chat_and_sender', ['chatId', 'senderId'], { unique: false });

                            
                            if (db.objectStoreNames.contains('chats')) {
                                const chatsStore = transaction.objectStore('chats');
                                chatsStore.openCursor().onsuccess = (e) => {
                                    const cursor = e.target.result;
                                    if (cursor) {
                                        const chat = cursor.value;
                                        if (chat.history && chat.history.length > 0) {
                                            
                                            
                                            let timestampOffset = 0; 
                                            for (const message of chat.history) {
                                                
                                                message.chatId = chat.chatId;

                                                
                                                
                                                message.timestamp = message.timestamp + (timestampOffset++);

                                                
                                                transaction.objectStore('messages').put(message);
                                            }
                                            
                                        }
                                        cursor.continue();
                                    } else {
                                        console.log("èŠå¤©è®°å½•è¿ç§»åˆ° messages è¡¨å®Œæˆã€‚");
                                    }
                                };
                            }
                        }

                        
                        if (event.oldVersion < 17) {
                            console.log("æ•°æ®åº“å‡çº§è‡³ç‰ˆæœ¬ 17ï¼šåˆ›å»º giftApiConfig è¡¨...");
                            if (!db.objectStoreNames.contains('giftApiConfig')) {
                                db.createObjectStore('giftApiConfig', { keyPath: 'id' });
                            }
                        }

                        
                        if (event.oldVersion < 20) {
                            console.log("æ•°æ®åº“å‡çº§è‡³ç‰ˆæœ¬ 20ï¼šä¸º chatMetadata æ·»åŠ  lastRawAiResponse...");
                            
                            
                        }
                        
                        console.log("æ•°æ®åº“å‡çº§å®Œæˆ");
                    };
                });
            },


            async get(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`Get error from ${storeName}: ${e.target.error}`);
                });
            },

            async getAll(storeName, indexName, sortOrder = 'next') {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const index = indexName ? store.index(indexName) : store;
                    const request = index.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`GetAll error from ${storeName}: ${e.target.error}`);
                });
            },

            async put(storeName, item) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(item);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`Put error in ${storeName}: ${e.target.error}`);
                });
            },

            async delete(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = (e) => reject(`Delete error from ${storeName}: ${e.target.error}`);
                });
            },

            async getMessages(chatId, limit, beforeTimestamp = Date.now()) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_time');
                    const range = IDBKeyRange.bound([chatId, 0], [chatId, beforeTimestamp], false, true);
                    const messages = [];
                    
                    index.openCursor(range, 'prev').onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor && messages.length < limit) {
                            messages.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(messages.reverse()); 
                        }
                    };
                    transaction.onerror = (e) => reject(`getMessages error: ${e.target.error}`);
                });
            },
            
            async getMessagesBySender(chatId, senderId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_sender');
                    const range = IDBKeyRange.only([chatId, senderId]);
                    const request = index.getAll(range);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`getMessagesBySender error: ${e.target.error}`);
                });
            },
            
            async getChatMessagesCount(chatId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_time');
                    const range = IDBKeyRange.bound([chatId, 0], [chatId, Date.now()]);
                    const request = index.count(range);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`getChatMessagesCount error: ${e.target.error}`);
                });
            },

            async deleteMessagesForChat(chatId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readwrite');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_time');
                    const range = IDBKeyRange.bound([chatId, 0], [chatId, Date.now()]);

                    const request = index.openCursor(range);
                    request.onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor) {
                            cursor.delete();
                            cursor.continue();
                        } else {
                            
                        }
                    };
                    transaction.oncomplete = () => {
                        console.log(`All messages for chat ${chatId} deleted.`);
                        resolve();
                    };
                    transaction.onerror = (e) => {
                        console.error(`Error deleting messages for chat ${chatId}:`, e.target.error);
                        reject(e.target.error);
                    };
                });
            },

            async batchPut(storeName, items) {
                if (!items || items.length === 0) {
                    return Promise.resolve();
                }
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = (e) => reject(`BatchPut error in ${storeName}: ${e.target.error}`);
                    
                    items.forEach(item => {
                        store.put(item);
                    });
                });
            },

            async findLastMessagesBySenderAndTypes(chatId, senderId, typesToFind) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_sender');
                    const range = IDBKeyRange.only([chatId, senderId]);
            
                    const results = {};
                    let foundCount = 0;
                    const typesSet = new Set(typesToFind);
            
                    index.openCursor(range, 'prev').onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor) {
                            const message = cursor.value;
                            const msgType = message.segmentType;
            
                            if (typesSet.has(msgType) && !results[msgType]) {
                                results[msgType] = message;
                                foundCount++;
                            }
            
                            
                            if (foundCount === typesToFind.length) {
                                resolve(results);
                            } else {
                                cursor.continue();
                            }
                        } else {
                            
                            resolve(results);
                        }
                    };
                    transaction.onerror = (e) => reject(`findLastMessagesBySenderAndTypes error: ${e.target.error}`);
                });
            },
        };

        
        const Utils = {
            generateId(prefix) {
                const uniquePart = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                return `${prefix}${uniquePart}`;
            },
            
            getRandomColor() {
                const colors = ['#F4E8DD', '#EDD4D8', '#CCD4CC', '#B5BFCF', '#E8A0BF'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            
            createAvatarDataUrl(color) {
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50"><rect width="50" height="50" fill="${color}"/></svg>`;
                return `data:image/svg+xml;base64,${btoa(svg)}`;
            },

            formatTimestampSmartly(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();

                const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const yesterdayStart = new Date(todayStart);
                yesterdayStart.setDate(yesterdayStart.getDate() - 1);
                
                const formatTime = (d) => d.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                
                if (date >= todayStart) {
                    
                    return formatTime(date);
                } else if (date >= yesterdayStart) {
                    
                    return `æ˜¨å¤© ${formatTime(date)}`;
                } else {
                    
                    return date.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }) + ' ' + formatTime(date);
                }
            },


            formatTimestampForBubble(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();

                const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const yesterdayStart = new Date(todayStart);
                yesterdayStart.setDate(yesterdayStart.getDate() - 1);

                const formatTime = (d) => d.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });

                if (date >= todayStart) {
                    return formatTime(date);
                } else if (date >= yesterdayStart) {
                    return `æ˜¨å¤© ${formatTime(date)}`;
                } else {
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    return `${month}/${day} ${formatTime(date)}`;
                }
            },
            formatTimestampForPrompt(timestamp) {
                const d = new Date(timestamp);
                return `${d.getMonth() + 1}æœˆ${d.getDate()}æ—¥ ${d.getHours()}:${String(d.getMinutes()).padStart(2, '0')}`;
            },

            compressImage(file, maxWidth = 800, maxHeight = 800, quality = 0.7) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');

                            let width = img.width;
                            let height = img.height;

                            if (width > height) {
                                if (width > maxWidth) {
                                    height = Math.round(height * (maxWidth / width));
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width = Math.round(width * (maxHeight / height));
                                    height = maxHeight;
                                }
                            }

                            canvas.width = width;
                            canvas.height = height;
                            ctx.drawImage(img, 0, 0, width, height);

                            resolve(canvas.toDataURL(file.type, quality));
                        };
                        img.onerror = reject;
                    };
                    reader.onerror = reject;
                });
            },

            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            },

            parseMomentTimestamp(timeStr) { 
                if (!timeStr) return Date.now();
                const now = new Date();
                const year = now.getFullYear();
                const [datePart, timePart] = timeStr.split(' ');
                if (!datePart || !timePart) return Date.now();

                const [month, day] = datePart.split('/');
                const [hour, minute] = timePart.split(':');
                
                
                const parsedDate = new Date(year, parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute));
                
                
                if (parsedDate > now) {
                    parsedDate.setFullYear(year - 1);
                }
                
                return parsedDate.getTime();
            }
        };

        
        const UIManager = {
            notificationQueue: [],
            isDisplayingNotification: false,
       async syncAiButtonState() {
            const aiRequestBtn = $('#ai-request-btn');
            if (!aiRequestBtn) return;

            if (AIHandler.isAwaitingResponse) {
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;
            } else {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const defaultIconHtml = '<i class="fas fa-feather-alt"></i>';
                const iconUrl = settings.aiRequestBtnUrl;
                const style = 'width: 2.2rem; height: 2.2rem; object-fit: contain;';

                if (iconUrl) {
                    const img = new Image();
                    img.onload = () => { aiRequestBtn.innerHTML = `<img src="${iconUrl}" style="${style}">`; };
                    img.onerror = () => { aiRequestBtn.innerHTML = defaultIconHtml; };
                    img.src = iconUrl;
                } else {
                    aiRequestBtn.innerHTML = defaultIconHtml;
                }
            }
        },
       async navigateTo(pageId, fromPage = null) {
            if (!pages[pageId]) return;

            
            if (['chat', 'prompts', 'moments', 'tutorial', 'pomodoro', 'gifts', 'forwarded-history'].includes(pageId)) { 
                bottomNav.style.display = 'none';
            } else {
                bottomNav.style.display = 'flex';
            }

            EventManager.updateFloatingBallVisibility();

            
            $$('#bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.page === pageId);
            });

            
            Object.values(pages).forEach(page => page.classList.remove('active'));
            pages[pageId].classList.add('active');
            appState.currentPage = pageId;
            appState.fromPage = fromPage; 
            
            
            switch(pageId) {
                case 'messages': await this.renderMessagesListPage(); break;
                case 'contacts': await this.renderContactsPage(); break;
                case 'discover':  break;
                case 'moments': await this.renderMomentsPage(); break;
                case 'settings': break; 
                case 'api-settings': await EventManager.renderApiSettingsPage(); break;
                case 'gifts': await UIManager.renderGiftsPage(); break;
                case 'theme-settings': await EventManager.renderThemeSettingsPage(); break;
                case 'bubble-settings': await EventManager.renderBubbleSettingsPage(); break;
                case 'prompts': await EventManager.renderPromptsPage(); break;
            }
        },

            async renderMessagesListPage() {
                const messageListUl = $('#message-list-ul');
                messageListUl.innerHTML = '';
                
                const allMetadata = await DBHelper.getAll('chatMetadata');
                if (allMetadata.length === 0) {
                    messageListUl.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">è¿˜æ²¡æœ‰æ¶ˆæ¯ï¼Œå¿«å»é€šè®¯å½•æ‰¾å¥½å‹èŠå¤©å§~</li>`;
                    return;
                }
                
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');
                const contactsMap = contacts.reduce((map, c) => (map[c.id] = c, map), {});
                const groupsMap = groups.reduce((map, g) => (map[g.id] = g, map), {});

                const pinnedChats = [];
                const unpinnedChats = [];

                for (const metadata of allMetadata) {
                    if (!metadata) continue; 
                    
                    const { chatId, lastMessage, unreadCount, isPinned, pinnedTimestamp } = metadata;
                    if (!lastMessage) continue;

                    let chatInfo = {
                        id: chatId,
                        lastMessageContent: lastMessage.content,
                        lastMessageTimestamp: lastMessage.timestamp,
                        unreadCount: unreadCount,
                        isPinned: isPinned || false,
                        pinnedTimestamp: pinnedTimestamp || 0
                    };
                    
                    let entity;
                    let isGroupChat = chatId.startsWith('group-');

                    if (isGroupChat) {
                        entity = groupsMap[chatId];
                    } else {
                        entity = contactsMap[chatId];
                    }

                    if (!entity) continue; 

                    chatInfo.name = entity.remark || entity.name;
                    chatInfo.avatar = entity.avatar;

                    switch (lastMessage.segmentType) {
                        case 'pat_a_pat': chatInfo.lastMessageContent = '[æ‹ä¸€æ‹]'; break;
                        case 'emoji-image':
                            const emojiDesc = appState.playerEmojiMap[lastMessage.content] || appState.aiEmojiMap[lastMessage.content];
                            chatInfo.lastMessageContent = emojiDesc ? `[è¡¨æƒ…] ${emojiDesc}` : '[æœªçŸ¥è¡¨æƒ…]';
                            break;
                        case 'narrator':
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = lastMessage.content;
                            
                            chatInfo.lastMessageContent = '[æ—ç™½] ' + tempDiv.textContent.trim().replace(/\s+/g, ' ').substring(0, 50);
                            break;
                            chatInfo.lastMessageContent = emojiDesc ? `[è¡¨æƒ…] ${emojiDesc}` : '[æœªçŸ¥è¡¨æƒ…]';
                            break;
                        case 'forward_custom': chatInfo.lastMessageContent = `[è½¬å‘] ${lastMessage.cardData.title}`; break;
                        case 'image_simulated': chatInfo.lastMessageContent = '[å›¾ç‰‡]'; break;
                        case 'image_vision': chatInfo.lastMessageContent = '[å›¾ç‰‡]'; break;
                        case 'card': chatInfo.lastMessageContent = `[${lastMessage.cardData.shareType || 'åˆ†äº«'} ${lastMessage.cardData.title}]`; break;
                        case 'voice': chatInfo.lastMessageContent = '[è¯­éŸ³]'; break;
                        case 'transfer': chatInfo.lastMessageContent = '[è½¬è´¦]'; break;
                        case 'transfer-return': chatInfo.lastMessageContent = '[è½¬è´¦å·²é€€å›]'; break;
                        case 'transfer-receipt': chatInfo.lastMessageContent = '[å·²æ”¶æ¬¾]'; break;
                        case 'red-packet': chatInfo.lastMessageContent = '[çº¢åŒ…]'; break;
                        case 'moment_forward': chatInfo.lastMessageContent = '[è½¬å‘åŠ¨æ€]'; break;
                    }

                    if (lastMessage.isRetracted) {
                        chatInfo.lastMessageContent = '[ä¸€æ¡æ¶ˆæ¯è¢«æ’¤å›]';
                    }
                    
                    if (isGroupChat && lastMessage.type === 'received' && lastMessage.senderId) {
                        const sender = contactsMap[lastMessage.senderId];
                        if (sender) {
                            chatInfo.lastMessageContent = `${sender.remark || sender.name}: ${chatInfo.lastMessageContent}`;
                        }
                    }
                    
                    if (chatInfo.isPinned) {
                        pinnedChats.push(chatInfo);
                    } else {
                        unpinnedChats.push(chatInfo);
                    }
                }
                
                
                pinnedChats.sort((a, b) => b.pinnedTimestamp - a.pinnedTimestamp);
                unpinnedChats.sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);
                
                const combinedChats = [...pinnedChats, ...unpinnedChats];

                combinedChats.forEach(chat => {
                    const li = document.createElement('li');
                    li.className = 'message-item';
                    li.dataset.chatId = chat.id;
                    li.innerHTML = `
                        <img src="${chat.avatar}" alt="avatar" class="item-avatar">
                        <div class="item-content">
                            <div class="item-name">
                                ${chat.isPinned ? '<i class="fas fa-thumbtack item-pin-icon"></i>' : ''}
                                ${chat.name}
                            </div>
                            <div class="item-last-msg">${chat.lastMessageContent}</div>
                        </div>
                        <div class="item-info">
                            <div class="item-time">${Utils.formatTimestampSmartly(chat.lastMessageTimestamp)}</div>
                            ${chat.unreadCount > 0 ? `<div class="unread-badge">${chat.unreadCount}</div>` : ''}
                        </div>
                    `;
                    li.addEventListener('click', () => this.openChat(chat.id));
                    messageListUl.appendChild(li);
                });
            },

            showMessageListOptions(itemElement) {
                const existingPopover = $('.message-list-popover');
                if (existingPopover) {
                    existingPopover.remove();
                }

                const chatId = itemElement.dataset.chatId;
                if (!chatId) return;

                const popover = document.createElement('div');
                popover.className = 'message-list-popover';

                (async () => {
                    const metadata = await DBHelper.get('chatMetadata', chatId);
                    const isPinned = metadata?.isPinned || false;
                    const pinButtonText = isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶';
                    const pinIcon = isPinned ? 'fa-arrow-down' : 'fa-thumbtack';

                    popover.innerHTML = `
                        <button class="message-list-popover-btn" data-action="pin"><i class="fas ${pinIcon}"></i> ${pinButtonText}</button>
                        <button class="message-list-popover-btn" data-action="delete"><i class="fas fa-trash-alt"></i> åˆ é™¤</button>
                    `;

                    
                    const rect = itemElement.getBoundingClientRect();
                    const containerRect = $('#page-messages .page-content').getBoundingClientRect();
                    
                    popover.style.top = `${rect.top - containerRect.top + (rect.height / 2)}px`;
                    popover.style.left = `${rect.left - containerRect.left + (rect.width / 2)}px`;
                    popover.style.transformOrigin = 'center center';
                    popover.style.transform = 'translate(-50%, -50%) scale(0.9)'; 

                    $('#page-messages .page-content').appendChild(popover);

                    
                    requestAnimationFrame(() => {
                        const popoverRect = popover.getBoundingClientRect();
                        if (popoverRect.bottom > containerRect.bottom - 10) {
                            popover.style.top = `${rect.top - containerRect.top - popoverRect.height - 5}px`;
                            popover.style.transformOrigin = 'bottom center';
                        }
                        if (popoverRect.top < containerRect.top + 10) {
                            popover.style.top = `${rect.bottom - containerRect.top + 5}px`;
                            popover.style.transformOrigin = 'top center';
                        }
                    });
                })();

                
                popover.addEventListener('click', async (e) => {
                    const button = e.target.closest('button');
                    if (!button) return;
                    e.stopPropagation();

                    const action = button.dataset.action;
                    popover.remove(); 

                    if (action === 'pin') {
                        const allMetadata = await DBHelper.getAll('chatMetadata');
                        const pinnedCount = allMetadata.filter(m => m.isPinned).length;
                        const metadata = await DBHelper.get('chatMetadata', chatId);
                        
                        if (!metadata.isPinned && pinnedCount >= 5) {
                            UIManager.showToast("æœ€å¤šåªèƒ½ç½®é¡¶5ä¸ªèŠå¤©");
                            return;
                        }

                        metadata.isPinned = !metadata.isPinned;
                        metadata.pinnedTimestamp = metadata.isPinned ? Date.now() : 0;
                        await DBHelper.put('chatMetadata', metadata);
                        await this.renderMessagesListPage();

                    } else if (action === 'delete') {
                        this.showModal({
                            title: 'åˆ é™¤æ­¤ä¼šè¯',
                            body: '<p>è¯·é€‰æ‹©åˆ é™¤æ–¹å¼ï¼š</p>',
                            actions: [
                                { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => this.hideModal() },
                                { text: 'ä»…ç§»é™¤åˆ—è¡¨', class: 'btn-primary', handler: async () => {
                                    await DBHelper.delete('chatMetadata', chatId);
                                    this.hideModal();
                                    await this.renderMessagesListPage();
                                }},
                                { text: 'åˆ é™¤èŠå¤©è®°å½•', class: 'btn-danger', handler: async () => {
                                    await DBHelper.delete('chatMetadata', chatId);
                                    await DBHelper.deleteMessagesForChat(chatId);

                                    
                                    const isGroup = chatId.startsWith('group-');
                                    const storeName = isGroup ? 'groups' : 'contacts';
                                    const entity = await DBHelper.get(storeName, chatId);
                                    if (entity) {
                                        entity.autoSummary = ''; 
                                        if (entity.totalPlayerTurns) { 
                                            entity.totalPlayerTurns = 0;
                                        }
                                        await DBHelper.put(storeName, entity);
                                    }
                                    

                                    this.hideModal();
                                    await this.renderMessagesListPage();
                                }}
                            ]
                        });
                    }
                });

                
                const hideOnClickOutside = (event) => {
                    if (!popover.contains(event.target)) {
                        popover.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                setTimeout(() => document.addEventListener('click', hideOnClickOutside, true), 0);
            },

            async renderContactsPage(tab = 'friends') {
                $$('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
                $$('.contact-section').forEach(sec => {
                    sec.classList.remove('active');
                });

                if (tab === 'friends') {
                    $('#contacts-friends').classList.add('active');
                    const friends = await DBHelper.getAll('contacts');
                    friends.sort((a, b) => {
                        return appState.contactsSortOrder === 'asc' 
                            ? a.createdAt - b.createdAt 
                            : b.createdAt - a.createdAt;
                    });
                    this.renderContactList($('#friends-list-ul'), friends, 'contact');
                } else if (tab === 'groups') {
                    $('#contacts-groups').classList.add('active');
                    const groups = await DBHelper.getAll('groups');
                     groups.sort((a, b) => {
                        return appState.groupsSortOrder === 'asc' 
                            ? a.createdAt - b.createdAt 
                            : b.createdAt - a.createdAt;
                    });
                    this.renderContactList($('#groups-list-ul'), groups, 'group');
                } else if (tab === 'friendFolders') {
                    $('#contacts-friend-folders').classList.add('active');
                    await this.renderFriendFoldersPage();
                }
            },

            async updateChatMetadata(chatId, newLastMessage = null, unreadChange = 0) {
                
                if (!chatId) {
                    console.error("å°è¯•æ›´æ–°ä¸€ä¸ªç©ºçš„ chatId çš„å…ƒæ•°æ®ï¼Œæ“ä½œå·²é˜»æ­¢ã€‚");
                    return;
                }

                const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId, unreadCount: 0 };
                
                if (newLastMessage) {
                    metadata.lastMessage = newLastMessage;
                    metadata.lastMessageTimestamp = newLastMessage.timestamp;
                }
                
                if (unreadChange > 0) {
                    metadata.unreadCount = (metadata.unreadCount || 0) + unreadChange;
                } else if (unreadChange < 0) { 
                    metadata.unreadCount = 0;
                }
                
                if (metadata.lastMessage) { 
                    await DBHelper.put('chatMetadata', metadata);
                }
            },

            
            renderContactList(ulElement, items, type) {
                const isSelectionMode = (type === 'contact' && appState.friendSelectionMode) || (type === 'group' && appState.groupSelectionMode);

                ulElement.classList.toggle('selection-mode', isSelectionMode);
                ulElement.innerHTML = '';

                if (items.length === 0) {
                    ulElement.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">ç©ºç©ºå¦‚ä¹Ÿ~</li>`;
                    return;
                }
                items.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'contact-item';
                    li.dataset.id = item.id;
                    li.innerHTML = `
                        ${isSelectionMode ? '<input type="checkbox" class="contact-select-checkbox">' : ''}
                        <img src="${item.avatar}" alt="avatar" class="contact-item-avatar">
                        <span class="contact-item-name">${type === 'contact' ? (item.remark || item.name) : item.name}</span>
                        ${type === 'contact' 
                            ? `<i class="fas fa-info-circle contact-info-btn" data-id="${item.id}"></i>` 
                            : `<i class="fas fa-ellipsis-h contact-info-btn" data-id="${item.id}"></i>`
                        }
                    `;
                    
                    li.addEventListener('click', (e) => {
                        if (isSelectionMode) {
                            if (e.target.type !== 'checkbox') {
                                const checkbox = li.querySelector('.contact-select-checkbox');
                                if (checkbox) checkbox.checked = !checkbox.checked;
                            }
                            return;
                        }
                        if (e.target.classList.contains('contact-info-btn')) return;
                        this.openChat(item.id);
                    });
                    
                    const infoBtn = li.querySelector('.contact-info-btn');
                    if (infoBtn) {
                        infoBtn.addEventListener('click', (e) => {
                           e.stopPropagation();
                           if (type === 'contact') this.showContactInfo(item.id);
                           else this.showGroupInfo(item.id);
                        });
                    }

                    ulElement.appendChild(li);
                });
            },

        async openChat(chatId) {
            appState.currentChatId = chatId;
            const isGroup = chatId.startsWith('group-');
            let target;
            if (isGroup) {
                target = await DBHelper.get('groups', chatId);
            } else {
                target = await DBHelper.get('contacts', chatId);
            }
        
            if (!target) {
                this.showModal({
                    title: "é”™è¯¯",
                    body: `<p>æ‰¾ä¸åˆ°è¯¥èŠå¤©å¯¹è±¡ï¼Œå¯èƒ½å·²è¢«åˆ é™¤ã€‚</p>`,
                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => this.hideModal() }]
                });
                return;
            }
        
            chatTitle.textContent = isGroup ? target.name : (target.remark || target.name);
        
            
            const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId, unreadCount: 0 };
            if (metadata.unreadCount > 0) {
                
                await this.updateChatMetadata(chatId, null, -1);
            }
        
            
            if (isGroup) {
                for (const memberId of target.members) {
                    await this.updateChatMetadata(memberId, null, -1);
                }
            }
        
            await this.refreshChatView();
            this.navigateTo('chat');
            await EventManager.applyChatSpecificStyles();
            await UIManager.applyChatBackground(chatId);
            await UIManager.applyChatBackground(chatId);
            
            this.syncAiButtonState(); 
            
            if (!isGroup && target.allowActiveReply === false) {
                console.log(`å·²ä¸ºè§’è‰² ${target.name} å…³é—­ä¸»åŠ¨å›å¤åŠŸèƒ½ã€‚`);
            } else {
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                const intervalHours = (typeof chatSettings.activeReplyInterval === 'number') ? chatSettings.activeReplyInterval : 0;
                const lastAiTimestamp = metadata.lastAiReplyTimestamp || 0;
                const now = Date.now();
                const elapsedHours = (now - lastAiTimestamp) / (1000 * 60 * 60);
        
                if (intervalHours > 0 && lastAiTimestamp > 0 && elapsedHours >= intervalHours) {
                    console.log(`è·ç¦»ä¸Šæ¬¡AIå›å¤å·²è¿‡å» ${elapsedHours.toFixed(2)} å°æ—¶ï¼Œå·²è¾¾åˆ°è®¾å®šçš„ ${intervalHours} å°æ—¶ï¼Œè§¦å‘ä¸»åŠ¨å›å¤ã€‚`);
                    setTimeout(() => AIHandler.handleActiveReplyRequest(lastAiTimestamp), 500);
                } else {
                    
                    if (intervalHours <= 0) {
                        console.log("ä¸»åŠ¨å›å¤åŠŸèƒ½å·²åœ¨èŠå¤©è®¾ç½®ä¸­å…³é—­ (é—´éš”ä¸º0)ã€‚");
                    } else if (lastAiTimestamp === 0) {
                        console.log("è¿™æ˜¯ä½ ä»¬çš„ç¬¬ä¸€æ¬¡äº’åŠ¨ï¼Œæš‚ä¸è§¦å‘ä¸»åŠ¨å›å¤ã€‚");
                    } else {
                        console.log(`è·ç¦»ä¸Šæ¬¡AIå›å¤ ${elapsedHours.toFixed(2)} å°æ—¶ï¼Œæœªè¾¾åˆ°è®¾å®šçš„ ${intervalHours} å°æ—¶ï¼Œä¸è§¦å‘ä¸»åŠ¨å›å¤ã€‚`);
                    }
                }
            }
        },

        async refreshChatView() {
            if (!appState.currentChatId) return;
            
            const totalMessages = await DBHelper.getChatMessagesCount(appState.currentChatId);
            
            appState.currentChat = {
                totalMessages: totalMessages,
                renderedCount: 0,
                oldestMessageTimestamp: Date.now(), 
                lastRefreshTimestamp: Date.now(), 
            };
            
            chatArea.innerHTML = ''; 
            if (totalMessages > 0) {
                const loaderHTML = '<div id="history-loader"><div class="loader-spinner"></div></div>';
                chatArea.insertAdjacentHTML('beforeend', loaderHTML);
            }

            await this.loadMoreMessages(true);
        },

        async loadMoreMessages(isInitialLoad = false) {
            if (appState.isHistoryLoading) return;

            const { totalMessages, renderedCount, oldestMessageTimestamp } = appState.currentChat;
            const loader = $('#history-loader');

            if (renderedCount >= totalMessages) {
                if(loader) loader.remove();
                return;
            }

            appState.isHistoryLoading = true;
            if (loader) loader.classList.add('visible');
            
            const messagesToLoad = await DBHelper.getMessages(appState.currentChatId, appState.messagesPerLoad, oldestMessageTimestamp);
            
            if (messagesToLoad.length === 0) {
                if (loader) loader.remove();
                appState.isHistoryLoading = false;
                return;
            }

            appState.currentChat.oldestMessageTimestamp = messagesToLoad[0].timestamp;
            
            const fragment = document.createDocumentFragment();
            const profile = await EventManager.getPlayerProfileForContext(appState.currentChatId);
            const contacts = await DBHelper.getAll('contacts');

            
            const nextMessageArr = (chatArea.querySelector('.message-row, .system-notice, .narrator-notice, .retracted-notice')?.id) 
                ? [await DBHelper.get('messages', chatArea.querySelector('.message-row, .system-notice, .narrator-notice, .retracted-notice').id)] 
                : [];
            let nextMessageTimestamp = nextMessageArr.length > 0 ? nextMessageArr[0].timestamp : Date.now() + 1000;

            for (let i = messagesToLoad.length - 1; i >= 0; i--) {
                const msg = messagesToLoad[i];
                
                
                if (nextMessageTimestamp - msg.timestamp > 5 * 60 * 1000 && !isInitialLoad) {
                    const timeDiv = this.createTimeDividerElement(nextMessageTimestamp);
                    fragment.prepend(timeDiv); 
                }
                
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                if (!(['inner_voice', 'essay'].includes(msg.segmentType) || msg.isHidden)) {
                    
                    if (msg.segmentType === 'pat_a_pat' && chatSettings.enablePatAPat === false) {
                        nextMessageTimestamp = msg.timestamp;
                        continue;
                    }

                    let senderInfo = (msg.type === 'sent') ? profile : contacts.find(c => c.id === msg.senderId) || { name: 'æœªçŸ¥æˆå‘˜', avatar: Utils.createAvatarDataUrl('#ccc') };
                    
                    
                    
                    if (msg.segmentType === 'emoji-image' && msg.type === 'received') {
                        const emojiSetting = senderInfo.allowEmoji;
                        if (emojiSetting === 'off') {
                            nextMessageTimestamp = msg.timestamp; 
                            continue; 
                        } else if (emojiSetting === 'prob') {
                            if (Math.random() < 0.5) {
                                nextMessageTimestamp = msg.timestamp;
                                continue; 
                            }
                        }
                    }

                    
                    if (msg.isRetracted && msg.type === 'received' && senderInfo.allowRetraction === false) {
                        msg.isRetracted = false; 
                    }
                    

                    let messageElement;

                    if (msg.isRetracted) {
                        messageElement = this.createRetractionNotice(msg, senderInfo);
                    } else if (msg.segmentType === 'system') {
                        messageElement = document.createElement('div');
                        messageElement.className = 'system-notice';
                        messageElement.id = msg.messageId; 
                        messageElement.textContent = msg.content;
                    } else if (msg.segmentType === 'narrator') {
                        messageElement = await this.createNarratorNoticeElement(msg);
                    } else if (msg.segmentType === 'pat_a_pat') {
                        messageElement = document.createElement('div');
                        messageElement.className = 'pat-notice';
                        messageElement.id = msg.messageId;
                        messageElement.textContent = msg.content.displayText;
                    } else {
                        messageElement = await this.createMessageElement(msg, senderInfo);
                    }
                    fragment.prepend(messageElement); 
                }

                nextMessageTimestamp = msg.timestamp; 
            }

            const oldScrollHeight = chatArea.scrollHeight;
            if (loader) loader.after(fragment);
            else chatArea.prepend(fragment);
            
            if (isInitialLoad) {
                setTimeout(() => chatArea.scrollTop = chatArea.scrollHeight, 10);
            } else {
                chatArea.scrollTop = chatArea.scrollHeight - oldScrollHeight;
            }

            appState.currentChat.renderedCount += messagesToLoad.length;
            if (loader) loader.classList.remove('visible');
            appState.isHistoryLoading = false;
            
            if (appState.currentChat.renderedCount >= totalMessages) {
                if (loader) loader.remove();
            }
        },

        async createMessageElement(msg, senderInfo, isTyping = false, isReadOnly = false) {
            const messageRow = document.createElement('div');
            messageRow.className = `message-row ${msg.type}`;
            
            if (!isTyping) {
                messageRow.id = msg.messageId;
                messageRow.dataset.messageId = msg.messageId;
            }

            let bubbleContent = '';
            let bubbleClass = 'bubble';
            let detailContent = ''; 
            
            
            if (msg.isAutoReply) {
                bubbleClass += ' auto-reply-bubble';
            }

            if (isTyping) {
                bubbleClass += ` bubble-typing`;
                bubbleContent = `<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>`;
            } else {
                 switch(msg.segmentType) {
                    case 'emoji-image':
                        bubbleClass += ` bubble-emoji`;
                        let emojiSrc;
                        if (msg.content.startsWith('custom-')) {
                            emojiSrc = appState.customEmojis[msg.content]?.url || '';
                        } else {
                            emojiSrc = `https://z.wiki/u/${msg.content}`;
                        }
                        bubbleContent = `<img src="${emojiSrc}" alt="${appState.playerEmojiMap[msg.content] || 'è¡¨æƒ…'}">`;
                        break;
                    case 'image_simulated':
                        bubbleClass += ' image-with-desc-bubble';
                        bubbleContent = `
                            ${msg.cardData.imageSrc ? `<img src="${msg.cardData.imageSrc}" alt="å›¾ç‰‡">` : ''}
                            <div class="description-text">${msg.cardData.description}</div>
                        `;
                        break;
                    case 'image_vision':
                        bubbleClass += ' image-with-desc-bubble vision-image-bubble';
                        bubbleContent = `
                            <img src="${msg.cardData.base64}" alt="ç”¨æˆ·å‘é€çš„å›¾ç‰‡">
                            ${msg.cardData.prompt ? `<div class="description-text">${msg.cardData.prompt}</div>` : ''}
                        `;
                        break;
                    case 'voice':
                        bubbleClass += ' voice-message-bubble';
                        bubbleContent = `<span class="voice-duration">${msg.cardData.duration}</span><div class="voice-wave"><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div></div>`;
                        detailContent = `<div class="voice-transcript">${msg.cardData.content}</div>`;
                        break;
                    case 'quote':
                        bubbleClass += ' quote-message-bubble';
                        bubbleContent = `<div class="quote-block"><span class="quoted-name">${msg.cardData.quotedName}:</span><span>${msg.cardData.quotedContent}</span></div><div>${msg.cardData.newContent}</div>`;
                        break;
                    case 'transfer':
                        bubbleClass += ' transfer-or-red-packet-bubble';
                        if (msg.cardData.isClaimed) bubbleClass += ' claimed';
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const transferCoverStyle = themeSettings.transferCover ? `background-image: url(${themeSettings.transferCover}); background-size: cover; background-position: center;` : '';
                            
                            bubbleContent = `
                                <div class="transfer-content-v3" style="${transferCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-exchange-alt transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>è½¬è´¦ç»™ ${msg.cardData.recipientName}</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    ${msg.cardData.note ? `<div class="transfer-footer-v3">${msg.cardData.note}</div>` : ''}
                                </div>
                            `;
                        }
                        break;
                    case 'transfer-return':
                        bubbleClass += ' transfer-or-red-packet-bubble claimed'; 
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const transferCoverStyle = themeSettings.transferCover ? `background-image: url(${themeSettings.transferCover}); background-size: cover; background-position: center;` : '';
                            const recipientIsPlayer = msg.cardData.recipientName === (await EventManager.getPlayerProfileForContext(appState.currentChatId))?.name;
                            const footerText = recipientIsPlayer ? `å·²é€€è¿˜ç»™ ${msg.cardData.recipientName}` : `${msg.cardData.senderName} é€€è¿˜äº†è½¬è´¦`;
                            
                            bubbleContent = `
                                <div class="transfer-content-v3" style="${transferCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-undo transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>è½¬è´¦å·²é€€å›</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    <div class="transfer-footer-v3">${footerText}</div>
                                </div>
                            `;
                        }
                        break;
                    case 'transfer-receipt':
                        bubbleClass += ' transfer-or-red-packet-bubble claimed'; 
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const receiptCoverStyle = themeSettings.receiptCover ? `background-image: url(${themeSettings.receiptCover}); background-size: cover; background-position: center;` : '';
                            const footerText = msg.type === 'sent' ? `æ¥è‡ª ${msg.cardData.senderName} çš„è½¬è´¦` : `${msg.cardData.recipientName} å·²æ”¶æ¬¾`;

                            bubbleContent = `
                                 <div class="transfer-content-v3" style="${receiptCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-check-circle transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>å·²æ”¶æ¬¾</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    <div class="transfer-footer-v3">${footerText}</div>
                                </div>
                            `;
                        }
                        break;
                    case 'red-packet':
                        bubbleClass += ' transfer-or-red-packet-bubble';
                        if (msg.cardData.isClaimedByPlayer) bubbleClass += ' claimed';
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const defaultCover = 'https://z.wiki/u/IDzEvp';
                            const rpCover = themeSettings.redPacketCover || defaultCover;
                            
                            bubbleContent = `
                                <div class="red-packet-v3-wrapper">
                                    <div class="rp-cover-v3" style="background-image: url('${rpCover}');">
                                        <h4 class="rp-title-v3">${msg.cardData.title}</h4>
                                        <div class="open-button-v3">
                                            <i class="fas fa-paw"></i>
                                        </div>
                                    </div>
                                    <div class="claimed-overlay-v3">å·²é¢†å–</div>
                                </div>
                            `;
                        }
                        break;
                    case 'card':
                        bubbleClass += ' card-bubble';
                        const cardId = `card-detail-${msg.messageId}`;
                        let cardInnerHtml = '';
                        
                        if (msg.type === 'sent') {
                            const cardData = msg.cardData;
                            switch(cardData.shareType) {
                                case 'åœ°ç‚¹åˆ†äº«': cardInnerHtml = `<div class="card-message-wrapper card-type-3" data-card-id="${cardId}"><div class="card-icon-area" style="background-color: var(--theme-color-1);"><i class="fas fa-map-marker-alt"></i></div><div class="card-content"><h4>${cardData.title}</h4><p>${cardData.summary}</p></div></div>`; break;
                                case 'æ–‡ä»¶åˆ†äº«': cardInnerHtml = `<div class="card-message-wrapper card-type-9" data-card-id="${cardId}"><i class="fas fa-file-archive file-icon" style="color: var(--theme-color-4);"></i><div class="file-info"><h4>${cardData.title}</h4><div class="file-size">${cardData.summary}</div></div></div>`; break;
                                default:
                                    const imageToUse = cardData.imageSrc || appState.cardCoverLibrary[Math.floor(Math.random() * appState.cardCoverLibrary.length)];
                                    cardInnerHtml = `<div class="card-message-wrapper card-type-2" data-card-id="${cardId}"><img src="${imageToUse}" class="card-image" alt="Card image"><div class="card-content"><h4>${cardData.title}</h4><p>${cardData.summary}</p></div></div>`;
                                    break;
                            }
                        } else {
                             switch(msg.cardData.shareType) {
                                case 'åœ°ç‚¹åˆ†äº«': cardInnerHtml = `<div class="card-message-wrapper card-type-3" data-card-id="${cardId}"><div class="card-icon-area" style="background-color: var(--theme-color-1);"><i class="fas fa-map-marker-alt"></i></div><div class="card-content"><h4>${msg.cardData.title}</h4><p>${msg.cardData.summary}</p></div></div>`; break;
                                case 'æ–‡ä»¶åˆ†äº«': cardInnerHtml = `<div class="card-message-wrapper card-type-9" data-card-id="${cardId}"><i class="fas fa-file-archive file-icon" style="color: var(--theme-color-4);"></i><div class="file-info"><h4>${msg.cardData.title}</h4><div class="file-size">${msg.cardData.summary}</div></div></div>`; break;
                                default:
                                    const randomCover = appState.cardCoverLibrary[Math.floor(Math.random() * appState.cardCoverLibrary.length)];
                                    cardInnerHtml = `<div class="card-message-wrapper card-type-2" data-card-id="${cardId}"><img src="${randomCover}" class="card-image" alt="Card image"><div class="card-content"><h4>${msg.cardData.title}</h4><p>${msg.cardData.summary}</p></div></div>`;
                                    break;
                            }
                        }
                        
                        const cardDetailHtml = `<div class="card-detail-content" id="${cardId}"><h5>${msg.cardData.title}</h5><p>${msg.cardData.details}</p></div>`;
                        
                        bubbleContent = cardInnerHtml;
                        detailContent = cardDetailHtml; 
                        break;
                    case 'moment_forward':
                        bubbleClass += ' forwarded-moment-bubble';
                        bubbleContent = `
                            <div class="forwarded-moment-card-content" data-moment-id="${msg.cardData.momentId}">
                                <h4 class="card-title">[æœ‹å‹åœˆåŠ¨æ€]</h4>
                                <p class="card-preview">${msg.cardData.authorName}ï¼š${msg.cardData.preview}</p>
                                <div class="card-footer">æœ‹å‹åœˆ</div>
                            </div>
                        `;
                        break;
                    case 'forwarded_history':
                        bubbleClass += ' forwarded-history-bubble';
                        bubbleContent = `
                            <div class="forwarded-history-card-content">
                                <h4 class="card-title">${msg.cardData.title}</h4>
                                <p class="card-preview">${msg.cardData.preview}</p>
                                <div class="card-footer">èŠå¤©è®°å½•</div>
                            </div>
                        `;
                        break;
                    case 'forward_custom':
                        bubbleClass += ' forwarded-moment-bubble';
                        bubbleContent = `
                            <div class="forwarded-moment-card-content" data-type="custom-forward">
                                <h4 class="card-title">[è½¬å‘] ${msg.cardData.title}</h4>
                                <p class="card-preview">${msg.cardData.content}</p>
                                <div class="card-footer">è½¬å‘</div>
                            </div>
                        `;
                        break;
                    case 'gift':
                        bubbleClass += ' gift-bubble';
                        bubbleContent = `
                            <div class="gift-message-content">
                                <img src="${msg.cardData.image}" class="gift-image" alt="ç¤¼ç‰©">
                                <div class="gift-info">
                                    <div class="gift-name">${msg.cardData.name}</div>
                                    <p class="gift-message">${msg.cardData.message}</p>
                                    <div class="gift-price">ï¿¥${msg.cardData.price}</div>
                                </div>
                            </div>
                        `;
                        break;
                    case 'text':
                    default:
                        bubbleContent = msg.content;
                        break;
                }
            }
            
            bubbleClass += ` ${msg.type}`;
            const avatarSrc = (isTyping && msg.isGroupTyping) ? senderInfo.avatar : (senderInfo.avatar || Utils.createAvatarDataUrl('#ccc'));
            const avatarClass = `message-avatar ${isTyping && msg.isGroupTyping ? 'group-avatar-style' : ''}`;
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            const isGroup = appState.currentChatId.startsWith('group-');
            const isMyMessage = msg.type === 'sent';
            let displayNameHtml = '';
            
            
            let timestampHtml = '';
            if (msg.isAutoReply && msg.displayTimestamp) {
                timestampHtml = `<div class="message-timestamp">${msg.displayTimestamp}<span class="auto-reply-tag">æœªè¯»</span></div>`;
            }

            if (isReadOnly) {
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);
                const nameColorStyle = chatEntity?.nameColor ? `style="color: ${chatEntity.nameColor};"` : '';
                displayNameHtml = `<div class="message-name" ${nameColorStyle}>${senderInfo.name}</div>`;
            } else if (!isTyping && !['transfer-receipt'].includes(msg.segmentType)) {
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);
                const nameColorStyle = chatEntity?.nameColor ? `style="color: ${chatEntity.nameColor};"` : '';

                if (isGroup) {
                    if (!isMyMessage) displayNameHtml = `<div class="message-name" ${nameColorStyle}>${senderInfo.remark || senderInfo.name}</div>`;
                    else if (chatSettings.showMyNameInGroup) displayNameHtml = `<div class="message-name" ${nameColorStyle}>${senderInfo.name}</div>`;
                } else {
                    if (chatSettings.showNamesInPrivate) displayNameHtml = `<div class="message-name" ${nameColorStyle}>${isMyMessage ? senderInfo.name : (senderInfo.remark || senderInfo.name)}</div>`;
                }
            }
            
            messageRow.innerHTML = `<div class="message-selector"><input type="checkbox" class="message-select-checkbox"></div><img src="${avatarSrc}" alt="avatar" class="${avatarClass}"><div class="message-content">${displayNameHtml}<div class="bubble-and-tag-wrapper"><div class="${bubbleClass}">${bubbleContent}</div>${detailContent}${timestampHtml}</div></div>`;

            const avatarEl = messageRow.querySelector('.message-avatar');
            if (!isTyping && !isReadOnly) {
                avatarEl.style.cursor = 'pointer';

                let clickTimer = null;
                let clickCount = 0;

                avatarEl.addEventListener('click', (e) => {
                    clickCount++;

                    if (clickCount === 1) {
                        clickTimer = setTimeout(() => {
                            
                            if (appState.selectionMode.active) {
                                const checkbox = messageRow.querySelector('.message-select-checkbox');
                                if (checkbox) checkbox.checked = !checkbox.checked;
                                EventManager.handleMessageSelection({ target: checkbox });
                            } else if (msg.type === 'received') {
                                this.showPersonaModal(msg.senderId);
                            } else if (msg.type === 'sent') {
                                AIHandler.handleRegenerateRequest(msg.messageId);
                            }
                            clickCount = 0;
                        }, 300); 
                    } else if (clickCount === 2) {
                        
                        clearTimeout(clickTimer);
                        if (!appState.selectionMode.active) {
                            EventManager.handlePatRequest(msg.type === 'sent' ? 'myProfile' : msg.senderId);
                        }
                        clickCount = 0;
                    }
                });
            }

            if (isReadOnly) {
                const nameContainer = messageRow.querySelector('.message-name');
                if (nameContainer) {
                    
                }
            }
            
                
                if (chatSettings.showBubbleTimestamp && !isTyping && !isReadOnly && !msg.isAutoReply && ['text', 'quote', 'voice'].includes(msg.segmentType)) {
                    const wrapper = messageRow.querySelector('.bubble-and-tag-wrapper');
                    if (wrapper) {
                        const timestampEl = document.createElement('div');
                        timestampEl.className = 'bubble-timestamp';
                        timestampEl.textContent = Utils.formatTimestampForBubble(msg.timestamp);
                        wrapper.appendChild(timestampEl);
                    }
                }
            
                return messageRow;
            },

        async addMessageToDOM(msg, senderInfo, isTyping = false, isAnimating = false) {
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            if (msg.isHidden || (msg.segmentType === 'pat_a_pat' && chatSettings.enablePatAPat === false)) {
                return;
            }

            
            let freshSenderInfo = senderInfo;
            if (msg.type === 'received' && msg.senderId) {
                
                freshSenderInfo = await DBHelper.get('contacts', msg.senderId);
            } else if (msg.type === 'sent') {
                
                freshSenderInfo = await EventManager.getPlayerProfileForContext(msg.chatId);
            }
            
            if (!freshSenderInfo) {
                freshSenderInfo = { name: 'æœªçŸ¥ç”¨æˆ·', avatar: Utils.createAvatarDataUrl('#ccc') };
            }
            

            let messageElement;
            if (msg.segmentType === 'system') {
                messageElement = document.createElement('div');
                messageElement.className = 'system-notice';
                messageElement.id = msg.messageId;
                messageElement.textContent = msg.content;
            } else if (msg.segmentType === 'narrator') {
                messageElement = await this.createNarratorNoticeElement(msg);
            } else if (msg.segmentType === 'pat_a_pat') {
                messageElement = document.createElement('div');
                messageElement.className = 'pat-notice';
                messageElement.id = msg.messageId;
                messageElement.dataset.messageId = msg.messageId; 
                messageElement.textContent = msg.content.displayText;
            } else {
                
                messageElement = await this.createMessageElement(msg, freshSenderInfo, isTyping);
            }
            
            if (isTyping && msg.messageId) {
                messageElement.id = msg.messageId;
            }

            chatArea.appendChild(messageElement);
            
            if(!isTyping) {
                appState.currentChat.totalMessages++;
                appState.currentChat.renderedCount++;
            }
            chatArea.scrollTop = chatArea.scrollHeight;
        },
        
        createTimeDividerElement(timestamp) {
            const timeDiv = document.createElement('div');
            timeDiv.className = 'time-divider';
            timeDiv.textContent = Utils.formatTimestampSmartly(timestamp);
            return timeDiv;
        },

        async createNarratorNoticeElement(msg) {
            const notice = document.createElement('div');
            notice.id = msg.messageId;
            notice.dataset.messageId = msg.messageId;

            const isGroup = appState.currentChatId.startsWith('group-');
            const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);
            const narratorStyle = entity?.narratorStyle || 'grey';

            notice.className = `narrator-notice narrator-style-${narratorStyle}`;

            
            const isHtmlContent = msg.content.trim().toLowerCase().startsWith('<!doctype html');

            if (isHtmlContent) {
                
                notice.style.padding = '0'; 
                notice.style.border = 'none'; 
                notice.style.background = 'transparent'; 
                notice.style.boxShadow = 'none'; 

                const iframe = document.createElement('iframe');
                iframe.srcdoc = msg.content;
                iframe.style.width = '100%';
                iframe.style.border = 'none';
                iframe.style.borderRadius = '10px'; 
                iframe.scrolling = 'no';
                
                
                iframe.onload = function() {
                    try {
                        const body = iframe.contentWindow.document.body;
                        const html = iframe.contentWindow.document.documentElement;
                        const height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
                        iframe.style.height = height + 'px';
                    } catch (e) {
                        console.error("æ— æ³•è°ƒæ•´iframeé«˜åº¦:", e);
                    }
                };

                notice.innerHTML = `<div class="message-selector"><input type="checkbox" class="message-select-checkbox"></div>`;
                notice.appendChild(iframe); 
            } else {
                
                notice.innerHTML = `<div class="message-selector"><input type="checkbox" class="message-select-checkbox"></div><span>${msg.content}</span>`;
            }

            return notice;
        },
        
            createRetractionNotice(msg, senderInfo) {
                const notice = document.createElement('div');
                notice.className = 'retracted-notice';
                notice.id = msg.messageId; 
                const isGroup = appState.currentChatId.startsWith('group-');
                const senderName = msg.type === 'sent' ? 'ä½ ' : (senderInfo.remark || senderInfo.name);
                notice.textContent = `${senderName} æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                
                notice.addEventListener('click', () => {
                    let retractedContentHtml = '';
                    if (msg.segmentType === 'emoji-image') {
                        retractedContentHtml = `<img src="https://z.wiki/u/${msg.content}" style="max-width: 150px; display: block; margin: 10px auto;">`;
                    } else {
                        retractedContentHtml = `<p style="line-height: 1.6;">${msg.content}</p>`;
                    }
                    this.showModal({
                        title: "è¢«æ’¤å›çš„æ¶ˆæ¯",
                        body: retractedContentHtml,
                        actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                });
                return notice;
            },

            async renderGiftsPage() {
                const giftsGrid = $('#gifts-grid');
                $('#gifts-section-title').textContent = 'å¤§å®¶éƒ½åœ¨é€';
                giftsGrid.innerHTML = ''; 

                const PREDEFINED_GIFTS = [
                    { name: 'ç«ç‘°èŠ±æŸ', price: 128.00, image: 'https://z.wiki/u/OZbNtm', message: 'é€ä½ ä¸€æŸç«ç‘°ï¼Œæ„¿ä½ å¤©å¤©å¼€å¿ƒã€‚' },
                    { name: 'å·§å…‹åŠ›ç¤¼ç›’', price: 88.00, image: 'https://cfimg.200996.xyz/file/1752744402256_retouch_2025071717245049.png', message: 'ç”œç”œçš„å·§å…‹åŠ›ï¼Œç»™ç”œç”œçš„ä½ ã€‚' },
                    { name: 'æ¸¸æˆæœº', price: 2199.00, image: 'https://cfimg.200996.xyz/file/1752744403509_retouch_2025071717243405.png', message: 'ä¸€èµ·ç©æ¸¸æˆå§ï¼' },
                    { name: 'æ‰‹ä½œè›‹ç³•', price: 68.00, image: 'https://z.wiki/u/18hMdP', message: 'äº²æ‰‹ä¸ºä½ åšçš„ï¼Œå°å°çœ‹ï¼Ÿ' },
                    { name: 'å¯çˆ±çŒ«å’ª', price: 0, image: 'https://z.wiki/u/RSvBmf', message: 'è·¯è¾¹æ¡çš„ï¼Œç»™ä½ å…»äº†ã€‚' },
                    { name: 'å¥¶èŒ¶ä¸€æ¯', price: 18.00, image: 'https://z.wiki/u/XIexsP', message: 'å¤©å†·äº†ï¼Œå–æ¯çƒ­å¥¶èŒ¶å§ã€‚' }
                ];
                
                PREDEFINED_GIFTS.forEach(gift => {
                    const card = EventManager.createGiftCard(gift);
                    card.onclick = () => EventManager.showSendGiftModal(gift);
                    giftsGrid.appendChild(card);
                });
            },

            async showPersonaModal(contactOrId, onCancelCallback = null, fromGroupInsight = false) {
                let contact;
                if (typeof contactOrId === 'string') {
                    contact = await DBHelper.get('contacts', contactOrId);
                } else {
                    contact = contactOrId;
                }

                if (!contact) return;

                const lastInnerVoice = contact.lastInnerVoiceId ? await DBHelper.get('messages', contact.lastInnerVoiceId) : null;
                const lastEssay = contact.lastEssayId ? await DBHelper.get('messages', contact.lastEssayId) : null;

                let bodyHtml = `
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
                        <img src="${contact.avatar}" style="width: 70px; height: 70px; border-radius: 12px; object-fit: cover;">
                        <div>
                            <h3 style="font-size: 1.4rem; margin-bottom: 5px;">${contact.remark || contact.name}</h3>
                            <p style="color: #888;">ID: ${contact.name}</p>
                        </div>
                    </div>
                `;

                
                bodyHtml += `<div class="persona-modal-card"><h4>å¿ƒå£°</h4><p>${lastInnerVoice ? lastInnerVoice.content : 'æš‚æœªæ´å¯Ÿåˆ°å¿ƒå£°å†…å®¹'}</p></div>`;

                
                if (lastEssay) {
                    bodyHtml += `<div class="persona-modal-card note-paper"><h4>éšç¬”</h4><p>${lastEssay.content}</p></div>`;
                }
                
                
                this.showModal({
                    title: "è§’è‰²æ´å¯Ÿ",
                    body: bodyHtml,
                    actions: [
                        { text: 'è¿›å…¥èŠå¤©', class: 'btn-primary', handler: () => {
                            this.hideModal();
                            this.openChat(contact.id); 
                        }}
                    ]
                });

                
                if (fromGroupInsight) {
                    const overlay = $('#modal-overlay');
                    const originalClickHandler = overlay.onclick; 
                    overlay.onclick = (e) => {
                        if (e.target === overlay) {
                            this.hideModal();
                            
                            if (appState.currentChatId) {
                                this.showGroupInsightModal(appState.currentChatId);
                            }
                        }
                    };

                    
                    const originalHide = this.hideModal;
                    this.hideModal = () => {
                        overlay.onclick = originalClickHandler; 
                        originalHide.call(this);
                        this.hideModal = originalHide; 
                    };
                }
            },

            async showModal(config) {
                
                if (appState.theme === 'neumorphic' && !config.customClass) {
                    modalContentWrapper.classList.add('modal-neumorphic');
                } else if (config.customClass) {
                    modalContentWrapper.classList.add(config.customClass);
                }

                
                if (config.isPersistent) {
                    modalOverlay.classList.add('no-overlay-close');
                } else {
                    modalOverlay.classList.remove('no-overlay-close');
                }
                
                let actionsHtml = '';
                if (config.actions) {
                    actionsHtml = `<div class="modal-actions">` + config.actions.map((action, index) => {
                        const idAttribute = action.id ? `id="${action.id}"` : '';
                        return `<button ${idAttribute} class="modal-btn ${action.class}" data-action-index="${index}">${action.text}</button>`;
                    }).join('') + `</div>`;
                }

                modalContentWrapper.innerHTML = `
                    <h2 class="modal-header">${config.title}</h2>
                    <div class="modal-body">${config.body}</div>
                    ${actionsHtml}
                `;

                if (config.actions) {
                    
                    $$('#modal-content-wrapper .modal-actions .modal-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const index = parseInt(btn.dataset.actionIndex, 10);
                            if (config.actions[index] && typeof config.actions[index].handler === 'function') {
                                config.actions[index].handler();
                            }
                        });
                    });
                }
                
                modalOverlay.classList.add('visible');
            },

            hideModal() {
                modalOverlay.classList.remove('visible');
                
                modalContentWrapper.className = 'modal-content';
                modalContentWrapper.innerHTML = '';
            },
            
            showBottomSheet(config) {
                const sheetOverlay = $('#bottom-sheet-overlay');
                const sheetContent = $('#bottom-sheet-content-wrapper');

                sheetContent.className = 'bottom-sheet-content';

                sheetContent.innerHTML = `
                    <div class="bottom-sheet-header">${config.title}</div>
                    <div class="bottom-sheet-body">
                        ${config.items.map(item => `<div class="bottom-sheet-item" data-value="${item.value}">${item.text}</div>`).join('')}
                    </div>
                `;

                if (appState.theme === 'neumorphic') sheetContent.classList.add('neumorphic');
                if (config.customClass) sheetContent.classList.add(...config.customClass.split(' '));
                
                $$('.bottom-sheet-item').forEach(item => {
                    item.addEventListener('click', () => {
                        config.onSelect(item.dataset.value, item.textContent);
                        this.hideBottomSheet();
                    });
                });

                
                sheetOverlay.style.visibility = 'visible';
                requestAnimationFrame(() => {
                    sheetOverlay.classList.add('visible');
                });
            },

            hideBottomSheet() {
                const sheetOverlay = $('#bottom-sheet-overlay');
                sheetOverlay.classList.remove('visible');
                
                setTimeout(() => {
                    sheetOverlay.style.visibility = 'hidden';
                }, 300); 
            },

            showSidebar(config) {
                const sidebarContent = $('#sidebar-content');
                const sidebarOverlay = $('#sidebar-overlay');

                
                sidebarContent.className = 'sidebar-content';

                
                if (appState.theme === 'neumorphic') {
                    sidebarContent.classList.add('neumorphic');
                }

                
                if (config.position === 'left') {
                    sidebarContent.classList.add('sidebar-from-left');
                } else {
                    sidebarContent.classList.remove('sidebar-from-left');
                }

                
                let actionsHtml = '';
                if (config.actions) {
                    actionsHtml = `<div class="modal-actions" style="margin-top: 30px;">` + config.actions.map((action, index) =>
                        `<button class="modal-btn ${action.class}" data-action-index="${index}">${action.text}</button>`
                    ).join('') + `</div>`;
                }
                sidebarContent.innerHTML = `
                    <h2 class="modal-header" style="text-align: left; padding-left: 0;">${config.title}</h2>
                    <div class="modal-body">${config.body}</div>
                    ${actionsHtml}
                `;

                
                if (config.actions) {
                    $$('#sidebar-content .modal-actions .modal-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const index = parseInt(btn.dataset.actionIndex, 10);
                            if (config.actions[index] && typeof config.actions[index].handler === 'function') {
                                config.actions[index].handler();
                            }
                        });
                    });
                }
                
                
                sidebarOverlay.classList.add('visible');
            },

            hideSidebar() {
                const sidebarOverlay = $('#sidebar-overlay');
                const sidebarContent = $('#sidebar-content');
                
                sidebarOverlay.classList.remove('visible');
                
                
                setTimeout(() => {
                    sidebarContent.classList.remove('sidebar-from-left');
                }, 400); 
            },

            showToast(message, duration = 1000) {
                
                const existingToast = $('#toast-notification');
                if (existingToast) {
                    existingToast.remove();
                }

                const toast = document.createElement('div');
                toast.id = 'toast-notification';
                toast.className = 'toast-notification';
                toast.textContent = message;

                
                document.body.appendChild(toast);

                
                setTimeout(() => {
                    
                    toast.classList.add('hiding');
                    
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300); 
                }, duration);
            },

            showTopNotification(msg) {
                this.notificationQueue.push(msg);
                this.processNotificationQueue();
            },

            showEssayNotification(authorName, contactId) {
                
                if ($('.essay-notification-banner')) return;

                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'essay-notification-banner';
                banner.innerHTML = `
                    <div class="icon-wrapper">
                        <i class="fas fa-heart"></i>
                    </div>
                    <span class="text-content">${authorName} æ›´æ–°äº†éšç¬”</span>
                `;

                
                banner.addEventListener('click', () => {
                    this.showPersonaModal(contactId);
                    hideAndRemove();
                });

                const hideAndRemove = () => {
                    if (container.contains(banner)) {
                         banner.style.animation = 'notification-exit 0.5s forwards';
                         setTimeout(() => {
                            if (container.contains(banner)) container.removeChild(banner);
                         }, 500);
                    }
                };
                
                container.appendChild(banner);

                
                setTimeout(() => {
                    banner.classList.add('is-playing');
                }, 10);

                
                setTimeout(hideAndRemove, 4000);
            },

            showPomodoroEndNotification(goal) {
                if ($('.pomodoro-notification-banner')) return;

                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'pomodoro-notification-banner';
                banner.innerHTML = `
                    <div class="icon-wrapper">
                        <i class="fas fa-clock"></i>
                    </div>
                    <span class="text-content">${goal} å·²ç»“æŸ</span>
                `;

                const hideAndRemove = () => {
                    if (container.contains(banner)) {
                         banner.style.animation = 'notification-exit 0.5s forwards';
                         setTimeout(() => {
                            if (container.contains(banner)) container.removeChild(banner);
                         }, 500);
                    }
                };
                
                container.appendChild(banner);

                setTimeout(() => {
                    banner.classList.add('is-playing');
                }, 10);

                setTimeout(hideAndRemove, 4000);
            },

            async showMomentNotification(moment) {
                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'notification-banner';

                const allContacts = await DBHelper.getAll('contacts');
                const author = allContacts.find(c => c.id === moment.authorId);
                
                if (!author) return;

                banner.innerHTML = `
                    <img src="${author.avatar}" alt="avatar" class="notification-avatar">
                    <div class="notification-content">
                        <div class="notification-header">
                            <span class="notification-name">${author.remark || author.name} å‘å¸ƒäº†æ–°åŠ¨æ€</span>
                        </div>
                        <p class="notification-message">${moment.content}</p>
                    </div>
                `;

                const hideAndRemove = () => {
                    if (container.contains(banner)) {
                         banner.style.animation = 'notification-exit 0.5s forwards';
                         setTimeout(() => {
                            if (container.contains(banner)) container.removeChild(banner);
                         }, 500);
                    }
                };

                banner.addEventListener('click', async () => {
                    await this.navigateTo('moments');
                    await this.renderMomentsPage(moment.circleId);
                    hideAndRemove();
                });
                
                container.appendChild(banner);

                setTimeout(hideAndRemove, 3000);
            },

            renderPomodoroPage() {
                const { isActive, goal } = appState.pomodoro;
                const timerDisplay = $('#pomodoro-timer-display');
                const goalInput = $('#pomodoro-goal-input');
                const startBtn = $('#pomodoro-start-btn');
                const stopBtn = $('#pomodoro-stop-btn');

                if (isActive) {
                    goalInput.value = goal;
                    goalInput.disabled = true;
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                } else {
                    timerDisplay.textContent = '25:00';
                    goalInput.value = '';
                    goalInput.disabled = false;
                    startBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'none';
                }
            },

            async processNotificationQueue() {
                if (this.isDisplayingNotification || this.notificationQueue.length === 0) {
                    return;
                }
                this.isDisplayingNotification = true;

                const msg = this.notificationQueue.shift();
                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'notification-banner';

                let messageContent = msg.content;
                if (msg.segmentType === 'emoji-image') messageContent = '[è¡¨æƒ…åŒ…]';
                else if (msg.segmentType === 'voice') messageContent = msg.cardData.content;
                else if (msg.isRetracted) messageContent = 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯';
                
                let notificationAvatar, notificationName, clickTargetId;
                const isGroup = msg.chatId && msg.chatId.startsWith('group-');
                clickTargetId = msg.chatId;

                if (isGroup) {
                    const group = await DBHelper.get('groups', msg.chatId);
                    if (group) {
                        notificationAvatar = group.avatar;
                        notificationName = group.name;
                        const senderName = msg.senderInfo.remark || msg.senderInfo.name;
                        messageContent = `${senderName}ï¼š${messageContent}`;
                    } else { 
                        notificationAvatar = msg.senderInfo.avatar;
                        notificationName = msg.senderInfo.remark || msg.senderInfo.name;
                    }
                } else {
                    notificationAvatar = msg.senderInfo.avatar;
                    notificationName = msg.senderInfo.remark || msg.senderInfo.name;
                }

                banner.innerHTML = `
                    <img src="${notificationAvatar}" alt="avatar" class="notification-avatar">
                    <div class="notification-content">
                        <div class="notification-header">
                            <span class="notification-name">${notificationName}</span>
                            <span class="notification-time">${Utils.formatTimestampSmartly(msg.timestamp)}</span>
                        </div>
                        <p class="notification-message">${messageContent}</p>
                    </div>
                `;

                const hideAndProcessNext = () => {
                    if (!container.contains(banner)) return;
                    clearTimeout(autoHideTimeout);
                    banner.style.animation = 'notification-exit 0.5s forwards';
                    setTimeout(() => {
                        if (container.contains(banner)) container.removeChild(banner);
                        this.isDisplayingNotification = false;
                        setTimeout(() => this.processNotificationQueue(), 200);
                    }, 500);
                };
                
                const displayDuration = this.notificationQueue.length > 0 ? 1000 : 5000;
                const autoHideTimeout = setTimeout(hideAndProcessNext, displayDuration);

                banner.addEventListener('click', () => {
                    this.openChat(clickTargetId);
                    hideAndProcessNext();
                });

                container.appendChild(banner);
            },

            async showContactInfo(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                const bodyHtml = `
                    <div class="details-card">
                        <div class="details-header">
                            <img src="${contact.avatar}" class="avatar">
                            <div class="details-info">
                                <div class="name">${contact.remark || contact.name}</div>
                                <div class="id">ID: ${contact.name}</div>
                            </div>
                        </div>
                         <div class="details-field"><span class="label">æ€§åˆ«</span><span class="value">${contact.gender}</span></div>
                    </div>
                    <div class="details-card">
                       ${contact.likes ? `<div class="details-field"><span class="label">å–œå¥½</span><span class="value">${contact.likes}</span></div>` : ''}
                       ${contact.dislikes ? `<div class="details-field"><span class="label">åŒæ¶</span><span class="value">${contact.dislikes}</span></div>` : ''}
                       ${contact.habits ? `<div class="details-field"><span class="label">ä¹ æƒ¯</span><span class="value">${contact.habits}</span></div>` : ''}
                       ${contact.background ? `<div class="details-section">
                            <div class="details-section-title">èƒŒæ™¯èµ„æ–™</div>
                            <p>${contact.background}</p>
                        </div>` : ''}
                    </div>
                    <div class="details-actions">
                        <button class="details-btn btn-details-primary" data-action="chat">å‘æ¶ˆæ¯</button>
                        <button class="details-btn" data-action="export" style="border-color: var(--theme-color-4); color: var(--text-color-dark);">å¯¼å‡ºè§’è‰²</button>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                             <button class="details-btn" data-action="edit" style="flex: 1;">ç¼–è¾‘</button>
                             <button class="details-btn btn-details-danger" data-action="delete" style="flex: 1;">åˆ é™¤å¥½å‹</button>
                        </div>
                    </div>
                `;

                this.showModal({
                    
                    title: `
                        <span style="flex-grow: 1;">è¯¦ç»†èµ„æ–™</span>
                        ${contact.author ? `<div class="details-header-attribution" data-action="show-attribution" title="æŸ¥çœ‹ä½œè€…ä¿¡æ¯" style="position: static; transform: none;">?</div>` : ''}
                    `,
                    body: bodyHtml,
                    actions: [] 
                });

                
                modalContentWrapper.querySelector('.modal-header').style.display = 'flex';
                modalContentWrapper.querySelector('.modal-header').style.alignItems = 'center';
                
                
                modalContentWrapper.querySelector('[data-action="chat"]').addEventListener('click', () => {
                    this.hideModal();
                    this.openChat(contactId);
                });
                modalContentWrapper.querySelector('[data-action="edit"]').addEventListener('click', () => {
                    this.hideModal();
                    
                    EventManager.showEditFriendModal(contactId, async () => {
                        await UIManager.renderContactsPage('friends');
                    });
                });
                modalContentWrapper.querySelector('[data-action="delete"]').addEventListener('click', async () => {
                    const groups = await DBHelper.getAll('groups');
                    const isInGroup = groups.some(g => g.members.includes(contactId));
                    this.confirmDeleteContact(contactId, isInGroup);
                });
                modalContentWrapper.querySelector('[data-action="export"]').addEventListener('click', () => EventManager.handleExportContact(contactId));
                
                const attributionBtn = modalContentWrapper.querySelector('[data-action="show-attribution"]');
                if (attributionBtn) {
                    attributionBtn.addEventListener('click', () => EventManager.showAttributionModal(contact));
                }
            },
            
            async showGroupInfo(groupId) {
                const group = await DBHelper.get('groups', groupId);
                if (!group) return;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                let creatorName = 'æœªçŸ¥';
                if (group.creatorId === myProfile.id) {
                    creatorName = `æˆ‘ (${myProfile.name})`;
                } else {
                    const creatorContact = allContacts.find(c => c.id === group.creatorId);
                    if (creatorContact) creatorName = creatorContact.remark || creatorContact.name;
                }
                
                const membersDetails = group.members
                    .map(memberId => allContacts.find(c => c.id === memberId))
                    .filter(Boolean);

                const membersHtml = membersDetails.map(member => `
                    <div class="member-item">
                        <img src="${member.avatar}" class="avatar" alt="${member.name}">
                        <span class="name">${member.remark || member.name}</span>
                    </div>
                `).join('');

                const isMyGroup = group.creatorId === myProfile.id;

                const bodyHtml = `
                    <div class="details-card">
                        <div class="details-header">
                            <img src="${group.avatar}" class="avatar">
                            <div class="details-info">
                                <div class="name">${group.name}</div>
                                <div class="id">ç¾¤ä¸»: ${creatorName}</div>
                            </div>
                        </div>
                    </div>
                    <div class="details-card">
                        <div class="details-section-title">ç¾¤æˆå‘˜ (${group.members.length})</div>
                        <div class="member-grid">${membersHtml}</div>
                    </div>
                    <div class="details-actions">
                        <button class="details-btn btn-details-primary" data-action="chat">å‘æ¶ˆæ¯</button>
                        <button class="details-btn" data-action="export" style="border-color: var(--theme-color-4); color: var(--text-color-dark);">å¯¼å‡ºç¾¤èŠ</button>
                        <button class="details-btn btn-details-danger" data-action="delete">${isMyGroup ? 'è§£æ•£ç¾¤èŠ' : 'é€€å‡ºç¾¤èŠ'}</button>
                    </div>
                `;

                this.showModal({
                    title: `
                        <span style="flex-grow: 1;">ç¾¤èŠèµ„æ–™</span>
                        ${group.author ? `<div class="details-header-attribution" data-action="show-attribution" title="æŸ¥çœ‹ä½œè€…ä¿¡æ¯" style="position: static; transform: none;">?</div>` : ''}
                    `,
                    body: bodyHtml,
                    actions: []
                });

                
                modalContentWrapper.querySelector('.modal-header').style.display = 'flex';
                modalContentWrapper.querySelector('.modal-header').style.alignItems = 'center';

                modalContentWrapper.querySelector('[data-action="chat"]').addEventListener('click', () => {
                    this.hideModal();
                    this.openChat(groupId);
                });
                modalContentWrapper.querySelector('[data-action="delete"]').addEventListener('click', () => {
                    this.confirmDeleteGroup(groupId, isMyGroup);
                });
                modalContentWrapper.querySelector('[data-action="export"]').addEventListener('click', () => EventManager.handleExportGroup(groupId));

                const attributionBtn = modalContentWrapper.querySelector('[data-action="show-attribution"]');
                if (attributionBtn) {
                    attributionBtn.addEventListener('click', () => EventManager.showAttributionModal(group));
                }
            },
            
            confirmDeleteGroup(groupId, isCreator, onCancel) { 
                const actionText = isCreator ? 'è§£æ•£' : 'é€€å‡º';
                this.showModal({
                    title: `ç¡®è®¤${actionText}`,
                    body: `<p>ä½ ç¡®å®šè¦${actionText}æ­¤ç¾¤èŠå—ï¼Ÿæ‰€æœ‰èŠå¤©è®°å½•å°†è¢«æ¸…ç©ºä¸”æ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            this.hideModal();
                            if (onCancel) {
                                onCancel();
                            } else {
                                this.showGroupInfo(groupId);
                            }
                        }},
                        { text: `ç¡®è®¤${actionText}`, class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('groups', groupId);
                            await DBHelper.delete('chatMetadata', groupId);
                            await DBHelper.deleteMessagesForChat(groupId); 
                            this.hideModal();
                            this.hideSidebar();
                            
                            await this.navigateTo('contacts');
                            await this.renderContactsPage('groups');
                            await this.renderMessagesListPage(); 
                        }}
                    ]
                });
            },
            async confirmDeleteContact(contactId, isInGroup) {
                if (isInGroup) {
                    const groups = (await DBHelper.getAll('groups')).filter(g => g.members.includes(contactId));
                    const groupNames = groups.map(g => g.name).join('ã€');
                    this.showModal({
                        title: "æ— æ³•åˆ é™¤",
                        body: `<p>æ— æ³•åˆ é™¤å¥½å‹ï¼Œå› ä¸ºå¯¹æ–¹ä»åœ¨ç¾¤èŠï¼š<strong>${groupNames}</strong> ä¸­ã€‚è¯·å…ˆå°†å…¶ç§»å‡ºç¾¤èŠæˆ–è§£æ•£ç¾¤èŠã€‚</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => this.showContactInfo(contactId) }]
                    });
                    return;
                }
                
                this.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤è¯¥å¥½å‹å—ï¼Ÿæ‰€æœ‰èŠå¤©è®°å½•å°†è¢«æ¸…ç©ºä¸”æ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => this.showContactInfo(contactId) },
                        { text: 'ç¡®è®¤åˆ é™¤', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('contacts', contactId);
                            await DBHelper.delete('chatMetadata', contactId);
                            await DBHelper.deleteMessagesForChat(contactId); 
                            this.hideModal();
                            await this.renderContactsPage();
                            await this.renderMessagesListPage(); 
                        }}
                    ]
                });
            },
            async showGroupManagementSidebar(group) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const isMyGroup = group.creatorId === myProfile.id;
                
                
                this.showSidebar({
                    position: 'right', 
                    title: "ç¾¤èŠç®¡ç†",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-edit-group">
                                <i class="fas fa-edit"></i>
                                <span>ä¿®æ”¹ç¾¤èŠä¿¡æ¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-view-members">
                                <i class="fas fa-users"></i>
                                <span>æŸ¥çœ‹ç¾¤æˆå‘˜</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-invite-members">
                                <i class="fas fa-user-plus"></i>
                                <span>é‚€è¯·æ–°æˆå‘˜</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            ${isMyGroup ? `
                            <div class="setting-item" id="sidebar-remove-members">
                                <i class="fas fa-user-minus"></i>
                                <span>ç§»é™¤ç¾¤æˆå‘˜</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            ` : ''}
                            <div class="setting-item" id="sidebar-bind-prompts">
                                <i class="fas fa-link"></i>
                                <span>ç»‘å®šæç¤ºè¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-persona">
                                <i class="fas fa-user-tag"></i>
                                <span>ç»‘å®šç©å®¶äººè®¾</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-opening-scene">
                                <i class="fas fa-scroll"></i>
                                <span>å¼€åœºç™½è®¾å®š</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-chat-background">
                                <i class="fas fa-image"></i>
                                <span>ä¸“å±èŠå¤©èƒŒæ™¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
<div class="setting-item" id="sidebar-auto-summary">
    <i class="fas fa-file-alt"></i>
    <span>è‡ªåŠ¨æ€»ç»“</span>
    <i class="fas fa-chevron-right"></i>
</div>
<div class="setting-item" id="sidebar-forward-chat">
                                <i class="fas fa-share-square"></i>
                                <span>å¤šé€‰æ¶ˆæ¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-clear-history-group">
                                <i class="fas fa-eraser"></i>
                                <span>æ¸…ç©ºèŠå¤©è®°å½•</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-leave-group">
                                <i class="fas ${isMyGroup ? 'fa-dumpster-fire' : 'fa-door-open'}"></i>
                                <span>${isMyGroup ? 'è§£æ•£ç¾¤èŠ' : 'é€€å‡ºç¾¤èŠ'}</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
                
                
                $('#sidebar-edit-group').addEventListener('click', () => {
                    this.showModal({
                        title: "ä¿®æ”¹ç¾¤èŠä¿¡æ¯",
                        body: `
                            <div class="form-group">
                                <label>ç¾¤å¤´åƒ</label>
                                <div class="avatar-uploader">
                                    <img src="${group.avatar}" id="group-manage-avatar-preview" class="avatar-preview">
                                    <input type="file" id="group-manage-avatar-input" accept="image/*" style="display:none;">
                                    <button class="upload-btn" onclick="document.getElementById('group-manage-avatar-input').click()">ä¸Šä¼ æ–°å¤´åƒ</button>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="group-manage-name">ç¾¤åç§°</label>
                                <input type="text" id="group-manage-name" value="${group.name}">
                            </div>
                        `,
                        actions: [
                            { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => this.hideModal() },
                            { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                                const newName = $('#group-manage-name').value.trim();
                                if (!newName) return;
                                const oldName = group.name;
                                const updatedGroup = { ...group, name: newName, avatar: $('#group-manage-avatar-preview').src };
                                await DBHelper.put('groups', updatedGroup);
                                chatTitle.textContent = newName;

                                if (oldName !== newName) {
                                    const myProfile = await DBHelper.get('profile', 'myProfile');
                                    const systemMessage = {
                                        messageId: Utils.generateId('msg'),
                                        chatId: group.id, 
                                        content: `${myProfile.name} ä¿®æ”¹ç¾¤åä¸º â€œ${newName}â€`,
                                        timestamp: Date.now(),
                                        type: 'received',
                                        segmentType: 'system',
                                        forAi: true,
                                    };
                                    
                                    await DBHelper.put('messages', systemMessage);
                                    
                                    await UIManager.updateChatMetadata(group.id, systemMessage);
                                    
                                    if (appState.currentChatId === group.id) {
                                        await UIManager.refreshChatView();
                                    }
                                }
                                this.hideModal();
                            }}
                        ]
                    });
                     $('#group-manage-avatar-input').addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) $('#group-manage-avatar-preview').src = await Utils.fileToBase64(file);
                    });
                });
                
                $('#sidebar-view-members').addEventListener('click', () => this.showGroupMemberListModal(group.id));
                $('#sidebar-invite-members').addEventListener('click', () => EventManager.handleInviteMembers(group.id));
                if (isMyGroup) {
                    $('#sidebar-remove-members').addEventListener('click', () => EventManager.handleRemoveMembers(group.id));
                }
                $('#sidebar-bind-prompts').addEventListener('click', () => EventManager.showBindingModal(group.id)); 
                $('#sidebar-bind-persona').addEventListener('click', () => EventManager.showPersonaBindingModal(group.id, true));
                $('#sidebar-opening-scene').addEventListener('click', () => EventManager.handleOpeningSceneSettings(group.id, true));
                $('#sidebar-chat-background').addEventListener('click', () => EventManager.handleChatBackgroundSettings(group.id, true));
                $('#sidebar-auto-summary').addEventListener('click', () => EventManager.handleAutoSummarySettings(group.id, true));
                $('#sidebar-forward-chat').addEventListener('click', () => {
                    UIManager.hideSidebar();
                    EventManager.toggleSelectionMode();
                });
                $('#sidebar-clear-history-group').addEventListener('click', () => EventManager.handleClearChatHistory(group.id, true));
                $('#sidebar-leave-group').addEventListener('click', () => {
                    this.confirmDeleteGroup(group.id, isMyGroup, () => this.showGroupManagementSidebar(group));
                });
            },

            async showGroupInsightModal(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');

                const members = group.members
                    .map(id => allContacts.find(c => c.id === id))
                    .filter(Boolean);

                const membersHtml = members.map(member => `
                    <div class="insight-member-item">
                        <img src="${member.avatar}" alt="${member.name}">
                        <span>${member.remark || member.name}</span>
                        <button class="modal-btn btn-secondary insight-view-btn" data-member-id="${member.id}">æŸ¥çœ‹</button>
                    </div>
                `).join('');

                this.showModal({
                    title: "é€‰æ‹©æˆå‘˜è¿›è¡Œæ´å¯Ÿ",
                    body: `<div class="insight-member-list">${membersHtml}</div>`,
                    actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => this.hideModal() }]
                });

                
                const modalBody = modalContentWrapper.querySelector('.modal-body');
                if (modalBody) {
                    modalBody.addEventListener('click', (e) => {
                        const viewBtn = e.target.closest('.insight-view-btn');
                        if (viewBtn) {
                            const memberId = viewBtn.dataset.memberId;
                            this.hideModal();
                            
                            this.showPersonaModal(memberId, null, true); 
                        }
                    });
                }
            },

            async showGroupMemberListModal(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                
                const aiMembers = group.members
                    .map(id => allContacts.find(c => c.id === id))
                    .filter(Boolean);

                
                const playerAsMember = {
                    id: myProfile.id,
                    avatar: myProfile.avatar,
                    name: myProfile.name,
                    isPlayer: true
                };

                
                const allParticipants = [...aiMembers, playerAsMember];

                
                let owner;
                const otherMembers = [];
                allParticipants.forEach(p => {
                    if (p.id === group.creatorId) {
                        owner = p;
                    } else {
                        otherMembers.push(p);
                    }
                });
                
                
                const finalOrderedList = owner ? [owner, ...otherMembers] : otherMembers;

                
                const membersHtml = finalOrderedList.map(member => `
                    <div class="member-list-modal-item">
                        <img src="${member.avatar}" alt="${member.name}">
                        <span>${member.remark || member.name}</span>
                        ${member.id === group.creatorId ? '<span class="owner-tag">ç¾¤ä¸»</span>' : ''}
                        ${member.isPlayer ? '<span class="owner-tag" style="background-color: var(--accent-color);">ä½ </span>' : ''}
                    </div>
                `).join('');

                this.showModal({
                    title: `ç¾¤æˆå‘˜ (${finalOrderedList.length})`,
                    body: `<div class="member-list-modal-body"><ul>${membersHtml}</ul></div>`,
                    actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => this.hideModal() }]
                });
            },

            async showFriendManagementSidebar(contact) {
                 this.showSidebar({
                    position: 'right', 
                    title: "å¥½å‹ç®¡ç†",
                     body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-view-friend">
                                <i class="fas fa-info-circle"></i>
                                <span>æŸ¥çœ‹è¯¦ç»†èµ„æ–™</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-edit-friend">
                                <i class="fas fa-user-edit"></i>
                                <span>ä¿®æ”¹å¥½å‹ä¿¡æ¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-persona-friend">
                                <i class="fas fa-user-tag"></i>
                                <span>ç»‘å®šç©å®¶äººè®¾</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-prompts">
                                <i class="fas fa-link"></i>
                                <span>ç»‘å®šæç¤ºè¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-opening-scene-friend">
                                <i class="fas fa-scroll"></i>
                                <span>å¼€åœºç™½è®¾å®š</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-chat-background">
                                <i class="fas fa-image"></i>
                                <span>ä¸“å±èŠå¤©èƒŒæ™¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-auto-summary">
    <i class="fas fa-file-alt"></i>
    <span>è‡ªåŠ¨æ€»ç»“</span>
    <i class="fas fa-chevron-right"></i>
</div>
                            <div class="setting-item" id="sidebar-bind-circle">
                                <i class="fas fa-link"></i>
                                <span>ç»‘å®šæœ‹å‹åœˆ</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-forward-chat-friend">
                                <i class="fas fa-share-square"></i>
                                <span>å¤šé€‰æ¶ˆæ¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-clear-history-friend">
                                <i class="fas fa-eraser"></i>
                                <span>æ¸…ç©ºèŠå¤©è®°å½•</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-delete-friend">
                                <i class="fas fa-user-times"></i>
                                <span>åˆ é™¤å¥½å‹</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });

                $('#sidebar-view-friend').addEventListener('click', () => {
                     this.showModal({
                        title: "è¯¦ç»†èµ„æ–™",
                        body: `
                            <div class="details-card">
                                <div class="details-header"><img src="${contact.avatar}" class="avatar"><div class="details-info"><div class="name">${contact.remark || contact.name}</div><div class="id">ID: ${contact.name}</div></div></div>
                                <div class="details-field"><span class="label">æ€§åˆ«</span><span class="value">${contact.gender}</span></div>
                            </div>
                            <div class="details-card">
                               ${contact.likes ? `<div class="details-field"><span class="label">å–œå¥½</span><span class="value">${contact.likes}</span></div>` : ''}
                               ${contact.dislikes ? `<div class="details-field"><span class="label">åŒæ¶</span><span class="value">${contact.dislikes}</span></div>` : ''}
                               ${contact.habits ? `<div class="details-field"><span class="label">ä¹ æƒ¯</span><span class="value">${contact.habits}</span></div>` : ''}
                               ${contact.background ? `<div class="details-section"><div class="details-section-title">èƒŒæ™¯èµ„æ–™</div><p>${contact.background}</p></div>` : ''}
                            </div>
                        `,
                        actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                });

                $('#sidebar-edit-friend').addEventListener('click', () => {
                    EventManager.showEditFriendModal(contact.id);
                });
                
                $('#sidebar-bind-persona-friend').addEventListener('click', () => EventManager.showPersonaBindingModal(contact.id, false));
                
                $('#sidebar-bind-prompts').addEventListener('click', () => EventManager.showBindingModal(contact.id)); 
                $('#sidebar-opening-scene-friend').addEventListener('click', () => EventManager.handleOpeningSceneSettings(contact.id, false));
                $('#sidebar-chat-background').addEventListener('click', () => EventManager.handleChatBackgroundSettings(contact.id, false));
                $('#sidebar-auto-summary').addEventListener('click', () => EventManager.handleAutoSummarySettings(contact.id, false));
                $('#sidebar-bind-circle').addEventListener('click', () => EventManager.showCircleBindingModal(contact.id, false));
                $('#sidebar-forward-chat-friend').addEventListener('click', () => {
                    UIManager.hideSidebar();
                    EventManager.toggleSelectionMode();
                });
                $('#sidebar-clear-history-friend').addEventListener('click', () => EventManager.handleClearChatHistory(contact.id, false));
                $('#sidebar-delete-friend').addEventListener('click', async () => {
                    const groups = await DBHelper.getAll('groups');
                    const isInGroup = groups.some(g => g.members.includes(contact.id));
                    UIManager.confirmDeleteContact(contact.id, isInGroup);
                });
            },


            async confirmDeleteContact(contactId, isInGroup) {
                if (isInGroup) {
                    const groups = (await DBHelper.getAll('groups')).filter(g => g.members.includes(contactId));
                    const groupNames = groups.map(g => g.name).join('ã€');
                    UIManager.showModal({
                        title: "æ— æ³•åˆ é™¤",
                        body: `<p>æ— æ³•åˆ é™¤å¥½å‹ï¼Œå› ä¸ºå¯¹æ–¹ä»åœ¨ç¾¤èŠï¼š<strong>${groupNames}</strong> ä¸­ã€‚è¯·å…ˆå°†å…¶ç§»å‡ºæˆ–è§£æ•£ç›¸å…³ç¾¤èŠã€‚</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }
                
                UIManager.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤è¯¥å¥½å‹å—ï¼Ÿæ‰€æœ‰èŠå¤©è®°å½•å°†è¢«æ¸…ç©ºä¸”æ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤åˆ é™¤', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('contacts', contactId);
                            await DBHelper.delete('chatMetadata', contactId);
                            await DBHelper.deleteMessagesForChat(contactId);
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.navigateTo('messages');
                            await UIManager.renderContactsPage();
                            await UIManager.renderMessagesListPage();
                        }}
                    ]
                });
            },

async showAutoSummaryModal(entityId, isGroup) {
    const storeName = isGroup ? 'groups' : 'contacts';
    const entity = await DBHelper.get(storeName, entityId);
    if (!entity) return;

    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
    const defaultSummaryPrompt = `ä½ æ˜¯ä¸€ä¸ªèŠå¤©è®°å½•æ€»ç»“åŠ©æ‰‹ã€‚è¯·æ ¹æ®â€œæœ€æ–°èŠå¤©è®°å½•â€ï¼Œä¸ºæˆ‘ç”Ÿæˆä¸€æ®µä¸è¶…è¿‡350ä¸ªå­—çš„æ–°æ€»ç»“ã€‚æ–°çš„æ€»ç»“éœ€è¦èåˆæ—§æ€»ç»“çš„æ ¸å¿ƒå†…å®¹å’Œæ–°èŠå¤©è®°å½•çš„è¦ç‚¹ï¼Œä¿æŒæ•…äº‹çš„è¿è´¯æ€§ã€‚è¯·é‡ç‚¹å…³æ³¨æ—¶é—´çš„å‘ç”Ÿæ—¶é—´ã€äººç‰©å…³ç³»çš„å˜åŒ–ã€å…³é”®äº‹ä»¶çš„è¿›å±•ã€ä»¥åŠé‡è¦ä¿¡æ¯çš„äº¤æ¢ã€‚å†…å®¹åº”å®¢è§‚ã€ä¿¡æ¯ä¸°å¯Œä¸”å‡ç»ƒã€‚`;
    const userSummaryPrompt = chatSettings.summaryPrompt || defaultSummaryPrompt;

    const summaryEnabled = entity.autoSummaryEnabled || false;
    const summaryText = entity.autoSummary || '';
    const isSummarizing = appState.isSummarizing[entityId] || false;

    const summaryStatusHtml = isSummarizing ? `
        <div style="display: flex; align-items: center; gap: 8px; font-size: 0.9rem; color: var(--accent-color); margin-top: 10px;">
            <div class="loader-spinner" style="width: 16px; height: 16px; border-width: 2px;"></div>
            <span>AIæ­£åœ¨æ€»ç»“ä¸­ï¼Œè¯·ç¨å...</span>
        </div>
    ` : '';

    UIManager.showModal({
        title: "è‡ªåŠ¨æ€»ç»“è®¾ç½®",
        body: `
            <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                <label style="margin: 0;">å¯ç”¨è‡ªåŠ¨æ€»ç»“</label>
                <label class="switch">
                    <input type="checkbox" id="auto-summary-switch" ${summaryEnabled ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
            </div>
            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: -10px; margin-bottom: 20px;">
                å¼€å¯åï¼Œæ¯éš”Næ¡æ¶ˆæ¯(åŒ…å«ä½ å’ŒAI é»˜è®¤å€¼200)ï¼ŒAIä¼šè‡ªåŠ¨æ€»ç»“ä¸€æ¬¡èŠå¤©å†…å®¹ã€‚ä½ å¯ä»¥åœ¨â€œèŠå¤©è®¾ç½®â€ä¸­ä¿®æ”¹æ­¤é—´éš”ã€‚
            </p>
            <div class="form-group">
                <label for="summary-prompt-input">æ€»ç»“æç¤ºè¯ (å¯ä¿®æ”¹)</label>
                <textarea id="summary-prompt-input" rows="6">${userSummaryPrompt}</textarea>
            </div>
            <button id="immediate-summary-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 20px;" ${isSummarizing ? 'disabled' : ''}>
                <i class="fas fa-magic"></i> ç«‹å³æ€»ç»“
            </button>
            <div class="form-group">
                <label for="auto-summary-content">å½“å‰æ€»ç»“å†…å®¹ (å¯ç¼–è¾‘)</label>
                <textarea id="auto-summary-content" rows="8" placeholder="æš‚æ— æ€»ç»“å†…å®¹..." ${isSummarizing ? 'readonly' : ''}>${summaryText}</textarea>
                ${summaryStatusHtml}
            </div>
        `,
        actions: [
            { text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() },
            { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                if (isSummarizing) {
                    return UIManager.showToast("æ­£åœ¨æ€»ç»“ä¸­ï¼Œè¯·ç¨åå†ä¿å­˜ã€‚");
                }
                const updatedEntity = await DBHelper.get(storeName, entityId);
                updatedEntity.autoSummaryEnabled = $('#auto-summary-switch').checked;
                updatedEntity.autoSummary = $('#auto-summary-content').value.trim();
                await DBHelper.put(storeName, updatedEntity);
                
                const currentChatSettings = await DBHelper.get('apiConfig', 'chatSettings') || { id: 'chatSettings' };
                currentChatSettings.summaryPrompt = $('#summary-prompt-input').value.trim();
                await DBHelper.put('apiConfig', currentChatSettings);

                UIManager.hideModal();
                UIManager.showToast("è®¾ç½®å·²ä¿å­˜ï¼");
            }}
        ]
    });

    $('#immediate-summary-btn').addEventListener('click', () => {
        EventManager.handleImmediateSummary(entityId, isGroup);
    });
},

            async showOpeningSceneModal(entityId, isGroup) {
                const scenes = (await DBHelper.getAll('openingScenes')).filter(s => {
                    return isGroup ? s.groupId === entityId : s.contactId === entityId;
                });

                let scenesHtml = scenes.map(scene => `
                    <div class="details-card" style="padding: 15px; margin-bottom: 15px;">
                        <h4 style="margin-bottom: 10px; font-size: 1.1rem;">${scene.name}</h4>
                        <p style="font-size: 0.9rem; color: var(--text-color-medium); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${scene.content}
                        </p>
                        <div class="modal-actions" style="margin-top: 15px; justify-content: flex-end; gap: 8px;">
                            <button class="modal-btn btn-danger" data-action="delete" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">åˆ é™¤</button>
                            <button class="modal-btn btn-secondary" data-action="edit" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">ç¼–è¾‘</button>
                            <button class="modal-btn btn-primary" data-action="apply" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">åº”ç”¨</button>
                        </div>
                    </div>
                `).join('');

                if (scenes.length === 0) {
                    scenesHtml = `<p style="text-align: center; color: #aaa; padding: 20px 0;">è¿˜æ²¡æœ‰å¼€åœºç™½ï¼Œå¿«æ¥åˆ›å»ºä¸€ä¸ªå§ï¼</p>`;
                }

                this.showModal({
                    title: "å¼€åœºç™½è®¾å®š",
                    body: `
                        <div id="opening-scene-list">${scenesHtml}</div>
                    `,
                    actions: [
                        { text: 'æ–°å»ºå¼€åœºç™½', class: 'btn-primary', handler: () => EventManager.handleNewOpeningScene(entityId, isGroup) }
                    ]
                });

                
                $('#opening-scene-list').addEventListener('click', async (e) => {
                    const button = e.target.closest('button');
                    if (!button) return;

                    const action = button.dataset.action;
                    const sceneId = button.dataset.sceneId;

                    if (action === 'delete') {
                        EventManager.handleDeleteOpeningScene(sceneId, entityId, isGroup);
                    } else if (action === 'edit') {
                        const scene = await DBHelper.get('openingScenes', sceneId);
                        EventManager.handleEditOpeningScene(scene, isGroup);
                    } else if (action === 'apply') {
                        const scene = await DBHelper.get('openingScenes', sceneId);
                        EventManager.handleApplyOpeningScene(scene);
                    }
                });
            },


            async renderMomentsPage(circleId = null) {
                
                if (circleId) {
                    appState.currentCircleId = circleId;
                } else if (!appState.currentCircleId) {
                    const circles = await DBHelper.getAll('circles');
                    if (circles.length > 0) {
                        appState.currentCircleId = circles[0].id; 
                    } else {
                        
                        $('#moments-list').innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•åœˆå­ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’èœå•å»åˆ›å»ºä¸€ä¸ªå§ï¼</li>`;
                        return;
                    }
                }

                
                const currentCircle = await DBHelper.get('circles', appState.currentCircleId);
                
                
                
                
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile }; 

                if (currentCircle && currentCircle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === currentCircle.boundPersonaPresetId);
                    if (boundPreset) {
                        
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                

                if (!currentCircle) {
                     $('#moments-list').innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">åœˆå­ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤ã€‚</li>`;
                     appState.currentCircleId = null; 
                     
                     $('#moments-my-name').textContent = myProfile.name;
                     $('#moments-my-avatar').src = myProfile.avatar;
                     return;
                }

                const moments = (await DBHelper.getAll('moments')).filter(m => m.circleId === appState.currentCircleId).sort((a, b) => b.timestamp - a.timestamp);
                const allContacts = await DBHelper.getAll('contacts');

                
                $('#moments-bg').src = currentCircle.backgroundImage || 'https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png';
                $('#moments-my-name').textContent = myProfile.name;
                $('#moments-my-avatar').src = myProfile.avatar;

                
                const momentsListUl = $('#moments-list');
                momentsListUl.innerHTML = '';
                if (moments.length === 0) {
                    momentsListUl.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">è¿™ä¸ªåœˆå­è¿˜æ²¡æœ‰åŠ¨æ€ï¼Œ<br>ç‚¹å‡»å³ä¸Šè§’åˆ·æ–°ä¸€ä¸‹è¯•è¯•ï¼Ÿ</li>`;
                } else {
                    for (const moment of moments) {
                        const momentElement = this.createMomentElement(moment, myProfile, allContacts, currentCircle.extraMembers);
                        momentsListUl.appendChild(momentElement);
                    }
                }
            },

            createMomentElement(moment, myProfile, allContacts, extraMembersStr) {
                const li = document.createElement('li');
                li.className = 'moments-post';
                li.dataset.momentId = moment.id;

                
                let author;
                if (moment.authorId === myProfile.id) {
                    author = myProfile;
                } else {
                    const contactAuthor = allContacts.find(c => c.id === moment.authorId);
                    if (contactAuthor) {
                        author = contactAuthor;
                    } else if (extraMembersStr && extraMembersStr.includes(moment.authorId)) {
                        author = { id: moment.authorId, name: moment.authorId, avatar: Utils.createAvatarDataUrl(Utils.getRandomColor()) };
                    } else {
                        author = { id: moment.authorId, name: 'æœªçŸ¥ç”¨æˆ·', avatar: Utils.createAvatarDataUrl('#ccc') };
                    }
                }
                
                
                let imagesHtml = '';
                if (moment.images && moment.images.length > 0) {
                    const gridClass = `grid-${moment.images.length > 9 ? 9 : moment.images.length}`;
                    imagesHtml = `
                        <div class="post-images-grid ${gridClass}">
                            ${moment.images.map(src => `<img src="${src}" alt="åŠ¨æ€å›¾ç‰‡">`).join('')}
                        </div>`;
                }
                
                
                const hasLikes = moment.likes && moment.likes.length > 0;
                const hasComments = moment.comments && moment.comments.length > 0;
                const playerHasLiked = moment.likes && moment.likes.includes(myProfile.name);

                let likesHtml = '';
                if (hasLikes) {
                    likesHtml = `<div class="post-likes"><i class="fas fa-heart"></i> ${moment.likes.join(', ')}</div>`;
                }

                let commentsHtml = '';
                if (hasComments) {
                    commentsHtml = moment.comments.map(comment => {
                         let commentAuthor;
                         
                         if (comment.authorId === myProfile.id) {
                            commentAuthor = myProfile;
                         } else {
                            
                            const contactCommenter = allContacts.find(c => c.id === comment.authorId);
                            if (contactCommenter) {
                                commentAuthor = contactCommenter;
                            } else {
                                
                                
                                commentAuthor = { name: comment.authorId, id: comment.authorId };
                            }
                         }
                         
                         const authorStyle = commentAuthor.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';
                         const replyHtml = comment.replyTo ? `<span class="comment-reply-to"> å›å¤ </span><span class="comment-author">${comment.replyTo}:</span>` : ':';

                         return `<div class="post-comment-item" data-author-name="${commentAuthor.name}" data-author-id="${commentAuthor.id}">
                                    <span class="comment-author" ${authorStyle}>${commentAuthor.name}</span>${replyHtml} ${comment.content}
                                </div>`;
                    }).join('');
                }
                
                const authorStyle = author.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';

                const isMyPost = author.id === myProfile.id;

                li.innerHTML = `
                    <img src="${author.avatar}" alt="ä½œè€…å¤´åƒ" class="post-avatar">
                    <div class="post-main-content">
                        <div class="post-author-name" ${authorStyle}>${author.name}</div>
                        <div class="post-text">${moment.content}</div>
                        ${imagesHtml}
                        <div class="post-footer">
                            <span class="post-timestamp">${Utils.formatTimestampSmartly(moment.timestamp)}</span>
                        <div class="action-buttons-wrapper">
                            <button class="post-action-icon-btn" data-action="delete-moment" title="åˆ é™¤">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                            <button class="post-action-icon-btn" data-action="forward" title="è½¬å‘">
                                <i class="fas fa-share"></i>
                            </button>
                            <button class="post-action-icon-btn ${playerHasLiked ? 'liked' : ''}" data-action="like" title="ç‚¹èµ">
                                <i class="far fa-heart"></i>
                            </button>
                            <button class="post-actions-btn" data-action="toggle-comment" title="è¯„è®º">
                                <i class="fas fa-comment-dots"></i>
                            </button>
                        </div>
                      </div>
                        ${(hasLikes || hasComments) ? `
                        <div class="post-interactions">
                            ${likesHtml}
                            <div class="post-comments-list">${commentsHtml}</div>
                            <div class="comment-input-wrapper">
                                <input type="text" placeholder="è¯„è®º...">
                                <button data-action="submit-comment">å‘é€</button>
                            </div>
                        </div>
                        ` : `
                        <div class="post-interactions" style="display:none;">
                            <div class="post-likes"></div>
                            <div class="post-comments-list"></div>
                            <div class="comment-input-wrapper">
                                <input type="text" placeholder="è¯„è®º...">
                                <button data-action="submit-comment">å‘é€</button>
                            </div>
                        </div>
                        `}
                    </div>
                `;
                return li;
            },

            async showCircleManagementSidebar() {
                this.showSidebar({
                    position: 'right',
                    title: "æœ‹å‹åœˆç®¡ç†",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-switch-circle">
                                <i class="fas fa-sync-alt"></i>
                                <span>åˆ‡æ¢åœˆå­</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-view-circle">
                                <i class="fas fa-info-circle"></i>
                                <span>æŸ¥çœ‹åœˆå­ä¿¡æ¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-add-circle">
                                <i class="fas fa-plus-circle"></i>
                                <span>æ–°å¢åœˆå­</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-edit-circle">
                                <i class="fas fa-edit"></i>
                                <span>ä¿®æ”¹å½“å‰åœˆå­</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-delete-circle">
                                <i class="fas fa-trash-alt"></i>
                                <span>åˆ é™¤åœˆå­</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-clear-circle-history">
                                <i class="fas fa-eraser"></i>
                                <span>æ¸…ç©ºæœ‹å‹åœˆè®°å½•</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
                
                $('#sidebar-clear-circle-history').onclick = () => EventManager.handleClearCircleHistory();
                $('#sidebar-switch-circle').onclick = () => EventManager.handleSwitchCircle();
                $('#sidebar-view-circle').onclick = () => EventManager.handleViewCircleInfo();
                $('#sidebar-add-circle').onclick = () => EventManager.handleAddCircle();
                $('#sidebar-edit-circle').onclick = () => EventManager.handleEditCircle(appState.currentCircleId);
                $('#sidebar-delete-circle').onclick = () => EventManager.handleDeleteCircle();
            },

            async applyChatBackground(chatId) {
                const isGroup = chatId.startsWith('group-');
                const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const chatAreaEl = $('#chat-area');
                
                
                const defaultChatBgColor = 'var(--bg-main)';

                
                if (entity && entity.chatBackground) {
                    chatAreaEl.style.backgroundImage = `url(${entity.chatBackground})`;
                    chatAreaEl.style.backgroundSize = 'cover';
                    chatAreaEl.style.backgroundPosition = 'center';
                    chatAreaEl.style.backgroundColor = ''; 
                    return;
                }

                
                if (themeSettings.globalChatBg) {
                    chatAreaEl.style.backgroundImage = `url(${themeSettings.globalChatBg})`;
                    chatAreaEl.style.backgroundSize = 'cover';
                    chatAreaEl.style.backgroundPosition = 'center';
                    chatAreaEl.style.backgroundColor = ''; 
                    return;
                }

                
                chatAreaEl.style.backgroundImage = ''; 
                chatAreaEl.style.backgroundColor = defaultChatBgColor; 
            },
            async renderFriendFoldersPage() {
                const contentArea = $('#contacts-friend-folders');
                contentArea.innerHTML = ''; 
                const friendFolders = await DBHelper.getAll('friendFolders');
                const allContacts = await DBHelper.getAll('contacts');

                const folderMap = friendFolders.reduce((acc, folder) => {
                    acc[folder.id] = folder;
                    return acc;
                }, {});

                const sortedFolders = friendFolders.sort((a, b) => a.createdAt - b.createdAt);

                for (const folder of sortedFolders) {
                    const folderContacts = allContacts.filter(c => c.folderId === folder.id);
                    const folderElement = this.createFriendFolderElement(folder, folderContacts);
                    contentArea.appendChild(folderElement);
                }

                const ungroupedContacts = allContacts.filter(c => !c.folderId || !folderMap[c.folderId]);
                if (ungroupedContacts.length > 0) {
                    const ungroupedFolder = { id: 'unclassified', name: 'æœªåˆ†ç»„å¥½å‹', isUnclassified: true };
                    const ungroupedElement = this.createFriendFolderElement(ungroupedFolder, ungroupedContacts);
                    contentArea.appendChild(ungroupedElement);
                }
                
                this.bindFriendFolderEvents();
            },

            createFriendFolderElement(folder, contacts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder'; 
                folderDiv.dataset.folderId = folder.id;

                let contactsHtml = contacts.map(contact => `
                    <div class="contact-item" data-id="${contact.id}" style="cursor: pointer; padding: 10px 5px;">
                        <img src="${contact.avatar}" alt="avatar" class="contact-item-avatar">
                        <span class="contact-item-name">${contact.remark || contact.name}</span>
                    </div>
                `).join('');
                if (contacts.length === 0 && !folder.isUnclassified) {
                    contactsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">æ­¤åˆ†ç»„ä¸ºç©º</p>`;
                }

                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            ${folder.name} (${contacts.length})
                        </h3>
                        ${!folder.isUnclassified ? `
                        <div class="prompt-folder-controls">
                            <button class="folder-action-btn" data-action="show-binding-options" title="ç»‘å®š"><i class="fas fa-link"></i></button>
                            <button class="folder-action-btn" data-action="edit-folder" title="ç¼–è¾‘åˆ†ç»„"><i class="fas fa-edit"></i></button>
                            <button class="folder-action-btn" data-action="delete-folder" title="åˆ é™¤åˆ†ç»„"><i class="fas fa-trash-alt"></i></button>
                        </div>
                        ` : ''}
                    </div>
                    <div class="prompt-folder-content collapsed" style="display: block; grid-template-columns: 1fr;">${contactsHtml}</div>
                `;
                return folderDiv;
            },

            bindFriendFolderEvents() {
                $('#contacts-friend-folders').onclick = (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const actionBtn = target.closest('.folder-action-btn');
                    const contactItem = target.closest('.contact-item');

                    if (actionBtn) {
                        e.stopPropagation();
                        const folderId = actionBtn.closest('.prompt-folder').dataset.folderId;
                        const action = actionBtn.dataset.action;
                        if (action === 'edit-folder') {
                            EventManager.showAddEditFriendFolderModal(folderId);
                        } else if (action === 'delete-folder') {
                            EventManager.confirmDeleteFriendFolder(folderId);
                        } else if (action === 'show-binding-options') {
                            EventManager.showFolderBindingOptionsModal(folderId);
                        }
                    } else if (folderHeader) {
                        const content = folderHeader.nextElementSibling;
                        folderHeader.classList.toggle('collapsed');
                        content.classList.toggle('collapsed');
                    } else if (contactItem) {
                        const contactId = contactItem.dataset.id;
                        this.openChat(contactId);
                    }
                };
            },
        };
            

        
        const AIHandler = {
            getGroupChatRules(settings) {
                let ruleTexts = [
                    `**å¤šè§’è‰²å‘è¨€**ï¼šä½ å¯ä»¥è®©å¤šä¸ªè§’è‰²å‘è¨€ï¼Œæ¯ä¸ªè§’è‰²çš„å‘è¨€éƒ½æ˜¯ç‹¬ç«‹çš„å•å…ƒï¼Œä½ å¯ä»¥æ ¹æ®äººè®¾å®‰æ’éƒ¨åˆ†ç¾¤å‹ä¸å‘è¨€(ä¾‹å¦‚æœ‰çš„è§’è‰²æ˜¯æ—©ç¡è®¾å®š,æ—¶é—´å¤ªæ™šå°±ä¸ä¼šå›å¤)ï¼Œä½†è‡³å°‘éœ€è¦æ„é€ ä¸€åç¾¤å‹çš„å‘è¨€ã€‚`,
                    `**å¿ƒå£°è§„åˆ™**ï¼šä½ å¿…é¡»ä¸ºç¾¤èŠä¸­æ‰€æœ‰åœ¨æœ¬å›åˆå‡ºåœºå‘è¨€çš„è§’è‰²ç”Ÿæˆã€å¿ƒå£°ã€‘ã€‚å¯¹äºæœªå‡ºåœºï¼ˆå³æœ¬å›åˆæœªå‘è¨€ï¼‰çš„è§’è‰²ï¼Œä½ æœ‰ä¸€å®šæ¦‚ç‡ä¸ºä»–ä»¬ç”Ÿæˆã€å¿ƒå£°ã€‘ï¼Œä»¥ä½“ç°ä»–ä»¬åœ¨çª¥å±ä½†ä¸å‘è¨€çš„çŠ¶æ€ã€‚`
                ];

                if (settings.memoryInterconnection) {
                    ruleTexts.push(`**ç§èŠæ¶ˆæ¯**: å¦‚æœæƒ³å¯¹**ç©å®¶**è¯´ä¸€äº›ä¸æƒ³è®©å…¶ä»–äººçŸ¥é“çš„è¯ï¼Œè¯·ä½¿ç”¨ <ç§èŠ></ç§èŠ> æ ‡ç­¾åŒ…è£¹ã€‚æ ‡ç­¾å†…çš„æ¶ˆæ¯æ ¼å¼ä¾ç„¶éµå¾ªæ‰€æœ‰åŸºç¡€è§„åˆ™ï¼ˆå¦‚ <ç§èŠ>[æ–¹é¹¤å®‰|ä½ åœ¨ç¾¤é‡Œè¯´çš„é‚£å¥è¯æ˜¯ä»€ä¹ˆæ„æ€]</ç§èŠ>ï¼‰ã€‚<ç§èŠ>æ ¼å¼åªèƒ½ç§èŠç©å®¶ï¼Œç§èŠå…¶ä»–è§’è‰²çš„å†…å®¹ç¦æ­¢ä½¿ç”¨<ç§èŠ>æ ‡ç­¾ã€‚`);
                }

                ruleTexts.push(
                    `**ä¿®æ”¹ç¾¤å**: ä½ å¯ä»¥æ ¹æ®å‰§æƒ…å‘å±•ï¼Œä¸»åŠ¨ä¿®æ”¹ç¾¤åã€‚æ ¼å¼ä¸ºï¼š<ç³»ç»Ÿ>è§’è‰²å ä¿®æ”¹ç¾¤åä¸º"æ–°ç¾¤å"</ç³»ç»Ÿ>ã€‚ä¾‹å¦‚ï¼š<ç³»ç»Ÿ>å•†æ—¶åº ä¿®æ”¹ç¾¤åä¸º"F4"</ç³»ç»Ÿ>ã€‚æ³¨æ„ï¼šæ­¤è¡Œä¸ºå¿…é¡»ç¬¦åˆä½ çš„è§’è‰²è®¾å®šï¼Œä¸èƒ½éšæ„æˆ–æ— ç†ç”±åœ°ä¿®æ”¹ã€‚`,
                    `**ç¾¤å‹å›å¤é¡ºåºä¸å›ºå®šï¼Œå¯ä»¥äº¤å‰å›å¤ï¼Œä¾‹å¦‚ç¾¤å‹Aã€ç¾¤å‹Bã€ç¾¤å‹Bã€ç¾¤å‹Aã€ç¾¤å‹Cè¿™æ ·çš„äº¤å‰é¡ºåºã€‚ä¸ä¸€å®šè¦ä¸€ä¸ªäººå…¨éƒ¨è¯´å®Œäº†æ‰è½®åˆ°ä¸‹ä¸€ä¸ªäººã€‚ç¾¤å‹ä¹‹é—´ä¹Ÿå¯ä»¥æœ‰äº’åŠ¨å¯¹è¯ï¼Œä¾‹å¦‚ä½¿ç”¨@æåŠå…¶ä»–ç¾¤å‹ã€‚**`
                );

                const formattedRules = ruleTexts.map((text, index) => `${index + 1}.  ${text}`).join('\n');
                return `\n---\nç¾¤èŠä¸“å±è§„åˆ™ï¼š\n${formattedRules}\n---`;
            },
            formatPromptTpl: `\n---
å›å¤è§„åˆ™ï¼ˆéå¸¸é‡è¦ï¼è¯·ä¸¥æ ¼éµå®ˆï¼ï¼‰ï¼š
1.  ä½ çš„æ‰€æœ‰å›å¤éƒ½å¿…é¡»ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ ¼å¼ï¼Œä½¿ç”¨**è§’è‰²å**ï¼Œè€Œä¸æ˜¯å…¶ä»–æ˜µç§°/ç§°å‘¼ï¼Œæ¯ä¸€å¥è¯éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å•å…ƒã€‚
2.  **æ™®é€šæ–‡æœ¬æ¶ˆæ¯**ï¼šè¯·å°†ä½ çš„æ™®é€šå›å¤æ‹†åˆ†æˆå¤šä¸ªé€šç•…çš„çŸ­å¥ï¼Œå¹¶ä½¿ç”¨æ ¼å¼ï¼š[è§’è‰²å|æ¶ˆæ¯å†…å®¹]ã€‚ä¾‹å¦‚ï¼š[é™ˆå¥šæ¥·|ä½ å¥½å•Š]ã€‚
3.  **è¡¨æƒ…åŒ…æ¶ˆæ¯**ï¼š<è§’è‰²å|è¡¨æƒ…åŒ…ID>ï¼Œ**ç¦æ­¢åœ¨<>å¤–é¢åŒ…è£¹[]**ã€‚ä½ å¿…é¡»åœ¨< >ä¸­ä½¿ç”¨å†’å·å·¦è¾¹çš„IDï¼Œè€Œä¸æ˜¯æ–‡å­—æè¿°ã€‚å¯ç”¨è¡¨æƒ…åŒ…IDåŠå…¶å«ä¹‰ï¼š\n{EMOJI_LIST}ã€‚ä¸€æ¬¡å›å¤å†…ä¸€èˆ¬æœ€å¤šä½¿ç”¨2ä¸ªè¡¨æƒ…åŒ…ã€‚
4.  **æ’¤å›æ¶ˆæ¯**ï¼šå¦‚æœä½ æƒ³è¡¨è¾¾æŸç§æƒ…ç»ªæˆ–è€…è¯´å‡ºä¸€äº›è§’è‰²ä¼šåæ‚”çš„è¯æˆ–è€…ä¸å°å¿ƒå‘å‡ºæ¥çš„è¯ï¼Œè¯·å°†è¯¥çŸ­å¥ç”¨è‹±æ–‡å¤§æ‹¬å·åŒ…è£¹ï¼Œæ ¼å¼ä¸ºï¼š{è§’è‰²å|å·²ç»å‘é€ç„¶åç«‹åˆ»æ’¤å›çš„åŸå§‹æ¶ˆæ¯å†…å®¹}ã€‚ä¾‹å¦‚ï¼šä¾‹å¦‚ï¼š{å­Ÿç¥å¹´|è£…è´§ï¼Œä½ ä»¥ä¸ºè€å­ä¸çŸ¥é“ä½ ä»€ä¹ˆå¿ƒæ€å—}ã€‚ä¸è¦å‘é€ä¸€æ¡æ­£å¸¸æ¶ˆæ¯å†å‘é€ä¸€æ¡â€œæ’¤å›â€çš„æŒ‡ä»¤ã€‚
5.  **è¯­éŸ³æ¶ˆæ¯**ï¼š[è§’è‰²å|è¯­éŸ³|è¯­éŸ³æ—¶é•¿|è¯­éŸ³å†…å®¹]ã€‚è¯­éŸ³æ—¶é•¿æœ€é•¿ä¸è¶…è¿‡60sã€‚ä¾‹å¦‚ï¼š[ä¸‰ä¸‰|è¯­éŸ³|13s|å¤ªå¥½äº†ï¼é‚£æˆ‘ä»¬ä¸‹åˆä¸‰ç‚¹åœ¨å…¬å¸ä¼šè®®å®¤è¯¦ç»†è®¨è®º]ã€‚
6.  **å¼•ç”¨æ¶ˆæ¯**: [è§’è‰²å|å¼•ç”¨|è¢«å¼•ç”¨äººID|è¢«å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹|ä½ çš„æ–°æ¶ˆæ¯å†…å®¹]ã€‚ä¸è¦æ»¥ç”¨ã€‚ä¾‹å¦‚: [é™ˆå¥šæ¥·|å¼•ç”¨|æ¥šå¯»|ä½ å“ªé‡Œä¸ä¼š?|å…³äºæœ€åä¸€é¢˜æˆ‘è¿˜æœ‰ç‚¹ç–‘é—®ã€‚]ã€‚ç¦æ­¢å¼•ç”¨è½¬è´¦/çº¢åŒ…æ¶ˆæ¯
7.  **è½¬è´¦æ¶ˆæ¯**: [è§’è‰²å|è½¬è´¦|è¢«è½¬è´¦è§’è‰²å|é‡‘é¢|å¤‡æ³¨]ã€‚é‡‘é¢æ ¼å¼ä¸º "ï¿¥XX.XX"ã€‚ä¾‹å¦‚: [å­Ÿç¥å¹´|è½¬è´¦|å•†æ—¶åº|ï¿¥520.00|ç»™ä½ çš„æƒŠå–œ]ã€‚
8.  **çº¢åŒ…æ¶ˆæ¯**: [è§’è‰²å|çº¢åŒ…|çº¢åŒ…åç§°|é‡‘é¢|çº¢åŒ…ä¸ªæ•°]ã€‚ç§èŠæ—¶çº¢åŒ…ä¸ªæ•°å¿…é¡»ä¸º1ã€‚ä¾‹å¦‚: [å­Ÿç¥å¹´|çº¢åŒ…|è¯·å¤§å®¶å–å¥¶èŒ¶|ï¿¥88.88|4]ã€‚
9. **å¡ç‰‡æ¶ˆæ¯**: å½“ä½ æƒ³åˆ†äº«ä¸€ç±»å¡ç‰‡æ¶ˆæ¯ï¼ˆå¦‚ï¼šåœ°ç‚¹åˆ†äº«ã€æ–‡ä»¶åˆ†äº«ã€æ­Œæ›²åˆ†äº«ã€æˆ–è€…å…¶ä»–æœ‰è¶£çš„å¯ä»¥ç”¨å¡ç‰‡å‘å‡ºæ¥çš„åˆ†äº«å†…å®¹ï¼‰æ—¶ï¼Œä½¿ç”¨è¿™ç§æ ¼å¼ï¼šã€è§’è‰²å|åˆ†äº«ç±»å‹|åˆ†äº«æ ‡é¢˜|ç®€ä»‹15å­—ä»¥å†…|è¯¦ç»†å†…å®¹30-60å­—ã€ï¼Œä¸¾ä¾‹ï¼šã€è§’è‰²å|å›¾ç‰‡åˆ†äº«|å¤æ—¥æµ·æ»©|ä¸€å¼ è®°å½•ç¾å¥½ç¬é—´çš„ç…§ç‰‡|ç…§ç‰‡é‡Œæ˜¯è”šè“çš„å¤§æµ·å’Œé‡‘è‰²çš„æ²™æ»©ï¼Œå……æ»¡äº†å¤æ—¥çš„æ´»åŠ›ä¸æƒ¬æ„ã€‚ã€
10. **ç¤¼ç‰©æ¶ˆæ¯**: å½“æŸä¸ªè§’è‰²åŸºäºäººç‰©è®¾å®š/èŠå¤©è®°å½•å†…å®¹æƒ³èµ é€ç¤¼ç‰©æ—¶ï¼Œä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼Œå¹¶ç¡®ä¿æ¯ä¸ªå­—æ®µéƒ½å¡«å†™å®Œæ•´ï¼š
<ç¤¼ç‰©>
å‘é€æ–¹ï¼šè§’è‰²å
æ¥æ”¶æ–¹ï¼šç©å®¶åæˆ–å¦ä¸€è§’è‰²å
ç¤¼ç‰©åç§°ï¼šxxx
ç¤¼ç‰©ä»·æ ¼ï¼šxxx
ç¤¼ç‰©ä»‹ç»ï¼šxxxï¼ˆä¸è¶…è¿‡50å­—ï¼‰
å¯„è¯­ï¼šxxxï¼ˆç®€å•ä¸€å¥è¯ï¼‰
</ç¤¼ç‰©>
{PAT_A_PAT_RULES}
13. **å¿ƒå£° (å¼ºåˆ¶è¦æ±‚)**: åœ¨ä½ æœ¬æ¬¡æ‰€æœ‰æ¶ˆæ¯å†…å®¹ä¹‹åï¼Œä½ å¿…é¡»ä»¥ã€å¿ƒå£°|è§’è‰²å|ä½ çš„å¿ƒå£°å†…å®¹ã€‘çš„æ ¼å¼æ¥ç»“æŸä½ çš„æ•´ä¸ªå›å¤ã€‚**å­—æ•°ä¸è¶…è¿‡30å­—ã€‚**
14. **éšç¬” (æ¦‚ç‡å‡ºç°)**: ä½ æœ‰ä¸€å®šæ¦‚ç‡ä¼šåœ¨ã€å¿ƒå£°ã€‘ä¹‹åï¼Œé¢å¤–å†™ä¸€æ®µã€Œéšç¬”|è§’è‰²å|ä½ çš„éšç¬”å†…å®¹ã€ã€‚è¿™æ®µéšç¬”æ˜¯è§’è‰²åœ¨å½“å‰æƒ…å¢ƒä¸‹ï¼Œæœ‰æ„Ÿè€Œå‘çš„ä¸€äº›æ€è€ƒæˆ–ç»å†ï¼Œå¯ä»¥ä¸å½“å‰å¯¹è¯å†…å®¹ç›¸å…³ï¼Œä¹Ÿå¯ä»¥æ˜¯ç‹¬ç«‹çš„å°æ•…äº‹æˆ–å¿ƒæƒ…è®°å½•ã€‚å­—æ•°è¯·æ§åˆ¶åœ¨50åˆ°250å­—ä¹‹é—´ã€‚
15. **ä¸¥ç¦äº‹é¡¹(1)**ï¼šç»ä¸å…è®¸ä½ ä»£å…¥ç©å®¶ï¼ˆâ€œ{PLAYER_NAME}â€ï¼‰çš„è§’è‰²å‘è¨€æˆ–ä¸ºå…¶ç”Ÿæˆå¿ƒå£°ã€‚
16. **ä¸¥ç¦äº‹é¡¹(2)**ï¼šä½ çš„å›å¤å†…å®¹ä¸­ï¼Œä¸è¦ä½¿ç”¨æ‹¬å· ()ã€æ˜Ÿå· ** æˆ–å…¶ä»–ä»»ä½•ç¬¦å·æ¥æè¿°è§’è‰²çš„åŠ¨ä½œã€è¡¨æƒ…æˆ–å†…å¿ƒæ´»åŠ¨ã€‚
---
ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯ï¼Œå¯¹ç©å®¶çš„æœ€æ–°æ¶ˆæ¯è¿›è¡Œå›åº”ã€‚`,

            activeReplyPromptTpl: `\n---
ä¸»åŠ¨å›å¤è§„åˆ™ï¼ˆéå¸¸é‡è¦ï¼è¯·ä¸¥æ ¼éµå®ˆï¼ï¼‰ï¼š
1.  ä½ ç°åœ¨éœ€è¦ä¸»åŠ¨å‘é€ä¸€äº›æ¶ˆæ¯ã€‚ä½ çš„æ‰€æœ‰å›å¤éƒ½å¿…é¡»ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ ¼å¼ï¼Œåœ¨æ¯æ¡æ¶ˆæ¯çš„æœ«å°¾é™„å¸¦æ¶ˆæ¯æ—¶é—´ï¼Œä½¿ç”¨ | åˆ†éš”ã€‚
2.  **æ™®é€šæ–‡æœ¬æ¶ˆæ¯**ï¼šè¯·å°†ä½ çš„æ™®é€šå›å¤æ‹†åˆ†æˆå¤šä¸ªé€šç•…çš„çŸ­å¥ï¼Œå¹¶ä½¿ç”¨æ ¼å¼ï¼š[è§’è‰²å|æ¶ˆæ¯å†…å®¹|æ¶ˆæ¯æ—¶é—´]ã€‚ä¾‹å¦‚ï¼š[é™ˆå¥šæ¥·|ä¸‹åˆå»çœ‹ç”µå½±å—|14:50]ã€‚
3.  **è¡¨æƒ…åŒ…æ¶ˆæ¯**ï¼š<è§’è‰²å|è¡¨æƒ…åŒ…ID|æ¶ˆæ¯æ—¶é—´>ï¼Œ**ç¦æ­¢åœ¨<>å¤–é¢åŒ…è£¹[]**ã€‚ä½ å¿…é¡»åœ¨< >ä¸­ä½¿ç”¨å†’å·å·¦è¾¹çš„IDï¼Œè€Œä¸æ˜¯æ–‡å­—æè¿°ã€‚å¯ç”¨è¡¨æƒ…åŒ…IDåŠå…¶å«ä¹‰ï¼š{EMOJI_LIST}ã€‚
4.  **æ’¤å›æ¶ˆæ¯**ï¼šå¦‚æœä½ æƒ³è¡¨è¾¾æŸç§æƒ…ç»ªæˆ–è€…è¯´å‡ºä¸€äº›è§’è‰²ä¼šåæ‚”çš„è¯æˆ–è€…ä¸å°å¿ƒå‘å‡ºæ¥çš„è¯ï¼Œè¯·å°†è¯¥çŸ­å¥ç”¨è‹±æ–‡å¤§æ‹¬å·åŒ…è£¹ï¼Œæ ¼å¼ä¸ºï¼š{è§’è‰²å|æ¶ˆæ¯å†…å®¹|æ¶ˆæ¯æ—¶é—´}
5.  **è¯­éŸ³æ¶ˆæ¯**ï¼š[è§’è‰²å|è¯­éŸ³|è¯­éŸ³æ—¶é•¿|è¯­éŸ³å†…å®¹|æ¶ˆæ¯æ—¶é—´]ã€‚è¯­éŸ³æ—¶é•¿æœ€é•¿ä¸è¶…è¿‡60sã€‚ä¾‹å¦‚ï¼š[ä¸‰ä¸‰|è¯­éŸ³|13s|å¤ªå¥½äº†ï¼é‚£æˆ‘ä»¬ä¸‹åˆä¸‰ç‚¹åœ¨å…¬å¸ä¼šè®®å®¤è¯¦ç»†è®¨è®º|13:43]ã€‚
6.  **å¼•ç”¨æ¶ˆæ¯**: [è§’è‰²å|å¼•ç”¨|è¢«å¼•ç”¨äººID|è¢«å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹|ä½ çš„æ–°æ¶ˆæ¯å†…å®¹|æ¶ˆæ¯æ—¶é—´]ã€‚ä¸è¦æ»¥ç”¨ã€‚ä¾‹å¦‚: [é™ˆå¥šæ¥·|å¼•ç”¨|æ¥šå¯»|ä½ å“ªé‡Œä¸ä¼š?|å…³äºæœ€åä¸€é¢˜æˆ‘è¿˜æœ‰ç‚¹ç–‘é—®ã€‚|9:46]ã€‚ç¦æ­¢å¼•ç”¨è½¬è´¦/çº¢åŒ…æ¶ˆæ¯
7.  **è½¬è´¦æ¶ˆæ¯**: [è§’è‰²å|è½¬è´¦|æ”¶æ¬¾äººè§’è‰²å|é‡‘é¢|å¤‡æ³¨]ã€‚é‡‘é¢æ ¼å¼ä¸º "ï¿¥XX.XX"ã€‚ä¾‹å¦‚: [å­Ÿç¥å¹´|è½¬è´¦|å•†æ—¶åº|ï¿¥520.00|ç»™ä½ çš„æƒŠå–œ]ã€‚
8.  **çº¢åŒ…æ¶ˆæ¯**: [è§’è‰²å|çº¢åŒ…|çº¢åŒ…åç§°|é‡‘é¢|çº¢åŒ…ä¸ªæ•°]ã€‚é‡‘é¢å¿…é¡»å¤§äºç­‰äºâ€œçº¢åŒ…ä¸ªæ•° * 0.01â€ã€‚ç§èŠæ—¶çº¢åŒ…ä¸ªæ•°å¿…é¡»ä¸º1ã€‚ä¾‹å¦‚: [å­Ÿç¥å¹´|çº¢åŒ…|è¯·å¤§å®¶å–å¥¶èŒ¶|ï¿¥88.88|4]ã€‚
9. **å¡ç‰‡æ¶ˆæ¯**: å½“ä½ æƒ³åˆ†äº«ä¸€ç±»å¡ç‰‡æ¶ˆæ¯ï¼ˆå¦‚ï¼šåœ°ç‚¹åˆ†äº«ã€æ–‡ä»¶åˆ†äº«ã€æ­Œæ›²åˆ†äº«ã€æˆ–è€…å…¶ä»–æœ‰è¶£çš„å¯ä»¥ç”¨å¡ç‰‡å‘å‡ºæ¥çš„åˆ†äº«å†…å®¹ï¼‰æ—¶ï¼Œä½¿ç”¨è¿™ç§æ ¼å¼ï¼šã€è§’è‰²å|åˆ†äº«ç±»å‹|åˆ†äº«æ ‡é¢˜|ç®€ä»‹15å­—ä»¥å†…|è¯¦ç»†å†…å®¹30-60å­—|æ¶ˆæ¯æ—¶é—´ã€ï¼Œä¸¾ä¾‹ï¼šã€è§’è‰²å|å›¾ç‰‡åˆ†äº«|å¤æ—¥æµ·æ»©|ä¸€å¼ è®°å½•ç¾å¥½ç¬é—´çš„ç…§ç‰‡|ç…§ç‰‡é‡Œæ˜¯è”šè“çš„å¤§æµ·å’Œé‡‘è‰²çš„æ²™æ»©ï¼Œå……æ»¡äº†å¤æ—¥çš„æ´»åŠ›ä¸æƒ¬æ„ã€‚|7/2 12:36ã€
10. **ç¤¼ç‰©æ¶ˆæ¯**: å½“ä½ æƒ³ä¸»åŠ¨èµ é€ç¤¼ç‰©æ—¶ï¼Œä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š
<ç¤¼ç‰©>
å‘é€æ–¹ï¼šè§’è‰²å
æ¥æ”¶æ–¹ï¼šç©å®¶åæˆ–å¦ä¸€è§’è‰²å
ç¤¼ç‰©åç§°ï¼šxxx
ç¤¼ç‰©ä»·æ ¼ï¼šxxx
ç¤¼ç‰©ä»‹ç»ï¼šxxxï¼ˆä¸è¶…è¿‡50å­—ï¼‰
å¯„è¯­ï¼šxxxï¼ˆç®€å•ä¸€å¥è¯ï¼‰
</ç¤¼ç‰©>
{PAT_A_PAT_RULES}
13. **å¿ƒå£° (å¼ºåˆ¶è¦æ±‚)**: åœ¨ä½ æœ¬æ¬¡æ‰€æœ‰æ¶ˆæ¯å†…å®¹ä¹‹åï¼Œä½ å¿…é¡»ä»¥ã€å¿ƒå£°|è§’è‰²å|ä½ çš„å¿ƒå£°å†…å®¹ã€‘çš„æ ¼å¼æ¥ç»“æŸä½ çš„æ•´ä¸ªå›å¤ã€‚å­—æ•°ä¸è¶…è¿‡30å­—ã€‚
14. **éšç¬” (æ¦‚ç‡å‡ºç°)**: ä½ æœ‰ä¸€å®šæ¦‚ç‡ä¼šåœ¨ã€å¿ƒå£°ã€‘ä¹‹åï¼Œé¢å¤–å†™ä¸€æ®µã€Œéšç¬”|è§’è‰²å|ä½ çš„éšç¬”å†…å®¹ã€ã€‚è¿™æ®µéšç¬”æ˜¯è§’è‰²åœ¨å½“å‰æƒ…å¢ƒä¸‹ï¼Œæœ‰æ„Ÿè€Œå‘çš„ä¸€äº›æ€è€ƒæˆ–ç»å†ï¼Œå¯ä»¥ä¸å½“å‰å¯¹è¯å†…å®¹ç›¸å…³ï¼Œä¹Ÿå¯ä»¥æ˜¯ç‹¬ç«‹çš„å°æ•…äº‹æˆ–å¿ƒæƒ…è®°å½•ã€‚å­—æ•°è¯·æ§åˆ¶åœ¨50åˆ°250å­—ä¹‹é—´ã€‚
15. **ä¸¥ç¦äº‹é¡¹(1)**ï¼šç»ä¸å…è®¸ä½ ä»£å…¥ç©å®¶ï¼ˆâ€œ{PLAYER_NAME}â€ï¼‰çš„è§’è‰²å‘è¨€æˆ–ä¸ºå…¶ç”Ÿæˆå¿ƒå£°ã€‚
16. **ä¸¥ç¦äº‹é¡¹(2)**ï¼šä½ çš„å›å¤å†…å®¹ä¸­ï¼Œä¸è¦ä½¿ç”¨æ‹¬å· ()ã€æ˜Ÿå· ** æˆ–å…¶ä»–ä»»ä½•ç¬¦å·æ¥æè¿°è§’è‰²çš„åŠ¨ä½œã€è¡¨æƒ…æˆ–å†…å¿ƒæ´»åŠ¨ã€‚
---
ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯ï¼Œå¼€å§‹ä½ çš„ä¸»åŠ¨å‘è¨€ã€‚`,

            buildTurnsFromHistory(history, allContacts, myProfile) {
                if (!history || history.length === 0) return [];
                
                const formatMessageContent = (msg, senderName, myName) => {
                    const recipientName = msg.cardData?.recipientName || 'å¯¹æ–¹';
                    if (msg.isRetracted) {
                        const retracter = (msg.type === 'sent') ? myName : senderName;
                        return `{${retracter}|${msg.content}}`;
                    }
                    if (msg.segmentType === 'inner_voice') {
                         return `ã€å¿ƒå£°|${senderName}|${msg.content}ã€‘`;
                    }
                    switch (msg.segmentType) {
                        case 'text': return `[${senderName}|${msg.content}]`;
                        case 'emoji-image': return `<${senderName}|${msg.content}>`;
                        case 'voice': return `[${senderName}|è¯­éŸ³|${msg.cardData.duration}|${msg.cardData.content}]`;
                        case 'quote': return `[${senderName}|å¼•ç”¨|${msg.cardData.quotedName}|${msg.cardData.quotedContent}|${msg.cardData.newContent}]`;
                        case 'transfer': return `[${senderName}|è½¬è´¦|${recipientName}|${msg.cardData.amount}|${msg.cardData.note || ''}]`;
                        case 'transfer-receipt': 
                            const receiptSender = allContacts.find(c => c.name === msg.cardData.senderName) || myProfile;
                            const receiptRecipient = allContacts.find(c => c.name === msg.cardData.recipientName) || myProfile;
                            return `[${receiptRecipient.name}|é¢†å–è½¬è´¦|${receiptSender.name}|${msg.cardData.amount}]`;
                        case 'transfer-return': return `[${senderName}|é€€è¿˜è½¬è´¦|${recipientName}|${msg.cardData.amount}]`;
                        case 'red-packet': return `[${senderName}|çº¢åŒ…|${msg.cardData.title}|ï¿¥${msg.cardData.amount.toFixed(2)}|${msg.cardData.count}]`;
                        case 'image_simulated': return `[${senderName}|å›¾ç‰‡æè¿°|${msg.cardData.description}]`;
                        case 'image_vision':
                            const promptText = msg.cardData.prompt ? ` ${msg.cardData.prompt}` : '';
                            return `[${senderName}|[å›¾ç‰‡]${promptText}]`;
                        case 'gift': return `<ç¤¼ç‰©>\nå‘é€æ–¹ï¼š${senderName}\næ¥æ”¶æ–¹ï¼š${recipientName}\nç¤¼ç‰©åç§°ï¼š${msg.cardData.name}\nç¤¼ç‰©ä»·æ ¼ï¼š${msg.cardData.price}\nç¤¼ç‰©ä»‹ç»ï¼š${msg.cardData.description || 'æ— '}\nå¯„è¯­ï¼š${msg.cardData.message}\n</ç¤¼ç‰©>`;
                        case 'pat_a_pat':
                            const pat = msg.content;
                            
                            const actionText = pat.action || 'æ‹äº†æ‹';
                            const contentText = pat.content ? ` ${pat.content}` : '';
                            return `<æ‹ä¸€æ‹>${pat.patterName} ${actionText} ${pat.patteeName}${contentText}</æ‹ä¸€æ‹>`;
                        case 'modify_pat_a_pat':
                            const mod = msg.content;
                            return `<ä¿®æ”¹æ‹ä¸€æ‹>\nä¿®æ”¹äººï¼š${mod.modifierName}\næ‹ä¸€æ‹åŠ¨ä½œï¼š${mod.action}\næ‹ä¸€æ‹å†…å®¹ï¼š${mod.content}\n</ä¿®æ”¹æ‹ä¸€æ‹>`;
                        case 'system': return msg.forAi ? `<ç³»ç»Ÿ>${msg.content}</ç³»ç»Ÿ>`: '';
                        case 'narrator': return `<æ—ç™½>${msg.content}</æ—ç™½>`;
                        case 'forwarded_history': return msg.content; 
                        case 'card':
                            if (msg.type === 'sent') {
                                return `ã€${myName}|${msg.cardData.shareType}|${msg.cardData.title}|${msg.cardData.summary}|${msg.cardData.details}ã€`;
                            } else {
                                return `ã€${senderName}|${msg.cardData.shareType}|${msg.cardData.title}|${msg.cardData.summary}|${msg.cardData.details}ã€`;
                            }
                        case 'moment_forward': return msg.content;
                        case 'forward_custom': return msg.content; 
                        default: return '';
                    }
                };

                const relevantHistory = history.filter(m => m.segmentType !== 'essay' && (!m.isHidden || (m.isHidden && m.forAi === true)));
                if (relevantHistory.length === 0) return [];

                let turns = [];
                let currentTurn = null;

                for (const msg of relevantHistory) {
                    const sender = (msg.type === 'sent') ? myProfile : allContacts.find(c => c.id === msg.senderId);
                    if (!sender && msg.segmentType !== 'system') continue;
                    
                    const senderName = sender ? (msg.type === 'sent' ? myProfile.name : sender.name) : 'ç³»ç»Ÿ';
                    const formattedContent = formatMessageContent(msg, senderName, myProfile.name);
                    if (!formattedContent) continue;

                    const role = msg.type === 'sent' ? 'player' : 'ai';

                    if (currentTurn && currentTurn.role === role) {
                        currentTurn.content += formattedContent;
                    } else {
                        if (currentTurn) {
                            turns.push(currentTurn);
                        }
                        currentTurn = {
                            role: role,
                            time: Utils.formatTimestampForPrompt(msg.timestamp),
                            content: formattedContent
                        };
                    }
                }
                if (currentTurn) {
                    turns.push(currentTurn);
                }
                return turns;
            },

            apiConfig: {}, 
            isAwaitingResponse: false,
            abortController: null,

            async loadApiConfig() {
                let config = await DBHelper.get('apiConfig', 'mainConfig');
                if (!config) {
                    config = {
                        id: 'mainConfig',
                        provider: 'gemini',
                        url: 'https://generativelanguage.googleapis.com/v1beta/models/',
                        model: 'gemini-2.5-flash',
                        temperature: 0.7,
                        keys: { gemini: [], siliconflow: [], paioupu: [], volcano: [], custom: [] } 
                    };
                    await DBHelper.put('apiConfig', config);
                }

                
                if (config.key && !config.keys) {
                    console.log("æ­£åœ¨è¿ç§»æ—§çš„API Keyç»“æ„...");
                    config.keys = { gemini: [], siliconflow: [], paioupu: [], volcano: [], custom: [] };
                    
                    if (config.provider && config.keys[config.provider]) {
                        config.keys[config.provider].push(config.key);
                    }
                    delete config.key; 
                    await DBHelper.put('apiConfig', config);
                    console.log("API Keyç»“æ„è¿ç§»å®Œæˆã€‚");
                }
                
                
                if (!config.keys) {
                     config.keys = { gemini: [], siliconflow: [], paioupu: [], volcano: [], custom: [] };
                }


                this.apiConfig = config;
            },

            async saveApiConfig(newConfig) {
                
                Object.assign(this.apiConfig, newConfig);

                
                if (this.apiConfig.provider === 'custom') {
                    this.apiConfig.customUrl = this.apiConfig.url;
                }
                
            
                
                
                if (newConfig.model) {
                    if (!this.apiConfig.models) {
                        this.apiConfig.models = {};
                    }
                    
                    this.apiConfig.models[this.apiConfig.provider] = this.apiConfig.model;
                    
                    delete this.apiConfig.model;
                }
            
                
                this.apiConfig.id = 'mainConfig';
            
                
                await DBHelper.put('apiConfig', this.apiConfig);
            },

            async getApiKeyAndRotate() {
                await this.loadApiConfig(); 
                const provider = this.apiConfig.provider;
                const keyArray = this.apiConfig.keys[provider] || [];

                if (keyArray.length === 0) {
                    throw new Error(`å½“å‰æä¾›å•† (${provider}) æ²¡æœ‰å¯ç”¨çš„API Keyã€‚`);
                }

                const keyToUse = keyArray.shift(); 
                keyArray.push(keyToUse); 

                this.apiConfig.keys[provider] = keyArray;
                await this.saveApiConfig(this.apiConfig); 

                return keyToUse;
            },

            async getPendingTransfersPrompt(chatId, aiCharactersInChat) {
                const history = await DBHelper.getMessages(chatId, 30); 
                if (history.length === 0) return '';
                
                const aiCharacterIds = aiCharactersInChat.map(c => c.id);

                const pendingTransfers = history.filter(msg => 
                    msg.segmentType === 'transfer' &&
                    msg.cardData && !msg.cardData.isClaimed &&
                    aiCharactersInChat.some(ai => ai.name === msg.cardData.recipientName)
                );
                
                if (pendingTransfers.length === 0) return '';

                const promptLines = pendingTransfers.map(t => {
                    const senderName = (t.type === 'sent') ? 'ç©å®¶' : t.senderInfo.name;
                    return `- æ¥è‡ª ${senderName} çš„è½¬è´¦ ${t.cardData.amount}ï¼Œå¤‡æ³¨ï¼š${t.cardData.note || 'æ— '}`;
                });
                
                return `\n---
è½¬è´¦å¾…åŠäº‹é¡¹ï¼š
æœ‰ä»¥ä¸‹æœªå¤„ç†çš„è½¬è´¦ï¼Œè¯·åœ¨æœ¬æ¬¡å›å¤ä¸­ï¼Œæ ¹æ®è¢«è½¬è´¦äººçš„äººè®¾å’ŒèŠå¤©è®°å½•å†³å®šã€é¢†å–è½¬è´¦ã€‘æˆ–ã€é€€è¿˜è½¬è´¦ã€‘ï¼Œå¹¶ä½¿ç”¨å¯¹åº”çš„æ ¼å¼è¿›è¡Œå›å¤ã€‚
${promptLines.join('\n')}
---\n
**æ”¶æ¬¾å›å¤æ ¼å¼**ï¼š[æ”¶æ¬¾äººè§’è‰²å|é¢†å–è½¬è´¦|è½¬è´¦äººåå­—|è½¬è´¦é‡‘é¢]
**é€€è¿˜å›å¤æ ¼å¼**ï¼š[é€€æ¬¾äººè§’è‰²å|é€€è¿˜è½¬è´¦|è½¬è´¦äººåå­—|è½¬è´¦é‡‘é¢]
ä¾‹å¦‚ï¼š[å­Ÿç¥å¹´|é¢†å–è½¬è´¦|å•†æ—¶åº|ï¿¥0.01]
---`;
            },

            async buildPrompt() {
                const chatId = appState.currentChatId;
                if (!chatId) return null;

                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const allContacts = await DBHelper.getAll('contacts');
                const allGroups = await DBHelper.getAll('groups');
                
                const defaults = { memoryInterconnection: false, historyCharLimit: 5000, promptTurnFrequency: 1 };
                const savedSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const chatSettings = { ...defaults, ...savedSettings };
                const isGroup = chatId.startsWith('group-');
                
                const chatMetadata = await DBHelper.get('chatMetadata', chatId) || { chatId, turnCountSinceLastPrompt: 0 };
                
                const recentMessages = await DBHelper.getMessages(chatId, 5);
                let extraEmojiHintPrompt = '';
                if (recentMessages.length > 0) {
                    const lastPlayerTurnMessages = [];
                    for (let i = recentMessages.length - 1; i >= 0; i--) {
                        if (recentMessages[i].type === 'sent') lastPlayerTurnMessages.unshift(recentMessages[i]);
                        else break;
                    }

                    if (lastPlayerTurnMessages.length > 0) {
                        const extraEmojiIds = new Set(
                            lastPlayerTurnMessages
                                .filter(msg => msg.segmentType === 'emoji-image' && !appState.aiEmojiMap.hasOwnProperty(msg.content))
                                .map(msg => msg.content)
                        );
                        if (extraEmojiIds.size > 0) {
                            const hintContent = Array.from(extraEmojiIds)
                                .map(id => appState.playerEmojiMap[id] ? `${id}ï¼š${appState.playerEmojiMap[id]}` : null)
                                .filter(Boolean).join('\n');
                            if (hintContent) {
                                extraEmojiHintPrompt = `\n--- è¡¥å……ä¿¡æ¯ï¼šç©å®¶æœ€æ–°å‘é€çš„è¡¨æƒ…åŒ…å«ä¹‰å¦‚ä¸‹ ---\n${hintContent}\n---`;
                            }
                        }
                    }
                }
                
                const turnFrequency = chatSettings.promptTurnFrequency;
                
                
                const shouldSendFullPrompt = turnFrequency <= 1 ? true : (chatMetadata.turnCountSinceLastPrompt || 0) >= turnFrequency;
                
                
                const buildHistoryBlock = async (targetChatId, title, charLimit, turnLimit = null) => {
                    
                    const messages = await DBHelper.getMessages(targetChatId, 200); 
                    if (messages.length === 0) return '';

                    let turns = AIHandler.buildTurnsFromHistory(messages, allContacts, myProfile);
                    if (turns.length === 0) return '';

                    
                    if (turnLimit !== null && turns.length > turnLimit) {
                        turns = turns.slice(-turnLimit);
                    }
                    
                    
                    let finalTurns = [];
                    let currentCharCount = 0;
                    for (let i = turns.length - 1; i >= 0; i--) {
                        const turn = turns[i];
                        const turnString = JSON.stringify(turn);
                        if (currentCharCount + turnString.length > charLimit) {
                            break; 
                        }
                        finalTurns.unshift(turn);
                        currentCharCount += turnString.length;
                    }

                    if (finalTurns.length === 0) return '';
                    return `--- ${title} ---\n${finalTurns.map(turn => JSON.stringify(turn)).join('\n')}\n`;
                };

                const now = new Date();
                const systemTime = `å½“å‰ç³»ç»Ÿæ—¶é—´æ˜¯ï¼š${Utils.formatTimestampForPrompt(now)}ï¼Œ${['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'][now.getDay()]}ã€‚`;
                
                let taskPrompt = '', characterInfoPrompt = '', chatEntity, pendingTransfersPrompt = '';
                
                if (isGroup) {
                    chatEntity = await DBHelper.get('groups', chatId);
                    const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    taskPrompt = `ä½ ç°åœ¨æ­£åœ¨ä¸€ä¸ªåä¸ºâ€œ${chatEntity.name}â€çš„ç¾¤èŠä¸­ï¼Œéœ€è¦åŒæ—¶æ‰®æ¼”ä»¥ä¸‹å‡ ä½è§’è‰²ï¼š${members.map(m => m.name).join('ã€')}ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®æ¯ä¸ªè§’è‰²çš„æ€§æ ¼è®¾å®šï¼Œä¸ç¾¤é‡Œçš„â€œ${myProfile.name}â€ï¼ˆä¹Ÿå°±æ˜¯ç©å®¶ï¼‰è¿›è¡Œäº’åŠ¨ã€‚**ç¦æ­¢è®©ç¾¤èŠå¤–çš„è§’è‰²è¿›è¡Œå‘è¨€ï¼Œç¦æ­¢è®©è¢«ç§»å‡ºç¾¤èŠçš„è§’è‰²å‘è¨€**`;
                    characterInfoPrompt = `ç¾¤èŠæˆå‘˜èµ„æ–™å¦‚ä¸‹ï¼š\n` + members.map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\næ‹ä¸€æ‹åŠ¨ä½œ(${m.name}è‡ªå·±è®¾å®šçš„): ${m.patAction || 'æ‹äº†æ‹'}\næ‹ä¸€æ‹å†…å®¹(${m.name}è‡ªå·±è®¾å®šçš„): ${m.patContent || ''}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n');
                } else {
                    chatEntity = await DBHelper.get('contacts', chatId);
                    taskPrompt = `ä½ ç°åœ¨æ­£åœ¨æ‰®æ¼”â€œ${chatEntity.name}â€ï¼Œä¸â€œ${myProfile.name}â€ï¼ˆä¹Ÿå°±æ˜¯ç©å®¶ï¼‰è¿›è¡Œä¸€å¯¹ä¸€ç§èŠã€‚`;
                    characterInfoPrompt = `ä½ çš„è§’è‰²èµ„æ–™å¦‚ä¸‹ï¼š\nè§’è‰²å: ${chatEntity.name}\næ€§åˆ«: ${chatEntity.gender}\nå–œå¥½: ${chatEntity.likes || 'æ— '}\nåŒæ¶: ${chatEntity.dislikes || 'æ— '}\nä¹ æƒ¯: ${chatEntity.habits || 'æ— '}\næ‹ä¸€æ‹åŠ¨ä½œ(${chatEntity.name}è‡ªå·±è®¾å®šçš„): ${chatEntity.patAction || 'æ‹äº†æ‹'}\næ‹ä¸€æ‹å†…å®¹(${chatEntity.name}è‡ªå·±è®¾å®šçš„): ${chatEntity.patContent || ''}\nèƒŒæ™¯: ${chatEntity.background || 'æ— '}`;
                }

                let aiCharactersInChat = isGroup ? chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean) : [chatEntity];
                pendingTransfersPrompt = await this.getPendingTransfersPrompt(chatId, aiCharactersInChat);

                const playerInfoPrompt = `ç©å®¶ï¼ˆâ€œ${myProfile.name}â€ï¼‰çš„ä¿¡æ¯å¦‚ä¸‹ï¼š\næ€§åˆ«: ${myProfile.gender}\n${chatSettings.enablePatAPat !== false ? `æ‹ä¸€æ‹åŠ¨ä½œ: ${myProfile.patAction || 'æ‹äº†æ‹'}\næ‹ä¸€æ‹å†…å®¹: ${myProfile.patContent || ''}\n` : ''}èƒŒæ™¯: ${myProfile.background || 'æ— '}`;

                let pomodoroPromptSection = '';
                if (appState.pomodoro && appState.pomodoro.isActive && appState.pomodoro.endTime) {
                    const remainingSeconds = Math.max(0, Math.round((appState.pomodoro.endTime - Date.now()) / 1000));
                    const remainingMinutes = Math.ceil(remainingSeconds / 60);
                    const startTime = new Date(appState.pomodoro.endTime - appState.pomodoro.totalSeconds * 1000);
                    pomodoroPromptSection = `\n---
ç•ªèŒ„é’ŸçŠ¶æ€ï¼šç©å®¶å½“å‰æ­£åœ¨è¿›è¡Œä¸€ä¸ªä¸ºæœŸ25åˆ†é’Ÿçš„ç•ªèŒ„é’Ÿä¸“æ³¨æ—¶æ®µã€‚
- ä¸“æ³¨ç›®æ ‡ï¼š${appState.pomodoro.goal}
- å¼€å§‹æ—¶é—´ï¼š${Utils.formatTimestampForPrompt(startTime)}
- å‰©ä½™æ—¶é—´ï¼šçº¦ ${remainingMinutes} åˆ†é’Ÿ
è¯·æ³¨æ„ï¼Œç©å®¶æ­¤æ—¶ç»™ä½ å‘æ¶ˆæ¯å±äºâ€œåˆ†å¿ƒâ€è¡Œä¸ºï¼Œä½ å¯ä»¥ç»“åˆä½ çš„è§’è‰²è®¾å®šï¼Œå¯¹æ­¤ä½œå‡ºå›åº”ã€‚
---`;
                }

                
                let momentsPromptSection = '';
                let charactersWithCircle = [];
                
                if (isGroup) {
                    const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    charactersWithCircle = members.filter(m => m.boundCircleId);
                } else {
                    if (chatEntity.boundCircleId) {
                        charactersWithCircle.push(chatEntity);
                    }
                }

                if (charactersWithCircle.length > 0) {
                    const allowedAuthors = charactersWithCircle.map(c => c.name).join('ã€');
                    momentsPromptSection = `
---
å³æ—¶æœ‹å‹åœˆåŠ¨æ€è§„åˆ™ (å¯é€‰):
1. åœ¨æœ¬æ¬¡èŠå¤©å›å¤ä¸­ï¼Œä½ æœ‰ä¸€å®šå‡ ç‡å¯ä»¥å‘å¸ƒä¸€æ¡æˆ–å¤šæ¡æœ‹å‹åœˆåŠ¨æ€ã€‚ç»“åˆå†å²èŠå¤©è®°å½•é‡Œçš„æœ‹å‹åœˆçš„å‘é€æƒ…å†µï¼Œ**ä¸å…è®¸é¢‘ç¹ã€è¿ç»­å‘é€æœ‹å‹åœˆåŠ¨æ€**ï¼Œ**å¦‚æœä¸Šæ¬¡èŠå¤©å†…å‘é€äº†æœ‹å‹åœˆï¼Œæœ¬æ¬¡å¦‚æœæ²¡æœ‰ç‰¹æ®Šæƒ…å†µ(å¦‚ç©å®¶è¦æ±‚)ï¼Œç¦æ­¢å‘é€æœ‹å‹åœˆ**
2. åŠ¨æ€å†…å®¹éœ€è¦ä¸å½“å‰èŠå¤©æƒ…æ™¯ã€è§’è‰²è¿‘æœŸç»å†æˆ–äººè®¾ç´§å¯†ç›¸å…³ã€‚
3. æ¯æ¡åŠ¨æ€éƒ½å¿…é¡»è¢«ä¸€ä¸ª <æœ‹å‹åœˆ> æ ‡ç­¾åŒ…è£¹ã€‚
4. åŠ¨æ€æ ¼å¼: ã€ä½œè€…è§’è‰²åï¼šåŠ¨æ€å†…å®¹|åŠ¨æ€æ—¶é—´(æœˆ/æ—¥ HH:mm)ã€‘
5. ç‚¹èµæ ¼å¼(å¼ºåˆ¶è¦æ±‚): åœ¨åŠ¨æ€æ ¼å¼ä¹‹åï¼Œå¦èµ·ä¸€è¡Œï¼Œç”¨ä¸­æ–‡æ‹¬å·åŒ…è£¹ç‚¹èµåˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼ˆå·²ç‚¹èµï¼šå¥½å‹åå­—,å¥½å‹åå­—ï¼‰ã€‚
6. è¯„è®ºæ ¼å¼: ã€–è¯„è®ºè€…è§’è‰²åï¼šè¯„è®ºå†…å®¹ã€—
7. åœ¨æœ¬æ¬¡ç¾¤èŠä¸­ï¼Œåªå…è®¸ä»¥ä¸‹è§’è‰²å‘å¸ƒåŠ¨æ€ï¼š${allowedAuthors}ã€‚
8. ä¸¥ç¦ä»£æ›¿ç©å®¶ï¼ˆâ€œ${myProfile.name}â€ï¼‰ç‚¹èµæˆ–è¯„è®ºã€‚
9. ä¸¾ä¾‹:
<æœ‹å‹åœˆ>
ã€ä¸‰ä¸‰ï¼šä»Šå¤©å¤©æ°”çœŸä¸é”™ï¼Œæœ‰æ²¡æœ‰è¦ä¸€èµ·å‡ºå»ç©çš„ï¼Ÿ|7/3 8:36ã€‘
ï¼ˆå·²ç‚¹èµï¼švv,å…¥å…¥ï¼‰
ã€–vvï¼šå¸¦æˆ‘ä¸€ä¸ªï¼ã€—
</æœ‹å‹åœˆ>
---
`;
                }
                

                
                
                let customPromptsSection = '';
                if (shouldSendFullPrompt && chatEntity && chatEntity.boundPromptFolderIds?.length > 0) {
                    const allFolders = await DBHelper.getAll('promptFolders');
                    const allPrompts = await DBHelper.getAll('prompts');
                    const playerLastMessage = (await DBHelper.getMessages(chatId, 1)).pop()?.content || '';

                    const activeBoundFolders = allFolders.filter(f => chatEntity.boundPromptFolderIds.includes(f.id) && f.isActive);
                    if (activeBoundFolders.length > 0) {
                        const activeBoundFolderIds = activeBoundFolders.map(f => f.id);
                        const relevantPrompts = allPrompts.filter(p => activeBoundFolderIds.includes(p.folderId) && p.isActive);
                        const promptsToInject = relevantPrompts
                            .filter(p => p.type === 'explicit' || (p.type === 'implicit' && JSON.parse(p.keywords).some(kw => playerLastMessage.includes(kw))))
                            .map(p => p.content);
                        if (promptsToInject.length > 0) {
                            customPromptsSection = `\n--- å…¶ä»–èµ„æ–™ ---\n${promptsToInject.join('\n\n')}\n---`;
                        }
                    }
                }

                
                let historyPrompt = "ä»¥ä¸‹æ˜¯èŠå¤©è®°å½•ï¼Œè¯·ç»“åˆä¸Šä¸‹æ–‡è¿›è¡Œå›å¤ï¼ˆæ¯è¡Œæ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œä»£è¡¨ä¸€ä¸ªå›åˆï¼‰ï¼š\n";
                const historyCharLimit = chatSettings.historyCharLimit || 5000;

                if (chatSettings.memoryInterconnection) {
                    if (isGroup) {
                        const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                        let privateContext = '--- ä»¥ä¸‹æ˜¯å„è§’è‰²çš„ç§èŠè®°å¿† (ä»…è§’è‰²è‡ªå·±å¯è§, æœ€å¤š10å›åˆ) ---\n';
                        for (const member of members) {
                            privateContext += await buildHistoryBlock(member.id, `ä¸ ${member.name} çš„ç§èŠè®°å½•`, 2000, 10);
                        }
                        historyPrompt += privateContext;
                        historyPrompt += await buildHistoryBlock(chatId, 'å½“å‰ç¾¤èŠè®°å½•', historyCharLimit);
                    } else { 
                        const relatedGroups = allGroups.filter(g => g.members.includes(chatEntity.id));
                        let groupContext = '--- ä»¥ä¸‹æ˜¯ç›¸å…³çš„ç¾¤èŠè®°å¿† (æœ€å¤š8å›åˆ) ---\n';
                        for (const group of relatedGroups) {
                            groupContext += await buildHistoryBlock(group.id, `ç¾¤èŠâ€œ${group.name}â€çš„è®°å½•`, 1500, 8);
                        }
                        historyPrompt += groupContext;
                        historyPrompt += await buildHistoryBlock(chatId, 'å½“å‰ç§èŠè®°å½•', historyCharLimit);
                    }
                } else { 
                    historyPrompt += await buildHistoryBlock(chatId, 'å½“å‰èŠå¤©è®°å½•', historyCharLimit);
                }

                
                const useBuiltin = chatSettings.useBuiltinEmojis !== false;
                const useCustom = chatSettings.useCustomEmojisInPrompt !== false;

                let emojiMapForPrompt = {};
                if (useBuiltin) {
                    Object.assign(emojiMapForPrompt, BUILTIN_AI_EMOJIS);
                }
                if (useCustom) {
                    for (const [id, data] of Object.entries(appState.customEmojis)) {
                        emojiMapForPrompt[id] = data.name;
                    }
                }

                const emojiListString = Object.entries(emojiMapForPrompt).map(([id, desc]) => `${id}ï¼š${desc}`).join('\n');
                
                let patAPatRulesForPrompt = '';
                if (chatSettings.enablePatAPat !== false) {
                    patAPatRulesForPrompt = `11. **æ‹ä¸€æ‹**: å½“ä½ æƒ³è¡¨è¾¾ä¸€äº›ä¿çš®ã€æé†’æˆ–æƒ³äº’åŠ¨ä½†æ— è¯å¯è¯´çš„åœºæ™¯æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ‹ä¸€æ‹ã€‚ä½ å¿…é¡»ä½¿ç”¨è¢«æ‹è€…çš„è‡ªå®šä¹‰åŠ¨ä½œå’Œå†…å®¹ï¼Œä½¿ç”¨æ­¤æ ¼å¼ï¼š<æ‹ä¸€æ‹>æ‹äººè§’è‰²å (è¢«æ‹äººè®¾å®šçš„åŠ¨ä½œ) è¢«æ‹è§’è‰²å (è¢«æ‹äººè®¾å®šçš„å†…å®¹)</æ‹ä¸€æ‹>ã€‚
ä¾‹å¦‚ï¼Œå¦‚æœç©å®¶çš„æ‹ä¸€æ‹å†…å®¹æ˜¯â€œè¢«å¼¹é£äº†â€ï¼Œåˆ™æ ¼å¼ä¸ºï¼š<æ‹ä¸€æ‹>33 æ‹äº†æ‹ {PLAYER_NAME} è¢«å¼¹é£äº†</æ‹ä¸€æ‹>ã€‚
ç»å¯¹ä¸èƒ½ç”¨æ‹äººè€…çš„è‡ªå®šä¹‰åŠ¨ä½œå’Œå†…å®¹æ¥å›å¤ï¼Œè¿™æ˜¯é”™è¯¯çš„ã€‚
12. **ä¿®æ”¹æ‹ä¸€æ‹**: å½“è§’è‰²åŸºäºèŠå¤©è¯­å¢ƒä¸‹æƒ³ä¿®æ”¹è‡ªå·±çš„æ‹ä¸€æ‹è®¾ç½®æ—¶ï¼Œä½¿ç”¨æ­¤æ ¼å¼ï¼š
<ä¿®æ”¹æ‹ä¸€æ‹>
ä¿®æ”¹äººï¼šè§’è‰²å
æ‹ä¸€æ‹åŠ¨ä½œï¼šxxxï¼ˆä¸è¶…è¿‡5ä¸ªå­—ï¼Œä¾‹å¦‚:æäº†æï¼‰
æ‹ä¸€æ‹å†…å®¹ï¼šxxxï¼ˆä¸è¶…è¿‡20ä¸ªå­—ï¼Œä¾‹å¦‚:çš„è„¸ï¼Œå¹¶è¯´å¥½è½¯å¥½è½¯;æˆ–è€…:çš„å¤´,è¢«å¼¹é£äº†ï¼‰
</ä¿®æ”¹æ‹ä¸€æ‹>`;
                }

                const formatPrompt = AIHandler.formatPromptTpl.replace('{EMOJI_LIST}', emojiListString).replace('{PLAYER_NAME}', myProfile.name).replace('{PAT_A_PAT_RULES}', patAPatRulesForPrompt);
                let summaryPromptSection = '';
                if (chatEntity && chatEntity.autoSummary) {
                    summaryPromptSection = `--- ä¼šè¯æ¦‚è¦---\n${chatEntity.autoSummary}\n---`;
                }

                
                const promptParts = [
                    systemTime, 
                    taskPrompt, 
                    characterInfoPrompt, 
                    playerInfoPrompt, 
                    pendingTransfersPrompt, 
                    pomodoroPromptSection,
                    momentsPromptSection, 
                    summaryPromptSection, 
                    customPromptsSection, 
                    historyPrompt, 
                    extraEmojiHintPrompt, 
                    formatPrompt
                ];

                if (shouldSendFullPrompt) {
                    chatMetadata.turnCountSinceLastPrompt = 0;
                    await DBHelper.put('chatMetadata', chatMetadata);
                }
                
                let finalPrompt = promptParts.filter(Boolean).join('\n\n');
                if (isGroup) finalPrompt += this.getGroupChatRules(chatSettings);
                
                
                console.log(`--- PROMPT SENT TO AI (Full: ${shouldSendFullPrompt}) ---\n`, finalPrompt);
                return finalPrompt;
            },

            async getApiResponse(textPrompt, images, signal) {
                
                await this.loadApiConfig();

                
                const { provider, url, temperature, models } = this.apiConfig;
                const model = models ? models[provider] : null; 
                
                
                const key = await this.getApiKeyAndRotate();

                
                if (!key || !url || !model) {
                    throw new Error('APIé…ç½®ä¸å®Œæ•´ï¼Œè¯·åœ¨è®¾ç½®ä¸­æ£€æŸ¥ã€‚');
                }

                let apiUrl = url;
                let headers = { 'Content-Type': 'application/json' };
                let body;

                
                if (images && images.length > 0) {
                    console.log(`æ­£åœ¨å‘é€ä¸€ä¸ªåŒ…å« ${images.length} å¼ å›¾ç‰‡çš„å¤šæ¨¡æ€è¯·æ±‚ã€‚`);
                    if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                        headers['Authorization'] = `Bearer ${key}`;
                        if (!apiUrl.endsWith('/chat/completions')) {
                            apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                        }
                        const content = [{ "type": "text", "text": textPrompt }];
                        images.forEach(img => {
                            content.push({ "type": "image_url", "image_url": { "url": img.base64 } });
                        });
                        body = { model: model, messages: [{ "role": "user", "content": content }], temperature: temperature };
                    } else if (provider === 'gemini') {
                        apiUrl += `${model}:generateContent?key=${key}`;
                        const parts = [{ "text": textPrompt }];
                        images.forEach(img => {
                            const base64Data = img.base64.split(',')[1];
                            const mimeTypeMatch = img.base64.match(/^data:(image\/[a-zA-Z]+);base64,/);
                            const mimeType = mimeTypeMatch ? mimeTypeMatch[1] : 'image/jpeg';
                            parts.push({ "inline_data": { "mime_type": mimeType, "data": base64Data } });
                        });
                        body = {
                            contents: [{ role: 'user', parts: parts }],
                            generationConfig: { temperature: temperature }
                        };
                    } else {
                        throw new Error('ä¸æ”¯æŒçš„APIæä¾›å•†ã€‚');
                    }
                } else {
                    
                    const messagesForApi = [{ role: 'user', content: textPrompt }];
                    if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                        headers['Authorization'] = `Bearer ${key}`;
                        if (!apiUrl.endsWith('/chat/completions')) {
                            apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                        }
                        body = { model: model, messages: messagesForApi, temperature: temperature };
                    } else if (provider === 'gemini') {
                        apiUrl += `${model}:generateContent?key=${key}`;
                        body = {
                            contents: [{ role: 'user', parts: [{ text: textPrompt }] }],
                            generationConfig: { temperature: temperature }
                        };
                    } else {
                        throw new Error('ä¸æ”¯æŒçš„APIæä¾›å•†ã€‚');
                    }
                }

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(body),
                        signal: signal
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("API Error Response:", errorData);
                        throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error ? errorData.error.message : JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    console.log("API Response Data:", JSON.stringify(data, null, 2));

                    if (provider === 'gemini') {
                        if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
                            return data.candidates[0].content.parts[0].text;
                        } else {
                            let reason = "æœªçŸ¥åŸå› ã€‚";
                            if (data.promptFeedback && data.promptFeedback.blockReason) {
                                reason = `å†…å®¹è¢«é˜»æ­¢ï¼ŒåŸå› ï¼š${data.promptFeedback.blockReason}ã€‚è¯·æ£€æŸ¥æ‚¨çš„Promptæˆ–è°ƒæ•´APIçš„å®‰å…¨è®¾ç½®ã€‚`;
                            } else {
                                reason = "APIè¿”å›äº†ç©ºçš„æˆ–æ— æ•ˆçš„å€™é€‰å†…å®¹ã€‚";
                            }
                            throw new Error(`Gemini APIæœªè¿”å›æœ‰æ•ˆå›å¤ï¼š${reason}`);
                        }
                    } else { 
                        if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                            return data.choices[0].message.content;
                        } else {
                            let reason = "APIè¿”å›äº†ç©ºçš„æˆ–æ— æ•ˆçš„é€‰é¡¹ã€‚";
                            if (data.choices && data.choices.length > 0 && data.choices[0].finish_reason) {
                                reason = `å†…å®¹è¢«é˜»æ­¢ï¼ŒåŸå› ï¼š${data.choices[0].finish_reason}ã€‚`;
                            }
                            throw new Error(`APIæœªè¿”å›æœ‰æ•ˆå›å¤ï¼š${reason}`);
                        }
                    }
                } catch (error) {
                    if (error instanceof TypeError && error.message === 'Failed to fetch') {
                        throw new Error('APIè¯·æ±‚å¤±è´¥ã€‚åŸå› ï¼šFailed to fetchã€‚<br>è¯·å°è¯•æ£€æŸ¥ä½ çš„APIé…ç½®æ˜¯å¦æ­£ç¡®ï¼Œç½‘ç»œæœåŠ¡æ˜¯å¦é€šç•…<br>è¯¦æƒ…å¯å‰å¾€ã€è®¾ç½®-é£Ÿç”¨æŒ‡å—ã€‘æŸ¥çœ‹æ•™ç¨‹ã€‚');
                    }
                    
                    throw error;
                }
            },
            
            async handleAiReplyRequest() {
                if (this.isAwaitingResponse) return; 

                const requestedChatId = appState.currentChatId;
                if (!requestedChatId) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController(); 
                
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false; 

                const isGroup = requestedChatId.startsWith('group-');
                let typingBubbleId = Utils.generateId('typing');
                let typingTarget;
                
                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', requestedChatId);
                    if(typingTarget) {
                         UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', requestedChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const textPrompt = await this.buildPrompt();
                    if (!textPrompt) {
                         this.showError("æ— æ³•æ„å»ºprompt");
                         this.isAwaitingResponse = false;
                         aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                         return;
                    }
                    
                    
                    const allMessages = await DBHelper.getMessages(requestedChatId, 15);
                    const imagesForApi = [];
                    
                    for (let i = allMessages.length - 1; i >= 0; i--) {
                        const msg = allMessages[i];
                        if (msg.type === 'sent') {
                            if (msg.segmentType === 'image_vision') {
                                imagesForApi.push({ base64: msg.cardData.base64 });
                            }
                        } else {
                            break;
                        }
                    }

                    const aiRawResponse = await this.getApiResponse(textPrompt, imagesForApi.reverse(), this.abortController.signal);
                    
                    const metadata = await DBHelper.get('chatMetadata', requestedChatId) || { chatId: requestedChatId };
                    metadata.lastRawAiResponse = aiRawResponse;
                    await DBHelper.put('chatMetadata', metadata);
                    
                    console.log("--- AI åŸå§‹å›å¤ ---\n", aiRawResponse);
                    await this.parseAndDisplayAIResponse(aiRawResponse, requestedChatId);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log("AIè¯·æ±‚å·²è¢«ç”¨æˆ·å–æ¶ˆã€‚");
                    } else {
                        console.error("AIå›å¤å¤±è´¥:", error);
                        this.showError(`AIå›å¤å¤±è´¥: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    if (typingBubbleId) {
                        const typingBubble = $(`#${typingBubbleId}`);
                        if (typingBubble) typingBubble.remove();
                    }
                    UIManager.syncAiButtonState();
                }
            },
            cancelAiRequest() {
                if (this.abortController) {
                    this.abortController.abort();
                    console.log("æ­£åœ¨å–æ¶ˆAIè¯·æ±‚...");
                }
            },
            async handleActiveReplyRequest(lastAiTimestamp) {
                if (this.isAwaitingResponse) return;
                
                const requestedChatId = appState.currentChatId;
                if (!requestedChatId) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();

                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const prompt = await this.buildActiveReplyPrompt(lastAiTimestamp);
                if (!prompt) {
                     this.showError("æ— æ³•æ„å»ºä¸»åŠ¨å›å¤prompt");
                     this.isAwaitingResponse = false;
                     aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                     return;
                }
                
                const isGroup = requestedChatId.startsWith('group-');
                let typingBubbleId = Utils.generateId('typing');
                let typingTarget;
                
                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', requestedChatId);
                    if(typingTarget) {
                         UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', requestedChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(prompt, null, this.abortController.signal); 
                    
                    const metadata = await DBHelper.get('chatMetadata', requestedChatId) || { chatId: requestedChatId };
                    metadata.lastRawAiResponse = aiRawResponse;
                    await DBHelper.put('chatMetadata', metadata);
                    
                    console.log("--- AI ä¸»åŠ¨å›å¤ (åŸå§‹) ---\n", aiRawResponse);
                    await this.parseAndDisplayActiveAIResponse(aiRawResponse, requestedChatId);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log("AIä¸»åŠ¨å›å¤è¯·æ±‚å·²è¢«ç”¨æˆ·å–æ¶ˆã€‚");
                    } else {
                        console.error("AIä¸»åŠ¨å›å¤å¤±è´¥:", error);
                        this.showError(`AIä¸»åŠ¨å›å¤å¤±è´¥: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    if (typingBubbleId) {
                        const typingBubble = $(`#${typingBubbleId}`);
                        if (typingBubble) typingBubble.remove();
                    }
                    UIManager.syncAiButtonState();
                }
            },
            
            async buildActiveReplyPrompt(lastAiTimestamp) {
                const chatId = appState.currentChatId;
                if (!chatId) return null;

                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const allContacts = await DBHelper.getAll('contacts');
                const allGroups = await DBHelper.getAll('groups');
                const isGroup = chatId.startsWith('group-');
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const fullHistory = await DBHelper.getMessages(chatId, 100); 
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                const historyLength = 10; 

                const now = Date.now();
                const lastDate = new Date(lastAiTimestamp);
                const elapsedMillis = now - lastAiTimestamp;
                const elapsedHours = Math.floor(elapsedMillis / (1000 * 60 * 60));
                const elapsedMinutes = Math.floor((elapsedMillis % (1000 * 60 * 60)) / (1000 * 60));
                const lastTimeFormatted = `${lastDate.getMonth() + 1}æœˆ${lastDate.getDate()}æ—¥ ${String(lastDate.getHours()).padStart(2, '0')}:${String(lastDate.getMinutes()).padStart(2, '0')}`;
                const durationString = `${elapsedHours > 0 ? `${elapsedHours}å°æ—¶` : ''}${elapsedMinutes}åˆ†é’Ÿ`;

                let situationPrompt = '';
                if (isGroup) {
                    situationPrompt = `ä½ ä»¬ä¸Šæ¬¡èŠå¤©æ˜¯${lastTimeFormatted}ï¼Œè·ç¦»ç°åœ¨è¿‡å»${durationString}äº†ï¼Œåœ¨è¿™æ®µæ—¶é—´å†…ï¼Œç©å®¶â€œ${myProfile.name}â€å¹¶ä¸åœ¨çº¿ï¼Œä½ ä»¬å¯ä»¥è‡ªç”±äº¤æµï¼Œäº¤æµå†…å®¹å¯ä»¥ä¸ç©å®¶æœ‰å…³ï¼Œä¹Ÿå¯ä»¥ä¸ç©å®¶æ— å…³ã€‚`;
                } else {
                    situationPrompt = `â€œ${myProfile.name}â€ä¸Šæ¬¡å’Œä½ èŠå¤©æ—¶é—´æ˜¯${lastTimeFormatted}ï¼Œè·ç¦»ç°åœ¨å·²ç»è¿‡å»äº†${durationString}ã€‚è¯·ä½ æ ¹æ®ä½ çš„äººè®¾ï¼Œè¯´ä¸€äº›åœ¨è¿™æ®µæ—¶é—´é‡Œä½ å¯èƒ½ä¼šå¯¹â€œ${myProfile.name}â€è¯´çš„è¯ï¼Œä¹Ÿå¯èƒ½æ˜¯è¿™æ®µæ—¶é—´å†…ä½ é‡åˆ°çš„æ–°é²œçš„äº‹ï¼Œæƒ³å’ŒTAåˆ†äº«ã€‚è¿™äº›è¯ä¸ä¸€å®šæ˜¯åŒä¸€æ—¶é—´å‘çš„ï¼Œæœ‰æ—¶å€™åªéš”äº†ä¸€ä¸¤åˆ†é’Ÿï¼Œæœ‰å¯èƒ½ä½ å¯èƒ½éš”äº†åå‡ äºŒååˆ†é’Ÿæ‰å‘ä¸‹ä¸€æ¡ï¼Œæ‰€ä»¥æ³¨æ„æ¶ˆæ¯çš„å£å»ã€‚**ç¦æ­¢è¶…å‡ºè¿™ä¸ªæ—¶é—´èŒƒå›´ï¼Œç¦æ­¢å‡ºç°æ¯”ç°åœ¨æ—¶é—´è¿˜è¦æ™šçš„æ—¶é—´**ï¼Œå¦‚æœå¯¹æ–¹ç¦»å¼€çš„æ—¶é—´åªæœ‰å‡ ä¸ªå°æ—¶æˆ–è€…åªæ˜¯æ™šä¸Šåˆ°ç™½å¤©(ç¡è§‰)ï¼Œå¯ä»¥ä¸ç”¨å‘å¾ˆå¤šæ¡æ¶ˆæ¯ã€‚`;
                }

                const formatMessageContent = (msg, senderName, myName) => { 
                    const recipientName = msg.cardData?.recipientName || 'å¯¹æ–¹'; 
                    if (msg.isRetracted) return `{${(msg.type === 'sent') ? myName : senderName}|${msg.content}}`;
                    if (msg.segmentType === 'inner_voice') return `ã€å¿ƒå£°|${senderName}|${msg.content}ã€‘`;
                    switch (msg.segmentType) {
                        case 'text': return `[${senderName}|${msg.content}]`;
                        case 'emoji-image': return `<${senderName}|${msg.content}>`;
                        case 'voice': return `[${senderName}|è¯­éŸ³|${msg.cardData.duration}|${msg.cardData.content}]`;
                        case 'quote': return `[${senderName}|å¼•ç”¨|${msg.cardData.quotedName}|${msg.cardData.quotedContent}|${msg.cardData.newContent}]`;
                        case 'transfer-return': return `[${senderName}|é€€è¿˜è½¬è´¦|${msg.cardData.recipientName}|${msg.cardData.amount}]`;
                        case 'transfer': return `[${senderName}|è½¬è´¦|${msg.cardData.recipientName}|${msg.cardData.amount}|${msg.cardData.note || ''}]`;
                        case 'red-packet': return `[${senderName}|çº¢åŒ…|${msg.cardData.title}|ï¿¥${msg.cardData.amount.toFixed(2)}|${msg.cardData.count}]`;
                        case 'image_simulated': return `[${senderName}|å›¾ç‰‡æè¿°|${msg.cardData.description}]`;
                        case 'gift': return `<ç¤¼ç‰©>\nå‘é€æ–¹ï¼š${senderName}\næ¥æ”¶æ–¹ï¼š${recipientName}\nç¤¼ç‰©åç§°ï¼š${msg.cardData.name}\nç¤¼ç‰©ä»·æ ¼ï¼š${msg.cardData.price}\nç¤¼ç‰©ä»‹ç»ï¼š${msg.cardData.description || 'æ— '}\nå¯„è¯­ï¼š${msg.cardData.message}\n</ç¤¼ç‰©>`;
                        case 'pat_a_pat':
                            const pat = msg.content;
                            const actionText = pat.action ? `(${pat.action})` : 'æ‹äº†æ‹';
                            const contentText = pat.content ? `(${pat.content})` : '';
                            return `<æ‹ä¸€æ‹>${pat.patterName} ${actionText} ${pat.patteeName} ${contentText}</æ‹ä¸€æ‹>`;
                        case 'modify_pat_a_pat':
                            const mod = msg.content;
                            return `<ä¿®æ”¹æ‹ä¸€æ‹>\nä¿®æ”¹äººï¼š${mod.modifierName}\næ‹ä¸€æ‹åŠ¨ä½œï¼š${mod.action}\næ‹ä¸€æ‹å†…å®¹ï¼š${mod.content}\n</ä¿®æ”¹æ‹ä¸€æ‹>`;
                        case 'system': return msg.forAi ? `<ç³»ç»Ÿ>${msg.content}</ç³»ç»Ÿ>`: '';
                        case 'narrator': return `<æ—ç™½>${msg.content}</æ—ç™½>`;
                        case 'moment_forward': return msg.content; 
                        default: return '';
                    }
                };
                const buildHistoryBlock = (history, title, turnLimit) => { 
                    if (!history || history.length === 0) return '';
                    let promptHistoryTurns = [];
                    for (const msg of history.filter(m => m.segmentType !== 'essay')) {
                        const sender = (msg.type === 'sent') ? myProfile : allContacts.find(c => c.id === msg.senderId);
                        if (!sender && msg.segmentType !== 'system') continue;
                        const formattedContent = formatMessageContent(msg, sender ? sender.name : 'ç³»ç»Ÿ', myProfile.name);
                        if (!formattedContent) continue;
                        const role = msg.type === 'sent' ? 'player' : 'ai';
                        if (promptHistoryTurns.length > 0 && promptHistoryTurns[promptHistoryTurns.length - 1].role === role) {
                            promptHistoryTurns[promptHistoryTurns.length - 1].content += formattedContent;
                        } else {
                            promptHistoryTurns.push({ role: role, time: Utils.formatTimestampForPrompt(msg.timestamp), content: formattedContent });
                        }
                    }
                    const finalTurns = turnLimit ? promptHistoryTurns.slice(-turnLimit) : promptHistoryTurns;
                    if (finalTurns.length === 0) return '';
                    return `--- ${title} ---\n${finalTurns.map(turn => JSON.stringify(turn)).join('\n')}\n`;
                };
                
                let historyPrompt = "ä½œä¸ºå‚è€ƒï¼Œä»¥ä¸‹æ˜¯ä½ ä»¬ä¹‹å‰çš„èŠå¤©è®°å½•ï¼š\n";

                if (chatSettings.memoryInterconnection) {
                     if (isGroup) {
                        historyPrompt += buildHistoryBlock(fullHistory, 'å½“å‰ç¾¤èŠè®°å½•', historyLength); 
                        let privateContext = '--- ä»¥ä¸‹æ˜¯å„è§’è‰²çš„ç§èŠè®°å¿† (ä»…è§’è‰²è‡ªå·±å¯è§) ---\n';
                        for (const member of chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean)) {
                            const privateChatHistory = await DBHelper.getMessages(member.id, 20);
                            if (privateChatHistory.length > 0) privateContext += buildHistoryBlock(privateChatHistory, `ä¸ ${member.name} çš„ç§èŠè®°å½•`, 10);
                        }
                        historyPrompt += privateContext;
                    } else {
                        historyPrompt += buildHistoryBlock(fullHistory, 'å½“å‰ç§èŠè®°å½•', historyLength); 
                        const relatedGroups = allGroups.filter(g => g.members.includes(chatEntity.id));
                        let groupContext = '--- ä»¥ä¸‹æ˜¯ç›¸å…³çš„ç¾¤èŠè®°å¿† ---\n';
                        for (const group of relatedGroups) {
                            const groupChatHistory = await DBHelper.getMessages(group.id, 20);
                            if (groupChatHistory.length > 0) groupContext += buildHistoryBlock(groupChatHistory, `ç¾¤èŠâ€œ${group.name}â€çš„è®°å½•`, 8);
                        }
                        historyPrompt += groupContext;
                    }
                } else {
                    historyPrompt += buildHistoryBlock(fullHistory, 'å½“å‰èŠå¤©è®°å½•', historyLength); 
                }

                const taskPrompt = isGroup ? 
                    `ä½ ç°åœ¨æ­£åœ¨ä¸€ä¸ªåä¸ºâ€œ${chatEntity.name}â€çš„ç¾¤èŠä¸­ï¼Œéœ€è¦åŒæ—¶æ‰®æ¼”ä»¥ä¸‹å‡ ä½è§’è‰²ï¼š${chatEntity.members.map(id => allContacts.find(c => c.id === id)?.name).filter(Boolean).join('ã€')}ã€‚` :
                    `ä½ ç°åœ¨æ­£åœ¨æ‰®æ¼”â€œ${chatEntity.name}â€ï¼Œä¸â€œ${myProfile.name}â€è¿›è¡Œä¸€å¯¹ä¸€ç§èŠã€‚`;

                const characterInfoPrompt = isGroup ?
                    `ç¾¤èŠæˆå‘˜èµ„æ–™å¦‚ä¸‹ï¼š\n` + chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean).map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n') :
                    `ä½ çš„è§’è‰²èµ„æ–™å¦‚ä¸‹ï¼š\nè§’è‰²å: ${chatEntity.name}\næ€§åˆ«: ${chatEntity.gender}\nèƒŒæ™¯: ${chatEntity.background || 'æ— '}`;
                
                const playerInfoPrompt = `ç©å®¶ï¼ˆâ€œ${myProfile.name}â€ï¼‰çš„ä¿¡æ¯å¦‚ä¸‹ï¼š\næ€§åˆ«: ${myProfile.gender}\næ‹ä¸€æ‹åŠ¨ä½œ: ${myProfile.patAction || 'æ‹äº†æ‹'}\næ‹ä¸€æ‹å†…å®¹: ${myProfile.patContent || ''}\nèƒŒæ™¯: ${myProfile.background || 'æ— '}`;

                const useBuiltin = chatSettings.useBuiltinEmojis !== false;
                const useCustom = chatSettings.useCustomEmojisInPrompt !== false;

                let emojiMapForPrompt = {};
                if (useBuiltin) {
                    Object.assign(emojiMapForPrompt, BUILTIN_AI_EMOJIS);
                }
                if (useCustom) {
                    for (const [id, data] of Object.entries(appState.customEmojis)) {
                        emojiMapForPrompt[id] = data.name;
                    }
                }

                const emojiListString = Object.entries(emojiMapForPrompt).map(([id, desc]) => `${id}ï¼š${desc}`).join('\n');

                let patAPatRulesForPrompt = '';
                if (chatSettings.enablePatAPat !== false) {
                    patAPatRulesForPrompt = `11. **æ‹ä¸€æ‹**: å½“ä½ æƒ³è¡¨è¾¾ä¸€äº›ä¿çš®ã€æé†’æˆ–æƒ³äº’åŠ¨ä½†æ— è¯å¯è¯´çš„åœºæ™¯æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ‹ä¸€æ‹ã€‚ä½ å¿…é¡»ä½¿ç”¨è¢«æ‹è€…çš„è‡ªå®šä¹‰åŠ¨ä½œå’Œå†…å®¹ï¼Œä½¿ç”¨æ­¤æ ¼å¼ï¼š<æ‹ä¸€æ‹>æ‹äººè§’è‰²å (è¢«æ‹äººè®¾å®šçš„åŠ¨ä½œ) è¢«æ‹è§’è‰²å (è¢«æ‹äººè®¾å®šçš„å†…å®¹)</æ‹ä¸€æ‹>ã€‚
ä¾‹å¦‚ï¼Œå¦‚æœç©å®¶çš„æ‹ä¸€æ‹å†…å®¹æ˜¯â€œè¢«å¼¹é£äº†â€ï¼Œåˆ™æ ¼å¼ä¸ºï¼š<æ‹ä¸€æ‹>33 æ‹äº†æ‹ {PLAYER_NAME} è¢«å¼¹é£äº†</æ‹ä¸€æ‹>ã€‚
ç»å¯¹ä¸èƒ½ç”¨æ‹äººè€…çš„è‡ªå®šä¹‰åŠ¨ä½œå’Œå†…å®¹æ¥å›å¤ï¼Œè¿™æ˜¯é”™è¯¯çš„ã€‚
12. **ä¿®æ”¹æ‹ä¸€æ‹**: å½“è§’è‰²åŸºäºèŠå¤©è¯­å¢ƒæƒ³ä¿®æ”¹è‡ªå·±çš„æ‹ä¸€æ‹è®¾ç½®æ—¶ï¼Œä½¿ç”¨æ­¤æ ¼å¼ï¼š
<ä¿®æ”¹æ‹ä¸€æ‹>
ä¿®æ”¹äººï¼šè§’è‰²å
æ‹ä¸€æ‹åŠ¨ä½œï¼šxxxï¼ˆä¸è¶…è¿‡5ä¸ªå­—ï¼Œä¾‹å¦‚:æäº†æï¼‰
æ‹ä¸€æ‹å†…å®¹ï¼šxxxï¼ˆä¸è¶…è¿‡20ä¸ªå­—ï¼Œä¾‹å¦‚:çš„è„¸ï¼Œå¹¶è¯´å¥½è½¯å¥½è½¯;æˆ–è€…:çš„å¤´,è¢«å¼¹é£äº†ï¼‰
</ä¿®æ”¹æ‹ä¸€æ‹>`;
                }
                
                const finalPrompt = [
                    situationPrompt,
                    taskPrompt,
                    characterInfoPrompt,
                    playerInfoPrompt, 
                    historyPrompt,
                    AIHandler.activeReplyPromptTpl.replace('{EMOJI_LIST}', emojiListString).replace('{PLAYER_NAME}', myProfile.name).replace('{PAT_A_PAT_RULES}', patAPatRulesForPrompt)
                ].join('\n\n');

                console.log(`--- ACTIVE REPLY PROMPT SENT TO AI ---\n`, finalPrompt);
                return finalPrompt;
            },

            async parseAndDisplayMixedAIResponse(text, chatId) {
                
                const contacts = await DBHelper.getAll('contacts');
                const baseTimestamp = Date.now();
                let timestampOffset = 0;
                const displayableMessages = [];
                const messagesToSave = [];
                const contactUpdates = {};

                const createBaseMessage = (senderName, isAutoReply = false, displayTimestamp = null) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`æœªåœ¨é€šè®¯å½•ä¸­æ‰¾åˆ°åä¸º "${senderName}" çš„è§’è‰²ï¼Œè·³è¿‡æ­¤æ¶ˆæ¯ã€‚`);
                        return null;
                    }
                    return {
                        messageId: Utils.generateId('msg'),
                        chatId: chatId,
                        senderId: sender.id,
                        timestamp: baseTimestamp + timestampOffset++,
                        type: 'received',
                        isUnread: chatId !== appState.currentChatId,
                        isAutoReply: isAutoReply,
                        displayTimestamp: displayTimestamp,
                    };
                };

                const allMessageRegex = /ã€([^ã€]+?)ã€|ã€([^ã€‘]+?)ã€‘|ã€Œ([^ã€]+?)ã€|{([^{}]+?)}|\[([\s\S]+?)\]|<([^>]+?)>/g;

                text.replace(allMessageRegex, (match, cardContent, innerVoiceContent, essayContent, retractedContent, standardContent, emojiContent) => {
                    if (innerVoiceContent || essayContent) {
                        const content = innerVoiceContent || essayContent;
                        const parts = content.split('|').map(p => p.trim());
                        if (parts.length < 3) return;

                        const type = parts[0];
                        const senderName = parts[1];
                        const msgContent = parts.slice(2).join('|');
                        const sender = contacts.find(c => c.name === senderName);
                        if (!sender) return;

                        let message;
                        if (type === 'å¿ƒå£°') {
                            message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'inner_voice' };
                            if (!contactUpdates[sender.id]) contactUpdates[sender.id] = {};
                            contactUpdates[sender.id].lastInnerVoiceId = message.messageId;
                        } else if (type === 'éšç¬”') {
                            message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'essay' };
                            if (!contactUpdates[sender.id]) contactUpdates[sender.id] = {};
                            contactUpdates[sender.id].lastEssayId = message.messageId;
                            UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                        }
                        if (message) messagesToSave.push(message);
                        return;
                    }

                    let innerContent, bracketType;
                    if (cardContent) { bracketType = 'ã€'; innerContent = cardContent; }
                    else if (retractedContent) { bracketType = '{'; innerContent = retractedContent; }
                    else if (standardContent) { bracketType = '['; innerContent = standardContent; }
                    else if (emojiContent) { bracketType = '<'; innerContent = emojiContent; }
                    else { return; }

                    const parts = innerContent.split('|').map(p => p.trim());
                    if (parts.length < 2) return;
                    
                    const senderName = parts[0];
                    const lastPart = parts[parts.length - 1];
                    const timeRegex = /^(\d{1,2}\/\d{1,2}\s+)?\d{1,2}:\d{2}$/;
                    let isAutoReply = timeRegex.test(lastPart);
                    let displayTimestamp = isAutoReply ? lastPart : null;

                    const baseMessage = createBaseMessage(senderName, isAutoReply, displayTimestamp);
                    if (!baseMessage) return;

                    baseMessage.isRetracted = bracketType === '{';
                    baseMessage.toBeRetracted = bracketType === '{';

                    const contentParts = isAutoReply ? parts.slice(1, -1) : parts.slice(1);

                    if (bracketType === 'ã€') {
                        if(contentParts.length < 4) return;
                        baseMessage.segmentType = 'card';
                        baseMessage.content = `[å¡ç‰‡] ${contentParts[1]}`;
                        baseMessage.cardData = { shareType: contentParts[0], title: contentParts[1], summary: contentParts[2], details: contentParts[3], isExpanded: false };
                    } else if (bracketType === '<') {
                        baseMessage.segmentType = 'emoji-image';
                        baseMessage.content = contentParts[0];
                    } else { 
                        if (contentParts.length === 1) {
                            baseMessage.segmentType = 'text';
                            baseMessage.content = contentParts[0];
                        } else {
                            const typeKeyword = contentParts[0];
                            switch (typeKeyword) {
                                case 'è¯­éŸ³':
                                    baseMessage.segmentType = 'voice';
                                    baseMessage.content = `[è¯­éŸ³] ${contentParts[2]}`;
                                    baseMessage.cardData = { duration: contentParts[1], content: contentParts[2] };
                                    break;
                                case 'å¼•ç”¨':
                                    baseMessage.segmentType = 'quote';
                                    baseMessage.content = `[å¼•ç”¨] ${contentParts[3]}`;
                                    baseMessage.cardData = { quotedName: contentParts[1], quotedContent: contentParts[2], newContent: contentParts[3] };
                                    break;
                                default:
                                    baseMessage.segmentType = 'text';
                                    baseMessage.content = contentParts.join('|');
                                    break;
                            }
                        }
                    }

                    if (baseMessage.segmentType) {
                        messagesToSave.push(baseMessage);
                        displayableMessages.push(baseMessage);
                    }
                });

                await DBHelper.batchPut('messages', messagesToSave);

                for (const [contactId, updates] of Object.entries(contactUpdates)) {
                    const contactToUpdate = await DBHelper.get('contacts', contactId);
                    if (contactToUpdate) {
                        Object.assign(contactToUpdate, updates);
                        await DBHelper.put('contacts', contactToUpdate);
                    }
                }

                if (displayableMessages.length > 0) {
                    const lastDisplayableMsg = displayableMessages[displayableMessages.length - 1];
                    const isUnread = chatId !== appState.currentChatId;
                    await UIManager.updateChatMetadata(chatId, lastDisplayableMsg, isUnread ? displayableMessages.length : 0);
                }
                
                let lastTimestamp = 0;
                for (const msg of displayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));

                    const senderForDisplay = contacts.find(c => c.id === msg.senderId) || { name: 'æœªçŸ¥ç”¨æˆ·' };

                    if (chatId === appState.currentChatId) {
                        if (lastTimestamp > 0 && msg.timestamp - lastTimestamp > 5 * 60 * 1000) {
                            chatArea.appendChild(UIManager.createTimeDividerElement(msg.timestamp));
                        }
                        await UIManager.addMessageToDOM(msg, senderForDisplay, false, true);
                        if (msg.toBeRetracted) {
                            setTimeout(async () => {
                                const msgToRetract = await DBHelper.get('messages', msg.messageId);
                                if (msgToRetract) {
                                    msgToRetract.isRetracted = true;
                                    await DBHelper.put('messages', msgToRetract);
                                    const bubbleEl = $(`#${msg.messageId}`);
                                    if (bubbleEl) {
                                        bubbleEl.replaceWith(UIManager.createRetractionNotice(msgToRetract, senderForDisplay));
                                    }
                                }
                            }, Math.random() * 1000 + 1000);
                        }
                        chatArea.scrollTop = chatArea.scrollHeight;
                        lastTimestamp = msg.timestamp;
                    } else {
                        msg.senderInfo = senderForDisplay;
                        UIManager.showTopNotification(msg);
                    }
                }
            },

            async handleRegenerateRequest(messageId) {
                const confirmation = await new Promise(resolve => {
                    UIManager.showModal({
                        title: "é‡æ–°ç”Ÿæˆå›å¤",
                        body: "<p>ä½ ç¡®å®šè¦è®©AIé‡æ–°ç”Ÿæˆä¸Šä¸€æ¡å›å¤å—ï¼Ÿè¿™ä¼šåˆ é™¤AIçš„æœ€æ–°å‡ æ¡æ¶ˆæ¯ã€‚</p>",
                        actions: [
                            { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => { UIManager.hideModal(); resolve(false); } },
                            { text: 'ç¡®å®š', class: 'btn-primary', handler: () => { UIManager.hideModal(); resolve(true); } }
                        ]
                    });
                });

                if (!confirmation) return;

                const chatId = appState.currentChatId;
                const allMessages = await DBHelper.getMessages(chatId, 1000, Date.now()); 
                if (!allMessages || allMessages.length === 0) return;

                const playerMessageIndex = allMessages.findIndex(m => m.messageId === messageId);
                if (playerMessageIndex === -1) return;

                const messagesToDelete = [];
                for (let i = playerMessageIndex + 1; i < allMessages.length; i++) {
                    if (allMessages[i].type === 'received') {
                        
                        messagesToDelete.push(allMessages[i]);
                    }
                }
                
                
                for (const msgToDelete of messagesToDelete) {
                    if ((msgToDelete.segmentType === 'inner_voice' || msgToDelete.segmentType === 'essay') && msgToDelete.senderId) {
                        const contact = await DBHelper.get('contacts', msgToDelete.senderId);
                        if (contact) {
                            let contactNeedsUpdate = false;
                            if (msgToDelete.segmentType === 'inner_voice' && contact.lastInnerVoiceId === msgToDelete.messageId) {
                                delete contact.lastInnerVoiceId;
                                contactNeedsUpdate = true;
                            }
                            if (msgToDelete.segmentType === 'essay' && contact.lastEssayId === msgToDelete.messageId) {
                                delete contact.lastEssayId;
                                contactNeedsUpdate = true;
                            }
                            if (contactNeedsUpdate) {
                                await DBHelper.put('contacts', contact);
                            }
                        }
                    }
                }

                
                for (const msg of messagesToDelete) {
                    await DBHelper.delete('messages', msg.messageId);
                }
                
                if (messagesToDelete.length > 0) {
                     const messagesToDeleteIds = messagesToDelete.map(m => m.messageId);
                     const remainingMessages = allMessages.filter(m => !messagesToDeleteIds.includes(m.messageId));
                     if (remainingMessages.length > 0) {
                        const lastMessage = remainingMessages[remainingMessages.length - 1];
                        await UIManager.updateChatMetadata(chatId, lastMessage);
                     } else {
                        await DBHelper.delete('chatMetadata', chatId);
                     }
                }

                for (const msg of messagesToDelete) {
                    const elementToDelete = $(`#${msg.messageId}`);
                    if (elementToDelete) {
                        elementToDelete.remove();
                    }
                }

                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const regenerationInstruction = `\n---
ç´§æ€¥æŒ‡ä»¤ï¼šç©å®¶ï¼ˆâ€œ${myProfile.name}â€ï¼‰è¦æ±‚ä½ é‡æ–°ç”Ÿæˆåˆšæ‰çš„å›å¤ï¼Œå› ä¸ºä½ ä¹‹å‰çš„å›å¤å¯èƒ½â€œä¸ç¬¦åˆè§’è‰²æ€§æ ¼(OOC)â€æˆ–â€œæœªä½¿ç”¨æ­£ç¡®çš„æ ¼å¼â€ã€‚è¯·ä½ ä»”ç»†å¤æ ¸ä½ çš„è§’è‰²è®¾å®šå’Œæ‰€æœ‰å›å¤è§„åˆ™ï¼Œç„¶åç»™å‡ºä¸€ä¸ªæ›´ä¼˜è´¨çš„å›å¤ã€‚
---`;
                
                const basePrompt = await this.buildPrompt();
                const newPrompt = basePrompt + regenerationInstruction;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const isGroup = chatId.startsWith('group-');
                let typingTarget;
                const typingBubbleId = Utils.generateId('typing');

                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', chatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', appState.currentChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const messagesForImageCheck = await DBHelper.getMessages(chatId, 15);
                    const imagesForApi = [];
                    
                    for (let i = messagesForImageCheck.length - 1; i >= 0; i--) {
                        const msg = messagesForImageCheck[i];
                        if (msg.type === 'sent' && msg.messageId !== messageId) { 
                            if (msg.segmentType === 'image_vision') {
                                imagesForApi.push({ base64: msg.cardData.base64 });
                            }
                        } else if (msg.messageId === messageId) {
                            
                            break; 
                        }
                    }

                    const aiRawResponse = await this.getApiResponse(newPrompt, imagesForApi.reverse(), this.abortController.signal);
                    
                    const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId };
                    metadata.lastRawAiResponse = aiRawResponse;
                    await DBHelper.put('chatMetadata', metadata);

                    console.log("--- AI åŸå§‹å›å¤ ---\n", aiRawResponse);

                    await this.parseAndDisplayAIResponse(aiRawResponse, chatId);
                } catch (error) {
                    if (error.name !== 'AbortError') this.showError(`AIå›å¤å¤±è´¥: ${error.message}`);
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    const typingBubble = $(`#${typingBubbleId}`);
                    if (typingBubble) typingBubble.remove();
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    UIManager.syncAiButtonState();
                }
            },

async buildSummaryPrompt(chatId) {
    const isGroup = chatId.startsWith('group-');
    const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
    if (!entity) return null;

    const myProfile = await EventManager.getPlayerProfileForContext(chatId);
    const allContacts = await DBHelper.getAll('contacts');
    
    const history = await DBHelper.getMessages(chatId, 60);
    const turns = this.buildTurnsFromHistory(history, allContacts, myProfile);
    const last30turns = turns.slice(-30);
    if (last30turns.length === 0) return null;
    
    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
    const defaultSummaryPrompt = `ä½ æ˜¯ä¸€ä¸ªèŠå¤©è®°å½•æ€»ç»“åŠ©æ‰‹ã€‚è¯·æ ¹æ®â€œæœ€æ–°èŠå¤©è®°å½•â€ï¼Œä¸ºæˆ‘ç”Ÿæˆä¸€æ®µä¸è¶…è¿‡350ä¸ªå­—çš„æ–°æ€»ç»“ã€‚æ–°çš„æ€»ç»“éœ€è¦èåˆæ—§æ€»ç»“çš„æ ¸å¿ƒå†…å®¹å’Œæ–°èŠå¤©è®°å½•çš„è¦ç‚¹ï¼Œä¿æŒæ•…äº‹çš„è¿è´¯æ€§ã€‚è¯·é‡ç‚¹å…³æ³¨æ—¶é—´çš„å‘ç”Ÿæ—¶é—´ã€äººç‰©å…³ç³»çš„å˜åŒ–ã€å…³é”®äº‹ä»¶çš„è¿›å±•ã€ä»¥åŠé‡è¦ä¿¡æ¯çš„äº¤æ¢ã€‚å†…å®¹åº”å®¢è§‚ã€ä¿¡æ¯ä¸°å¯Œä¸”å‡ç»ƒã€‚`;
    const userSummaryPrompt = chatSettings.summaryPrompt || defaultSummaryPrompt;

    let prompt = `${userSummaryPrompt}\n\n`;
    prompt += `--- æœ€æ–°èŠå¤©è®°å½• (æœ€è¿‘30è½®) ---\n${last30turns.map(turn => `${turn.role}: ${turn.content}`).join('\n')}\n\n`;

    return prompt;
},

async handleAutoSummaryRequest(chatId) {
    if (appState.isSummarizing[chatId]) {
        console.log("å·²åœ¨æ€»ç»“ä¸­ï¼Œè·³è¿‡æ­¤æ¬¡è¯·æ±‚ã€‚");
        return;
    }

    try {
        appState.isSummarizing[chatId] = true;
        
        if ($('#auto-summary-content')) {
            const isGroup = chatId.startsWith('group-');
            UIManager.showAutoSummaryModal(chatId, isGroup);
        }

        const prompt = await this.buildSummaryPrompt(chatId);
        if (!prompt) {
            console.log("æ„å»ºæ€»ç»“Promptå¤±è´¥æˆ–æ— éœ€æ€»ç»“ã€‚");
            return;
        }

        console.log("--- SUMMARY PROMPT SENT TO AI ---\n", prompt);
        const summaryResponse = await this.getApiResponse(prompt, new AbortController().signal);

        if (summaryResponse) {
            const isGroup = chatId.startsWith('group-');
            const storeName = isGroup ? 'groups' : 'contacts';
            const entity = await DBHelper.get(storeName, chatId);
            
                const newSummaryPart = summaryResponse.trim().slice(0, 350);
                const separator = `\n\n--- ${new Date().toLocaleString()} ---\n`;
                
                if (entity.autoSummary) {
                    entity.autoSummary += separator + newSummaryPart;
                } else {
                    entity.autoSummary = newSummaryPart;
                }
                UIManager.showToast(`â€œ${entity.name}â€çš„æ€»ç»“å·²æ›´æ–°ï¼`); 
            
            await DBHelper.put(storeName, entity);
            console.log("æ–°æ€»ç»“å·²ä¿å­˜:", entity.autoSummary);
        }

    } catch (error) {
        console.error("è‡ªåŠ¨æ€»ç»“å¤±è´¥:", error);
    } finally {
        appState.isSummarizing[chatId] = false;
        
        if ($('#auto-summary-content')) {
            const isGroup = chatId.startsWith('group-');
            UIManager.showAutoSummaryModal(chatId, isGroup);
        }
    }
},

            async handleOpeningSceneRequest(scene) {
                if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const isGroup = !!scene.groupId;
                const chatId = isGroup ? scene.groupId : scene.contactId;
                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const allContacts = await DBHelper.getAll('contacts');
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};

                let taskPrompt, characterInfoPrompt, finalPrompt;
                
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);

                if (isGroup) {
                    const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    taskPrompt = `ä½ ç°åœ¨æ­£åœ¨ä¸€ä¸ªåä¸ºâ€œ${chatEntity.name}â€çš„ç¾¤èŠä¸­ï¼Œéœ€è¦åŒæ—¶æ‰®æ¼”ä»¥ä¸‹å‡ ä½è§’è‰²ï¼š${members.map(m => m.name).join('ã€')}ã€‚`;
                    characterInfoPrompt = `ç¾¤èŠæˆå‘˜èµ„æ–™å¦‚ä¸‹ï¼š\n` + members.map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n');
                } else {
                    taskPrompt = `ä½ ç°åœ¨æ­£åœ¨æ‰®æ¼”â€œ${chatEntity.name}â€ï¼Œä¸â€œ${myProfile.name}â€ï¼ˆä¹Ÿå°±æ˜¯ç©å®¶ï¼‰è¿›è¡Œä¸€å¯¹ä¸€ç§èŠã€‚`;
                    characterInfoPrompt = `ä½ çš„è§’è‰²èµ„æ–™å¦‚ä¸‹ï¼š\nè§’è‰²å: ${chatEntity.name}\næ€§åˆ«: ${chatEntity.gender}\nå–œå¥½: ${chatEntity.likes || 'æ— '}\nåŒæ¶: ${chatEntity.dislikes || 'æ— '}\nä¹ æƒ¯: ${chatEntity.habits || 'æ— '}\nèƒŒæ™¯: ${chatEntity.background || 'æ— '}`;
                }
                
                let customPromptsSection = '';
                if (chatEntity && chatEntity.boundPromptFolderIds?.length > 0) {
                    const allFolders = await DBHelper.getAll('promptFolders');
                    const allPrompts = await DBHelper.getAll('prompts');
                    const playerInputForScene = scene.content;

                    const activeBoundFolders = allFolders.filter(f => chatEntity.boundPromptFolderIds.includes(f.id) && f.isActive);
                    if (activeBoundFolders.length > 0) {
                        const activeBoundFolderIds = activeBoundFolders.map(f => f.id);
                        const relevantPrompts = allPrompts.filter(p => activeBoundFolderIds.includes(p.folderId) && p.isActive);
                        const promptsToInject = relevantPrompts
                            .filter(p => p.type === 'explicit' || (p.type === 'implicit' && JSON.parse(p.keywords).some(kw => playerInputForScene.includes(kw))))
                            .map(p => p.content);
                        if (promptsToInject.length > 0) {
                            customPromptsSection = `\n--- å…¶ä»–èµ„æ–™ ---\n${promptsToInject.join('\n\n')}\n---`;
                        }
                    }
                }

                const playerInfoPrompt = `ç©å®¶ï¼ˆâ€œ${myProfile.name}â€ï¼‰çš„ä¿¡æ¯å¦‚ä¸‹ï¼š\næ€§åˆ«: ${myProfile.gender}\næ‹ä¸€æ‹åŠ¨ä½œ: ${myProfile.patAction || 'æ‹äº†æ‹'}\næ‹ä¸€æ‹å†…å®¹: ${myProfile.patContent || ''}\nèƒŒæ™¯: ${myProfile.background || 'æ— '}`;
                const openingInstruction = `\n---
ç´§æ€¥æŒ‡ä»¤ï¼šè¿™æ˜¯ä¸€ä¸ªå…¨æ–°çš„å¼€åœºã€‚è¯·æ ¹æ®ä»¥ä¸‹â€œå¼€åœºç™½â€å†…å®¹ï¼Œè®©è§’è‰²å¼€å§‹å¯¹è¯ï¼Œè¥é€ å‡ºå¼€åœºæ°›å›´ã€‚ä¸è¦æåŠâ€œå¼€åœºç™½â€è¿™ä¸‰ä¸ªå­—ï¼Œç›´æ¥å¼€å§‹è¡¨æ¼”ã€‚
å¼€åœºç™½å†…å®¹ï¼š
â€œ${scene.content}â€
---`;
                
                const useBuiltin = chatSettings.useBuiltinEmojis !== false;
                const useCustom = chatSettings.useCustomEmojisInPrompt !== false;
                let emojiMapForPrompt = {};
                if (useBuiltin) Object.assign(emojiMapForPrompt, BUILTIN_AI_EMOJIS);
                if (useCustom) {
                    for (const [id, data] of Object.entries(appState.customEmojis)) {
                        emojiMapForPrompt[id] = data.name;
                    }
                }
                const emojiListString = Object.entries(emojiMapForPrompt).map(([id, desc]) => `${id}ï¼š${desc}`).join('\n');
                
                let patAPatRulesForPrompt = '';
                if (chatSettings.enablePatAPat !== false) {
                    patAPatRulesForPrompt = `11. **æ‹ä¸€æ‹**: å½“ä½ æƒ³è¡¨è¾¾ä¸€äº›ä¿çš®ã€æé†’æˆ–æƒ³äº’åŠ¨ä½†æ— è¯å¯è¯´çš„åœºæ™¯æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ‹ä¸€æ‹ã€‚ä½ å¿…é¡»ä½¿ç”¨è¢«æ‹è€…çš„è‡ªå®šä¹‰åŠ¨ä½œå’Œå†…å®¹ï¼Œä½¿ç”¨æ­¤æ ¼å¼ï¼š<æ‹ä¸€æ‹>æ‹äººè§’è‰²å (è¢«æ‹äººè®¾å®šçš„åŠ¨ä½œ) è¢«æ‹è§’è‰²å (è¢«æ‹äººè®¾å®šçš„å†…å®¹)</æ‹ä¸€æ‹>ã€‚
ä¾‹å¦‚ï¼Œå¦‚æœç©å®¶çš„æ‹ä¸€æ‹å†…å®¹æ˜¯â€œè¢«å¼¹é£äº†â€ï¼Œåˆ™æ ¼å¼ä¸ºï¼š<æ‹ä¸€æ‹>33 æ‹äº†æ‹ {PLAYER_NAME} è¢«å¼¹é£äº†</æ‹ä¸€æ‹>ã€‚
ç»å¯¹ä¸èƒ½ç”¨æ‹äººè€…çš„è‡ªå®šä¹‰åŠ¨ä½œå’Œå†…å®¹æ¥å›å¤ï¼Œè¿™æ˜¯é”™è¯¯çš„ã€‚
12. **ä¿®æ”¹æ‹ä¸€æ‹**: å½“è§’è‰²åŸºäºèŠå¤©è¯­å¢ƒä¸‹æƒ³ä¿®æ”¹è‡ªå·±çš„æ‹ä¸€æ‹è®¾ç½®æ—¶ï¼Œä½¿ç”¨æ­¤æ ¼å¼ï¼š
<ä¿®æ”¹æ‹ä¸€æ‹>
ä¿®æ”¹äººï¼šè§’è‰²å
æ‹ä¸€æ‹åŠ¨ä½œï¼šxxxï¼ˆä¸è¶…è¿‡5ä¸ªå­—ï¼Œä¾‹å¦‚:æäº†æï¼‰
æ‹ä¸€æ‹å†…å®¹ï¼šxxxï¼ˆä¸è¶…è¿‡20ä¸ªå­—ï¼Œä¾‹å¦‚:çš„è„¸ï¼Œå¹¶è¯´å¥½è½¯å¥½è½¯;æˆ–è€…:çš„å¤´,è¢«å¼¹é£äº†ï¼‰
</ä¿®æ”¹æ‹ä¸€æ‹>`;
                }
                
                const formatPrompt = AIHandler.formatPromptTpl.replace('{EMOJI_LIST}', emojiListString).replace('{PLAYER_NAME}', myProfile.name).replace('{PAT_A_PAT_RULES}', patAPatRulesForPrompt);

                const promptParts = [
                    taskPrompt, 
                    characterInfoPrompt, 
                    playerInfoPrompt, 
                    customPromptsSection,
                    openingInstruction, 
                    formatPrompt
                ];

                finalPrompt = promptParts.filter(Boolean).join('\n\n');
                if (isGroup) {
                    finalPrompt += this.getGroupChatRules(chatSettings);
                }
                
                console.log("--- OPENING SCENE PROMPT SENT TO AI ---\n", finalPrompt);
                
                const typingTarget = chatEntity;
                const typingBubbleId = Utils.generateId('typing');
                if (typingTarget) {
                     if (isGroup) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    } else {
                        chatTypingIndicator.style.display = 'block';
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(finalPrompt, null, this.abortController.signal);
                    const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId };
                    metadata.lastRawAiResponse = aiRawResponse;
                    await DBHelper.put('chatMetadata', metadata);
                    
                    console.log("--- AI åŸå§‹å›å¤ ---\n", aiRawResponse);
                    await this.parseAndDisplayAIResponse(aiRawResponse, chatId);
                } catch (error) {
                    if (error.name !== 'AbortError') this.showError(`AIå›å¤å¤±è´¥: ${error.message}`);
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    const typingBubble = $(`#${typingBubbleId}`);
                    if (typingBubble) typingBubble.remove();
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },

            async findAndClaimTransfer(senderName, recipientName, amount, chatId) {
                const history = await DBHelper.getMessages(chatId, 30);
                const targetTransfer = history.reverse().find(msg => 
                    msg.segmentType === 'transfer' &&
                    !msg.cardData.isClaimed &&
                    msg.cardData.recipientName === recipientName &&
                    msg.cardData.amount === `ï¿¥${amount.toFixed(2)}` 
                );

                if (targetTransfer) {
                    targetTransfer.cardData.isClaimed = true;
                    await DBHelper.put('messages', targetTransfer);
                    const bubble = $(`#${targetTransfer.messageId} .bubble`);
                    if (bubble) bubble.classList.add('claimed');
                    console.log(`Transfer ${targetTransfer.messageId} has been claimed.`);
                } else {
                    console.warn(`Could not find matching unclaimed transfer for ${recipientName} from ${senderName}.`);
                }
            },
            async parseAndDisplayAIResponse(text, chatId) {
                const contacts = await DBHelper.getAll('contacts');
                const baseTimestamp = Date.now();
                let timestampOffset = 0;
                const displayableMessages = [];
                const parseStartTime = Date.now(); 
                let newGroupNameFromAI = null;
                const chatMetadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId };

                const createBaseMessage = (senderName) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`æœªåœ¨é€šè®¯å½•ä¸­æ‰¾åˆ°åä¸º "${senderName}" çš„è§’è‰²ï¼Œè·³è¿‡æ­¤æ¶ˆæ¯ã€‚`);
                        return null;
                    }
                    const baseMessage = {
                        messageId: Utils.generateId('msg'),
                        chatId: chatId,
                        senderId: sender.id,
                        timestamp: baseTimestamp + timestampOffset++,
                        type: 'received',
                        isUnread: chatId !== appState.currentChatId,
                    };
                    return { baseMessage, sender };
                };

                const allMessageRegex = /<æœ‹å‹åœˆ>([\s\S]*?)<\/æœ‹å‹åœˆ>|<æ—ç™½>([\s\S]*?)<\/æ—ç™½>|<ç³»ç»Ÿ>([\s\S]*?)<\/ç³»ç»Ÿ>|<ç§èŠ>([\s\S]*?)<\/ç§èŠ>|<ç¤¼ç‰©>([\s\S]*?)<\/ç¤¼ç‰©>|<æ‹ä¸€æ‹>([\s\S]*?)<\/æ‹ä¸€æ‹>|<ä¿®æ”¹æ‹ä¸€æ‹>([\s\S]*?)<\/ä¿®æ”¹æ‹ä¸€æ‹>|ã€([^ã€]+?)ã€|ã€([^ã€‘]+?)ã€‘|ã€Œ([^ã€]+?)ã€|{([^{}]+?)}|\[([\s\S]+?)\]|<((?!ç³»ç»Ÿ|ç§èŠ)[^>]+?)>/g;

                const messagesToSave = [];
                const contactUpdates = {};

                const matches = text.matchAll(allMessageRegex);
                
                const isGroup = chatId.startsWith('group-');
                let currentMemberIds = [];
                if (isGroup) {
                    const group = await DBHelper.get('groups', chatId);
                    if(group) {
                        currentMemberIds = group.members;
                    }
                }
                
                
                for (const match of matches) {
                    const [
                        fullMatch, momentContent, narratorContent, systemContent, privateContent,
                        giftContent, patAPatContent, modifyPatContent, cardContent,
                        innerVoiceContent, essayContent, retractedContent,
                        standardContent, emojiContent
                    ] = match;

                    if (momentContent !== undefined) {
                        (async () => {
                            const block = momentContent.trim();
                            const postMatch = block.match(/ã€(.*?)ã€‘/);
                            if (!postMatch) return;

                            const [authorPart, timePart] = postMatch[1].split('|');
                            const [authorName, ...contentParts] = authorPart.split('ï¼š');
                            const content = contentParts.join('ï¼š').trim();
                            const trimmedAuthorName = authorName.trim();

                            const author = contacts.find(c => c.name === trimmedAuthorName);
                            if (!author || !author.boundCircleId) {
                                console.log(`æœ‹å‹åœˆåŠ¨æ€è¢«è·³è¿‡ï¼šè§’è‰²â€œ${trimmedAuthorName}â€æœªæ‰¾åˆ°æˆ–æœªç»‘å®šæœ‹å‹åœˆã€‚`);
                                return;
                            }

                            const myProfile = await EventManager.getPlayerProfileForContext(author.boundCircleId);

                            const likeMatch = block.match(/ï¼ˆå·²ç‚¹èµï¼š(.*?)ï¼‰/);
                            const likerNames = likeMatch ? likeMatch[1].split(/,|ï¼Œ/).map(n => n.trim()) : [];

                            const newMoment = {
                                id: Utils.generateId('moment'),
                                circleId: author.boundCircleId,
                                authorId: author.id,
                                content: content,
                                images: [], 
                                timestamp: Utils.parseMomentTimestamp(timePart ? timePart.trim() : null),
                                likes: likerNames, 
                                comments: []
                            };
                            
                            const commentMatches = block.match(/ã€–(.*?)ã€—/g) || [];
                            for (const cMatch of commentMatches) {
                                const inner = cMatch.slice(1, -1);
                                const [cAuthorName, ...cContentParts] = inner.split('ï¼š');
                                const trimmedCommentAuthor = cAuthorName.trim();
                                
                                let cAuthorId;
                                if (trimmedCommentAuthor === myProfile.name) {
                                    cAuthorId = myProfile.id; 
                                } else {
                                    const cAuthorContact = contacts.find(c => c.name === trimmedCommentAuthor);
                                    cAuthorId = cAuthorContact ? cAuthorContact.id : trimmedCommentAuthor; 
                                }
                                
                                newMoment.comments.push({
                                    authorId: cAuthorId,
                                    content: cContentParts.join('ï¼š').trim(),
                                    timestamp: Date.now()
                                });
                            }

                            await DBHelper.put('moments', newMoment);
                            UIManager.showMomentNotification(newMoment);
                        })();
                    } else if (patAPatContent !== undefined) {
                        const content = patAPatContent.trim();
                        const patMatch = content.match(/(\S+)\s+.*?\s+(\S+)/);

                        if (patMatch) {
                            const [, patterName, patteeName] = patMatch.map(s => s.trim());
                            
                            
                            const patterContact = contacts.find(c => c.name === patterName);
                            const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                            const patteeIsPlayer = patteeName === myProfile.name;
                            const patteeContact = patteeIsPlayer ? myProfile : contacts.find(c => c.name === patteeName);

                            if (patterContact && patteeContact) {
                                const finalAction = patteeContact.patAction || 'æ‹äº†æ‹';
                                const finalContent = patteeContact.patContent || '';
                                const finalDisplayText = `${patterName} ${finalAction} ${patteeName}${finalContent ? ` ${finalContent}` : ''}`;

                                const message = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: chatId,
                                    senderId: patterContact.id,
                                    timestamp: baseTimestamp + timestampOffset++,
                                    type: 'received',
                                    isUnread: chatId !== appState.currentChatId,
                                    segmentType: 'pat_a_pat',
                                    content: {
                                        patterName: patterName,
                                        patteeName: patteeName,
                                        action: finalAction,
                                        content: finalContent,
                                        displayText: finalDisplayText
                                    }
                                };
                                messagesToSave.push(message);
                                displayableMessages.push(message);
                            }
                        }
                    } else if (modifyPatContent !== undefined) {
                        const content = modifyPatContent.trim();
                        const modifierMatch = content.match(/ä¿®æ”¹äººï¼š(.+)/);
                        const actionMatch = content.match(/æ‹ä¸€æ‹åŠ¨ä½œï¼š(.+)/);
                        const contentMatch = content.match(/æ‹ä¸€æ‹å†…å®¹ï¼š(.+)/);

                        const modifierName = modifierMatch ? modifierMatch[1].trim() : null;
                        if (modifierName) {
                            const contactToUpdate = contacts.find(c => c.name === modifierName);
                            if (contactToUpdate) {
                                if (actionMatch) contactToUpdate.patAction = actionMatch[1].trim();
                                if (contentMatch) contactToUpdate.patContent = contentMatch[1].trim();
                                
                                if (!contactUpdates[contactToUpdate.id]) {
                                    contactUpdates[contactToUpdate.id] = {};
                                }
                                Object.assign(contactUpdates[contactToUpdate.id], {
                                    patAction: contactToUpdate.patAction,
                                    patContent: contactToUpdate.patContent
                                });

                                const systemMessage = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: chatId,
                                    timestamp: baseTimestamp + timestampOffset++,
                                    type: 'received',
                                    content: `${modifierName} æ›´æ–°äº†è‡ªå·±çš„æ‹ä¸€æ‹`,
                                    segmentType: 'system',
                                    forAi: false
                                };
                                messagesToSave.push(systemMessage);
                                displayableMessages.push(systemMessage);
                            }
                        }
                    } else if (narratorContent !== undefined) {
                        const message = { 
                            messageId: Utils.generateId('msg'), 
                            chatId: chatId,
                            timestamp: baseTimestamp + timestampOffset++,
                            type: 'received',
                            content: narratorContent.trim(), 
                            segmentType: 'narrator' 
                        };
                        messagesToSave.push(message);
                        displayableMessages.push(message);
                    } else if (systemContent !== undefined) {
                        const content = systemContent.trim();
                        const nameChangeParts = content.match(/(.+?)\s*ä¿®æ”¹ç¾¤åä¸º\s*(.*)$/);

                        if (nameChangeParts && nameChangeParts.length === 3) {
                            const modifierName = nameChangeParts[1].trim();
                            const rawNewName = nameChangeParts[2].trim();
                            
                            
                            if (isGroup) {
                                const modifierContact = contacts.find(c => c.name === modifierName);
                                if (!modifierContact || !currentMemberIds.includes(modifierContact.id)) {
                                    console.warn(`å·²å¿½ç•¥ï¼šç¾¤èŠå¤–çš„æˆå‘˜ "${modifierName}" å°è¯•ä¿®æ”¹ç¾¤åã€‚`);
                                    continue; 
                                }
                            }
                            

                            const parsedNewName = rawNewName.replace(/^["â€œ]|["â€]$/g, '');
                            newGroupNameFromAI = parsedNewName;

                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                chatId: chatId,
                                timestamp: baseTimestamp + timestampOffset++,
                                type: 'received',
                                content: `${modifierName} ä¿®æ”¹ç¾¤åä¸º â€œ${parsedNewName}â€`,
                                segmentType: 'system',
                                forAi: true
                            };
                            messagesToSave.push(systemMessage);
                            displayableMessages.push(systemMessage);
                        }
                    } else if (privateContent !== undefined) {
                        const innerContent = privateContent.trim();
                        (async () => {
                            const innerMatches = innerContent.matchAll(allMessageRegex);
                            for (const innerMatch of innerMatches) {
                                const [
                                    innerFullMatch, iMoment, iNarrator, iSystem, iPrivate, iGift,
                                    iPat, iModifyPat, iCard, iInnerVoice, iEssay,
                                    iRetracted, iStandard, iEmoji
                                ] = innerMatch;

                                let senderName, sender;
                                const contentToParse = iRetracted || iStandard || iEmoji || '';
                                const senderMatch = contentToParse.match(/^([^|]+?)\|/);

                                if (!senderMatch) continue;
                                senderName = senderMatch[1].trim();
                                sender = contacts.find(c => c.name === senderName);
                                if (!sender) continue;

                                const privateMessage = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: sender.id,
                                    senderId: sender.id,
                                    timestamp: Date.now() + timestampOffset++,
                                    type: 'received',
                                    isUnread: true,
                                    isPrivateInGroup: true,
                                };

                                if (iRetracted) {
                                    const parts = iRetracted.split('|');
                                    privateMessage.segmentType = 'text';
                                    privateMessage.content = parts.slice(1).join('|').trim();
                                    privateMessage.isRetracted = true;
                                } else if (iEmoji) {
                                    const parts = iEmoji.split('|');
                                    privateMessage.segmentType = 'emoji-image';
                                    privateMessage.content = parts[1].trim();
                                } else if (iStandard) {
                                    const parts = iStandard.split('|').map(p => p.trim());
                                    const typeKeyword = parts[1];
                                    switch (typeKeyword) {
                                        case 'è¯­éŸ³':
                                            privateMessage.segmentType = 'voice';
                                            privateMessage.content = `[è¯­éŸ³] ${parts[3]}`;
                                            privateMessage.cardData = { duration: parts[2], content: parts[3] };
                                            break;
                                        case 'å¼•ç”¨':
                                            privateMessage.segmentType = 'quote';
                                            privateMessage.content = `[å¼•ç”¨] ${parts[4]}`;
                                            privateMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] };
                                            break;
                                        default:
                                            privateMessage.segmentType = 'text';
                                            privateMessage.content = parts.slice(1).join('|').trim();
                                            break;
                                    }
                                } else {
                                    continue;
                                }

                                if (privateMessage.segmentType) {
                                    await DBHelper.put('messages', privateMessage);
                                    await UIManager.updateChatMetadata(sender.id, privateMessage, 1);
                                    const senderForDisplay = await DBHelper.get('contacts', privateMessage.senderId);
                                    privateMessage.senderInfo = senderForDisplay;
                                    UIManager.showTopNotification(privateMessage);
                                    if (appState.currentPage === 'messages') {
                                        await UIManager.renderMessagesListPage();
                                    }
                                }
                            }
                        })();
                    } else if (giftContent !== undefined) {
                        const content = giftContent.trim();
                        const senderMatch = content.match(/å‘é€æ–¹ï¼š(.+)/);
                        const recipientMatch = content.match(/æ¥æ”¶æ–¹ï¼š(.+)/);
                        const nameMatch = content.match(/ç¤¼ç‰©åç§°ï¼š(.+)/);
                        const priceMatch = content.match(/ç¤¼ç‰©ä»·æ ¼ï¼š(.+)/);
                        const descMatch = content.match(/ç¤¼ç‰©ä»‹ç»ï¼š([\s\S]+?)å¯„è¯­ï¼š/);
                        const messageMatch = content.match(/å¯„è¯­ï¼š(.+)/);

                        const senderName = senderMatch ? senderMatch[1].trim() : null;
                        if (!senderName) continue;
                        
                        
                        const result = createBaseMessage(senderName);
                        if (result) {
                            const { baseMessage, sender } = result; 
                            baseMessage.segmentType = 'gift';
                            baseMessage.content = `[ç¤¼ç‰©] ${nameMatch ? nameMatch[1].trim() : 'ä¸€ä»½ç¤¼ç‰©'}`;
                            baseMessage.cardData = {
                                recipientName: recipientMatch ? recipientMatch[1].trim() : 'ä½ ',
                                name: nameMatch ? nameMatch[1].trim() : 'ç¤¼ç‰©',
                                price: priceMatch ? priceMatch[1].trim() : '0.00',
                                description: descMatch ? descMatch[1].trim() : '',
                                message: messageMatch ? messageMatch[1].trim() : 'ä¸€ä»½å¿ƒæ„ã€‚',
                                image: [
                                    'https://cfimg.200996.xyz/file/1752744399723_retouch_2025071717250175.png',
                                    'https://cfimg.200996.xyz/file/1752744402256_retouch_2025071717245049.png',
                                    'https://cfimg.200996.xyz/file/1752744401540_retouch_2025071717242531.png',
                                    'https://cfimg.200996.xyz/file/1752744403509_retouch_2025071717243405.png',
                                    'https://cfimg.200996.xyz/file/1752744399889_retouch_2025071717244351.png'
                                ][Math.floor(Math.random() * 5)]
                            };
                            messagesToSave.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    } else if (cardContent !== undefined) {
                        const parts = cardContent.split('|').map(p => p.trim());
                        const [senderName, shareType, title, summary, details] = parts;
                        const result = createBaseMessage(senderName);
                        if (!result) continue;
                        const { baseMessage, sender } = result;

                        baseMessage.segmentType = 'card';
                        baseMessage.content = `[å¡ç‰‡] ${title}`;
                        baseMessage.cardData = { shareType, title, summary, details, isExpanded: false };
                        messagesToSave.push(baseMessage);
                        displayableMessages.push(baseMessage);
                    } else if (innerVoiceContent !== undefined || essayContent !== undefined) {
                        const content = innerVoiceContent || essayContent;
                        const parts = content.split('|').map(p => p.trim());
                        if (parts.length !== 3) continue;

                        const type = parts[0];
                        const senderName = parts[1];
                        const msgContent = parts[2];
                        
                        const sender = contacts.find(c => c.name === senderName);
                        if (!sender) continue;

                        let message;
                        if (type === 'å¿ƒå£°') {
                            message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'inner_voice' };
                        } else if (type === 'éšç¬”') {
                            message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'essay' };
                            UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                        } else {
                            continue;
                        }
                        
                        messagesToSave.push(message);

                        if (!contactUpdates[sender.id]) {
                            contactUpdates[sender.id] = {};
                        }
                        if (type === 'å¿ƒå£°') {
                            contactUpdates[sender.id].lastInnerVoiceId = message.messageId;
                        } else if (type === 'éšç¬”') {
                            contactUpdates[sender.id].lastEssayId = message.messageId;
                        }
                    } else { 
                        let bracketType, innerContent;
                        if (retractedContent) { bracketType = '{'; innerContent = retractedContent; }
                        else if (standardContent) { bracketType = '['; innerContent = standardContent; }
                        else if (emojiContent) { bracketType = '<'; innerContent = emojiContent; }
                        else { continue; } 

                        if (bracketType === '<' && innerContent.startsWith('éšç¬”|')) {
                            const parts = innerContent.split('|').map(p => p.trim());
                            if (parts.length >= 3) {
                                const senderName = parts[1];
                                const msgContent = parts.slice(2).join('|');
                                const sender = contacts.find(c => c.name === senderName);
                                if (sender) {
                                    messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'essay' });
                                    UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                                }
                            }
                            continue; 
                        }

                        const parts = innerContent.split('|').map(p => p.trim());
                        const [senderName] = parts;
                        const result = createBaseMessage(senderName);
                        
                        if (isGroup) {
                            const senderContact = contacts.find(c => c.name === senderName);
                            if (!senderContact || !currentMemberIds.includes(senderContact.id)) {
                                console.warn(`å·²å¿½ç•¥ï¼šç¾¤èŠå¤–çš„æˆå‘˜ "${senderName}" çš„æ¶ˆæ¯ã€‚`);
                                continue; 
                            }
                        }
                        if (!result) continue;
                        const { baseMessage, sender } = result;

                        if (bracketType === '<') {
                            const emojiSetting = sender.allowEmoji;
                            let shouldDisplay = true;

                            if (emojiSetting === 'off') {
                                shouldDisplay = false;
                            } else if (emojiSetting === 'prob') {
                                shouldDisplay = Math.random() < 0.5;
                            }
                            
                            if (!shouldDisplay) {
                                continue;
                            }

                            baseMessage.segmentType = 'emoji-image';
                            baseMessage.content = parts[1];
                        } else {
                            baseMessage.isRetracted = bracketType === '{';
                            baseMessage.toBeRetracted = bracketType === '{';

                            if (baseMessage.toBeRetracted && sender.allowRetraction === false) {
                                baseMessage.toBeRetracted = false;
                                baseMessage.isRetracted = false;
                            }
                            
                            if (parts.length === 2) { baseMessage.segmentType = 'text'; baseMessage.content = parts[1]; }
                            else if (parts[1] === 'é¢†å–è½¬è´¦') { 
                                baseMessage.segmentType = 'transfer-receipt'; 
                                baseMessage.content = `${parts[2]}å·²æ”¶æ¬¾${parts[3]}`; 
                                baseMessage.cardData = { recipientName: parts[0], senderName: parts[2], amount: parts[3] }; 
                                this.findAndClaimTransfer(parts[2], parts[0], parseFloat(parts[3].replace('ï¿¥', '')), chatId);
                            }
                            else if (parts[1] === 'é€€è¿˜è½¬è´¦') {
                                baseMessage.segmentType = 'transfer-return';
                                baseMessage.content = `${parts[0]}é€€è¿˜äº†è½¬è´¦${parts[3]}`;
                                baseMessage.cardData = { recipientName: parts[2], senderName: parts[0], amount: parts[3] };
                                this.findAndClaimTransfer(parts[2], parts[0], parseFloat(parts[3].replace('ï¿¥', '')), chatId);
                            }
                            else if (parts[1] === 'è¯­éŸ³') { baseMessage.segmentType = 'voice'; baseMessage.content = `[è¯­éŸ³] ${parts[3]}`; baseMessage.cardData = { duration: parts[2], content: parts[3] }; }
                            else if (parts[1] === 'å¼•ç”¨') { baseMessage.segmentType = 'quote'; baseMessage.content = `[å¼•ç”¨] ${parts[4]}`; baseMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] }; }
                            else if (parts[1] === 'è½¬è´¦') { baseMessage.segmentType = 'transfer'; baseMessage.content = `[è½¬è´¦] ${parts[3]}`; baseMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false }; }
                            else if (parts[1] === 'çº¢åŒ…') { baseMessage.segmentType = 'red-packet'; baseMessage.content = `[çº¢åŒ…] ${parts[2]}`; baseMessage.cardData = { title: parts[2], amount: parseFloat(parts[3].replace('ï¿¥', '')), count: parseInt(parts[4]), claimedBy: [] }; }
                        }

                        if (baseMessage.segmentType) {
                            messagesToSave.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    }
                }

                
                for (const [contactId, updates] of Object.entries(contactUpdates)) {
                    const contactToUpdate = await DBHelper.get('contacts', contactId);
                    if (contactToUpdate) {
                        Object.assign(contactToUpdate, updates);
                        await DBHelper.put('contacts', contactToUpdate);
                    }
                }



                
                const validMessagesToSave = messagesToSave.filter(msg => {
                    if (msg.messageId) {
                        return true;
                    } else {
                        
                        console.warn("è¿‡æ»¤æ‰ä¸€ä¸ªæ— æ•ˆçš„æ¶ˆæ¯å¯¹è±¡ (ç¼ºå°‘ messageId):", msg);
                        return false;
                    }
                });
                
                await DBHelper.batchPut('messages', validMessagesToSave);
                

                if (newGroupNameFromAI && chatId.startsWith('group-')) {
                    const group = await DBHelper.get('groups', chatId);
                    if (group) {
                        group.name = newGroupNameFromAI;
                        await DBHelper.put('groups', group);
                        if (chatId === appState.currentChatId) {
                            chatTitle.textContent = newGroupNameFromAI;
                        }
                    }
                }

                
                
                const validDisplayableMessages = displayableMessages.filter(displayMsg =>
                    validMessagesToSave.some(savedMsg => savedMsg.messageId === displayMsg.messageId)
                );

                
                if (validDisplayableMessages.length > 0) {
                    chatMetadata.lastAiReplyTimestamp = Date.now();
                    await DBHelper.put('chatMetadata', chatMetadata);
                }

                if (validDisplayableMessages.length > 0) {
                    const lastDisplayableMsg = validDisplayableMessages[validDisplayableMessages.length - 1];
                    const isUnread = chatId !== appState.currentChatId;
                    await UIManager.updateChatMetadata(chatId, lastDisplayableMsg, isUnread ? validDisplayableMessages.length : 0);
                }
                

                
                const lastMessageBeforeLoop = (await DBHelper.getMessages(chatId, 1, baseTimestamp)).pop();
                let lastTimestamp = lastMessageBeforeLoop ? lastMessageBeforeLoop.timestamp : 0;
                
                for (const msg of validDisplayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));

                    
                    const senderForDisplay = contacts.find(c => c.id === msg.senderId) || { name: 'æœªçŸ¥ç”¨æˆ·', avatar: Utils.createAvatarDataUrl('#ccc') };
                    msg.senderInfo = senderForDisplay;

                    if (chatId === appState.currentChatId) {
                        
                        if (appState.currentChat.lastRefreshTimestamp > parseStartTime) {
                            console.log("èŠå¤©è§†å›¾å·²åœ¨AIå›å¤å¤„ç†æœŸé—´è¢«åˆ·æ–°ï¼Œä¸­æ­¢å¤šä½™çš„DOMæ›´æ–°ä»¥é˜²æ­¢é‡å¤ã€‚");
                            break; 
                        }

                        
                        if (lastTimestamp > 0 && msg.timestamp - lastTimestamp > 5 * 60 * 1000) {
                            const timeDiv = UIManager.createTimeDividerElement(msg.timestamp);
                            chatArea.appendChild(timeDiv);
                        }
                        
                        if (msg.segmentType === 'system') {
                            const notice = document.createElement('div');
                            notice.className = 'system-notice'; notice.id = msg.messageId; notice.textContent = msg.content;
                            chatArea.appendChild(notice);
                        } else if (msg.segmentType === 'narrator') {
                            const narratorNotice = await UIManager.createNarratorNoticeElement(msg);
                            chatArea.appendChild(narratorNotice);
                        } else {
                             await UIManager.addMessageToDOM(msg, msg.senderInfo, false, true);
                             if (msg.toBeRetracted) {
                                const retractDelay = Math.random() * 1000 + 1000;
                                setTimeout(async () => {
                                    const msgToRetract = await DBHelper.get('messages', msg.messageId);
                                    if (msgToRetract) {
                                        msgToRetract.isRetracted = true;
                                        await DBHelper.put('messages', msgToRetract);
                                        const bubbleEl = $(`#${msg.messageId}`);
                                        if (bubbleEl) {
                                            const retractionNotice = UIManager.createRetractionNotice(msgToRetract, msg.senderInfo);
                                            bubbleEl.replaceWith(retractionNotice);
                                        }
                                    }
                                }, retractDelay);
                            }
                        }
                        chatArea.scrollTop = chatArea.scrollHeight;
                        lastTimestamp = msg.timestamp; 

                    } else {
                        if (msg.segmentType !== 'system' && msg.segmentType !== 'narrator' && !msg.isRetracted) {
                            UIManager.showTopNotification(msg);
                        }
                    }
                }
            },

            async parseAndDisplayActiveAIResponse(text, chatId) {
                const contacts = await DBHelper.getAll('contacts');
                const baseTimestamp = Date.now();
                let timestampOffset = 0;
                const displayableMessages = [];
                const contactUpdates = {};
                const createBaseMessage = (senderName, displayTimestamp) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`æœªæ‰¾åˆ°è§’è‰² "${senderName}"ï¼Œè·³è¿‡æ­¤ä¸»åŠ¨å›å¤æ¶ˆæ¯ã€‚`);
                        return null;
                    }
                    return {
                        messageId: Utils.generateId('msg'),
                        chatId: chatId, 
                        senderId: sender.id,
                        timestamp: baseTimestamp + timestampOffset++,
                        type: 'received',
                        isUnread: chatId !== appState.currentChatId, 
                        
                        isAutoReply: true, 
                        displayTimestamp: displayTimestamp,
                    };
                };

                const allMessageRegex = /ã€([^ã€]+?)ã€|ã€([^ã€‘]+?)ã€‘|ã€Œ([^ã€]+?)ã€|{([^{}]+?)}|\[([\s\S]+?)\]|<([^>]+?)>/g;

                const messagesToSave = []; 

                text.replace(allMessageRegex, (match, cardContent, innerVoiceContent, essayContent, retractedContent, standardContent, emojiContent) => {
                    
                    
                    if (innerVoiceContent) { 
                        const parts = innerVoiceContent.split('|').map(p => p.trim());
                        const sender = contacts.find(c => c.name === parts[1]);
                        if (sender) {
                            let message;
                            if (parts[0] === 'å¿ƒå£°' && parts.length === 3) {
                                message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'inner_voice' };
                                if (!contactUpdates[sender.id]) contactUpdates[sender.id] = {};
                                contactUpdates[sender.id].lastInnerVoiceId = message.messageId;
                            } else if (parts[0] === 'éšç¬”' && parts.length === 3) {
                                message = { messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'essay' };
                                if (!contactUpdates[sender.id]) contactUpdates[sender.id] = {};
                                contactUpdates[sender.id].lastEssayId = message.messageId;
                                UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                            }
                            if (message) {
                                messagesToSave.push(message);
                            }
                        }
                        return;
                    }
                    
                    if (essayContent) {
                        const parts = essayContent.split('|').map(p => p.trim());
                        if (parts[0] === 'éšç¬”' && parts.length === 3) {
                            const sender = contacts.find(c => c.name === parts[1]);
                            if (sender) {
                                messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'essay' });
                                UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                            }
                        }
                        return; 
                    }

                    let parts, senderName, displayTimestamp, baseMessage;

                    if (cardContent !== undefined) {
                        parts = cardContent.split('|').map(p => p.trim());
                        if (parts.length < 5) return;
                        senderName = parts[0];
                        displayTimestamp = parts.pop();
                        baseMessage = createBaseMessage(senderName, displayTimestamp);
                        if (baseMessage) {
                            baseMessage.segmentType = 'card';
                            baseMessage.content = `[å¡ç‰‡] ${parts[2]}`;
                            baseMessage.cardData = { shareType: parts[1], title: parts[2], summary: parts[3], details: parts[4], isExpanded: false };
                            messagesToSave.push(baseMessage); 
                            displayableMessages.push(baseMessage);
                        }
                    } else {
                        let innerContent, bracketType;
                        if (retractedContent) { innerContent = retractedContent; bracketType = '{'; }
                        else if (standardContent) { innerContent = standardContent; bracketType = '['; }
                        else if (emojiContent) { innerContent = emojiContent; bracketType = '<'; }
                        else { return; }

                        if (bracketType === '<' && innerContent.startsWith('éšç¬”|')) {
                            const parts = innerContent.split('|').map(p => p.trim());
                            if (parts.length >= 3) {
                                const senderName = parts[1];
                                const msgContent = parts.slice(2).join('|');
                                const sender = contacts.find(c => c.name === senderName);
                                if (sender) {
                                    messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'essay' });
                                    UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                                }
                            }
                            return; 
                        }

                        parts = innerContent.split('|').map(p => p.trim());
                        if (parts.length < 2) return;

                        senderName = parts[0];
                        displayTimestamp = parts.pop();
                        baseMessage = createBaseMessage(senderName, displayTimestamp);
                        if (!baseMessage) return;
                        
                        baseMessage.chatId = chatId;
                        
                        if (bracketType === '{') {
                            baseMessage.isRetracted = true;
                            baseMessage.toBeRetracted = true;
                        }

                        if (bracketType === '<') {
                            baseMessage.segmentType = 'emoji-image';
                            baseMessage.content = parts[1];
                        } else if (bracketType === '[') {
                            const typeKeyword = parts[1];
                            switch (typeKeyword) {
                                case 'è¯­éŸ³':
                                    baseMessage.segmentType = 'voice';
                                    baseMessage.content = `[è¯­éŸ³] ${parts[3]}`;
                                    baseMessage.cardData = { duration: parts[2], content: parts[3] };
                                    break;
                                case 'å¼•ç”¨':
                                    baseMessage.segmentType = 'quote';
                                    baseMessage.content = `[å¼•ç”¨] ${parts[4]}`;
                                    baseMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] };
                                    break;
                                case 'è½¬è´¦':
                                    baseMessage.segmentType = 'transfer';
                                    baseMessage.content = `[è½¬è´¦] ${parts[3]}`;
                                    baseMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false };
                                    break;
                                case 'çº¢åŒ…':
                                    baseMessage.segmentType = 'red-packet';
                                    baseMessage.content = `[çº¢åŒ…] ${parts[2]}`;
                                    baseMessage.cardData = { title: parts[2], amount: parseFloat(parts[3].replace('ï¿¥', '')), count: parseInt(parts[4]), claimedBy: [] };
                                    break;
                                default:
                                    baseMessage.segmentType = 'text';
                                    baseMessage.content = parts.slice(1).join('|');
                                    break;
                            }
                        } else {
                            baseMessage.segmentType = 'text';
                            baseMessage.content = parts.slice(1).join('|');
                        }

                        if (baseMessage.segmentType) {
                            messagesToSave.push(baseMessage); 
                            displayableMessages.push(baseMessage);
                        }
                    }
                });

                 
                for (const msg of messagesToSave) {
                    await DBHelper.put('messages', msg);
                }
                
                for (const [contactId, updates] of Object.entries(contactUpdates)) {
                    const contactToUpdate = await DBHelper.get('contacts', contactId);
                    if (contactToUpdate) {
                        Object.assign(contactToUpdate, updates);
                        await DBHelper.put('contacts', contactToUpdate);
                    }
                }
                if (displayableMessages.length > 0 || messagesToSave.some(m => m.segmentType === 'inner_voice' || m.segmentType === 'essay')) {
                    const chatMetadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId, unreadCount: 0 };
                    chatMetadata.lastAiReplyTimestamp = Date.now();

                    
                    const lastDisplayableMsg = displayableMessages.length > 0 ? displayableMessages[displayableMessages.length - 1] : null;
                    if (lastDisplayableMsg) {
                        chatMetadata.lastMessage = lastDisplayableMsg;
                        chatMetadata.lastMessageTimestamp = lastDisplayableMsg.timestamp;
                    }

                    await DBHelper.put('chatMetadata', chatMetadata);
                }

                if (displayableMessages.length > 0) {
                    const lastDisplayableMsg = displayableMessages[displayableMessages.length - 1];
                    const isUnread = chatId !== appState.currentChatId;
                    await UIManager.updateChatMetadata(chatId, lastDisplayableMsg, isUnread ? displayableMessages.length : 0);
                }

                for (const msg of displayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));
                    
                    
                    const senderForDisplay = contacts.find(c => c.id === msg.senderId) || { name: 'æœªçŸ¥ç”¨æˆ·', avatar: Utils.createAvatarDataUrl('#ccc') };
                    
                    msg.senderInfo = senderForDisplay;

                    if (chatId === appState.currentChatId) {
                        UIManager.addMessageToDOM(msg, senderForDisplay, false, true);

                        if (msg.toBeRetracted) {
                            const retractDelay = Math.random() * 1000 + 1000;
                            setTimeout(async () => {
                                
                                const msgToRetract = await DBHelper.get('messages', msg.messageId);
                                if (msgToRetract) {
                                    msgToRetract.isRetracted = true;
                                    await DBHelper.put('messages', msgToRetract);
                                    const bubbleEl = $(`#${msg.messageId}`);
                                    if (bubbleEl) {
                                        
                                        const retractionNotice = UIManager.createRetractionNotice(msgToRetract, senderForDisplay);
                                        bubbleEl.replaceWith(retractionNotice);
                                    }
                                }
                            }, retractDelay);
                        }
                    } else {
                        
                        UIManager.showTopNotification(msg);
                    }
                }
            },

            showError(message) {
                 UIManager.showModal({
                    title: "é”™è¯¯",
                    body: `<p>${message}</p>`,
                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleMomentsRefreshRequest() {
                if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const refreshBtn = $('#moments-refresh-btn i');
                refreshBtn.classList.add('fa-spin');

                try {
                    const prompt = await this.buildMomentsRefreshPrompt();
                    if (!prompt) {
                        UIManager.showToast("æ— æ³•ç”ŸæˆåŠ¨æ€ï¼šåœˆå­ä¿¡æ¯ä¸å®Œæ•´ã€‚");
                        return;
                    }
                    
                    const aiRawResponse = await this.getApiResponse(prompt, null, this.abortController.signal);
                    console.log("--- AI æœ‹å‹åœˆåŠ¨æ€ (åŸå§‹) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsResponse(aiRawResponse);
                    
                    
                    const circle = await DBHelper.get('circles', appState.currentCircleId);
                    if (circle) {
                        circle.lastRefreshed = Date.now();
                        await DBHelper.put('circles', circle);
                    }

                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error("æœ‹å‹åœˆåŠ¨æ€ç”Ÿæˆå¤±è´¥:", error);
                        this.showError(`åŠ¨æ€ç”Ÿæˆå¤±è´¥: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    refreshBtn.classList.remove('fa-spin');
                }
            },
            
            async _getBoundPromptsForMoments(circle, playerInputText = '') {
                if (!circle || !circle.boundPromptFolderIds || circle.boundPromptFolderIds.length === 0) {
                    return '';
                }

                const allFolders = await DBHelper.getAll('promptFolders');
                const allPrompts = await DBHelper.getAll('prompts');

                const activeBoundFolders = allFolders.filter(f => circle.boundPromptFolderIds.includes(f.id) && f.isActive);
                if (activeBoundFolders.length === 0) return '';
                
                const activeBoundFolderIds = activeBoundFolders.map(f => f.id);
                const relevantPrompts = allPrompts.filter(p => activeBoundFolderIds.includes(p.folderId) && p.isActive);

                const promptsToInject = relevantPrompts
                    .filter(p => 
                        p.type === 'explicit' || 
                        (p.type === 'implicit' && playerInputText && JSON.parse(p.keywords).some(kw => playerInputText.includes(kw)))
                    )
                    .map(p => p.content);

                if (promptsToInject.length > 0) {
                    return `\n--- é™„åŠ é£æ ¼è¦æ±‚ (æ¥è‡ªç»‘å®šçš„æç¤ºè¯) ---\n${promptsToInject.join('\n\n')}\n---`;
                }
                return '';
            },
            
            async handleMomentsCommentRequest(momentId) {
                 if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const commentsSection = postElement.querySelector('.post-interactions'); 
                
                
                let typingIndicator = commentsSection.querySelector('.post-comment-typing-indicator');
                if (!typingIndicator) {
                    typingIndicator = document.createElement('div');
                    typingIndicator.className = 'post-comment-typing-indicator';
                    
                    commentsSection.style.display = 'block'; 
                    commentsSection.insertBefore(typingIndicator, commentsSection.querySelector('.comment-input-wrapper'));
                }
                typingIndicator.textContent = 'æœ‹å‹ä»¬æ­£åœ¨èµ¶æ¥è¯„è®º...';


                try {
                    const prompt = await this.buildMomentsCommentPrompt(momentId);
                    if (!prompt) return;

                    const aiRawResponse = await this.getApiResponse(prompt, null, this.abortController.signal);
                    console.log("--- AI æœ‹å‹åœˆè¯„è®º (åŸå§‹) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsCommentsResponse(momentId, aiRawResponse);

                } catch (error) {
                     if (error.name !== 'AbortError') {
                        console.error("æœ‹å‹åœˆè¯„è®ºç”Ÿæˆå¤±è´¥:", error);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    if(typingIndicator) typingIndicator.remove();
                }
            },

            async handleMomentsPlayerCommentResponse(momentId, playerComment) {
                 if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const commentsSection = postElement.querySelector('.post-interactions');
                
                let typingIndicator = commentsSection.querySelector('.post-comment-typing-indicator');
                if (!typingIndicator) {
                    typingIndicator = document.createElement('div');
                    typingIndicator.className = 'post-comment-typing-indicator';
                    commentsSection.insertBefore(typingIndicator, commentsSection.querySelector('.comment-input-wrapper'));
                }
                typingIndicator.textContent = 'æœ‹å‹ä»¬æ­£åœ¨èµ¶æ¥è¯„è®º...';
                commentsSection.style.display = 'block'; 

                try {
                    const prompt = await this.buildMomentsPlayerCommentPrompt(momentId, playerComment);
                    if (!prompt) return;

                    const aiRawResponse = await this.getApiResponse(prompt, null, this.abortController.signal);
                    console.log("--- AI æœ‹å‹åœˆç©å®¶è¯„è®ºå›å¤ (åŸå§‹) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsPlayerCommentResponse(momentId, aiRawResponse);

                } catch (error) {
                     if (error.name !== 'AbortError') {
                        console.error("æœ‹å‹åœˆAIå›å¤ç©å®¶è¯„è®ºå¤±è´¥:", error);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    if(typingIndicator) typingIndicator.remove();
                }
            },

            async buildMomentsRefreshPrompt() {
                const circle = await DBHelper.get('circles', appState.currentCircleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const allContacts = await DBHelper.getAll('contacts');
                
                
                const validMemberIds = circle.memberIds.filter(id => allContacts.some(c => c.id === id));
                if (validMemberIds.length !== circle.memberIds.length) {
                    circle.memberIds = validMemberIds; 
                    await DBHelper.put('circles', circle);
                    UIManager.showToast("å·²è‡ªåŠ¨ç§»é™¤åœˆå­ä¸­ä¸å­˜åœ¨çš„å¥½å‹ã€‚");
                }
                if(validMemberIds.length === 0) return null;

                
                const shuffled = validMemberIds.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedMemberIds = shuffled.slice(0, Math.min(numToSelect, validMemberIds.length));
                const selectedMembers = selectedMemberIds.map(id => allContacts.find(c => c.id === id));
                
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile };
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                const allGroups = await DBHelper.getAll('groups');

                
                const timeNow = new Date();
                const lastRefreshTime = new Date(circle.lastRefreshed || (Date.now() - 24*60*60*1000)); 
                const timePrompt = `ç°åœ¨æ˜¯ ${timeNow.toLocaleString('zh-CN')}ã€‚ä¸Šæ¬¡ç”ŸæˆåŠ¨æ€çš„æ—¶é—´æ˜¯ ${lastRefreshTime.toLocaleString('zh-CN')}ã€‚è¯·ç¡®ä¿æœ¬æ¬¡ç”Ÿæˆçš„åŠ¨æ€æ—¶é—´åœ¨æ­¤èŒƒå›´ä¹‹å†…ã€‚`;

                const membersInfo = selectedMembers.map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n');
                const playerInfo = `ç©å®¶å: ${myProfile.name}\næ€§åˆ«: ${myProfile.gender}\nèƒŒæ™¯: ${myProfile.background || 'æ— '}`;
                const extraMembersInfo = circle.extraMembers ? `è¿™ä¸ªåœˆå­è¿˜æœ‰ä¸€äº›å…¶ä»–æœ‹å‹ï¼š${circle.extraMembers}ã€‚` : '';

                let contextHistory = '';
for (const member of selectedMembers) {
    
    const privateChatHistory = await DBHelper.getMessages(member.id, 10); 
    if (privateChatHistory && privateChatHistory.length > 0) {
        const turns = this.buildTurnsFromHistory(privateChatHistory, allContacts, myProfile);
        const lastTwoTurns = turns.slice(-2);
        if (lastTwoTurns.length > 0) {
            contextHistory += `ä¸ ${member.name} çš„æœ€æ–°ç§èŠ (æœ€å¤š2è½®):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
        }
    }
    
    
    const groupsWithMember = allGroups.filter(g => g.members.includes(member.id));
    for (const group of groupsWithMember) {
        const groupChatHistory = await DBHelper.getMessages(group.id, 10); 
        if (groupChatHistory && groupChatHistory.length > 0) {
            const turns = this.buildTurnsFromHistory(groupChatHistory, allContacts, myProfile);
            const lastTwoTurns = turns.slice(-2);
            if (lastTwoTurns.length > 0) {
                contextHistory += `åœ¨ç¾¤èŠ ${group.name} ä¸­ ${member.name} çš„ç›¸å…³åŠ¨æ€ (æœ€å¤š2è½®):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
            }
        }
    }
}
                const formatRules = `
---
æœ‹å‹åœˆåŠ¨æ€ç”Ÿæˆè§„åˆ™ï¼ˆéå¸¸é‡è¦ï¼ï¼‰ï¼š
1.  ä½ å°†æ‰®æ¼” ${selectedMembers.map(m=>m.name).join('ã€')} è¿™å‡ ä½è§’è‰²ï¼Œå¹¶ä¸ºä»–ä»¬ç”Ÿæˆæœ‹å‹åœˆåŠ¨æ€ã€‚
2.  **ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ï¼Œæ¯æ¡åŠ¨æ€éƒ½å¿…é¡»è¢«ä¸€ä¸ª <æœ‹å‹åœˆ> æ ‡ç­¾åŒ…è£¹ã€‚**
3.  åŠ¨æ€æ ¼å¼: ã€ä½œè€…è§’è‰²åï¼šåŠ¨æ€å†…å®¹|åŠ¨æ€æ—¶é—´(æœˆ/æ—¥ HH:mm)ã€‘
4.  ç‚¹èµæ ¼å¼(å¼ºåˆ¶è¦æ±‚): åœ¨åŠ¨æ€æ ¼å¼ä¹‹åï¼Œå¦èµ·ä¸€è¡Œï¼Œç”¨ä¸­æ–‡æ‹¬å·åŒ…è£¹ç‚¹èµåˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼ˆå·²ç‚¹èµï¼šå¼ ä¸‰,æå››,ç‹äº”ï¼‰ã€‚ç‚¹èµè€…å¯ä»¥æ˜¯åœˆå†…ä»»ä½•AIè§’è‰²ã€é¢å¤–å¥½å‹â€ã€‚
5.  è¯„è®ºæ ¼å¼: ã€–è¯„è®ºè€…è§’è‰²åï¼šè¯„è®ºå†…å®¹ã€—ç¦æ­¢åœ¨ã€–ã€—å†…åµŒå¥—ã€–ã€—
6.  ä½ å¯ä»¥è®©è§’è‰²äº’ç›¸è¯„è®ºï¼Œä¹Ÿå¯ä»¥è®©åœˆå­é‡Œçš„é¢å¤–å¥½å‹ï¼ˆ${circle.extraMembers || 'æ— '}ï¼‰å‚ä¸è¯„è®ºã€‚
7.  åŠ¨æ€å†…å®¹è¦ç¬¦åˆè§’è‰²äººè®¾ï¼Œå¯ä»¥å›¾æ–‡å¹¶èŒ‚ï¼ˆç”¨æ–‡å­—æè¿°å›¾ç‰‡ï¼‰ï¼Œä¹Ÿå¯ä»¥åªæ˜¯çº¯æ–‡å­—ã€‚
8.  ç”Ÿæˆ1åˆ°4æ¡ä¸ç­‰çš„åŠ¨æ€ï¼Œå†…å®¹ä¸èƒ½é‡å¤ã€‚
9.  ä½œè€…å’Œè¯„è®ºè€…çš„è§’è‰²åå¿…é¡»æ˜¯è§’è‰²çš„åå­—ï¼ˆä¾‹å¦‚ï¼š${selectedMembers.map(m=>m.name).join(', ')}ï¼‰ã€é¢å¤–å¥½å‹çš„åå­—ã€‚
10. **ä¸¥ç¦OOCï¼Œä¸¥ç¦ç”Ÿæˆæ ¼å¼ä¹‹å¤–çš„å†…å®¹ï¼Œä¸¥ç¦ä»£æ›¿ç©å®¶ (â€œ${myProfile.name}â€) è¿›è¡Œè¯„è®ºã€å›å¤æˆ–è€…ç‚¹èµ**ã€‚**ç¦æ­¢ä»£æ›¿ç©å®¶ (â€œ${myProfile.name}â€) è¿›è¡Œè¯„è®ºã€å›å¤æˆ–ç‚¹èµ**
11.ä¸¾ä¾‹ï¼š
<æœ‹å‹åœˆ>
ã€33ï¼šä»Šå¤©å¤©æ°”çœŸä¸é”™ï¼Œæœ‰æ²¡æœ‰è¦ä¸€èµ·å‡ºå»ç©çš„ï¼Ÿ|7/3 8:36ã€‘
ï¼ˆå·²ç‚¹èµï¼švv,å…¥å…¥ï¼‰
ã€–vvï¼šå¸¦æˆ‘ä¸€ä¸ªï¼ã€—
ã€–å…¥å…¥ï¼šæˆ‘ä¹Ÿè¦å»â€”â€”ã€—
</æœ‹å‹åœˆ>
<æœ‹å‹åœˆ>
ã€vvï¼šæ–°æ‰‹æŸ„åˆ°æ‰‹å•¦ï¼|7/3 9:35ã€‘
ï¼ˆå·²ç‚¹èµï¼šä¸‰ä¸‰,å…¥å…¥ï¼‰
ã€–å…¥å…¥ï¼šå¥½ç”¨å—ï¼Ÿé“¾æ¥å‘æˆ‘ã€—
</æœ‹å‹åœˆ>
---
`;
                
                const customPromptsSection = await this._getBoundPromptsForMoments(circle);

                const finalPrompt = [
                    timePrompt,
                    playerInfo,
                    `--- åœˆå­é‡Œçš„AIè§’è‰² ---\n${membersInfo}`,
                    extraMembersInfo,
                    `--- æœ€è¿‘çš„èŠå¤©è®°å½•å‚è€ƒ ---\n${contextHistory}`,
                    customPromptsSection,
                    formatRules
                ].join('\n\n');
                
                console.log("--- MOMENTS REFRESH PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async buildMomentsCommentPrompt(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                const circle = await DBHelper.get('circles', moment.circleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const allContacts = await DBHelper.getAll('contacts');
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile };
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                const allGroups = await DBHelper.getAll('groups'); 

                
                const momentAuthor = allContacts.find(c => c.id === moment.authorId);
                const circleMembers = allContacts.filter(c => circle.memberIds.includes(c.id));
                const otherMembers = circleMembers.filter(c => c.id !== moment.authorId);
                const shuffled = otherMembers.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedRandomMembers = shuffled.slice(0, Math.min(numToSelect, otherMembers.length));

                let membersToProvideInfo = [];
                if (momentAuthor) { 
                    membersToProvideInfo.push(momentAuthor);
                }
                membersToProvideInfo.push(...selectedRandomMembers);
                membersToProvideInfo = [...new Set(membersToProvideInfo)]; 

                const membersInfo = membersToProvideInfo.map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n');
                
                
                let contextHistory = '';
                for (const member of membersToProvideInfo) {
                    const privateChat = await DBHelper.get('chats', member.id);
                    if (privateChat && privateChat.history.length > 0) {
                        const turns = this.buildTurnsFromHistory(privateChat.history, allContacts, myProfile);
                        const lastTwoTurns = turns.slice(-2);
                        if (lastTwoTurns.length > 0) {
                            contextHistory += `ä¸ ${member.name} çš„æœ€æ–°ç§èŠ (æœ€å¤š2è½®):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                        }
                    }
                    const groupsWithMember = allGroups.filter(g => g.members.includes(member.id));
                    for (const group of groupsWithMember) {
                        const groupChat = await DBHelper.get('chats', group.id);
                        if (groupChat && groupChat.history.length > 0) {
                            const turns = this.buildTurnsFromHistory(groupChat.history, allContacts, myProfile);
                            const lastTwoTurns = turns.slice(-2);
                            if (lastTwoTurns.length > 0) {
                                contextHistory += `åœ¨ç¾¤èŠ ${group.name} ä¸­ ${member.name} çš„ç›¸å…³åŠ¨æ€ (æœ€å¤š2è½®):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                            }
                        }
                    }
                }

                const postContentText = `ç©å®¶â€œ${myProfile.name}â€å‘å¸ƒäº†ä¸€æ¡åŠ¨æ€ï¼š\nâ€œ${moment.content}â€`;

                const privateChatRules = `
---
ç§èŠè§„åˆ™:
1.  å¦‚æœä½ æƒ³è®©æŸä½è§’è‰²ç§èŠç©å®¶ï¼Œè¯·ä½¿ç”¨ <ç§èŠ></ç§èŠ> æ ‡ç­¾åŒ…è£¹ç§èŠå†…å®¹ã€‚åªèƒ½ç§èŠç©å®¶ï¼Œç§èŠå…¶ä»–è§’è‰²çš„å†…å®¹ç¦æ­¢ä½¿ç”¨<ç§èŠ>æ ‡ç­¾
2.  ç§èŠå†…å®¹æ ¼å¼å¯ä»¥æ˜¯: [è§’è‰²å|æ¶ˆæ¯å†…å®¹] æˆ– {è§’è‰²å|æ’¤å›å†…å®¹} æˆ– [è§’è‰²å|è¯­éŸ³|æ—¶é•¿|å†…å®¹] æˆ– [è§’è‰²å|è½¬è´¦|æ”¶æ¬¾äºº|é‡‘é¢|å¤‡æ³¨]
3.  ä¾‹å¦‚: <ç§èŠ>[ä¸‰ä¸‰|ä½ åˆšæ‰å‘çš„åŠ¨æ€æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ]</ç§èŠ>
---
`;

                const formatRules = `
---
æœ‹å‹åœˆè¯„è®ºç”Ÿæˆè§„åˆ™ï¼š
1.  ä½ å°†æ‰®æ¼”åœˆå­é‡Œçš„å¥½å‹ï¼Œå¯¹ç©å®¶çš„åŠ¨æ€è¿›è¡Œè¯„è®ºå’Œç‚¹èµã€‚
2.  ç‚¹èµæ ¼å¼ï¼šç”¨ä¸­æ–‡æ‹¬å·åŒ…è£¹ç‚¹èµåˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼ˆå·²ç‚¹èµï¼šå¼ ä¸‰,æå››,ç‹äº”ï¼‰ã€‚ç‚¹èµè€…å¯ä»¥æ˜¯åœˆå†…ä»»ä½•AIè§’è‰²æˆ–é¢å¤–å¥½å‹ã€‚
3.  ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ï¼Œæ¯æ¡è¯„è®ºéƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å•å…ƒ: ã€–è¯„è®ºè€…è§’è‰²åï¼šè¯„è®ºå†…å®¹ã€—ï¼Œç¦æ­¢åœ¨ã€–ã€—å†…åµŒå¥—ã€–ã€—ã€‚
4.  è¯„è®ºå†…å®¹è¦ç¬¦åˆè§’è‰²äººè®¾ï¼Œä¸è¶…è¿‡20ä¸ªå­—ã€‚
5.  **ä¸¥ç¦OOCï¼Œä¸¥ç¦ç”Ÿæˆæ ¼å¼ä¹‹å¤–çš„å†…å®¹ï¼Œä¸¥ç¦ä»£æ›¿ç©å®¶ (â€œ${myProfile.name}â€) è¿›è¡Œè¯„è®ºæˆ–å›å¤**ã€‚**ç¦æ­¢ä»£æ›¿ç©å®¶ (â€œ${myProfile.name}â€) è¿›è¡Œè¯„è®ºã€å›å¤æˆ–ç‚¹èµ**
6.  è‡³å°‘ç”Ÿæˆ2æ¡è¯„è®ºï¼Œæœ€å¤šç”Ÿæˆ5æ¡è¯„è®ºã€‚
7.  ä¸¾ä¾‹ï¼š
ï¼ˆå·²ç‚¹èµï¼š33,vv,å…¥å…¥ï¼‰
ã€–33ï¼šè¿™æ˜¯ä»€ä¹ˆï¼Œçœ‹èµ·æ¥å¾ˆå¥½åƒçš„æ ·å­ã€—
ã€–å…¥å…¥ï¼šæˆ‘ä¹Ÿè¦åƒwwwã€—
---
`;
                const playerInfo = `--- å‘å¸ƒåŠ¨æ€çš„ç©å®¶èµ„æ–™ ---\nç©å®¶å: ${myProfile.name}\næ€§åˆ«: ${myProfile.gender}\nèƒŒæ™¯: ${myProfile.background || 'æ— '}`;

                const customPromptsSection = await this._getBoundPromptsForMoments(circle, moment.content);

                const finalPrompt = [
                    postContentText,
                    playerInfo, 
                    `--- å‚ä¸è¯„è®ºçš„è§’è‰²èµ„æ–™å‚è€ƒ ---\n${membersInfo}`,
                    `--- æœ€è¿‘çš„èŠå¤©è®°å½•å‚è€ƒ ---\n${contextHistory}`,
                    customPromptsSection,
                    privateChatRules,
                    formatRules
                ].join('\n\n');
                
                console.log("--- MOMENTS COMMENT PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async buildMomentsPlayerCommentPrompt(momentId, playerComment) {
                const moment = await DBHelper.get('moments', momentId);
                const circle = await DBHelper.get('circles', moment.circleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile };
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                const allContacts = await DBHelper.getAll('contacts');
                
                
                let membersToProvideInfo = [];
                const circleMembers = allContacts.filter(c => circle.memberIds.includes(c.id));
                
                
                const repliedToContact = playerComment.replyTo ? circleMembers.find(c => c.name === playerComment.replyTo) : null;
                if (repliedToContact) {
                    membersToProvideInfo.push(repliedToContact);
                }

                
                const otherMembers = circleMembers.filter(c => c.name !== playerComment.replyTo);
                const shuffled = otherMembers.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedRandomMembers = shuffled.slice(0, Math.min(numToSelect, otherMembers.length));
                membersToProvideInfo.push(...selectedRandomMembers);

                membersToProvideInfo = [...new Set(membersToProvideInfo)]; 

                const membersInfo = membersToProvideInfo.length > 0
                    ? membersToProvideInfo.map(m => `è§’è‰²å: ${m.name}\næ€§åˆ«: ${m.gender}\nå–œå¥½: ${m.likes || 'æ— '}\nåŒæ¶: ${m.dislikes || 'æ— '}\nä¹ æƒ¯: ${m.habits || 'æ— '}\nèƒŒæ™¯: ${m.background || 'æ— '}`).join('\n---\n')
                    : 'æ— ';

                
                let momentAuthor = moment.authorId === myProfile.id ? myProfile : allContacts.find(c => c.id === moment.authorId) || { name: moment.authorId };
                let postAndCommentsHistory = `è¿™æ˜¯â€œ${momentAuthor.name}â€å‘å¸ƒçš„åŠ¨æ€ï¼šâ€œ${moment.content}â€\nç›®å‰çš„è¯„è®ºæœ‰ï¼š\n` + 
                    (moment.comments || []).map(c => {
                        const cAuthor = c.authorId === myProfile.id ? myProfile : allContacts.find(u => u.id === c.authorId) || { name: c.authorId };
                        return `â€œ${cAuthor.name}${c.replyTo ? ` å›å¤ ${c.replyTo}` : ''}ï¼š${c.content}â€`;
                    }).join('\n');
                
                const playerActionText = playerComment.replyTo 
                    ? `ç©å®¶â€œ${myProfile.name}â€å›å¤äº†â€œ${playerComment.replyTo}â€è¯´ï¼šâ€œ${playerComment.content}â€` 
                    : `ç©å®¶â€œ${myProfile.name}â€è¯„è®ºè¯´ï¼šâ€œ${playerComment.content}â€`;

                const privateChatRules = `
---
ç§èŠè§„åˆ™(å¯é€‰):
1.  å¦‚æœä½ æƒ³è®©æŸä¸ªè§’è‰²ç§èŠç©å®¶ï¼Œè¯·ä½¿ç”¨ <ç§èŠ></ç§èŠ> æ ‡ç­¾åŒ…è£¹ã€‚åªèƒ½ç§èŠç©å®¶ï¼Œç§èŠå…¶ä»–è§’è‰²çš„å†…å®¹ç¦æ­¢ä½¿ç”¨<ç§èŠ>æ ‡ç­¾
2.  ç§èŠå†…å®¹æ ¼å¼å¯ä»¥æ˜¯: [è§’è‰²å|æ¶ˆæ¯å†…å®¹] æˆ– {è§’è‰²å|æ’¤å›å†…å®¹} æˆ– [è§’è‰²å|è¯­éŸ³|æ—¶é•¿|å†…å®¹] æˆ– [è§’è‰²å|è½¬è´¦|æ”¶æ¬¾äºº|é‡‘é¢|å¤‡æ³¨]
3.  ä¾‹å¦‚: <ç§èŠ>[33|ä½ åˆšæ‰å‘çš„åŠ¨æ€æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ]</ç§èŠ>
---
`;
                
                const formatRules = `
---
æœ‹å‹åœˆè¯„è®ºç”Ÿæˆè§„åˆ™ï¼š
1.  ä½ å°†æ‰®æ¼”åœˆå†…å¥½å‹å¯¹ç©å®¶çš„è¯„è®ºåšå‡ºå›åº”ã€‚
2.  ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ç”Ÿæˆå›å¤ï¼Œå¯ä»¥åªæœ‰ç‚¹èµï¼Œæˆ–åªæœ‰è¯„è®ºï¼Œæˆ–ä¸¤è€…éƒ½æœ‰ã€‚
3.  ç‚¹èµæ ¼å¼ï¼šç”¨ä¸­æ–‡æ‹¬å·åŒ…è£¹ç‚¹èµåˆ—è¡¨ï¼Œæ ¼å¼ä¸ºï¼ˆå·²ç‚¹èµï¼šå¼ ä¸‰,æå››ï¼‰ã€‚
4.  è¯„è®ºæ ¼å¼: ã€–è¯„è®ºè€…è§’è‰²åï¼šè¯„è®ºå†…å®¹ã€—ï¼Œç¦æ­¢åœ¨ã€–ã€—å†…åµŒå¥—ã€–ã€—ã€‚
5.  è¯„è®ºå†…å®¹è¦ç¬¦åˆè§’è‰²äººè®¾ï¼Œå¯ä»¥æ˜¯å¯¹ç©å®¶è¯„è®ºçš„ç›´æ¥å›åº”ï¼Œä¹Ÿå¯ä»¥æ˜¯è§’è‰²ä¹‹é—´çš„äº’åŠ¨ã€‚
6.  **ä¸¥ç¦OOCï¼Œä¸¥ç¦ç”Ÿæˆæ ¼å¼ä¹‹å¤–çš„å†…å®¹ï¼Œä¸¥ç¦ä»£æ›¿ç©å®¶ (â€œ${myProfile.name}â€) è¿›è¡Œè¯„è®ºã€å›å¤æˆ–ç‚¹èµã€‚**
---
`;
                
                const playerInfo = `--- è¯„è®ºçš„ç©å®¶èµ„æ–™ ---\nç©å®¶å: ${myProfile.name}\næ€§åˆ«: ${myProfile.gender}\nèƒŒæ™¯: ${myProfile.background || 'æ— '}`;

                const customPromptsSection = await this._getBoundPromptsForMoments(circle, playerComment.content);

                const finalPrompt = [
                    `--- åŠ¨æ€ä¸å†å²è¯„è®º ---\n${postAndCommentsHistory}`,
                    `--- ç©å®¶æœ€æ–°åŠ¨ä½œ ---\n${playerActionText}`,
                    playerInfo, 
                    `--- å…¶ä»–è§’è‰²èµ„æ–™å‚è€ƒ ---\n${membersInfo}`,
                    customPromptsSection,
                    privateChatRules,
                    formatRules
                ].join('\n\n');

                console.log("--- MOMENTS PLAYER COMMENT PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async parseAndDisplayMomentsResponse(text) {
                const momentsListUl = $('#moments-list');
                const momentBlocks = text.match(/<æœ‹å‹åœˆ>[\s\S]*?<\/æœ‹å‹åœˆ>/g) || [];
                const allContacts = await DBHelper.getAll('contacts');
                const circle = await DBHelper.get('circles', appState.currentCircleId);
                
                
                const myProfile = await EventManager.getPlayerProfileForContext(appState.currentCircleId);

                if (momentBlocks.length > 0 && momentsListUl.innerHTML.includes('è¿˜æ²¡æœ‰åŠ¨æ€')) {
                    momentsListUl.innerHTML = ''; 
                }

                for (const block of momentBlocks) {
                    const postMatch = block.match(/ã€(.*?)ã€‘/);
                    if (!postMatch) continue;

                    const [authorPart, timePart] = postMatch[1].split('|');
                    const [authorName, ...contentParts] = authorPart.split('ï¼š');
                    const content = contentParts.join('ï¼š');

                    const author = allContacts.find(c => c.name === authorName.trim());
                    
                    const likeMatch = block.match(/ï¼ˆå·²ç‚¹èµï¼š(.*?)ï¼‰/);
                    let likerNames = likeMatch ? likeMatch[1].split(/,|ï¼Œ/).map(n => n.trim()) : [];
                    
                    likerNames = likerNames.filter(name => name !== myProfile.name);

                    const newMoment = {
                        id: Utils.generateId('moment'),
                        circleId: appState.currentCircleId,
                        authorId: author ? author.id : authorName.trim(),
                        content: content.trim(),
                        images: [], 
                        timestamp: Utils.parseMomentTimestamp(timePart ? timePart.trim() : null),
                        likes: likerNames, 
                        comments: []
                    };
                    
                    const commentMatches = block.match(/ã€–(.*?)ã€—/g) || [];
                    for (const cMatch of commentMatches) {
                        const inner = cMatch.slice(1, -1);
                        const [cAuthorName, ...cContentParts] = inner.split('ï¼š');
                        const trimmedAuthorName = cAuthorName.trim();
                        
                        
                        if (trimmedAuthorName === myProfile.name) {
                            continue;
                        }
                        
                        const cAuthor = allContacts.find(c => c.name === trimmedAuthorName);
                        const authorId = cAuthor ? cAuthor.id : trimmedAuthorName; 
                        
                        newMoment.comments.push({
                            authorId: authorId,
                            content: cContentParts.join('ï¼š').trim(),
                            timestamp: Date.now()
                        });
                    }

                    await DBHelper.put('moments', newMoment);
                    const momentElement = UIManager.createMomentElement(newMoment, myProfile, allContacts, circle.extraMembers);
                    momentsListUl.prepend(momentElement);
                }
            },
            async parseAndDisplayMomentsCommentsResponse(momentId, text) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return; 

                
                const privateChatRegex = /<ç§èŠ>([\s\S]*?)<\/ç§èŠ>/g;
                let privateMessageMatch;
                while ((privateMessageMatch = privateChatRegex.exec(text)) !== null) {
                    await this.handlePrivateMessageFromMoment(privateMessageMatch[1], moment);
                }
                const publicText = text.replace(privateChatRegex, '').trim();

                
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await EventManager.getPlayerProfileForContext(moment.circleId);
                const postElement = $(`[data-moment-id="${momentId}"]`);

                if (!postElement) return;

                const interactionsContainer = postElement.querySelector('.post-interactions');
                if (!interactionsContainer) return;
                interactionsContainer.style.display = 'block';

                const likeMatch = publicText.match(/ï¼ˆå·²ç‚¹èµï¼š(.*?)ï¼‰/);
                if (likeMatch && likeMatch[1]) {
                    const likerNames = likeMatch[1].split(/,|ï¼Œ/).map(n => n.trim()).filter(Boolean);
                    if (!moment.likes) moment.likes = [];
                    likerNames.forEach(name => {
                        if (!moment.likes.includes(name)) moment.likes.push(name);
                    });
                    const likesContainer = interactionsContainer.querySelector('.post-likes');
                    if (likesContainer && moment.likes.length > 0) {
                        likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    }
                    const likeBtn = postElement.querySelector('[data-action="like"]');
                    if (likeBtn) {
                        likeBtn.classList.toggle('liked', moment.likes.includes(myProfile.name));
                    }
                }

                const commentMatches = publicText.match(/ã€–(.*?)ã€—/g) || [];
                const commentsListContainer = interactionsContainer.querySelector('.post-comments-list');
                if (!commentsListContainer) return;

                if (commentMatches.length === 0 && !likeMatch) {
                    if (likeMatch) await DBHelper.put('moments', moment);
                    return;
                }

                for (const cMatch of commentMatches) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                    const inner = cMatch.slice(1, -1);
                    const [cAuthorName, ...cContentParts] = inner.split('ï¼š');
                    const content = cContentParts.join('ï¼š').trim();
                    if (!content) continue;

                    const cAuthor = allContacts.find(c => c.name === cAuthorName.trim());
                    const authorId = cAuthor ? cAuthor.id : cAuthorName.trim();
                    
                    const newComment = { authorId, content, timestamp: Date.now() };
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push(newComment);
                    
                    let commentAuthorInfo;
                     if (authorId === myProfile.id) {
                        commentAuthorInfo = myProfile;
                    } else {
                        commentAuthorInfo = allContacts.find(c => c.id === authorId) || { name: authorId, id: authorId };
                    }
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'post-comment-item';
                    const authorStyle = commentAuthorInfo.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';
                    commentDiv.innerHTML = `<span class="comment-author" ${authorStyle}>${commentAuthorInfo.name}:</span> ${content}`;

                    commentsListContainer.appendChild(commentDiv);
                }

                await DBHelper.put('moments', moment);
            },

            async handlePrivateMessageFromMoment(privateContent, moment) {
                if (!moment || !moment.id) return; 

                
                const freshMoment = await DBHelper.get('moments', moment.id);
                if (!freshMoment) return; 
                

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await EventManager.getPlayerProfileForContext(freshMoment.circleId);
                
                const standardMatch = privateContent.match(/\[([^\[\]]+?)\]/);
                const retractedMatch = privateContent.match(/{([^{}]+?)}/);
                const emojiMatch = privateContent.match(/<([^>]+?)>/);

                let parts, senderName, sender;
                let match = standardMatch || retractedMatch || emojiMatch;
                if (!match) return;

                parts = match[1].split('|').map(p => p.trim());
                senderName = parts[0];
                sender = allContacts.find(c => c.name === senderName);
                if (!sender) return;

                
                const momentAuthor = (await EventManager.getMomentAuthor(freshMoment.authorId, freshMoment.circleId))?.name || 'æœªçŸ¥ä½œè€…';
                let commentsText = 'æ— ';
                if (freshMoment.comments && freshMoment.comments.length > 0) {
                    commentsText = '\n' + freshMoment.comments.map(c => {
                        const cAuthor = c.authorId === myProfile.id ? myProfile : allContacts.find(u => u.id === c.authorId) || { name: c.authorId };
                        return `${cAuthor.name}${c.replyTo ? ` å›å¤ ${c.replyTo}` : ''}: ${c.content}`;
                    }).join('\n');
                }
                const contextContent = `<æœ‹å‹åœˆåŠ¨æ€>
åŠ¨æ€å‘å¸–äººï¼š${momentAuthor}
åŠ¨æ€å†…å®¹ï¼š${freshMoment.content}
åŠ¨æ€æ—¶é—´ï¼š${Utils.formatTimestampSmartly(freshMoment.timestamp)}
ç‚¹èµæƒ…å†µï¼š${(freshMoment.likes && freshMoment.likes.length > 0) ? freshMoment.likes.join(', ') : 'æ— '}
è¯„è®ºåŒºï¼š${commentsText}
</æœ‹å‹åœˆåŠ¨æ€>`;

                const contextMessage = {
                    messageId: Utils.generateId('sys'),
                    chatId: sender.id,
                    timestamp: Date.now() - 1,
                    type: 'system',
                    segmentType: 'system',
                    content: contextContent,
                    isHidden: true,
                    forAi: true,
                };

                
                const visibleMessage = {
                    messageId: Utils.generateId('msg'),
                    chatId: sender.id,
                    senderId: sender.id,
                    timestamp: Date.now(),
                    type: 'received',
                    isUnread: appState.currentPage !== 'chat' || appState.currentChatId !== sender.id,
                    senderInfo: sender,
                };
                
                if (retractedMatch) {
                    visibleMessage.isRetracted = true;
                    visibleMessage.segmentType = 'text';
                    visibleMessage.content = parts[1];
                } else if (emojiMatch) {
                    visibleMessage.segmentType = 'emoji-image';
                    visibleMessage.content = parts[1];
                } else {
                    if (parts.length === 2) {
                        visibleMessage.segmentType = 'text';
                        visibleMessage.content = parts[1];
                    } else if (parts[1] === 'è¯­éŸ³') {
                        visibleMessage.segmentType = 'voice';
                        visibleMessage.content = `[è¯­éŸ³] ${parts[3]}`;
                        visibleMessage.cardData = { duration: parts[2], content: parts[3] };
                    } else if (parts[1] === 'è½¬è´¦') {
                        visibleMessage.segmentType = 'transfer';
                        visibleMessage.content = `[è½¬è´¦] ${parts[3]}`;
                        visibleMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false };
                    } else {
                        return;
                    }
                }
                
                
                await DBHelper.put('messages', contextMessage);
                await DBHelper.put('messages', visibleMessage);

                
                await UIManager.updateChatMetadata(sender.id, visibleMessage, 1);
                UIManager.showTopNotification(visibleMessage);
                UIManager.renderMessagesListPage(); 
            },

            async parseAndDisplayMomentsPlayerCommentResponse(momentId, text) {
                const moment = await DBHelper.get('moments', momentId);
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const postElement = $(`[data-moment-id="${momentId}"]`);

                if (!postElement) return;

                const interactionsContainer = postElement.querySelector('.post-interactions');
                interactionsContainer.style.display = 'block';

                
                const likeMatch = text.match(/ï¼ˆå·²ç‚¹èµï¼š(.*?)ï¼‰/);
                if (likeMatch && likeMatch[1]) {
                    const newLikerNames = likeMatch[1].split(/,|ï¼Œ/).map(n => n.trim()).filter(Boolean);
                    
                    if (!moment.likes) moment.likes = [];
                    newLikerNames.forEach(name => {
                        if (!moment.likes.includes(name)) {
                            moment.likes.push(name);
                        }
                    });

                    const likesContainer = interactionsContainer.querySelector('.post-likes');
                    if (likesContainer && moment.likes.length > 0) {
                        likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    }
                }

                
                const commentMatches = text.match(/ã€–(.*?)ã€—/g) || [];
                const commentsListContainer = interactionsContainer.querySelector('.post-comments-list');
                
                if (commentMatches.length === 0 && !likeMatch) return;
                
                for (const cMatch of commentMatches) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));

                    const inner = cMatch.slice(1, -1);
                    const [cAuthorName, ...cContentParts] = inner.split('ï¼š');
                    const content = cContentParts.join('ï¼š').trim();
                    if (!content) continue;

                    const cAuthor = allContacts.find(c => c.name === cAuthorName.trim());
                    
                    const newComment = {
                        authorId: cAuthor ? cAuthor.id : cAuthorName.trim(),
                        content: content,
                        timestamp: Date.now()
                    };
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push(newComment);
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'post-comment-item';
                    commentDiv.dataset.authorName = cAuthor ? cAuthor.name : cAuthorName.trim();
                    commentDiv.dataset.authorId = newComment.authorId;
                    commentDiv.innerHTML = `<span class="comment-author">${cAuthor ? cAuthor.name : cAuthorName.trim()}:</span> ${content}`;
                    commentsListContainer.appendChild(commentDiv);
                }
                
                await DBHelper.put('moments', moment);
            },
            async getGiftApiResponse(prompt, signal) {
                let giftApiConfig = await DBHelper.get('giftApiConfig', 'mainConfig');
                
                if (!giftApiConfig || !giftApiConfig.key) {
                    throw new Error('ç¤¼ç‰©æœç´¢APIæœªé…ç½®ï¼Œè¯·å…ˆåœ¨ç¤¼ç‰©é¡µé¢å³ä¸Šè§’è®¾ç½®ã€‚è®¾ç½®å‰é˜…è¯»å¸®åŠ©å†…å®¹ï¼Œä½ ä¹Ÿå¯ä»¥ç‚¹å‡»â€œä½¿ç”¨ä¸»APIé…ç½®â€æŒ‰é’®æ¥å¿«é€Ÿé…ç½®ã€‚\nå¦‚æœä¸æƒ³é…ç½®APIï¼Œå¯ä»¥é€‰æ‹©è‡ªå®šä¹‰æŒ‰é’®ï¼Œè‡ªå®šä¹‰è‡ªå·±æƒ³è¦èµ é€çš„ç¤¼ç‰©');
                }
                
                
                const { provider, url, key, model, temperature } = giftApiConfig;
                
                let apiUrl = url;
                let headers = { 'Content-Type': 'application/json' };
                let body;

                const messagesForApi = [{ role: 'user', content: prompt }];

                if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                    headers['Authorization'] = `Bearer ${key}`;
                    if (!apiUrl.endsWith('/chat/completions')) {
                        apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                    }
                    body = { model: model, messages: messagesForApi, temperature: temperature || 0.5 };
                } else if (provider === 'gemini') {
                    apiUrl += `${model}:generateContent?key=${key}`;
                    body = {
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        generationConfig: { temperature: temperature || 0.5 }
                    };
                } else {
                    throw new Error('ä¸æ”¯æŒçš„APIæä¾›å•†ã€‚');
                }

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body),
                    signal: signal
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorData.error ? errorData.error.message : JSON.stringify(errorData)}`);
                }
                
                const data = await response.json();
                
                if (provider === 'gemini') {
                    if (data.candidates && data.candidates[0].content) {
                        return data.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error(`Gemini APIæœªè¿”å›æœ‰æ•ˆå›å¤ã€‚`);
                    }
                } else {
                    if (data.choices && data.choices[0].message) {
                        return data.choices[0].message.content;
                    } else {
                        throw new Error(`APIæœªè¿”å›æœ‰æ•ˆå›å¤ã€‚`);
                    }
                }
            },

            async handleGiftSearchRequest(keyword) {
                if (!keyword) return;

                const giftsGrid = $('#gifts-grid');
                const refreshBtn = $('#gift-search-refresh-btn');
                const sectionTitle = $('#gifts-section-title');
                const cancelBtn = $('#gift-cancel-search-btn');

                giftsGrid.innerHTML = '';

                const loader = document.createElement('div');
                loader.className = 'gift-loader';
                loader.style.display = 'block';
                loader.innerHTML = `
                    <div class="loader-spinner"></div>
                    <p>æ­£åœ¨åŠªåŠ›å¯»æ‰¾ç¤¼ç‰©...</p>
                `;
                giftsGrid.appendChild(loader);

                refreshBtn.style.display = 'block';
                cancelBtn.style.display = 'inline-flex';
                sectionTitle.textContent = `â€œ${keyword}â€çš„æœç´¢ç»“æœ`;
                
                
                let customPrompt = '';
                try {
                    const giftApiConfig = await DBHelper.get('giftApiConfig', 'mainConfig');
                    if (giftApiConfig && giftApiConfig.giftPromptFolderIds && giftApiConfig.giftPromptFolderIds.length > 0) {
                        const allPrompts = await DBHelper.getAll('prompts');
                        const relevantPrompts = allPrompts
                            .filter(p => giftApiConfig.giftPromptFolderIds.includes(p.folderId) && p.isActive)
                            .map(p => p.content);
                        if (relevantPrompts.length > 0) {
                            customPrompt = `\n--- é™„åŠ é£æ ¼è¦æ±‚ ---\n${relevantPrompts.join('\n\n')}\n---`;
                        }
                    }
                } catch(e) { console.error("è·å–ç¤¼ç‰©ç»‘å®šæç¤ºè¯å¤±è´¥", e); }


                const prompt = `è¯·ä½ æ‰®æ¼”ä¸€ä½ä¸“ä¸šçš„ç”µå•†å•†å“æ–‡æ¡ˆç­–åˆ’ï¼Œä¸ºæˆ‘æ¨è8ä¸ªä¸å…³é”®è¯â€œ${keyword}â€åŒç±»æˆ–ç›¸å…³çš„åˆ›æ„ç¤¼ç‰©ã€‚
è¦æ±‚ï¼š
1. ç¤¼ç‰©åç§°è¦ç”ŸåŠ¨æœ‰è¶£ï¼Œå¯ä»¥åŒ…å«è™šæ„çš„å“ç‰Œåæˆ–ç³»åˆ—åã€‚
2. ç¤¼ç‰©ç®€ä»‹è¦ç²¾ç‚¼ä¸”æœ‰å¸å¼•åŠ›ï¼Œ20å­—ä»¥å†…ï¼Œçªå‡ºç¤¼ç‰©çš„ç‰¹ç‚¹æˆ–å¯“æ„ã€‚
3. ç¤¼ç‰©å›¾ç‰‡å¿…é¡»æ˜¯æ¥è‡ªUnsplash, Pexelsç­‰å…è´¹å›¾åº“çš„é«˜è´¨é‡URLã€‚
4. ä¸¥æ ¼ä»¥JSONæ•°ç»„æ ¼å¼è¿”å›ï¼Œä¸è¦æœ‰ä»»ä½•å¤šä½™çš„æ–‡å­—æˆ–ä»£ç å—æ ‡è®°ã€‚
5. æ¯ä¸ªJSONå¯¹è±¡å¿…é¡»åŒ…å«å››ä¸ªé”®ï¼š
   - "url": å›¾ç‰‡é“¾æ¥ (string)
   - "name": ç¤¼ç‰©åç§° (string)
   - "summary": ç¤¼ç‰©ç®€ä»‹ (string)
   - "price": ç¤¼ç‰©ä»·æ ¼ (number)${customPrompt}
`;
                try {
                    const response = await this.getGiftApiResponse(prompt, new AbortController().signal);
                    console.log("--- AI ç¤¼ç‰©æœç´¢ (åŸå§‹) ---\n", response); 
                    
                    const jsonString = response.replace(/```json/g, '').replace(/```/g, '').trim();
                    const gifts = JSON.parse(jsonString);

                    giftsGrid.innerHTML = '';

                    if (Array.isArray(gifts) && gifts.length > 0) {
                        gifts.forEach(gift => {
                            const giftData = {
                                name: gift.name,
                                price: Number(gift.price) || 0,
                                image: gift.url,
                                message: gift.summary
                            };
                            const card = EventManager.createGiftCard(giftData);
                            card.onclick = () => EventManager.showSendGiftModal(giftData);
                            giftsGrid.appendChild(card);
                        });
                    } else {
                        giftsGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: #aaa;">æ²¡æœ‰æ‰¾åˆ°ç›¸å…³çš„ç¤¼ç‰©ï¼Œæ¢ä¸ªå…³é”®è¯è¯•è¯•ï¼Ÿ</p>';
                    }
                } catch (error) {
                    console.error("ç¤¼ç‰©æœç´¢å¤±è´¥:", error);
                    giftsGrid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: #e74c3c;">æœç´¢å¤±è´¥äº†...<br>${error.message}</p>`;
                }
            },
        };

        
        const EventManager = {

            async showAnnouncementModal(isFromTutorial = false) {
                const page1Content = `
                    <h4>ä¸ºäº†33èŠå¤©å®¤ä¿æŒå‹å¥½å’Œè°çš„äº¤æµæ°”æ°›ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä½œå‡ºä»¥ä¸‹æé†’ï¼š</h4>
                    <p>1. èŠå¤©å®¤å†…å…·æœ‰è‡ªå®šä¹‰è§’è‰²åŠŸèƒ½ï¼Œè§’è‰²å¡å¹¶éå¼ºåˆ¶è´­ä¹°ã€‚</p>
                    <p>2. è¯·å°Šé‡åŸåˆ›ï¼Œä¸è¦ä½¿ç”¨å…¶ä»–è€å¸ˆæœªæˆæƒçš„è§’è‰²è®¾å®šæˆ–å…¶ä»–è®¾å®šã€‚å¦‚æœå› ä½¿ç”¨æœªæˆæƒå†…å®¹å¼•å‘ä¾µæƒé—®é¢˜ï¼Œåæœéœ€è‡ªè¡Œæ‰¿æ‹…ã€‚</p>
                    <p>3. è¯·å¤§å®¶å°Šé‡æ‰€æœ‰äººçš„äº§å‡ºï¼Œä¸è¦åœ¨ä»»ä½•å…¬å¼€å¹³å°ä¸Šå°†33èŠå¤©å®¤ä¸å…¶ä»–aièŠå¤©å·¥å…·è¿›è¡Œæ‹‰è¸©ã€æ¯”è¾ƒã€‚</p>
                    <p>4. ç¦æ­¢ç›´æ¥å¤–ä¼ ç½‘å€æˆ–å¤–ä¼ å¸¦æœ‰33èŠå¤©å®¤ç½‘å€çš„æˆªå›¾ï¼Œå¦åˆ™è¿‡å¤šéè´­ä¹°33èŠå¤©å™¨çš„è®¿å®¢è®¿é—®ç½‘å€ï¼Œå°†å¯¼è‡´ç½‘å€å¤±æ•ˆï¼Œæ‰€æœ‰äººçš„è®°å½•å…¨éƒ½ä¼šè¢«æ¸…é™¤ã€‚æˆ‘ä»¬å°†ä¸äºˆè´Ÿè´£ï¼Œè¯·å„è‡ªç»´æŠ¤å¥½è‡ªèº«æƒç›Šã€‚</p>
                    <p><strong>åœ¨è¿™é‡Œè¯šæŒšåœ°ç¥æ„¿å„ä½åœ¨èŠå¤©å®¤ç©å¾—å¼€å¿ƒã€‚</strong></p>
                `;

                const page2Content = `
                    <h4>èŠå¤©å®¤æˆæƒè€å¸ˆID</h4>
                    <div class="announcement-auth-list">
                        <span>ç›æ±½æ°´Vio.</span><span>VV</span><span>DDè¦åŠªåŠ›</span>
                        <span>ç¯ç¯</span><span>å‡å‘å«è¡£</span><span>é­”ç‹å’•å½</span>
                        <span>å°ç”œSweettt</span><span>ä¹ç³»èŒ</span><span>è“è“ã®24h</span>
                        <span>å–»ç¦§ã®æ–‡æ¸¸</span><span>äº‘æœµã®</span><span>äº‘æœµæœµ</span>
                        <span>åŸå¦‚</span><span>æ˜¯çŸ­çŸ­</span><span>ç¾å‘³å¨æˆ¿ai</span>
                        <span>åˆæœˆæœˆæœˆæœˆ</span>
                    </div>
                    <p class="announcement-warning">å¦‚æœä½ æ˜¯ä»å…¶ä»–é€”å¾„è·å–ï¼Œè¯´æ˜å¯¹æ–¹æ˜¯å€’å–/äºŒä¼ çš„ï¼Œæˆ‘ä»¬æŠµåˆ¶ç›—ç”¨äºŒè´©è¡Œä¸ºï¼Œä¸”ä¸æ‰¿æ‹…å”®åè§£ç­”ä¹‰åŠ¡ã€‚</p>
                `;

                const modalBody = `
                    <div id="announcement-page-1" class="announcement-page active">${page1Content}</div>
                    <div id="announcement-page-2" class="announcement-page">${page2Content}</div>
                    <div class="announcement-nav">
                        <button id="announcement-prev-btn" class="modal-btn btn-secondary nav-btn" style="visibility: hidden;">ä¸Šä¸€é¡µ</button>
                        <span class="page-indicator">1 / 2</span>
                        <button id="announcement-next-btn" class="modal-btn btn-secondary nav-btn">ä¸‹ä¸€é¡µ</button>
                    </div>
                `;

                UIManager.showModal({
                    title: "é‡è¦æé†’",
                    customClass: 'announcement-modal-content',
                    body: modalBody,
                    actions: [
                        { text: 'å·²é˜…è¯»', class: 'btn-primary', id: 'announcement-close-btn' }
                    ]
                });
                
                const pages = $$('.announcement-page');
                const prevBtn = $('#announcement-prev-btn');
                const nextBtn = $('#announcement-next-btn');
                const pageIndicator = $('.page-indicator');
                const closeBtn = $('#announcement-close-btn');
                let currentPage = 0;

                const updateNav = () => {
                    pages.forEach((page, index) => page.classList.toggle('active', index === currentPage));
                    prevBtn.style.visibility = currentPage === 0 ? 'hidden' : 'visible';
                    nextBtn.style.visibility = currentPage === pages.length - 1 ? 'hidden' : 'visible';
                    pageIndicator.textContent = `${currentPage + 1} / ${pages.length}`;
                };

                prevBtn.onclick = () => {
                    if (currentPage > 0) {
                        currentPage--;
                        updateNav();
                        
                        closeBtn.disabled = true;
                    }
                };
                nextBtn.onclick = () => {
                    if (currentPage < pages.length - 1) {
                        currentPage++;
                        updateNav();
                        
                        if (currentPage === pages.length - 1) {
                            closeBtn.disabled = false;
                        }
                    }
                };
                
                closeBtn.onclick = async () => {
                    UIManager.hideModal();
                    const config = await DBHelper.get('apiConfig', 'mainConfig') || {id: 'mainConfig'};
                    config.announcementReadV1 = true;
                    await DBHelper.put('apiConfig', config);
                };

                
                if (!isFromTutorial) {
                    nextBtn.disabled = true;
                    closeBtn.disabled = true;
                    let countdown = 3;
                    nextBtn.textContent = `ä¸‹ä¸€é¡µ (${countdown}s)`;
                    const interval = setInterval(() => {
                        countdown--;
                        if (countdown > 0) {
                            nextBtn.textContent = `ä¸‹ä¸€é¡µ (${countdown}s)`;
                        } else {
                            clearInterval(interval);
                            nextBtn.disabled = false;
                            nextBtn.textContent = 'ä¸‹ä¸€é¡µ';
                        }
                    }, 1000);
                } else {
                    
                    closeBtn.disabled = true;
                }
            },

            _scopeCSS(css, prefix) {
                if (!css || !prefix) return '';
                
                let scopedCss = '';
                let depth = 0;
                let buffer = '';
                let selectors = [];

                for (let i = 0; i < css.length; i++) {
                    const char = css[i];
                    buffer += char;

                    if (char === '{') {
                        if (depth === 0) {
                            const selectorPart = buffer.slice(0, -1).trim();
                            selectors = selectorPart.split(',').map(s => s.trim());
                            buffer = '{';
                        }
                        depth++;
                    } else if (char === '}') {
                        depth--;
                        if (depth === 0) {
                            const prefixedSelectors = selectors.map(s => {
                                if (s.startsWith('@')) return s; 
                                return `${prefix} ${s}`;
                            }).join(', ');
                            scopedCss += `${prefixedSelectors} ${buffer}\n`;
                            buffer = '';
                            selectors = [];
                        }
                    }
                }
                return scopedCss;
            },

            async setupEmojiMaps() {
                const profile = await DBHelper.get('profile', 'myProfile');
                appState.customEmojis = profile.customEmojis || {};

                appState.aiEmojiMap = { ...BUILTIN_AI_EMOJIS };

                appState.playerEmojiMap = { ...BUILTIN_PLAYER_EMOJIS };
                for (const [id, data] of Object.entries(appState.customEmojis)) {
                    appState.playerEmojiMap[id] = data.name;
                }
            },

            BUILTIN_CHARACTERS: {
                'æ—ç™½001': {
                    id: 'æ—ç™½001',
                    remark: 'æ—ç™½',
                    avatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj48cmVjdCB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNMTYuMSA1LjJjLTEuNyAyLjUtMy44IDQuOC02LjIgNi43LTIuNCAxLjktNS4xIDMuMy03LjkgNC4xLjQgMi4xIDEuMyA0LjEgMi43IDUuOCAxLjQgMS',
                    gender: 'å…¶ä»–',
                    likes: 'æè¿°åœºæ™¯ã€è¡¥å……è®¾å®šã€æ¨åŠ¨å‰§æƒ…',
                    previewDesc: 'æ¨åŠ¨å‰§æƒ…ã€æè¿°åœºæ™¯ã€‚éœ€è¦æ·»åŠ åˆ°ç¾¤èŠå†…ä½¿ç”¨ã€‚',
                    dislikes: 'è¢«å½“æˆæ™®é€šè§’è‰²å¯¹è¯',
                    habits: 'åœ¨å…³é”®æ—¶åˆ»å‡ºç°',
                    background: 'è¯·ä¸¥æ ¼ä½¿ç”¨ <æ—ç™½>æ—ç™½å†…å®¹</æ—ç™½> çš„æ ¼å¼è¿›è¡Œå›å¤ï¼Œç”¨äºæè¿°åœºæ™¯ã€è¡¥å……è®¾å®šæˆ–æ¨åŠ¨å‰§æƒ…ã€‚'
                }
            },
            _syncColorInputs(colorPickerId, hexInputId) {
                const colorPicker = $(`#${colorPickerId}`);
                const hexInput = $(`#${hexInputId}`);

                if (!colorPicker || !hexInput) return;

                const updateHex = () => {
                    hexInput.value = colorPicker.value.toUpperCase();
                };

                const updatePicker = () => {
                    let value = hexInput.value.trim();
                    if (/^#?([0-9A-F]{6}|[0-9A-F]{3})$/i.test(value)) {
                         if (!value.startsWith('#')) {
                            value = '#' + value;
                        }
                        colorPicker.value = value;
                        
                        colorPicker.dispatchEvent(new Event('input', { bubbles: true }));
                    } else {
                        
                        hexInput.value = colorPicker.value.toUpperCase();
                    }
                };

                colorPicker.addEventListener('input', updateHex);
                hexInput.addEventListener('change', updatePicker);
            },
            init() {
                
                bottomNav.addEventListener('click', (e) => {
                    const navItem = e.target.closest('.nav-item');
                    if (navItem) UIManager.navigateTo(navItem.dataset.page);
                });

                
                $('#nav-to-moments').addEventListener('click', () => UIManager.navigateTo('moments', 'discover'));

                $('#nav-to-pomodoro').addEventListener('click', () => UIManager.navigateTo('pomodoro', 'discover'));
                
                $('#moments-back-btn').addEventListener('click', () => UIManager.navigateTo('discover'));
                $('#moments-refresh-btn').addEventListener('click', () => AIHandler.handleMomentsRefreshRequest());
                $('#moments-new-post-btn').addEventListener('click', () => this.handleNewMoment());
                $('#moments-manage-btn').addEventListener('click', () => UIManager.showCircleManagementSidebar());
                $('#moments-list').addEventListener('click', (e) => {
                    const postElement = e.target.closest('.moments-post');
                    if (!postElement) return;

                    const momentId = postElement.dataset.momentId;
                    const actionBtn = e.target.closest('[data-action]');
                    const commentItem = e.target.closest('.post-comment-item');

                    
                    if (actionBtn) {
                        const action = actionBtn.dataset.action;

                        if (action === 'toggle-comment') {
                            this.toggleCommentInput(postElement);
                        } else if (action === 'submit-comment') {
                            this.handlePlayerComment(momentId);
                        } else if (action === 'like') {
                            this.handlePlayerLike(momentId);
                        } else if (action === 'forward') {
                            this.handleForwardMoment(momentId);
                        } else if (action === 'delete-moment') {
                            this.confirmDeleteMoment(momentId, postElement);
                        }
                        return; 
                    }
                    
                    
                    if (commentItem) {
                        const authorName = commentItem.dataset.authorName;
                        this.toggleCommentInput(postElement, authorName);
                    }
                });

                $('#moments-list').addEventListener('mousedown', e => this.handleMomentCommentInteractionStart(e, 'mouse'));
                $('#moments-list').addEventListener('keypress', async (e) => {
                    
                    if (!e.target.matches('.comment-input-wrapper input') || e.key !== 'Enter' || e.shiftKey) {
                        return;
                    }

                    
                    e.preventDefault();

                    
                    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                    if (chatSettings.enterToSend) {
                        const momentId = e.target.closest('.moments-post').dataset.momentId;
                        if (momentId) {
                            this.handlePlayerComment(momentId);
                        }
                    }
                });

                $('#moments-list').addEventListener('touchstart', e => this.handleMomentCommentInteractionStart(e, 'touch'));
                
                $('#page-forwarded-history').addEventListener('click', async (e) => {
                    const unclickableBubble = e.target.closest('.transfer-or-red-packet-bubble, .gift-bubble, .forwarded-moment-bubble, .forwarded-history-bubble');
                    if (unclickableBubble) {
                        UIManager.showToast('å½“å‰çŠ¶æ€æ— æ³•æŸ¥çœ‹');
                        return;
                    }

                    const voiceBubble = e.target.closest('.voice-message-bubble');
                    if (voiceBubble) {
                        const wrapper = voiceBubble.closest('.bubble-and-tag-wrapper');
                        const transcript = wrapper.querySelector('.voice-transcript');
                        if (transcript) transcript.classList.toggle('show');
                        return;
                    }

                    const cardWrapper = e.target.closest('.card-message-wrapper');
                    if (cardWrapper) {
                        const messageRow = cardWrapper.closest('.message-row');
                        if (!messageRow) return;
                        const cardId = `card-detail-${messageRow.dataset.messageId}`;
                        const detailElement = document.getElementById(cardId);
                        if (detailElement) detailElement.classList.toggle('visible');
                        return;
                    }
                });

                
                
                $('#gift-btn').addEventListener('click', () => UIManager.navigateTo('gifts', 'chat'));
                $('#gifts-back-btn').addEventListener('click', () => UIManager.navigateTo('chat'));
                $('#custom-gift-btn').addEventListener('click', () => this.showCustomGiftModal());
                $('#gift-api-config-btn').addEventListener('click', () => this.showGiftApiConfigModal());
                $('#gift-search-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        AIHandler.handleGiftSearchRequest(e.target.value);
                    }
                });
                $('#gift-search-refresh-btn').addEventListener('click', () => {
                    const keyword = $('#gift-search-input').value.trim();
                    if(keyword) AIHandler.handleGiftSearchRequest(keyword);
                });
                $('#gift-cancel-search-btn').addEventListener('click', async () => {
                    $('#gift-search-input').value = '';
                    $('#gift-search-refresh-btn').style.display = 'none';
                    $('#gift-cancel-search-btn').style.display = 'none';
                    await UIManager.renderGiftsPage();
                });
                $('#gift-bind-prompt-btn').addEventListener('click', () => this.handleGiftPromptBinding());
                $('#gift-help-btn').addEventListener('click', () => this.showGiftHelpModal());
                $('#my-avatar').addEventListener('click', () => this.handleEditProfile());
                $('#batch-delete-btn').addEventListener('click', () => this.handleBatchDelete());
                $('#select-all-btn').addEventListener('click', () => this.handleSelectAll());
                $('#cancel-selection-btn').addEventListener('click', () => this.handleBatchDelete());
                $('#delete-selected-btn').addEventListener('click', () => this.handleConfirmBatchDelete());
                $('#add-menu-btn').addEventListener('click', () => this.showAddMenu());
                $$('.tab-btn').forEach(btn => btn.addEventListener('click', () => UIManager.renderContactsPage(btn.dataset.tab)));
                $('#sort-friends-btn').addEventListener('click', () => this.handleSortContacts());
                $('#sort-groups-btn').addEventListener('click', () => this.handleSortGroups());
                $('#chat-settings-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#save-chat-settings-btn').onclick = () => this.handleSaveChatSettings();
                $('#setting-chat').addEventListener('click', async () => {
                    await UIManager.navigateTo('chat-settings', 'settings');
                    await this.renderChatSettingsPage();
                });
                $('#setting-api').addEventListener('click', () => UIManager.navigateTo('api-settings', 'settings'));
                $('#setting-prompts').addEventListener('click', () => UIManager.navigateTo('prompts', 'settings'));
                $('#setting-theme').addEventListener('click', () => UIManager.navigateTo('theme-settings', 'settings'));
                $('#setting-bubble').addEventListener('click', () => UIManager.navigateTo('bubble-settings', 'settings'));
                $('#setting-data-management').addEventListener('click', () => this.showDataManagementModal());
                $('#setting-reset').addEventListener('click', () => this.handleResetApp());
                $('#setting-wish-pool').addEventListener('click', () => this.handleWishPool());

                $('#pomodoro-back-btn').addEventListener('click', () => UIManager.navigateTo('discover'));
                $('#pomodoro-start-btn').addEventListener('click', () => this.startPomodoro());
                $('#pomodoro-stop-btn').addEventListener('click', () => this.stopPomodoro());
                $('#pomodoro-float-ball').addEventListener('click', () => {
                    
                    if ($('#pomodoro-float-ball').isDragging) {
                        $('#pomodoro-float-ball').isDragging = false; 
                        return;
                    }
                    UIManager.navigateTo('pomodoro');
                });
                
                
                const setupPomodoroDrag = () => {
                    const floatBall = $('#pomodoro-float-ball');
                    let isDragging = false;
                    let initialY;
                    let initialBottom;
                    let hasMoved = false;

                    const onDragStart = (e) => {
                        if (e.target.closest('.time-left') || e.target.closest('.progress-ring')) {
                            isDragging = true;
                            hasMoved = false;
                            floatBall.isDragging = false; 
                            floatBall.classList.add('dragging');

                            initialY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                            initialBottom = parseInt(window.getComputedStyle(floatBall).bottom, 10);
                            
                            
                            e.preventDefault();

                            document.addEventListener('mousemove', onDragMove);
                            document.addEventListener('touchmove', onDragMove, { passive: false });
                            document.addEventListener('mouseup', onDragEnd);
                            document.addEventListener('touchend', onDragEnd);
                        }
                    };

                    const onDragMove = (e) => {
                        if (!isDragging) return;

                        e.preventDefault();
                        hasMoved = true;
                        floatBall.isDragging = true;

                        const currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                        const deltaY = currentY - initialY;
                        let newBottom = initialBottom - deltaY;

                        
                        const maxHeight = window.innerHeight - floatBall.offsetHeight - 20; 
                        const minHeight = 80; 
                        newBottom = Math.max(minHeight, Math.min(newBottom, maxHeight));
                        
                        floatBall.style.bottom = `${newBottom}px`;
                    };

                    const onDragEnd = () => {
                        isDragging = false;
                        floatBall.classList.remove('dragging');
                        
                        document.removeEventListener('mousemove', onDragMove);
                        document.removeEventListener('touchmove', onDragMove);
                        document.removeEventListener('mouseup', onDragEnd);
                        document.removeEventListener('touchend', onDragEnd);
                        
                        
                        if (!hasMoved) {
                            setTimeout(() => { floatBall.isDragging = false; }, 10);
                        }
                    };

                    floatBall.addEventListener('mousedown', onDragStart);
                    floatBall.addEventListener('touchstart', onDragStart, { passive: false });
                };
                setupPomodoroDrag();
                
                
                const messageListUl = $('#message-list-ul');
                let messageListLongPressTimer = null;
                messageListUl.addEventListener('mousedown', (e) => handleInteractionStart(e, 'mouse'));
                messageListUl.addEventListener('touchstart', (e) => handleInteractionStart(e, 'touch'), { passive: true });

                function handleInteractionStart(e, type) {
                    const item = e.target.closest('.message-item');
                    if (!item) return;

                    clearTimeout(messageListLongPressTimer);
                    messageListLongPressTimer = setTimeout(() => {
                        UIManager.showMessageListOptions(item);
                    }, 500);

                    function clearLongPress() {
                        clearTimeout(messageListLongPressTimer);
                        document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                        document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                    }
                    document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                }
                
                $('#setting-tutorial').addEventListener('click', () => UIManager.navigateTo('tutorial', 'settings'));
                
                
                $('#tutorial-back-btn').addEventListener('click', () => UIManager.navigateTo('settings'));
                $('#page-tutorial .page-content').addEventListener('click', (e) => {
                    const item = e.target.closest('.setting-item');
                    if (!item) return;

                    const showTutorialModal = (title, body) => {
                        UIManager.showModal({
                            title: title,
                            body: `<div style="line-height: 1.7; font-size: 0.95rem;">${body}</div>`,
                            actions: [{ text: 'æˆ‘æ˜ç™½äº†', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                        });
                    };

                    switch (item.id) {
                        case 'setting-announcement':
                            this.showAnnouncementModal(true);
                            break;
                        case 'tutorial-api':
                            showTutorialModal('å¦‚ä½•é…ç½®API', `
                                <p>èŠå¤©å®¤éœ€è¦ä½ æä¾›ä¸€ä¸ªAIæœåŠ¡å•†çš„API Keyæ‰èƒ½è¿è¡Œã€‚</p>
                                <p>1. è¿›å…¥ <strong>è®¾ç½® > APIé…ç½®</strong> é¡µé¢ã€‚</p>
                                <p>2. ä»â€œAPIæä¾›å•†â€ä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ä½ æ‹¥æœ‰çš„æœåŠ¡å•†ã€‚å¦‚Gemini(è°·æ­Œå®˜æ–¹), SiliconFlow(ç¡…åŸºæµåŠ¨)ç­‰ã€‚</p>
                                <p>3. ç³»ç»Ÿä¼šè‡ªåŠ¨å¡«å……å¤§éƒ¨åˆ†æœåŠ¡å•†çš„é»˜è®¤URLå’Œæ¨¡å‹ï¼Œä½ åªéœ€åœ¨ <strong>API Key</strong> è¾“å…¥æ¡†ä¸­å¡«å…¥ä½ çš„å¯†é’¥å³å¯ã€‚</p>
                                <p>4. å¦‚æœä½ ä½¿ç”¨è‡ªå®šä¹‰æˆ–æœªåˆ—å‡ºçš„æœåŠ¡å•†ï¼Œè¯·é€‰æ‹©â€œè‡ªå®šä¹‰â€å¹¶æ‰‹åŠ¨å¡«å†™æ‰€æœ‰å­—æ®µã€‚</p>
                                <p>5. å¦‚æœä½ æ˜¯<strong>è‡ªå·±è´­å…¥çš„Geminiæ¨¡å‹</strong>ï¼Œè¯·é€‰æ‹©â€œè‡ªå®šä¹‰â€å¹¶æ‰‹åŠ¨å¡«å†™æ‰€æœ‰å­—æ®µã€‚æ‰€æœ‰éœ€è¦å¡«å…¥çš„å­—æ®µå¯è¯¢é—®ä½ çš„apiå–å®¶</p>
                                <p><strong>æç¤ºï¼š</strong>API Keyéå¸¸é‡è¦ï¼Œè¯·å¦¥å–„ä¿ç®¡ï¼Œä¸è¦æ³„éœ²ã€‚</p>
                            `);
                            break;
                        case 'tutorial-character':
                            showTutorialModal('å¦‚ä½•åˆ›å»ºæ–°è§’è‰²', `
                                <p>è§’è‰²æ˜¯ä¸ä½ èŠå¤©çš„å¥½å‹ã€‚</p>
                                <p>1. è¿›å…¥ <strong>é€šè®¯å½•</strong> é¡µé¢ã€‚</p>
                                <p>2. ç‚¹å‡»å³ä¸Šè§’çš„ <strong>+</strong> å·æŒ‰é’®ã€‚</p>
                                <p>3. åœ¨å¼¹å‡ºçš„èœå•ä¸­é€‰æ‹© <strong>æ·»åŠ æ–°å¥½å‹</strong>ã€‚</p>
                                <p>4. å¡«å†™è§’è‰²çš„å„é¡¹ä¿¡æ¯ã€‚<strong>å§“å</strong>æ˜¯è§’è‰²çš„å”¯ä¸€IDï¼Œä¸å¯é‡å¤ã€‚å…¶ä»–ä¿¡æ¯å¦‚å–œå¥½ã€èƒŒæ™¯æŒ‰éœ€è¦å¡«å†™ã€‚</p>
                                <p>5. ç‚¹å‡»â€œæ·»åŠ â€å³å¯å®Œæˆåˆ›å»ºã€‚</p>
                                <p>6. ç‚¹å‡»<strong>é€šè®¯å½•</strong>é¡µé¢çš„å¥½å‹å¯è¿›å…¥èŠå¤©ç•Œé¢</p>
                            `);
                            break;
                        case 'tutorial-group':
                            showTutorialModal('å¦‚ä½•åˆ›å»ºç¾¤èŠ', `
                                <p>ä½ å¯ä»¥åˆ›å»ºåŒ…å«å¤šä¸ªå¥½å‹è§’è‰²çš„ç¾¤èŠã€‚</p>
                                <p>1. åŒæ ·åœ¨ <strong>é€šè®¯å½•</strong> é¡µé¢ï¼Œç‚¹å‡»å³ä¸Šè§’ <strong>+</strong> å·å¹¶é€‰æ‹© <strong>æ–°å»ºç¾¤èŠ</strong>ã€‚</p>
                                <p>2. ä¸ºç¾¤èŠèµ·ä¸€ä¸ªåå­—ï¼Œå¹¶ä»å¥½å‹åˆ—è¡¨ä¸­å‹¾é€‰è¦åŠ å…¥ç¾¤èŠçš„å¥½å‹è§’è‰²ï¼ˆè‡³å°‘ä¸€ä½ï¼‰ã€‚</p>
                                <p>3. ä½ è¿˜å¯ä»¥æŒ‡å®šä¸€ä½ç¾¤ä¸»ï¼Œç¾¤ä¸»å¯ä»¥æ˜¯ä½ è‡ªå·±æˆ–ä»»ä½•ä¸€ä½å¥½å‹è§’è‰²ã€‚</p>
                                <p>4. åˆ›å»ºæˆåŠŸåï¼Œä½ å°±å¯ä»¥åœ¨ç¾¤èŠä¸­ä¸å¤šä¸ªå¥½å‹åŒæ—¶äº’åŠ¨äº†ã€‚</p>
                            `);
                            break;
                        case 'tutorial-chatting':
                            showTutorialModal('å¦‚ä½•è¿›è¡ŒèŠå¤©', `
                                <p><strong>1. å‘é€ä¸å›å¤ï¼š</strong></p>
                                <p>åœ¨èŠå¤©è¾“å…¥æ¡†ï¼ˆå³ä¸‹è§’ï¼‰è¾“å…¥å¹¶å‘é€ä½ çš„æ‰€æœ‰æ¶ˆæ¯åï¼Œç‚¹å‡»å·¦ä¸‹è§’çš„ <strong>ç¾½æ¯›æŒ‰é’® <i class="fas fa-feather-alt"></i></strong> æ¥è®©AIè¿›è¡Œå›å¤ã€‚</p>
                                <p><strong>2. é‡æ–°ç”Ÿæˆï¼š</strong></p>
                                <p>å¦‚æœä½ å¯¹AIçš„æœ€æ–°å›å¤ä¸æ»¡æ„ï¼Œå¯ä»¥ç‚¹å‡»ä½ è‡ªå·±çš„å¤´åƒï¼ŒAIä¼šæ’¤é”€åˆšæ‰çš„å›å¤å¹¶é‡æ–°ç”Ÿæˆä¸€æ¬¡ã€‚</p>
                                <p><strong>3. æŸ¥çœ‹å†…å¿ƒï¼š</strong></p>
                                <p>æƒ³çŸ¥é“å¥½å‹åœ¨æƒ³ä»€ä¹ˆå—ï¼Ÿç‚¹å‡»å¥½å‹çš„å¤´åƒï¼Œå¯ä»¥çœ‹åˆ°TAæœ€è¿‘çš„â€œå¿ƒå£°â€å’Œâ€œéšç¬”â€ã€‚</p>
                                <p><strong>4. æ›´å¤šæ“ä½œï¼š</strong></p>
                                <p>é•¿æŒ‰ä»»æ„ä¸€æ¡æ¶ˆæ¯æ°”æ³¡ï¼Œå¯ä»¥è¿›è¡Œâ€œå¼•ç”¨â€ã€â€œåˆ é™¤â€æˆ–â€œæ’¤å›â€ï¼ˆä»…è‡ªå·±å‘çš„æ¶ˆæ¯ï¼‰æ“ä½œã€‚</p>
                            `);
                            break;
                        case 'tutorial-opening-scene':
                            showTutorialModal('å¼€åœºç™½æ˜¯ä»€ä¹ˆï¼Ÿ', `
                                <p>å¼€åœºç™½æ˜¯ä¸€ä¸ª<strong>é¢„è®¾çš„å¯¹è¯åœºæ™¯</strong>ï¼Œç”¨äºå¿«é€Ÿå¼€å¯ä¸€æ®µç‰¹å®šæƒ…å¢ƒçš„å¯¹è¯ï¼Œè€Œæ— éœ€ä»é›¶å¼€å§‹å¼•å¯¼ã€‚</p>
                                <p><strong>å¦‚ä½•æ·»åŠ ä¸åº”ç”¨ï¼š</strong></p>
                                <p>1. åœ¨å¥½å‹æˆ–ç¾¤èŠçš„èŠå¤©ç•Œé¢ï¼Œç‚¹å‡»å³ä¸Šè§’çš„èœå•æŒ‰é’®(<i class="fas fa-ellipsis-v"></i> æˆ– <i class="fas fa-ellipsis-h"></i>)è¿›å…¥ç®¡ç†ç•Œé¢ã€‚</p>
                                <p>2. é€‰æ‹© <strong>å¼€åœºç™½è®¾å®š</strong>ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œæ–°å»ºã€ç¼–è¾‘æˆ–åˆ é™¤å¤šä¸ªå¼€åœºç™½æ–¹æ¡ˆã€‚</p>
                                <p>3. åœ¨å¼€åœºç™½åˆ—è¡¨ä¸­ç‚¹å‡» <strong>åº”ç”¨</strong> æŒ‰é’®åï¼Œ<strong>å½“å‰èŠå¤©è®°å½•ä¼šè¢«æ¸…ç©º</strong>ï¼Œç„¶åå¥½å‹/ç¾¤èŠä¼šæ ¹æ®ä½ è®¾å®šçš„å¼€åœºç™½å†…å®¹ï¼Œè‡ªåŠ¨å¼€å§‹ä¸€æ®µæ–°çš„å¯¹è¯ã€‚</p>
                                <p><strong>æç¤ºï¼š</strong>è¿™æ˜¯ä¸€ä¸ªéå¸¸é€‚åˆå¿«é€Ÿæµ‹è¯•è§’è‰²è®¾å®šæˆ–å¼€å¯æ–°å‰§æƒ…çš„åŠŸèƒ½ã€‚</p>
                            `);
                            break;
                        case 'tutorial-prompts':
                            showTutorialModal('æç¤ºè¯æ˜¯ä»€ä¹ˆï¼Ÿ', `
                                <p>æç¤ºè¯ï¼ˆPromptï¼‰æ˜¯ç”¨æ¥æŒ‡å¯¼AIå¦‚ä½•å›åº”çš„ç‰¹æ®ŠæŒ‡ä»¤ï¼Œèƒ½æå¤§åœ°å½±å“è§’è‰²çš„æ€§æ ¼ã€è¯´è¯é£æ ¼å’Œè¡Œä¸ºé€»è¾‘ã€‚</p>
                                <p><strong>åŠŸèƒ½ä¸ç»‘å®šï¼š</strong></p>
                                <p>ä½ å¯ä»¥åœ¨ <strong>è®¾ç½® > è‡ªå®šä¹‰æç¤ºè¯</strong> é¡µé¢åˆ›å»ºå’Œç®¡ç†æç¤ºè¯ã€‚æç¤ºè¯å¯ä»¥ç»‘å®šç»™å•ä¸ªå¥½å‹ã€ç¾¤èŠã€ç”šè‡³æœ‹å‹åœˆï¼ˆå½±å“åŠ¨æ€ç”Ÿæˆï¼‰ï¼Œè®©å¥½å‹åœ¨ä¸åŒåœºæ™¯ä¸‹éµå¾ªä¸åŒçš„è§„åˆ™ã€‚</p>
                                <p>ç‚¹å‡»<strong>èŠå¤©ç•Œé¢/æœ‹å‹åœˆç•Œé¢å³ä¸Šè§’</strong>çš„ç®¡ç†æŒ‰é’®ï¼Œé€‰æ‹©<strong>ç»‘å®šæç¤ºè¯</strong></p>
                                <p><strong>æç¤ºè¯ç±»å‹ï¼š</strong></p>
                                <p>  - <strong>æ˜¾æ€§(Explicit):</strong> è¿™ç§æç¤ºè¯<strong>æ€»æ˜¯</strong>ä¼šè¢«æ¿€æ´»ï¼Œéå¸¸é€‚åˆå®šä¹‰è§’è‰²çš„æ ¸å¿ƒæ€§æ ¼ã€ä¸–ç•Œè§‚æˆ–å¿…é¡»éµå®ˆçš„è§„åˆ™ã€‚</p>
                                <p>  - <strong>éšæ€§(Implicit):</strong> åªæœ‰å½“ä½ çš„å‘è¨€ä¸­åŒ…å«é¢„è®¾çš„<strong>å…³é”®è¯</strong>æ—¶ï¼Œè¿™ç§æç¤ºè¯æ‰ä¼šè¢«æ¿€æ´»ã€‚é€‚åˆè®¾å®šä¸€äº›ç‰¹å®šæƒ…å¢ƒä¸‹çš„ååº”ï¼Œå¦‚â€œå½“ç©å®¶æåˆ°â€˜ä¸‹é›¨â€™æ—¶ï¼Œè§’è‰²ä¼šè¡¨ç°å‡ºæ‚²ä¼¤â€ã€‚</p>
                                <p><strong>å¯¼å…¥ä¸å¯¼å‡ºï¼š</strong></p>
                                <p>åœ¨æç¤ºè¯ç®¡ç†é¡µé¢ï¼Œä½ å¯ä»¥å°†å†™å¥½çš„æç¤ºè¯æ–‡ä»¶å¤¹å¯¼å‡ºä¸º<code>.json</code>æ–‡ä»¶ï¼Œç”¨äºå¤‡ä»½æˆ–åˆ†äº«ç»™ä»–äººã€‚åŒæ ·ï¼Œä¹Ÿå¯ä»¥å¯¼å…¥ä»–äººåˆ†äº«çš„æç¤ºè¯æ–‡ä»¶ã€‚</p>
                                <p><strong>æ³¨æ„ï¼ˆTokenæ¶ˆè€—ï¼‰ï¼š</strong></p>
                                <p>æç¤ºè¯å†…å®¹è¶Šé•¿ã€ç»‘å®šçš„æç¤ºè¯è¶Šå¤šï¼Œæ¯æ¬¡ä¸å¥½å‹äº¤äº’æ—¶æ¶ˆè€—çš„Tokenå°±è¶Šå¤šï¼Œå¹¶é™ä½å“åº”é€Ÿåº¦ã€‚è¯·æ ¹æ®éœ€è¦è‡ªè¡Œå–èˆã€‚</p>
                            `);
                            break;
                        case 'tutorial-import-export':
                             showTutorialModal('å¦‚ä½•å¯¼å…¥å¯¼å‡º', `
                                <p>ä½ å¯ä»¥æ–¹ä¾¿åœ°åˆ†äº«æˆ–å¤‡ä»½ä½ çš„è§’è‰²ä¸ç¾¤èŠæ•°æ®ã€‚</p>
                                <p><strong>å¯¼å‡ºï¼š</strong></p>
                                <p>1. åœ¨é€šè®¯å½•ç‚¹å‡»å¥½å‹æˆ–ç¾¤èŠçš„è¯¦æƒ…æŒ‰é’®ï¼Œæˆ–åœ¨èŠå¤©é¡µé¢ç‚¹å‡»å³ä¸Šè§’èœå•è¿›å…¥ç®¡ç†é¡µé¢ã€‚</p>
                                <p>2. ç‚¹å‡»â€œå¯¼å‡ºè§’è‰²/ç¾¤èŠâ€æŒ‰é’®ï¼Œä¼šç”Ÿæˆä¸€ä¸ª <code>.json</code> æ ¼å¼çš„é…ç½®æ–‡ä»¶ï¼Œä¿å­˜åˆ°æœ¬åœ°å³å¯ã€‚</p>
                                <p><strong>å¯¼å…¥ï¼š</strong></p>
                                <p>1. åœ¨é€šè®¯å½•é¡µé¢ï¼Œç‚¹å‡»å³ä¸Šè§’ <strong>+</strong> å·ï¼Œé€‰æ‹© <strong>å¯¼å…¥è§’è‰²/ç¾¤èŠ</strong>ã€‚</p>
                                <p>2. é€‰æ‹©ä½ ä¹‹å‰å¯¼å‡ºçš„ <code>.json</code> æ–‡ä»¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è¯†åˆ«å¹¶å¯¼å…¥ã€‚</p>
                                <p>å¯¼å…¥å‰ç¡®ä¿å¯¼å…¥çš„æ–‡ä»¶æ˜¯æ”¯æŒè¿™ä¸ªèŠå¤©å®¤ä½¿ç”¨çš„ã€‚</p>
                                <p><strong>æç¤ºï¼š</strong>å¦‚æœå¯¼å…¥çš„è§’è‰²åä¸ç°æœ‰è§’è‰²å†²çªï¼Œç³»ç»Ÿä¼šæç¤ºä½ é€‰æ‹©â€œæ›´æ–°â€æˆ–â€œè¦†ç›–â€ã€‚</p>
                            `);
                            break;
                        case 'tutorial-emoji':
                            showTutorialModal('å¦‚ä½•æ–°å¢/åˆ é™¤è¡¨æƒ…åŒ…', `
                                <p>ä½ å¯ä»¥æ·»åŠ å’Œç®¡ç†è‡ªå·±çš„ä¸“å±è¡¨æƒ…åŒ…ã€‚</p>
                                <p>1. åœ¨ä»»æ„èŠå¤©ç•Œé¢ï¼Œç‚¹å‡»è¾“å…¥æ¡†ä¸‹æ–¹çš„ <strong>æ”¶è—è¡¨æƒ… <i class="fas fa-star"></i></strong> æŒ‰é’®ï¼Œæ‰“å¼€æ”¶è—è¡¨æƒ…é¢æ¿ã€‚</p>
                                <p>2. ç‚¹å‡»é¢æ¿å·¦ä¸Šè§’çš„ <strong><i class="fas fa-plus"></i></strong> æŒ‰é’®ï¼Œå¯ä»¥<strong>æ–°å¢</strong>è‡ªå®šä¹‰è¡¨æƒ…ã€‚ä½ éœ€è¦æä¾›è¡¨æƒ…å›¾ç‰‡çš„URLé“¾æ¥å’Œè¡¨æƒ…çš„æ–‡å­—æè¿°ï¼ˆè¿™ä¸ªæè¿°ä¼šå‘Šè¯‰AIè¡¨æƒ…çš„å«ä¹‰ï¼‰ã€‚</p>
                                <p>3. ç‚¹å‡» <strong><i class="fas fa-minus"></i></strong> æŒ‰é’®ï¼Œå¯ä»¥<strong>åˆ é™¤</strong>ä½ æ·»åŠ è¿‡çš„è‡ªå®šä¹‰è¡¨æƒ…ã€‚</p>
                                <p><strong>æç¤ºï¼š</strong>åœ¨æ™®é€šè¡¨æƒ…åŒ…é¢æ¿ï¼Œä½ ä¹Ÿå¯ä»¥ç‚¹å‡»æ¯ä¸ªè¡¨æƒ…å³ä¸Šè§’çš„æ˜Ÿæ˜Ÿ <i class="fas fa-star"></i> æ¥æ”¶è—æˆ–å–æ¶ˆæ”¶è—å†…ç½®è¡¨æƒ…ã€‚</p>
                            `);
                            break;
                        case 'tutorial-persona':
                            showTutorialModal('ç©å®¶äººè®¾åŠç»‘å®š', `
                                <p>ä½ å¯ä»¥åˆ›å»ºå¤šå¥—â€œä½ â€çš„äººè®¾ï¼Œå¹¶åœ¨ä¸åŒèŠå¤©ä¸­åˆ‡æ¢ï¼Œè®©AIæ ¹æ®ä¸åŒçš„äººè®¾ä¸ä½ äº’åŠ¨ã€‚</p>
                                <p><strong>1. åˆ›å»º/ç®¡ç†é¢„è®¾ï¼š</strong></p>
                                <p>  - åœ¨ <strong>æ¶ˆæ¯</strong> é¡µé¢ï¼Œç‚¹å‡»å·¦ä¸Šè§’ä½ è‡ªå·±çš„å¤´åƒï¼Œä¼šæ»‘å‡ºâ€œæˆ‘çš„ä¿¡æ¯â€ä¾§è¾¹æ ã€‚</p>
                                <p>  - åœ¨è¿™é‡Œç¼–è¾‘ä½ çš„å§“åã€æ€§åˆ«ã€èƒŒæ™¯ç­‰ä¿¡æ¯ï¼Œè¿™å°±æ˜¯ä½ <strong>å½“å‰ä½¿ç”¨</strong>çš„äººè®¾ã€‚</p>
                                <p>  - ç‚¹å‡»ä¸‹æ–¹çš„ <strong>è¯»å–/ä¿å­˜/åˆ é™¤</strong> æŒ‰é’®ï¼Œå¯ä»¥ç®¡ç†ä½ çš„äººè®¾<strong>é¢„è®¾</strong>ã€‚ä½ å¯ä»¥å°†å½“å‰çš„äººè®¾ä¿å­˜ä¸ºä¸€ä¸ªæ–°çš„é¢„è®¾ï¼Œæˆ–è¯»å–ä¸€ä¸ªå·²æœ‰çš„é¢„è®¾æ¥æ›¿æ¢å½“å‰äººè®¾ã€‚</p>
                                <p><strong>2. ç»‘å®šäººè®¾ï¼š</strong></p>
                                <p>  - <strong>ç»‘å®š</strong>çš„ä½œç”¨æ˜¯å°†æŸä¸ªç‰¹å®šçš„äººè®¾é¢„è®¾<strong>å›ºå®š</strong>ç»™ä¸€ä¸ªèŠå¤©å¯¹è±¡æˆ–åœºæ™¯ã€‚</p>
                                <p>  - ä½ å¯ä»¥åœ¨ä»¥ä¸‹åœ°æ–¹è¿›è¡Œç»‘å®šï¼š</p>
                                <p>    â€¢ <strong>ç§èŠ/ç¾¤èŠï¼š</strong>èŠå¤©ç•Œé¢å³ä¸Šè§’èœå• > ç»‘å®šç©å®¶äººè®¾ã€‚</p>
                                <p>    â€¢ <strong>å¥½å‹åˆ†ç»„ï¼š</strong>é€šè®¯å½• > åˆ†ç»„ > å¯¹åº”åˆ†ç»„å³ä¸Šè§’èœå• > ç»‘å®šç©å®¶äººè®¾ (ä¼šå¯¹æ­¤åˆ†ç»„ä¸‹æ‰€æœ‰æœªå•ç‹¬ç»‘å®šçš„å¥½å‹ç”Ÿæ•ˆ)ã€‚</p>
                                <p>    â€¢ <strong>æœ‹å‹åœˆï¼š</strong>å‘ç° > æœ‹å‹åœˆ > å³ä¸Šè§’èœå• > ä¿®æ”¹å½“å‰åœˆå­ > ç»‘å®šç©å®¶äººè®¾ã€‚</p>
                                <p><strong>é‡è¦ï¼š</strong>å¦‚æœä¸€ä¸ªèŠå¤©å¯¹è±¡æ²¡æœ‰ç»‘å®šä»»ä½•ç‰¹å®šäººè®¾ï¼ŒAIå°†é»˜è®¤ä½¿ç”¨ä½ åœ¨â€œæˆ‘çš„ä¿¡æ¯â€ä¾§è¾¹æ ä¸­<strong>å½“å‰æ­£åœ¨ä½¿ç”¨</strong>çš„äººè®¾ä¸ä½ å¯¹è¯ã€‚</p>
                            `);
                            break;
                        case 'tutorial-narrator':
                             showTutorialModal('æ—ç™½å¦‚ä½•ä½¿ç”¨', `
                                <p>â€œæ—ç™½â€åŠŸèƒ½å…è®¸ä½ è®¾å®šä¸€ä¸ªâ€œæ•…äº‹çš„è®²è¿°è€…â€æ¥æè¿°åœºæ™¯ã€è¡¥å……è®¾å®šæˆ–æ¨åŠ¨å‰§æƒ…ã€‚</p>
                                <p><strong>ä½¿ç”¨æ–¹æ³•ï¼š</strong></p>
                                <p>é€šè®¯å½•æ–°å¢å†…ç½®è§’è‰²é€‰æ‹©æ—ç™½ï¼Œå°†æ—ç™½æ·»åŠ è¿›å…¥ç¾¤èŠå†…ã€‚æˆ–è€…è‡ªè¡Œåˆ›å»ºä¸€ä¸ªæ—ç™½è§’è‰²ï¼Œå›ºå®šå®ƒä½¿ç”¨ <code>&lt;æ—ç™½&gt;...&lt;/æ—ç™½&gt;</code> çš„æ ¼å¼æ¥å‘é€æ—ç™½æ¶ˆæ¯ã€‚</p>
                                <p>å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥è‡ªå·±è¾“å…¥æ—ç™½æ¶ˆæ¯æ ¼å¼ï¼Œæ¥ä½œä¸ºé‚£ä¸ªå‰§æƒ…çš„æ¨åŠ¨è€…ã€‚</p>
                                <p><strong>ç¤ºä¾‹ï¼š</strong></p>
                                <p><code>&lt;æ—ç™½&gt;çª—å¤–ä¸‹èµ·äº†æ·…æ·…æ²¥æ²¥çš„å°é›¨ï¼Œæˆ¿é—´é‡Œçš„æ°”æ°›æœ‰äº›æ²‰é—·ã€‚&lt;/æ—ç™½&gt;</code></p>
                            `);
                            break;
                        case 'tutorial-moments':
                            showTutorialModal('æœ‹å‹åœˆå¦‚ä½•ä½¿ç”¨', `
                                <p>æœ‹å‹åœˆæ˜¯ä¸€ä¸ªæ¨¡æ‹Ÿç¤¾äº¤åŠ¨æ€çš„è¶£å‘³åŠŸèƒ½ã€‚</p>
                                <p>1. è¿›å…¥ <strong>å‘ç° > æœ‹å‹åœˆ</strong>ã€‚é¦–æ¬¡è¿›å…¥éœ€è¦ç‚¹å‡»å³ä¸Šè§’èœå•æŒ‰é’®ï¼Œå…ˆåˆ›å»ºä¸€ä¸ªâ€œåœˆå­â€ã€‚</p>
                                <p>2. ç‚¹å‡»å³ä¸Šè§’èœå•æŒ‰é’®å¯ä»¥ <strong>ç®¡ç†åœˆå­</strong>ï¼ˆå¢åˆ æ”¹æŸ¥ã€åˆ‡æ¢ï¼‰ã€‚</p>
                                <p>3. ç‚¹å‡»ç›¸æœºå›¾æ ‡å¯ä»¥ <strong>å‘å¸ƒä½ è‡ªå·±çš„åŠ¨æ€</strong>ã€‚</p>
                                <p>4. ç‚¹å‡»åˆ·æ–°æŒ‰é’®ï¼Œå¥½å‹ä¼šæ ¹æ®å·²æœ‰è®¾å®šï¼Œ<strong>è‡ªåŠ¨ç”Ÿæˆæ–°çš„æœ‹å‹åœˆåŠ¨æ€</strong>ã€‚</p>
                                <p>5. ä½ å¯ä»¥åƒçœŸå®ç¤¾äº¤è½¯ä»¶ä¸€æ ·ï¼Œå¯¹åŠ¨æ€è¿›è¡Œç‚¹èµã€è¯„è®ºå’Œè½¬å‘ã€‚</p>
                            `);
                            break;
                        case 'tutorial-theme':
                            showTutorialModal('å¦‚ä½•è®¾ç½®ä¸»é¢˜', `
                                <p>ä½ å¯ä»¥é«˜åº¦è‡ªå®šä¹‰åº”ç”¨çš„å¤–è§‚ã€‚</p>
                                <p>1. è¿›å…¥ <strong>è®¾ç½® > ä¸»é¢˜è®¾ç½®</strong>ã€‚</p>
                                <p>2. åœ¨è¿™é‡Œï¼Œä½ å¯ä»¥æ›´æ”¹<strong>å¼¹çª—é£æ ¼</strong>ã€<strong>èŠå¤©æ°”æ³¡æ ·å¼</strong>ã€<strong>å­—ä½“å¤§å°</strong>å’Œ<strong>é¢œè‰²</strong>ã€‚</p>
                                <p>3. ç‚¹å‡» <strong>é€šç”¨è®¾ç½® > èƒŒæ™¯ä¸å°é¢</strong>ï¼Œå¯ä»¥ä¸Šä¼ ä½ å–œæ¬¢çš„å›¾ç‰‡ä½œä¸ºå…¨å±€é¡µé¢èƒŒæ™¯ã€å…¨å±€èŠå¤©èƒŒæ™¯ï¼Œå¥½å‹/ç¾¤èŠèŠå¤©ç•Œé¢å³ä¸Šè§’å¯è®¾ç½®ä¸“å±èŠå¤©èƒŒæ™¯ã€‚æ”¯æŒè‡ªå®šä¹‰çº¢åŒ…å’Œè½¬è´¦çš„å°é¢å›¾ã€‚</p>
                                <p>4. <strong>å­—ä½“è®¾ç½®</strong>ä½ å¯ä»¥åŠ è½½å¯å…è´¹ä½¿ç”¨çš„æˆ–å·²è´­ä¹°çš„æœ¬åœ°å­—ä½“æ–‡ä»¶/ç½‘ç»œå­—ä½“èµ„æº</p>
                            `);
                            break;
                    }
                });
                
                
                chatBackBtn.addEventListener('click', async () => {
                    if (appState.selectionMode.active) {
                        UIManager.showToast('è¯·å…ˆå–æ¶ˆå¤šé€‰æ¨¡å¼');
                        return;
                    }
                    const chatId = appState.currentChatId;
                    if (chatId) {
                        const chatData = await DBHelper.get('chats', chatId);
                        if (chatData && chatData.history) {
                            let madeChanges = false;
                            chatData.history.forEach(msg => {
                                if (msg.isUnread) {
                                    msg.isUnread = false;
                                    madeChanges = true;
                                }
                            });
                            if (madeChanges) {
                                await DBHelper.put('chats', chatData);
                            }
                        }
                    }
                    this.resetQuoteState();
                    UIManager.navigateTo('messages');
                });
                $('#chat-manage-btn').addEventListener('click', () => {
                    const chatId = appState.currentChatId;
                    if (!chatId) return;
                    if (chatId.startsWith('group-')) this.handleOpenGroupManagementSidebar(chatId);
                    else this.handleOpenFriendManagementSidebar(chatId);
                });
                $('#chat-insight-btn').addEventListener('click', () => {
                    const chatId = appState.currentChatId;
                    if (!chatId) return;
                    
                    if (chatId.startsWith('group-')) {
                        UIManager.showGroupInsightModal(chatId);
                    } else {
                        UIManager.showPersonaModal(chatId);
                    }
                });
                 sendBtn.addEventListener('click', () => this.handlePlayerSendMessage());
                messageInput.addEventListener('keypress', async (e) => {
                    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                    if (chatSettings.enterToSend && e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handlePlayerSendMessage();
                    }
                });
                aiRequestBtn.addEventListener('click', () => {
                    if (AIHandler.isAwaitingResponse) AIHandler.cancelAiRequest();
                    else AIHandler.handleAiReplyRequest();
                });
                messageInput.addEventListener('input', () => {
                    messageInput.style.height = 'auto';
                    messageInput.style.height = (messageInput.scrollHeight) + 'px';
                });

                
                appContainer.addEventListener('click', (e) => this.handleClickEffect(e));
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay && !modalOverlay.classList.contains('no-overlay-close')) UIManager.hideModal();
                });
                $('#sidebar-overlay').addEventListener('click', (e) => {
                    if (e.target === $('#sidebar-overlay')) UIManager.hideSidebar();
                });

                $('#bottom-sheet-overlay').addEventListener('click', (e) => {
                    if (e.target === $('#bottom-sheet-overlay')) UIManager.hideBottomSheet();
                });

                
                emojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    favoriteEmojiCard.classList.remove('active'); 
                    emojiCard.classList.toggle('active');
                });

                favoriteEmojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    emojiCard.classList.remove('active'); 
                    favoriteEmojiCard.classList.toggle('active');
                    if (favoriteEmojiCard.classList.contains('active')) {
                        this.renderFavoriteEmojiPage();
                    }
                });

                $('#simulated-image-btn').addEventListener('click', () => this.handleSimulatedImageSend());
                $('#image-vision-btn').addEventListener('click', () => this.handleVisionImageSend());
                $('#card-btn').addEventListener('click', () => this.handlePlayerCardSend());
                $('#delete-last-turn-btn').addEventListener('click', () => this.handleDeleteLastTurn());
                $('#edit-last-reply-btn').addEventListener('click', () => this.handleEditLastReply());
                voiceBtn.addEventListener('click', () => this.handleVoiceInput());
                $('#transfer-btn').addEventListener('click', () => this.handlePlayerTransfer());
                $('#red-packet-btn').addEventListener('click', () => this.handlePlayerRedPacket());
                document.addEventListener('click', (e) => {
                    if (!chatInputArea.contains(e.target)) {
                        emojiCard.classList.remove('active');
                        favoriteEmojiCard.classList.remove('active');
                    }
                });
                $('#emoji-prev-btn').addEventListener('click', () => { appState.emojiCurrentPage--; this.renderEmojiPage(); });
                $('#emoji-next-btn').addEventListener('click', () => { appState.emojiCurrentPage++; this.renderEmojiPage(); });
                $('#favorite-emoji-prev-btn').addEventListener('click', () => {
                    const slotsOnFirstPage = appState.emojisPerPage - 3;
                    const slotsOnOtherPages = appState.emojisPerPage;
                    let pageCount = 1;
                    if (appState.favoriteEmojis.length > slotsOnFirstPage) {
                        pageCount = 1 + Math.ceil((appState.favoriteEmojis.length - slotsOnFirstPage) / slotsOnOtherPages);
                    }
                    
                    appState.favoriteEmojiCurrentPage--;
                    if (appState.favoriteEmojiCurrentPage < 0) {
                        appState.favoriteEmojiCurrentPage = pageCount - 1;
                    }
                    this.renderFavoriteEmojiPage();
                });
                $('#favorite-emoji-next-btn').addEventListener('click', () => {
                    const slotsOnFirstPage = appState.emojisPerPage - 3;
                    const slotsOnOtherPages = appState.emojisPerPage;
                    let pageCount = 1;
                    if (appState.favoriteEmojis.length > slotsOnFirstPage) {
                        pageCount = 1 + Math.ceil((appState.favoriteEmojis.length - slotsOnFirstPage) / slotsOnOtherPages);
                    }

                    appState.favoriteEmojiCurrentPage++;
                    if (appState.favoriteEmojiCurrentPage >= pageCount) {
                        appState.favoriteEmojiCurrentPage = 0;
                    }
                    this.renderFavoriteEmojiPage();
                });
                
                chatArea.addEventListener('mousedown', (e) => this.handleInteractionStart(e, 'mouse'));
                chatArea.addEventListener('touchstart', (e) => this.handleInteractionStart(e, 'touch'));
                cancelQuoteBtn.addEventListener('click', () => this.resetQuoteState());
                $('#forwarded-history-back-btn').addEventListener('click', () => UIManager.navigateTo('chat'));
                $('#cancel-forward-btn').addEventListener('click', () => this.toggleSelectionMode());
                $('#delete-selected-messages-btn').addEventListener('click', () => this.handleDeleteSelectedMessages());
                $('#confirm-forward-btn').addEventListener('click', () => this.showForwardTargetModal());

                chatArea.addEventListener('click', async (e) => {
                    
                    if (appState.selectionMode.active) {
                        const messageElement = e.target.closest('[data-message-id]');
                        if (messageElement) {
                            const checkbox = messageElement.querySelector('.message-select-checkbox');
                            if (checkbox && e.target !== checkbox) {
                                checkbox.checked = !checkbox.checked;
                            }
                            
                            this.handleMessageSelection({ target: checkbox });
                        }
                        return; 
                    }

                    const messageRow = e.target.closest('.message-row');
                    if (!messageRow) return;
                    const messageId = messageRow.dataset.messageId;
                    const voiceBubble = e.target.closest('.voice-message-bubble');
                    if (voiceBubble) {
                        const wrapper = voiceBubble.closest('.bubble-and-tag-wrapper');
                        const transcript = wrapper.querySelector('.voice-transcript');
                        if (transcript) transcript.classList.toggle('show');
                        return;
                    }
                    const cardWrapper = e.target.closest('.card-message-wrapper');
                    if (cardWrapper) {
                        const cardId = cardWrapper.dataset.cardId;
                        if (!cardId) return;
                        const detailElement = document.getElementById(cardId);
                        if (detailElement) detailElement.classList.toggle('visible');
                        return;
                    }
                    const specialBubble = e.target.closest('.transfer-or-red-packet-bubble');
                    if (specialBubble) {
                        const msg = await DBHelper.get('messages', messageId);
                        if (!msg) return;
                        if (msg.segmentType === 'transfer' && !msg.cardData.isClaimed) {
                            this.handleTransferClick(msg);
                        } else if (msg.segmentType === 'red-packet' && !msg.cardData.isClaimedByPlayer) {
                            this.handleRedPacketClick(msg);
                        }
                        return; 
                    }

                    
                    const customForwardCard = e.target.closest('[data-type="custom-forward"]');
                    if (customForwardCard) {
                        const messageId = customForwardCard.closest('.message-row').dataset.messageId;
                        if (messageId) {
                            this.showCustomForwardDetail(messageId);
                        }
                        return;
                    }
                    
                    const forwardedMomentCard = e.target.closest('.forwarded-moment-card-content');
                    if (forwardedMomentCard) {
                        const momentId = forwardedMomentCard.dataset.momentId;
                        if (momentId) {
                            this.showForwardedMomentDetail(momentId);
                        }
                        return; 
                    }
                    const giftBubble = e.target.closest('.gift-bubble');
                    if (giftBubble) {
                        this.showGiftDetailsModal(messageId);
                        return;
                    }
                    const forwardedHistoryBubble = e.target.closest('.forwarded-history-bubble');
                    if (forwardedHistoryBubble) {
                        this.openForwardedHistoryPage(messageId);
                        return;
                    }
                });
                chatArea.addEventListener('scroll', () => {
                    if (chatArea.scrollTop < 50 && !appState.isHistoryLoading) {
                        UIManager.loadMoreMessages();
                    }
                });

                const momentsBg = $('#moments-bg');
                const momentsBgInput = $('#moments-bg-input');

                momentsBg.addEventListener('click', () => {
                    momentsBgInput.click();
                });

                momentsBgInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file || !appState.currentCircleId) return;

                    try {
                        const compressedImage = await Utils.compressImage(file, 1000, 1000, 0.8);
                        const circle = await DBHelper.get('circles', appState.currentCircleId);
                        if (circle) {
                            circle.backgroundImage = compressedImage;
                            await DBHelper.put('circles', circle);
                            momentsBg.src = compressedImage;
                            UIManager.showToast('èƒŒæ™¯å·²æ›´æ¢ï¼');
                        }
                    } catch (error) {
                        console.error("æ›´æ¢èƒŒæ™¯å¤±è´¥ï¼š", error);
                        UIManager.showToast('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                });
            },

            async getPlayerProfileForContext(contextId) {
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                if (!contextId) {
                    return baseProfile;
                }

                let boundId = null;

                if (contextId.startsWith('group-')) { 
                    const group = await DBHelper.get('groups', contextId);
                    boundId = group?.boundPersonaPresetId;
                } else if (contextId.startsWith('contact')) { 
                    const contact = await DBHelper.get('contacts', contextId);
                    if (contact) {
                        if (contact.boundPersonaPresetId) {
                            boundId = contact.boundPersonaPresetId;
                        } else if (contact.folderId) {
                            const folder = await DBHelper.get('friendFolders', contact.folderId);
                            boundId = folder?.boundPersonaPresetId;
                        }
                    }
                } else if (contextId.startsWith('circle')) {
                    const circle = await DBHelper.get('circles', contextId);
                    boundId = circle?.boundPersonaPresetId;
                }

                if (boundId && baseProfile.presets && Array.isArray(baseProfile.presets)) {
                    const boundProfile = baseProfile.presets.find(p => p && p.presetId === boundId);
                    if (boundProfile) {
                        
                        return { ...baseProfile, ...boundProfile };
                    }
                }

                
                return baseProfile;
            },

            async handlePatRequest(patteeId) {
                if (appState.selectionMode.active) return; //
                const chatId = appState.currentChatId;
                if (!chatId) return;

                const patter = await this.getPlayerProfileForContext(chatId);
                const pattee = patteeId === 'myProfile' ? patter : await DBHelper.get('contacts', patteeId);
                
                if (!patter || !pattee) return;

                const patAction = pattee.patAction || 'æ‹äº†æ‹';
                const patContent = pattee.patContent || '';

                const displayText = `${patter.name} ${patAction} ${pattee.name}${patContent ? ` ${patContent}` : ''}`;

                const message = {
                    messageId: Utils.generateId('msg'),
                    senderId: patter.id, 
                    content: { 
                        patterName: patter.name,
                        patteeName: pattee.name,
                        action: patAction,
                        content: patContent,
                        displayText: displayText
                    },
                    type: 'sent', 
                    segmentType: 'pat_a_pat',
                };
                
                await this.handlePlayerSendMessage(message);
            },

        async handlePlayerSendMessage(prebuiltMessage = null) {
            const content = messageInput.value.trim();
            if (!prebuiltMessage && (!content || !appState.currentChatId)) return;

            let message;
            const profile = await this.getPlayerProfileForContext(appState.currentChatId);
            const allMessages = await DBHelper.getMessages(appState.currentChatId, 1, Date.now());
            const lastMessage = allMessages.pop();

            const now = Date.now();
            
            if (lastMessage && (now - lastMessage.timestamp > 5 * 60 * 1000)) {
                const timeDivider = UIManager.createTimeDividerElement(now);
                chatArea.appendChild(timeDivider);
            }

            if (prebuiltMessage) {
                message = prebuiltMessage;
                message.timestamp = now; 
            } else if (appState.quotingMessage) {
                
                const quotedMsg = appState.quotingMessage;
                let senderName = 'å¯¹æ–¹'; 

                if (quotedMsg.type === 'sent') {
                    
                    const profile = await this.getPlayerProfileForContext(appState.currentChatId);
                    senderName = profile.name;
                } else {
                    
                    const contact = await DBHelper.get('contacts', quotedMsg.senderId);
                    senderName = contact ? (contact.remark || contact.name) : 'å¯¹æ–¹';
                }

                let quotedContentText;
                switch (quotedMsg.segmentType) {
                    case 'text':
                        quotedContentText = quotedMsg.content;
                        break;
                    case 'card':
                        quotedContentText = `[å¡ç‰‡æ¶ˆæ¯] ${quotedMsg.cardData.title}`;
                        break;
                    case 'image_vision':
                        quotedContentText = '[å›¾ç‰‡]';
                        break;
                    case 'quote':
                        quotedContentText = quotedMsg.cardData.newContent;
                        break;
                    case 'voice':
                        quotedContentText = '[è¯­éŸ³]';
                        break;
                    case 'emoji-image':
                        const emojiId = quotedMsg.content;
                        const emojiDesc = appState.playerEmojiMap[emojiId] || 'æœªçŸ¥è¡¨æƒ…';
                        quotedContentText = `[è¡¨æƒ…] ${emojiDesc}`;
                        break;
                    case 'image_simulated':
                        quotedContentText = '[å›¾ç‰‡]';
                        break;
                    default:
                        quotedContentText = '[æ¶ˆæ¯]';
                        break;
                }

                message = {
                    messageId: Utils.generateId('msg'),
                    content: `[å¼•ç”¨] ${content}`,
                    timestamp: now,
                    type: 'sent',
                    segmentType: 'quote',
                    cardData: {
                        quotedName: senderName,
                        quotedContent: quotedContentText,
                        newContent: content
                    }
                };
                this.resetQuoteState();
            } else {
                const narratorRegex = /^<æ—ç™½>([\s\S]*)<\/æ—ç™½>$/;
                const narratorMatch = content.match(narratorRegex);

                if (narratorMatch) {
                    message = {
                        messageId: Utils.generateId('msg'),
                        content: narratorMatch[1].trim(),
                        timestamp: now,
                        type: 'sent',
                        segmentType: 'narrator',
                    };
                } else {
                    message = {
                        messageId: Utils.generateId('msg'),
                        content,
                        timestamp: now,
                        type: 'sent',
                        isRetracted: false,
                        isUnread: false,
                        segmentType: 'text',
                    };
                }
            }
            
            message.chatId = appState.currentChatId;
            await DBHelper.put('messages', message);
            await UIManager.updateChatMetadata(appState.currentChatId, message);
            
            const chatMetadata = await DBHelper.get('chatMetadata', appState.currentChatId) || { chatId: appState.currentChatId, turnCountSinceLastPrompt: 0, totalPlayerTurns: 0 };
chatMetadata.turnCountSinceLastPrompt = (chatMetadata.turnCountSinceLastPrompt || 0) + 1;
chatMetadata.totalPlayerTurns = (chatMetadata.totalPlayerTurns || 0) + 1;
await DBHelper.put('chatMetadata', chatMetadata);

UIManager.addMessageToDOM(message, profile, false, true);


const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
const summaryInterval = chatSettings.summaryMessageInterval || 200;

const isGroup = appState.currentChatId.startsWith('group-');
const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);

if (entity && entity.autoSummaryEnabled && summaryInterval > 0 && appState.currentChat.totalMessages > 0 && appState.currentChat.totalMessages % summaryInterval === 0) {
    console.log(`è¾¾åˆ°ç¬¬ ${appState.currentChat.totalMessages} æ¡æ¶ˆæ¯ï¼Œè§¦å‘è‡ªåŠ¨æ€»ç»“ã€‚`);
    setTimeout(() => AIHandler.handleAutoSummaryRequest(appState.currentChatId), 0);
}
            
            
            if (!prebuiltMessage) {
                messageInput.value = '';
                messageInput.style.height = 'auto';
                messageInput.focus();
            }
        },
            
            
            
            async renderEmojiPage() {
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                const useBuiltin = chatSettings.useBuiltinEmojis !== false; 

                let emojiEntries;

                if (useBuiltin) {
                    
                    emojiEntries = Object.entries(appState.playerEmojiMap);
                } else {
                    
                    
                    emojiEntries = Object.entries(appState.customEmojis).map(([id, data]) => [id, data.name]);
                }
                
                const pageCount = Math.ceil(emojiEntries.length / appState.emojisPerPage);

                if (appState.emojiCurrentPage < 0) appState.emojiCurrentPage = pageCount - 1;
                if (appState.emojiCurrentPage >= pageCount) appState.emojiCurrentPage = 0;
                
                const pageIndex = appState.emojiCurrentPage;
                const start = pageIndex * appState.emojisPerPage;
                const end = start + appState.emojisPerPage;
                const pageEmojis = emojiEntries.slice(start, end);

                emojiGrid.innerHTML = '';
                pageEmojis.forEach(([id, desc]) => {
                    const item = document.createElement('div');
                    item.className = 'emoji-item';
                    item.dataset.emojiId = id;
                    item.title = desc;
                    
                    let emojiSrc;
                    if (id.startsWith('custom-')) {
                        emojiSrc = appState.customEmojis[id]?.url || '';
                    } else {
                        emojiSrc = `https://z.wiki/u/${id}`;
                    }
                    
                    const isFavorite = appState.favoriteEmojis.includes(id);

                    item.innerHTML = `
                        <img src="${emojiSrc}" alt="${desc}">
                        <div class="favorite-emoji-toggle ${isFavorite ? 'is-favorite' : ''}" title="æ”¶è—">
                            <i class="fas fa-star"></i>
                        </div>
                    `;
                    
                    const imgEl = item.querySelector('img');
                    imgEl.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const message = {
                            messageId: Utils.generateId('msg'),
                            content: id,
                            timestamp: Date.now(), 
                            type: 'sent',
                            segmentType: 'emoji-image',
                        };
                        
                        await EventManager.handlePlayerSendMessage(message);
                        emojiCard.classList.remove('active');
                    });

                    const favToggle = item.querySelector('.favorite-emoji-toggle');
                    favToggle.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const emojiId = item.dataset.emojiId;
                        const index = appState.favoriteEmojis.indexOf(emojiId);
                        
                        if (index > -1) {
                            appState.favoriteEmojis.splice(index, 1);
                            favToggle.classList.remove('is-favorite');
                        } else {
                            appState.favoriteEmojis.push(emojiId);
                            favToggle.classList.add('is-favorite');
                        }
                        
                        const profile = await DBHelper.get('profile', 'myProfile');
                        profile.favoriteEmojis = appState.favoriteEmojis;
                        await DBHelper.put('profile', profile);
                    });
                    
                    emojiGrid.appendChild(item);
                });
                
                $('#emoji-page-indicator').textContent = `${pageIndex + 1} / ${pageCount}`;
            },

            renderFavoriteEmojiPage() {
                favoriteEmojiGrid.innerHTML = '';
                const favNav = $('#favorite-emoji-card .emoji-nav');
                const favoriteEmojis = appState.favoriteEmojis;
                const pageIndex = appState.favoriteEmojiCurrentPage;

                const slotsOnFirstPage = appState.emojisPerPage - 3;
                const slotsOnOtherPages = appState.emojisPerPage;

                if (pageIndex === 0) {
                    const extractBtn = document.createElement('div');
                    extractBtn.className = 'emoji-item-add';
                    extractBtn.innerHTML = '<i class="fas fa-paw"></i>';
                    extractBtn.title = 'æå–è‡ªå®šä¹‰è¡¨æƒ…åŒ…ID';
                    extractBtn.onclick = () => EventManager.showEmojiIdExtractionModal();
                    favoriteEmojiGrid.appendChild(extractBtn);

                    const addEmojiBtn = document.createElement('div');
                    addEmojiBtn.className = 'emoji-item-add';
                    addEmojiBtn.innerHTML = '<i class="fas fa-plus"></i>';
                    addEmojiBtn.title = 'æ·»åŠ è‡ªå®šä¹‰è¡¨æƒ…';
                    addEmojiBtn.onclick = () => this.showAddCustomEmojiModal();
                    favoriteEmojiGrid.appendChild(addEmojiBtn);

                    const deleteEmojiBtn = document.createElement('div');
                    deleteEmojiBtn.className = 'emoji-item-add';
                    deleteEmojiBtn.innerHTML = '<i class="fas fa-minus"></i>';
                    deleteEmojiBtn.title = 'åˆ é™¤è‡ªå®šä¹‰è¡¨æƒ…';
                    deleteEmojiBtn.onclick = () => this.showDeleteCustomEmojiModal();
                    favoriteEmojiGrid.appendChild(deleteEmojiBtn);
                }

                let pageCount = 1;
                if (favoriteEmojis.length > slotsOnFirstPage) {
                    pageCount = 1 + Math.ceil((favoriteEmojis.length - slotsOnFirstPage) / slotsOnOtherPages);
                }

                favNav.style.display = pageCount > 1 ? 'flex' : 'none';
                if (favoriteEmojis.length === 0) return;

                if (appState.favoriteEmojiCurrentPage < 0) appState.favoriteEmojiCurrentPage = 0;
                if (appState.favoriteEmojiCurrentPage >= pageCount) appState.favoriteEmojiCurrentPage = pageCount - 1;

                let start, end;
                if (pageIndex === 0) {
                    start = 0;
                    end = slotsOnFirstPage;
                } else {
                    start = slotsOnFirstPage + (pageIndex - 1) * slotsOnOtherPages;
                    end = start + slotsOnOtherPages;
                }
                const pageEmojis = favoriteEmojis.slice(start, end);

                pageEmojis.forEach(id => {
                    const desc = appState.playerEmojiMap[id] || 'å·²æ”¶è—è¡¨æƒ…';
                    const emojiItem = document.createElement('div');
                    emojiItem.className = 'emoji-item';
                    emojiItem.dataset.emojiId = id;
                    emojiItem.title = desc;

                    let emojiSrc;
                    if (id.startsWith('custom-')) {
                        emojiSrc = appState.customEmojis[id]?.url || '';
                    } else {
                        emojiSrc = `https://z.wiki/u/${id}`;
                    }

                    emojiItem.innerHTML = `<img src="${emojiSrc}" alt="${desc}" style="width: 60px; height: 60px;">`;
                    
                    let longPressTimer;
                    let isLongPress = false;
                    
                    const startLongPress = (e) => {
                        isLongPress = false; 
                        longPressTimer = setTimeout(() => {
                            isLongPress = true;
                            UIManager.showModal({
                                title: "å–æ¶ˆæ”¶è—",
                                body: `<p>è¦å°†è¿™ä¸ªè¡¨æƒ…ç§»å‡ºæ”¶è—å—ï¼Ÿ</p>`,
                                actions: [
                                    { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: 'ç¡®å®š', class: 'btn-danger', handler: async () => {
                                        const index = appState.favoriteEmojis.indexOf(id);
                                        if (index > -1) {
                                            appState.favoriteEmojis.splice(index, 1);
                                            const profile = await DBHelper.get('profile', 'myProfile');
                                            profile.favoriteEmojis = appState.favoriteEmojis;
                                            await DBHelper.put('profile', profile);
                                            this.renderFavoriteEmojiPage();
                                            UIManager.showToast("å·²å–æ¶ˆæ”¶è—");
                                        }
                                        UIManager.hideModal();
                                    }}
                                ]
                            });
                        }, 500);
                    };

                    const cancelLongPress = () => clearTimeout(longPressTimer);
                    
                    const handleClick = async (e) => {
                        if (isLongPress) return;
                        await this.handlePlayerSendMessage({
                            messageId: Utils.generateId('msg'),
                            content: id,
                            type: 'sent',
                            segmentType: 'emoji-image',
                        });
                        favoriteEmojiCard.classList.remove('active');
                    };

                    emojiItem.addEventListener('mousedown', startLongPress);
                    emojiItem.addEventListener('touchstart', startLongPress, { passive: true });
                    emojiItem.addEventListener('mouseup', cancelLongPress);
                    emojiItem.addEventListener('mouseleave', cancelLongPress);
                    emojiItem.addEventListener('touchend', cancelLongPress);
                    emojiItem.addEventListener('touchcancel', cancelLongPress);
                    emojiItem.addEventListener('click', handleClick);

                    favoriteEmojiGrid.appendChild(emojiItem);
                });

                if (pageCount > 1) {
                    $('#favorite-emoji-page-indicator').textContent = `${pageIndex + 1} / ${pageCount}`;
                }
            },

            async showBatchAddEmojiResultModal(addedEmojis) {
                let formattedText = 'é¢å¤–è¡¨æƒ…åŒ…:\n';
                addedEmojis.forEach(emoji => {
                    formattedText += `${emoji.id}:${emoji.name}\n`;
                });

                UIManager.showModal({
                    title: `æˆåŠŸæ·»åŠ  ${addedEmojis.length} ä¸ªè¡¨æƒ…åŒ…`,
                    body: `
                        <style>
                            #emoji-id-display {
                                width: 100%;
                                max-height: 200px;
                                overflow-y: auto;
                                font-family: monospace;
                                white-space: pre-wrap;
                                word-break: break-all;
                                user-select: text;
                                -webkit-user-select: text;
                                background-color: var(--text-color-white);
                                border: 1px solid var(--border-color);
                                border-radius: 8px;
                                padding: 10px;
                                font-size: 0.9rem;
                                color: var(--text-color-dark);
                                box-sizing: border-box;
                            }
                        </style>
                        <p>ä»¥ä¸‹æ˜¯æ–°æ·»åŠ çš„è¡¨æƒ…åŒ…åŠå…¶IDï¼Œå¯ç”¨äºæç¤ºè¯ä¸­ï¼š</p>
                        <pre id="emoji-id-display">${formattedText}</pre>
                    `,
                    actions: [
                        { text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å¤åˆ¶', class: 'btn-primary', id: 'copy-emoji-ids-btn' }
                    ]
                });

                const copyButton = $('#copy-emoji-ids-btn');
                if (copyButton) {
                    copyButton.addEventListener('click', async () => {
                        const textToCopy = $('#emoji-id-display').textContent;
                        
                        const copyTextFallback = (text) => {
                            const textArea = document.createElement("textarea");
                            textArea.value = text;
                            textArea.style.position = "fixed";
                            textArea.style.top = "-9999px";
                            textArea.style.left = "-9999px";
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            try {
                                const successful = document.execCommand('copy');
                                if (successful) {
                                    UIManager.showToast("å·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿ï¼");
                                } else {
                                    UIManager.showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
                                }
                            } catch (err) {
                                console.error('ä½¿ç”¨ execCommand å¤åˆ¶å¤±è´¥: ', err);
                                UIManager.showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
                            }
                            document.body.removeChild(textArea);
                        };

                        if (navigator.clipboard && window.isSecureContext) {
                            try {
                                await navigator.clipboard.writeText(textToCopy);
                                UIManager.showToast("å·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿ï¼");
                            } catch (err) {
                                console.error('ä½¿ç”¨ navigator.clipboard å¤åˆ¶å¤±è´¥ï¼Œå°†å°è¯•å¤‡ç”¨æ–¹æ³•: ', err);
                                copyTextFallback(textToCopy);
                            }
                        } else {
                            console.log("å½“å‰ç¯å¢ƒä¸å®‰å…¨æˆ–ä¸æ”¯æŒ Clipboard APIï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•ã€‚");
                            copyTextFallback(textToCopy);
                        }
                    });
                }
            },

            async showAddCustomEmojiModal() {
                UIManager.showModal({
                    title: "æ·»åŠ è‡ªå®šä¹‰è¡¨æƒ…",
                    body: `
                        <div class="creation-mode-tabs" style="margin-bottom: 20px;">
                            <button class="mode-btn active" data-mode="single">å•ä¸ªæ·»åŠ </button>
                            <button class="mode-btn" data-mode="batch">æ‰¹é‡æ·»åŠ </button>
                        </div>

                        <div id="add-emoji-single-panel">
                            <div class="form-group">
                                <label for="custom-emoji-url">è¡¨æƒ…åŒ…é“¾æ¥ (URL)</label>
                                <input type="text" id="custom-emoji-url" placeholder="è¯·ç²˜è´´å›¾ç‰‡çš„URL">
                            </div>
                            <div class="form-group">
                                <label for="custom-emoji-name">è¡¨æƒ…åŒ…åç§°/æè¿°</label>
                                <input type="text" id="custom-emoji-name" placeholder="ä¾‹å¦‚ï¼šå¯çˆ±çŒ«çŒ«æ‘‡å°¾å·´">
                            </div>
                            <p style="font-size:0.8rem; color:#aaa;">è¡¨æƒ…åŒ…å¯ä»¥æ˜¯é™æ€å›¾ç‰‡/åŠ¨æ€å›¾ç‰‡ï¼Œè¡¨æƒ…åŒ…åç§°å°†ç”¨äºAIç†è§£è¡¨æƒ…å«ä¹‰ï¼Œè¯·å‡†ç¡®å¡«å†™å«ä¹‰ã€‚</p>
                        </div>

                        <div id="add-emoji-batch-panel" style="display: none;">
                            <div class="form-group">
                                <label for="batch-emoji-input">æ‰¹é‡æ·»åŠ è¡¨æƒ…åŒ…</label>
                                <textarea id="batch-emoji-input" rows="8" placeholder="è¯·æŒ‰æ ¼å¼è¾“å…¥ï¼Œæ¯ä¸ªè¡¨æƒ…åŒ…å ä¸€è¡Œï¼š\nè¡¨æƒ…åŒ…åç§°ï¼šè¡¨æƒ…åŒ…é“¾æ¥\nå¯çˆ±çŒ«çŒ«ï¼šhttps://.../cat.gif"></textarea>
                            </div>
                            <p style="font-size:0.8rem; color:#aaa;">åç§°ä¸é“¾æ¥ä¹‹é—´è¯·ä½¿ç”¨ä¸­æ–‡å†’å·â€œï¼šâ€éš”å¼€ã€‚ä¸ç¬¦åˆæ ¼å¼çš„è¡Œå°†è¢«è‡ªåŠ¨å¿½ç•¥ã€‚</p>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'æ·»åŠ ', class: 'btn-primary', handler: async () => {
                            const isBatchMode = $('#add-emoji-batch-panel').style.display !== 'none';
                            const profile = await DBHelper.get('profile', 'myProfile');
                            if (!profile.customEmojis) profile.customEmojis = {};
                            
                            if (isBatchMode) {
                                const batchInput = $('#batch-emoji-input').value.trim();
                                if (!batchInput) return UIManager.showToast("æ‰¹é‡è¾“å…¥å†…å®¹ä¸èƒ½ä¸ºç©ºã€‚");

                                const lines = batchInput.split('\n');
                                const addedEmojis = [];
                                let successCount = 0;

                                for (const line of lines) {
                                    const parts = line.split('ï¼š');
                                    if (parts.length < 2) continue;

                                    const name = parts[0].trim();
                                    const url = parts.slice(1).join('ï¼š').trim();

                                    if (name && url && url.startsWith('http')) {
                                        const emojiId = Utils.generateId('custom-');
                                        profile.customEmojis[emojiId] = { url, name };
                                        
                                        appState.customEmojis[emojiId] = { url, name };
                                        appState.playerEmojiMap[emojiId] = name;
                                        appState.aiEmojiMap[emojiId] = name;
                                        
                                        addedEmojis.push({ id: emojiId, name: name });
                                        successCount++;
                                    }
                                }

                                if (successCount > 0) {
                                    await DBHelper.put('profile', profile);
                                    UIManager.hideModal();
                                    this.showBatchAddEmojiResultModal(addedEmojis);
                                    this.renderFavoriteEmojiPage();
                                } else {
                                    UIManager.showToast("æ²¡æœ‰æ‰¾åˆ°ä»»ä½•ç¬¦åˆæ ¼å¼çš„æœ‰æ•ˆè¡¨æƒ…åŒ…ã€‚");
                                }
                            } else {
                                const url = $('#custom-emoji-url').value.trim();
                                const name = $('#custom-emoji-name').value.trim();

                                if (!url || !name) return UIManager.showToast("é“¾æ¥å’Œåç§°éƒ½ä¸èƒ½ä¸ºç©ºã€‚");
                                if (!url.startsWith('http')) return UIManager.showToast("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„URLã€‚");

                                const emojiId = Utils.generateId('custom-');
                                profile.customEmojis[emojiId] = { url, name };
                                await DBHelper.put('profile', profile);

                                appState.customEmojis[emojiId] = { url, name };
                                appState.playerEmojiMap[emojiId] = name;
                                appState.aiEmojiMap[emojiId] = name;

                                UIManager.hideModal();
                                UIManager.showToast("è‡ªå®šä¹‰è¡¨æƒ…æ·»åŠ æˆåŠŸï¼");
                                
                                if (!appState.favoriteEmojis.includes(emojiId)) {
                                    appState.favoriteEmojis.push(emojiId);
                                    profile.favoriteEmojis = appState.favoriteEmojis;
                                    await DBHelper.put('profile', profile);
                                }
                                this.renderFavoriteEmojiPage();
                            }
                        }}
                    ]
                });

                const singlePanel = $('#add-emoji-single-panel');
                const batchPanel = $('#add-emoji-batch-panel');
                $$('.creation-mode-tabs .mode-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        $$('.creation-mode-tabs .mode-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        const isBatch = e.target.dataset.mode === 'batch';
                        singlePanel.style.display = isBatch ? 'none' : 'block';
                        batchPanel.style.display = isBatch ? 'block' : 'none';
                    };
                });
            },


            async showDeleteCustomEmojiModal() {
                const customEmojis = appState.customEmojis;
                if (Object.keys(customEmojis).length === 0) {
                    return UIManager.showToast("æ²¡æœ‰å¯åˆ é™¤çš„è‡ªå®šä¹‰è¡¨æƒ…");
                }

                const emojiListHtml = Object.entries(customEmojis).map(([id, data]) => `
                    <label class="member-select-item">
                        <input type="checkbox" name="delete-custom-emoji" value="${id}">
                        <img src="${data.url}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${data.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "åˆ é™¤è‡ªå®šä¹‰è¡¨æƒ…",
                    body: `
                        <button id="select-all-emojis-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 8px;">å…¨é€‰</button>
                        <div class="member-select-list" style="max-height: 40vh;">${emojiListHtml}</div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤é€‰ä¸­', class: 'btn-danger', handler: async () => {
                            const checkedEmojis = $$('input[name="delete-custom-emoji"]:checked');
                            if (checkedEmojis.length === 0) {
                                return UIManager.showToast("è¯·é€‰æ‹©è¦åˆ é™¤çš„è¡¨æƒ…");
                            }
                            const idsToDelete = Array.from(checkedEmojis).map(cb => cb.value);

                            const profile = await DBHelper.get('profile', 'myProfile');
                            if (!profile.customEmojis) profile.customEmojis = {};
                            if (!profile.favoriteEmojis) profile.favoriteEmojis = [];

                            idsToDelete.forEach(id => {
                                delete profile.customEmojis[id];
                                const favIndexDB = profile.favoriteEmojis.indexOf(id);
                                if (favIndexDB > -1) profile.favoriteEmojis.splice(favIndexDB, 1);
                                
                                const favIndexApp = appState.favoriteEmojis.indexOf(id);
                                if (favIndexApp > -1) appState.favoriteEmojis.splice(favIndexApp, 1);
                            });
                            
                            await DBHelper.put('profile', profile);
                            await this.setupEmojiMaps();
                            this.renderFavoriteEmojiPage();

                            UIManager.hideModal();
                            UIManager.showToast("é€‰ä¸­çš„è¡¨æƒ…å·²åˆ é™¤");
                        }}
                    ]
                });

                $('#select-all-emojis-btn').addEventListener('click', () => {
                    $$('input[name="delete-custom-emoji"]').forEach(cb => cb.checked = true);
                });
            },

        async initEmojiPanel() {
            this.renderEmojiPage(); 
        },

        handleVoiceInput() {
            UIManager.showModal({
                isPersistent: true, 
                customClass: 'modal-neumorphic',
                title: "å‘é€è¯­éŸ³",
                body: `
                    <div class="form-group">
                        <label for="modal-voice-text-input">è¯­éŸ³å†…å®¹ (æ–‡æœ¬)</label>
                        <textarea id="modal-voice-text-input" rows="4" placeholder="è¾“å…¥è¯­éŸ³æ¶ˆæ¯å†…å®¹..."></textarea>
                    </div>
                `,
                actions: [
                    { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                    { text: 'å‘é€', class: 'btn-primary', handler: async () => {
                        const text = $('#modal-voice-text-input').value.trim();
                        if (!text) return;

                        let duration = Math.max(1, Math.ceil(text.length / 4));
                        duration = Math.min(duration, 60); 

                        const profile = await DBHelper.get('profile', 'myProfile');
                        const message = {
                            messageId: Utils.generateId('msg'),
                            content: `[è¯­éŸ³] ${text}`,
                            timestamp: Date.now(),
                            type: 'sent',
                            segmentType: 'voice',
                            cardData: {
                                duration: `${duration}s`,
                                content: text
                            }
                        };
                        
                        await this.handlePlayerSendMessage(message);
                        UIManager.hideModal();
                    }}
                ]
            });
            setTimeout(() => $('#modal-voice-text-input').focus(), 100);
        },           

            async handlePlayerTransfer() {
                const isGroup = appState.currentChatId.startsWith('group-');
                let recipientHtml;
                let recipientName; 

                if (isGroup) {
                    
                    recipientHtml = `
                        <div class="form-group">
                            <label>è½¬è´¦ç»™</label>
                            <div id="transfer-recipient-display" class="form-group" style="padding: 12px 15px; cursor: pointer; background: #F0F0F3; border-radius: 12px; box-shadow: inset -5px -5px 9px rgba(255,255,255,0.7), inset 5px 5px 9px rgba(174,174,192,0.2);">
                                <span style="color: #888;">è¯·é€‰æ‹©æ”¶æ¬¾äºº</span>
                            </div>
                        </div>
                    `;
                } else {
                    
                    const contact = await DBHelper.get('contacts', appState.currentChatId);
                    recipientName = contact.name;
                }
                
                UIManager.showModal({
                    isPersistent: true, 
                    customClass: 'modal-neumorphic',
                    title: "è½¬è´¦",
                    body: `
                        ${isGroup ? recipientHtml : ''}
                        <div class="form-group">
                            <label for="modal-transfer-amount">è½¬è´¦é‡‘é¢</label>
                            <input type="number" id="modal-transfer-amount" placeholder="0.00" min="0.01" step="0.01">
                        </div>
                        <div class="form-group">
                            <label for="modal-transfer-note">å¤‡æ³¨ (é€‰å¡«)</label>
                            <input type="text" id="modal-transfer-note" placeholder="è½¬è´¦è¯´æ˜">
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'è½¬è´¦', class: 'btn-primary', handler: async () => {
                            const amount = parseFloat($('#modal-transfer-amount').value);
                            const note = $('#modal-transfer-note').value.trim();

                            if (isNaN(amount) || amount <= 0) {
                                return UIManager.showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
                            }
                            if (isGroup && !recipientName) { 
                                return UIManager.showToast('è¯·é€‰æ‹©æ”¶æ¬¾äºº');
                            }

                            const formattedAmount = `ï¿¥${amount.toFixed(2)}`;
                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[è½¬è´¦] ${formattedAmount}`,
                                type: 'sent',
                                segmentType: 'transfer',
                                cardData: {
                                    recipientName: recipientName,
                                    amount: formattedAmount,
                                    note: note,
                                    isClaimed: false
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
                
                
                if(isGroup) {
                    const displayDiv = $('#transfer-recipient-display');
                    displayDiv.addEventListener('click', async () => {
                         const group = await DBHelper.get('groups', appState.currentChatId);
                         const contacts = await DBHelper.getAll('contacts');
                         const members = group.members
                            .map(id => contacts.find(c => c.id === id))
                            .filter(Boolean);

                        if (members.length === 0) return;
                        
                        UIManager.showBottomSheet({
                            title: 'é€‰æ‹©æ”¶æ¬¾äºº',
                            customClass: 'compact-list', 
                            items: members.map(m => ({ value: m.name, text: m.remark || m.name })),
                            onSelect: (value, text) => {
                                recipientName = value; 
                                displayDiv.querySelector('span').textContent = text; 
                                displayDiv.querySelector('span').style.color = 'var(--text-color-dark)';
                            }
                        });
                    });
                }
            },

            async handlePlayerRedPacket() {
                const isGroup = appState.currentChatId.startsWith('group-');
                const groupOnlyHtml = isGroup ? `
                    <div class="form-group">
                        <label for="modal-rp-count">çº¢åŒ…ä¸ªæ•°</label>
                        <input type="number" id="modal-rp-count" value="1" min="1" step="1">
                    </div>
                ` : '';

                UIManager.showModal({
                    isPersistent: true, 
                    customClass: 'modal-neumorphic',
                    title: "å‘çº¢åŒ…",
                    body: `
                        <div class="form-group">
                            <label for="modal-rp-amount">æ€»é‡‘é¢</label>
                            <input type="number" id="modal-rp-amount" placeholder="0.00" min="0.01" step="0.01">
                        </div>
                        <div class="form-group">
                            <label for="modal-rp-title">çº¢åŒ…ç¥ç¦è¯­ (é€‰å¡«)</label>
                            <input type="text" id="modal-rp-title" placeholder="æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©">
                        </div>
                        ${groupOnlyHtml}
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å¡é’±è¿›çº¢åŒ…', class: 'btn-primary', handler: async () => {
                            const amount = parseFloat($('#modal-rp-amount').value);
                            const title = $('#modal-rp-title').value.trim() || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©';
                            const count = isGroup ? parseInt($('#modal-rp-count').value, 10) : 1;

                            if (isNaN(amount) || amount <= 0) {
                                return UIManager.showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
                            }
                            if (isGroup && (isNaN(count) || count <= 0)) {
                                return UIManager.showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„çº¢åŒ…ä¸ªæ•°');
                            }
                            if (isGroup && amount < count * 0.01) {
                                return UIManager.showToast('å•ä¸ªçº¢åŒ…é‡‘é¢ä¸èƒ½å°‘äº0.01å…ƒ');
                            }

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[çº¢åŒ…] ${title}`,
                                type: 'sent',
                                segmentType: 'red-packet',
                                cardData: {
                                    title: title,
                                    amount: amount,
                                    count: count,
                                    isClaimedByPlayer: false, 
                                    claimedBy: []
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
            },
           
            
            
            handleInteractionStart(e, type) {
                if (appState.selectionMode.active) return; 

                const targetElement = e.target.closest('.bubble, .narrator-notice, .pat-notice');
                if (!targetElement) return;

                const messageRow = targetElement.closest('.message-row, .narrator-notice, .pat-notice');
                if (!messageRow || !messageRow.dataset.messageId) return;

                clearTimeout(appState.longPressTimer);

                const startAction = () => {
                    const existingButton = $('.retract-button-wrapper.show');
                    if (existingButton) {
                        existingButton.remove();
                    }
                    
                    if (messageRow.classList.contains('narrator-notice')) {
                        this.showMessageOptions(messageRow, 'narrator');
                    } else if (messageRow.classList.contains('pat-notice')) {
                        this.showMessageOptions(messageRow, 'pat_a_pat');
                    } else if (messageRow.classList.contains('received')) {
                        this.showMessageOptions(messageRow, 'received');
                    } else if (messageRow.classList.contains('sent')) {
                        this.showMessageOptions(messageRow, 'sent');
                    }
                };

                appState.longPressTimer = setTimeout(startAction, 500);

                const clearLongPress = () => {
                    clearTimeout(appState.longPressTimer);
                    document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                };
                document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
            },

            async startQuote(messageRowElement) {
                const messageId = messageRowElement.dataset.messageId;
                const messageData = await DBHelper.get('messages', messageId);
                if (!messageData || messageData.isRetracted) return;

                appState.quotingMessage = messageData;
                
                let senderName = 'å¯¹æ–¹'; 
                if (messageData.type === 'sent') {
                    
                    const profile = await this.getPlayerProfileForContext(appState.currentChatId);
                    senderName = profile.name;
                } else {
                    
                    const contact = await DBHelper.get('contacts', messageData.senderId);
                    senderName = contact ? (contact.remark || contact.name) : 'å¯¹æ–¹';
                }

                let quotedContentText;
                switch (messageData.segmentType) {
                    case 'text':
                        quotedContentText = messageData.content;
                        break;
                    case 'card':
                        quotedContentText = `[å¡ç‰‡æ¶ˆæ¯] ${messageData.cardData.title}`;
                        break;
                    case 'image_vision':
                        quotedContentText = '[å›¾ç‰‡]';
                        break;
                    case 'quote':
                        quotedContentText = messageData.cardData.newContent;
                        break;
                    case 'voice':
                        quotedContentText = '[è¯­éŸ³]';
                        break;
                    case 'emoji-image':
                        const emojiId = messageData.content;
                        const emojiDesc = appState.playerEmojiMap[emojiId] || 'æœªçŸ¥è¡¨æƒ…';
                        quotedContentText = `[è¡¨æƒ…] ${emojiDesc}`;
                        break;
                    case 'image_simulated':
                        quotedContentText = '[å›¾ç‰‡]';
                        break;
                    default:
                        quotedContentText = '[æ¶ˆæ¯]';
                        break;
                }
                
                quotePreviewContent.textContent = `${senderName}: ${quotedContentText}`;
                quotePreviewArea.style.display = 'flex';
                messageInput.focus();
            },

            resetQuoteState() {
                appState.quotingMessage = null;
                quotePreviewArea.style.display = 'none';
            },

            async showMessageOptions(messageRowElement, messageType) {
                const messageId = messageRowElement.dataset.messageId;
                if (!messageId) return;

                const wrapper = document.createElement('div');
                wrapper.className = 'retract-button-wrapper';

                let buttonsHtml = '';
                if (messageType === 'narrator' || messageType === 'pat_a_pat') {
                    buttonsHtml = `<button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> åˆ é™¤</button>`;
                } else if (messageType === 'sent') {
                    buttonsHtml = `
                        <button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> åˆ é™¤</button>
                        <button class="retract-btn" data-action="retract"><i class="fas fa-undo"></i> æ’¤å›</button>
                        <button class="retract-btn" data-action="quote"><i class="fas fa-quote-left"></i> å¼•ç”¨</button>
                    `;
                } else { 
                    buttonsHtml = `
                        <button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> åˆ é™¤</button>
                        <button class="retract-btn" data-action="quote"><i class="fas fa-quote-left"></i> å¼•ç”¨</button>
                    `;
                }
                wrapper.innerHTML = buttonsHtml;
                
                wrapper.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const button = e.target.closest('.retract-btn');
                    if (!button) return;

                    const action = button.dataset.action;

                    if (action === 'delete') {
                        await DBHelper.delete('messages', messageId);
                        const originalRow = $(`#${messageId}`);
                        if (originalRow) originalRow.remove();
                        wrapper.remove();
                    } else if (action === 'retract') {
                        const msgToRetract = await DBHelper.get('messages', messageId);
                        if (!msgToRetract) return;

                        msgToRetract.isRetracted = true;
                        await DBHelper.put('messages', msgToRetract);

                        const myProfile = await DBHelper.get('profile', 'myProfile');
                        const retractionNotice = UIManager.createRetractionNotice(msgToRetract, myProfile);
                        
                        const originalRow = $(`#${messageId}`);
                        if (originalRow) originalRow.replaceWith(retractionNotice);
                        wrapper.remove();
                    } else if (action === 'quote') {
                        this.startQuote(messageRowElement);
                        wrapper.remove();
                    }
                });

                let attachTarget;
                if (messageType === 'narrator' || messageType === 'pat_a_pat') {
                    attachTarget = messageRowElement;
                    messageRowElement.style.position = 'relative';
                } else {
                    attachTarget = messageRowElement.querySelector('.bubble-and-tag-wrapper');
                }

                if (attachTarget) {
                    attachTarget.appendChild(wrapper);
                    setTimeout(() => wrapper.classList.add('show'), 10);
                }

                const hideOnClickOutside = (event) => {
                    if (!wrapper.contains(event.target)) {
                        wrapper.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                document.addEventListener('click', hideOnClickOutside, true);
            },

            async handleEditProfile() {
                const profile = await DBHelper.get('profile', 'myProfile');
                UIManager.showSidebar({
                    position: 'left', 
                    title: "æˆ‘çš„ä¿¡æ¯",
                    body: `
                        <div class="form-group">
                            <label>å¤´åƒ</label>
                            <div class="avatar-uploader">
                                <img src="${profile.avatar}" id="profile-avatar-preview" class="avatar-preview">
                                <input type="file" id="profile-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('profile-avatar-input').click()">ä¸Šä¼ æ–°å¤´åƒ</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="profile-name-input">å§“å</label>
                            <input type="text" id="profile-name-input" value="${profile.name}">
                        </div>
                        <div class="form-group">
                            <label for="profile-gender-select">æ€§åˆ«</label>
                            <select id="profile-gender-select">
                                <option value="ç”·" ${profile.gender === 'ç”·' ? 'selected' : ''}>ç”·</option>
                                <option value="å¥³" ${profile.gender === 'å¥³' ? 'selected' : ''}>å¥³</option>
                                <option value="å…¶ä»–" ${profile.gender === 'å…¶ä»–' ? 'selected' : ''}>å…¶ä»–</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="profile-pat-action-input">æ‹ä¸€æ‹åŠ¨ä½œ</label>
                            <input type="text" id="profile-pat-action-input" value="${profile.patAction || ''}" maxlength="5" placeholder="é€‰å¡«, ä¾‹å¦‚:æ‹ä¸€æ‹">
                        </div>
                        <div class="form-group">
                            <label for="profile-pat-content-input">æ‹ä¸€æ‹å†…å®¹</label>
                            <input type="text" id="profile-pat-content-input" value="${profile.patContent || ''}" maxlength="20" placeholder="é€‰å¡«, ä¾‹å¦‚:çš„å¤´,è¢«æäº†">
                        </div>
                        <div class="form-group">
                            <label for="profile-background-input">èƒŒæ™¯èµ„æ–™</label>
                            <textarea id="profile-background-input">${profile.background || ''}</textarea>
                        </div>
                        <div class="details-actions" style="margin-top: 20px; flex-direction: row; justify-content: space-around; gap: 10px;">
                            <button class="details-btn" id="load-profile-preset-btn" style="flex: 1;">è¯»å–</button>
                            <button class="details-btn" id="save-profile-preset-btn" style="flex: 1;">ä¿å­˜</button>
                            <button class="details-btn" id="delete-profile-preset-btn" style="flex: 1;">åˆ é™¤</button>
                        </div>
                        <p style="text-align: center; font-size: 12px; color: #aaa; user-select: none; margin-top: 30px;">æ­¤èŠå¤©å®¤ç”±33åˆ¶ä½œï¼Œxhs:@å›é£</p>
                    `,
                    actions: [
                        { text: 'å¯¼å…¥', class: 'btn-secondary', handler: () => this.handleImportProfilePresets() },
                        { text: 'å¯¼å‡º', class: 'btn-secondary', handler: () => this.handleExportProfilePresets() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const profileToUpdate = await DBHelper.get('profile', 'myProfile');
                            const newAvatar = $('#profile-avatar-preview').src;
                            const newName = $('#profile-name-input').value.trim();
                            if (!newName) { 
                                UIManager.showModal({ title:"æç¤º", body:"<p>å§“åä¸èƒ½ä¸ºç©ºï¼</p>", actions:[{text:"å¥½çš„", class:"btn-primary", handler:()=>UIManager.hideModal()}]});
                                return; 
                            }
                            
                            const updatedProfile = {
                                ...profileToUpdate,
                                avatar: newAvatar,
                                name: newName,
                                gender: $('#profile-gender-select').value,
                                patAction: $('#profile-pat-action-input').value.trim(),
                                patContent: $('#profile-pat-content-input').value.trim(),
                                background: $('#profile-background-input').value.trim()
                            };
                            
                            await DBHelper.put('profile', updatedProfile);
                            $('#my-avatar').src = newAvatar;
                            UIManager.hideSidebar();
                        }}
                    ]
                });
                
                
                $('#profile-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const base64 = await Utils.fileToBase64(file);
                        $('#profile-avatar-preview').src = base64;
                    }
                });

                $('#load-profile-preset-btn').addEventListener('click', () => this.handleLoadProfilePreset());
                $('#save-profile-preset-btn').addEventListener('click', () => this.handleSaveProfilePreset());
                $('#delete-profile-preset-btn').addEventListener('click', () => this.handleDeleteProfilePreset());
            },

            async handleLoadProfilePreset() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p); 

                if (presets.length === 0) {
                    return UIManager.showToast("æ²¡æœ‰å¯è¯»å–çš„é¢„è®¾");
                }

                const items = presets.map((preset) => ({
                    value: preset.presetId, 
                    text: preset.presetName || preset.name // ä¼˜å…ˆä½¿ç”¨æ˜¾ç¤ºåï¼Œå…¼å®¹æ—§æ•°æ®
                }));

                UIManager.showBottomSheet({
                    title: 'é€‰æ‹©è¦è¯»å–çš„é¢„è®¾',
                    items: items,
                    onSelect: (presetId) => { 
                        const selectedPreset = presets.find(p => p.presetId === presetId);
                        if (selectedPreset) {
                            $('#profile-avatar-preview').src = selectedPreset.avatar;
                            $('#profile-name-input').value = selectedPreset.name;
                            $('#profile-gender-select').value = selectedPreset.gender;
                            $('#profile-pat-action-input').value = selectedPreset.patAction || '';
                            $('#profile-pat-content-input').value = selectedPreset.patContent || '';
                            $('#profile-background-input').value = selectedPreset.background || '';
                            UIManager.showToast(`å·²åŠ è½½é¢„è®¾ "${selectedPreset.name}"`);
                        }
                    }
                });
            },
            
            async handleSaveProfilePreset() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p);

                const items = [{
                    value: 'new',
                    text: `ä¿å­˜ä¸ºæ–°é¢„è®¾ (${presets.length}/20)`
                }];

                presets.forEach((preset) => {
                    items.push({
                        value: preset.presetId, 
                        text: `è¦†ç›–é¢„è®¾: ${preset.presetName || preset.name}` // ä¼˜å…ˆä½¿ç”¨æ˜¾ç¤ºå
                    });
                });

                UIManager.showBottomSheet({
                    title: 'ä¿å­˜é¢„è®¾',
                    items: items,
                    onSelect: (value) => { 
                        const currentData = {
                            name: $('#profile-name-input').value.trim(),
                            avatar: $('#profile-avatar-preview').src,
                            gender: $('#profile-gender-select').value,
                            background: $('#profile-background-input').value.trim()
                        };

                        if (!currentData.name) {
                            UIManager.showToast("ä¿å­˜å¤±è´¥ï¼Œå§“åä¸èƒ½ä¸ºç©º");
                            return;
                        }

                        if (value === 'new') {
                            this.confirmAndSavePreset(null, currentData); 
                        } else {
                            this.confirmAndSavePreset(value, currentData); 
                        }
                    }
                });
            },
            
            async confirmAndSavePreset(presetIdToOverwrite, currentData) {
                const profile = await DBHelper.get('profile', 'myProfile');
                const isNew = presetIdToOverwrite === null;
                const existingPreset = isNew ? null : (profile.presets || []).find(p => p.presetId === presetIdToOverwrite);

                const doSave = async (presetName) => {
                        const newPreset = {
                            ...currentData, // currentDataä¸­åŒ…å«äº†æ­£ç¡®çš„ç©å®¶å§“å name
                            presetId: isNew ? Utils.generateId('persona') : presetIdToOverwrite,
                            presetName: presetName, // è¿™æ˜¯é¢„è®¾çš„æ˜¾ç¤ºåç§°
                            patAction: $('#profile-pat-action-input').value.trim(),
                            patContent: $('#profile-pat-content-input').value.trim()
                        };
                        delete newPreset.playerName; // æ¸…ç†å¯èƒ½å­˜åœ¨çš„æ—§å­—æ®µ

                    
                    profile.presets = (profile.presets || []).filter(p => p);

                    if (isNew) {
                        if (profile.presets.length >= 20) {
                            UIManager.showToast("é¢„è®¾å·²è¾¾åˆ°20ä¸ªä¸Šé™");
                            return;
                        }
                        profile.presets.push(newPreset);
                    } else {
                        const indexToUpdate = profile.presets.findIndex(p => p.presetId === presetIdToOverwrite);
                        if (indexToUpdate !== -1) {
                            profile.presets[indexToUpdate] = newPreset;
                        } else {
                            
                            profile.presets.push(newPreset);
                        }
                    }

                    await DBHelper.put('profile', profile); 
                    UIManager.hideModal();
                    UIManager.showToast(`é¢„è®¾ "${presetName}" å·²ä¿å­˜`);
                };

                UIManager.showModal({
                    title: isNew ? 'ä¿å­˜ä¸ºæ–°é¢„è®¾' : 'è¦†ç›–é¢„è®¾',
                    body: `
                        <p>${existingPreset ? `è¿™å°†è¦†ç›–é¢„è®¾ "${existingPreset.name}"ã€‚` : 'ä¸ºè¿™ä¸ªæ–°é¢„è®¾èµ·ä¸ªåå­—å§ã€‚'}</p>
                        <div class="form-group">
                            <label for="preset-name-input">é¢„è®¾åç§°</label>
                            <input type="text" id="preset-name-input" value="${existingPreset ? (existingPreset.presetName || existingPreset.name) : currentData.name}">
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤ä¿å­˜', class: 'btn-primary', handler: () => {
                            const presetName = $('#preset-name-input').value.trim();
                            if (!presetName) {
                                UIManager.showToast("é¢„è®¾åç§°ä¸èƒ½ä¸ºç©º");
                                return;
                            }
                            doSave(presetName);
                        }}
                    ]
                });
            },

            async handleDeleteProfilePreset() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p);

                if (presets.length === 0) {
                    return UIManager.showToast("æ²¡æœ‰å¯åˆ é™¤çš„é¢„è®¾");
                }

                const presetsHtml = presets.map(preset => `
                    <label class="member-select-item">
                        <input type="checkbox" name="delete-preset" value="${preset.presetId}">
                        <img src="${preset.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${preset.presetName || preset.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "åˆ é™¤ç©å®¶é¢„è®¾",
                    body: `
                        <button id="select-all-presets-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 8px;">å…¨é€‰</button>
                        <div class="member-select-list" style="max-height: 40vh;">${presetsHtml}</div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤é€‰ä¸­', class: 'btn-danger', handler: async () => {
                            const checkedPresets = $$('input[name="delete-preset"]:checked');
                            if (checkedPresets.length === 0) {
                                return UIManager.showToast("è¯·é€‰æ‹©è¦åˆ é™¤çš„é¢„è®¾");
                            }
                            
                            UIManager.showModal({
                                title: 'ç¡®è®¤åˆ é™¤',
                                body: `<p>ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${checkedPresets.length} ä¸ªé¢„è®¾å—ï¼Ÿæ‰€æœ‰ä¸è¿™äº›é¢„è®¾çš„ç»‘å®šéƒ½å°†è¢«æ¸…é™¤ã€‚</p>`,
                                actions: [
                                    { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                                        const idsToDelete = Array.from(checkedPresets).map(cb => cb.value);
                                        const storesToUpdate = ['contacts', 'groups', 'friendFolders', 'circles'];
                                        for (const storeName of storesToUpdate) {
                                            const entities = await DBHelper.getAll(storeName);
                                            for (const entity of entities) {
                                                if (idsToDelete.includes(entity.boundPersonaPresetId)) {
                                                    entity.boundPersonaPresetId = null;
                                                    await DBHelper.put(storeName, entity);
                                                }
                                            }
                                        }

                                        const profileToUpdate = await DBHelper.get('profile', 'myProfile');
                                        profileToUpdate.presets = profileToUpdate.presets.filter(p => !idsToDelete.includes(p.presetId));
                                        await DBHelper.put('profile', profileToUpdate);
                                        
                                        UIManager.hideModal();
                                        UIManager.showToast(`${idsToDelete.length} ä¸ªé¢„è®¾å·²åˆ é™¤`);
                                    }}
                                ]
                            });
                        }}
                    ]
                });

                $('#select-all-presets-btn').addEventListener('click', () => {
                    const checkboxes = $$('input[name="delete-preset"]');
                    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                    checkboxes.forEach(cb => cb.checked = !allChecked);
                });
            },

            async handleExportProfilePresets() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p);

                if (presets.length === 0) {
                    return UIManager.showToast("æ²¡æœ‰å¯å¯¼å‡ºçš„é¢„è®¾");
                }

                const presetsHtml = presets.map(preset => `
                    <label class="member-select-item">
                        <input type="checkbox" name="export-preset" value="${preset.presetId}">
                        <img src="${preset.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${preset.presetName || preset.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é€‰æ‹©è¦å¯¼å‡ºçš„é¢„è®¾",
                    body: `
                        <button id="select-all-export-presets-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 8px;">å…¨é€‰</button>
                        <div class="member-select-list" style="max-height: 40vh;">${presetsHtml}</div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç”Ÿæˆæ–‡ä»¶', class: 'btn-primary', handler: () => {
                            const checkedPresets = $$('input[name="export-preset"]:checked');
                            if (checkedPresets.length === 0) {
                                return UIManager.showToast("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªé¢„è®¾");
                            }
                            
                            const idsToExport = Array.from(checkedPresets).map(cb => cb.value);
                            const presetsToExport = presets.filter(p => idsToExport.includes(p.presetId));

                            let filename;
                            if (presetsToExport.length === 1) {
                                filename = `${presetsToExport[0].presetName || presetsToExport[0].name}.json`;
                            } else {
                                filename = `${presetsToExport[0].name} ç­‰${presetsToExport.length}ä¸ªç©å®¶é¢„è®¾.json`;
                            }
                            
                            const exportData = presetsToExport;
                            const jsonString = JSON.stringify(exportData, null, 2);
                            const blob = new Blob([jsonString], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);

                            UIManager.showModal({
                                title: 'æ–‡ä»¶å·²ç”Ÿæˆ',
                                body: `<a href="${url}" download="${filename}" class="modal-btn btn-primary" style="display: block; text-align: center;">ç‚¹å‡»ä¸‹è½½é¢„è®¾æ–‡ä»¶</a>`,
                                actions: [{ text: 'å…³é—­', class: 'btn-secondary', handler: () => { URL.revokeObjectURL(url); UIManager.hideModal(); } }]
                            });
                        }}
                    ]
                });

                $('#select-all-export-presets-btn').addEventListener('click', () => {
                    const checkboxes = $$('input[name="export-preset"]');
                    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                    checkboxes.forEach(cb => cb.checked = !allChecked);
                });
            },

            async handleImportProfilePresets() {
                const fileInput = $('#import-presets-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const importedPresets = JSON.parse(event.target.result);
                            if (!Array.isArray(importedPresets)) {
                                throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œåº”ä¸ºJSONæ•°ç»„ã€‚");
                            }

                            const profile = await DBHelper.get('profile', 'myProfile');
                            const currentPresets = profile.presets || [];
                            const availableSlots = 20 - currentPresets.length;
                            const numToImport = importedPresets.length;

                            if (numToImport > availableSlots) {
                                let message = `é¢„è®¾ä½ç½®ä¸è¶³ã€‚æ–‡ä»¶å†…æœ‰ ${numToImport} ä¸ªé¢„è®¾ï¼Œä½†å½“å‰åªæœ‰ ${availableSlots} ä¸ªç©ºä½ã€‚è¯·å…ˆæ‰‹åŠ¨åˆ é™¤ä¸€äº›é¢„è®¾åå†è¯•ã€‚`;
                                if (numToImport === 1 && availableSlots === 0) {
                                    message = "é¢„è®¾ä½ç½®å·²æ»¡ï¼Œè¯·å…ˆæ‰‹åŠ¨åˆ é™¤ä¸€ä¸ªé¢„è®¾åå†å¯¼å…¥ã€‚";
                                }
                                UIManager.showModal({
                                    title: "å¯¼å…¥å¤±è´¥",
                                    body: `<p>${message}</p>`,
                                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            UIManager.showModal({
                                title: "ç¡®è®¤å¯¼å…¥",
                                body: `<p>æ–‡ä»¶å†…åŒ…å« ${numToImport} ä¸ªé¢„è®¾ã€‚è¯·ç¡®ä¿ä½ æœ‰è¶³å¤Ÿçš„ç©ºä½™ä½ç½®ã€‚åŒåé¢„è®¾å°†è¢«è·³è¿‡ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p>`,
                                actions: [
                                    { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: 'ç»§ç»­å¯¼å…¥', class: 'btn-primary', handler: async () => {
                                        const profileToUpdate = await DBHelper.get('profile', 'myProfile');
                                        profileToUpdate.presets = profileToUpdate.presets || [];
                                        const existingNames = profileToUpdate.presets.map(p => p.presetName || p.name);
                                        let skippedCount = 0;
                                        let importedCount = 0;

                                        for (const preset of importedPresets) {
                                            // æ£€æŸ¥æ–°æ ¼å¼çš„æ˜¾ç¤ºå(presetName)æˆ–æ—§æ ¼å¼çš„åç§°(name)æ˜¯å¦å­˜åœ¨
                                            const presetDisplayName = preset.presetName || preset.name;
                                            if (existingNames.includes(presetDisplayName)) {
                                                skippedCount++;
                                                continue;
                                            }
                                            
                                            // å…¼å®¹æ—§æ ¼å¼çš„å¯¼å…¥æ•°æ®
                                            if (!preset.presetName) {
                                                preset.presetName = preset.name; // å°†æ—§çš„nameä½œä¸ºæ˜¾ç¤ºå
                                            }
                                            
                                            
                                            preset.presetId = Utils.generateId('persona'); 
                                            profileToUpdate.presets.push(preset);
                                            existingNames.push(preset.presetName);
                                            importedCount++;
                                        }

                                        await DBHelper.put('profile', profileToUpdate);
                                        UIManager.hideModal();
                                        
                                        let successMessage = `æˆåŠŸå¯¼å…¥ ${importedCount} ä¸ªé¢„è®¾ã€‚`;
                                        if (skippedCount > 0) {
                                            successMessage += `\nè·³è¿‡äº† ${skippedCount} ä¸ªåŒåé¢„è®¾ã€‚`;
                                        }
                                        UIManager.showToast(successMessage, 3000);
                                    }}
                                ]
                            });

                        } catch (error) {
                            UIManager.showModal({
                                title: "å¯¼å…¥å¤±è´¥",
                                body: `<p>æ–‡ä»¶è§£æå¤±è´¥æˆ–æ ¼å¼ä¸æ­£ç¡®ã€‚è¯·ç¡®ä¿æ–‡ä»¶æ˜¯æ­£ç¡®çš„ç©å®¶é¢„è®¾å¯¼å‡ºæ–‡ä»¶ã€‚<br>é”™è¯¯: ${error.message}</p>`,
                                actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                            });
                        } finally {
                            fileInput.value = '';
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            async showFolderBindingOptionsModal(folderId) {
                const folder = await DBHelper.get('friendFolders', folderId);
                if (!folder) return;
            
                UIManager.showModal({
                    customClass: 'modal-default-style', 
                    title: `ä¸ºåˆ†ç»„â€œ${folder.name}â€ç»‘å®š`,
                    body: `
                        <div class="settings-list" style="padding:0; margin:0;">
                            <div class="setting-item" id="folder-bind-persona-btn">
                                <i class="fas fa-user-tag"></i>
                                <span>ç»‘å®šç©å®¶äººè®¾</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="folder-bind-prompts-btn">
                                <i class="fas fa-magic"></i>
                                <span>ç»‘å®šæç¤ºè¯</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="folder-bind-circle-btn">
                                <i class="fas fa-camera-retro"></i>
                                <span>ç»‘å®šæœ‹å‹åœˆ</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
            
                $('#folder-bind-persona-btn').onclick = () => {
                    UIManager.hideModal();
                    this.showPersonaBindingModal(folderId, false);
                };
                $('#folder-bind-prompts-btn').onclick = () => {
                    UIManager.hideModal();
                    this.showPromptBindingModalForFolder(folderId);
                };
                $('#folder-bind-circle-btn').onclick = () => {
                    UIManager.hideModal();
                    this.showCircleBindingModal(folderId, true);
                };
            },
            
            async showPromptBindingModalForFolder(folderId) {
                const folder = await DBHelper.get('friendFolders', folderId);
                if (!folder) return;
            
                const allPromptFolders = await DBHelper.getAll('promptFolders');
                if (allPromptFolders.length === 0) {
                    return UIManager.showToast("è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•æç¤ºè¯æ–‡ä»¶å¤¹ã€‚");
                }
            
                const boundFolderIds = folder.boundPromptFolderIds || [];
                const folderListHtml = allPromptFolders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="bind-folder" value="${f.id}" ${boundFolderIds.includes(f.id) ? 'checked' : ''}>
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');
            
                UIManager.showModal({
                    title: `ä¸ºåˆ†ç»„â€œ${folder.name}â€ç»‘å®šæç¤ºè¯`,
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const selectedIds = [...$$('input[name="bind-folder"]:checked')].map(cb => cb.value);
                            
                            UIManager.showModal({
                                title: 'ç¡®è®¤æ‰¹é‡ç»‘å®š',
                                body: `<p>è¿™å°†æŠŠåˆ†ç»„â€œ<strong>${folder.name}</strong>â€å†…æ‰€æœ‰å¥½å‹çš„æç¤ºè¯ç»‘å®šéƒ½æ›´æ–°ä¸ºå½“å‰æ‰€é€‰ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p><p style="font-size: 0.8rem; color: #aaa;">æ­¤æ“ä½œä¼šè¦†ç›–å¥½å‹åŸæœ‰çš„å•ç‹¬ç»‘å®šã€‚</p>`,
                                actions: [
                                    { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: 'ç¡®è®¤', class: 'btn-primary', handler: async () => {
                                        folder.boundPromptFolderIds = selectedIds;
                                        await DBHelper.put('friendFolders', folder);
                                        
                                        const contactsInFolder = (await DBHelper.getAll('contacts')).filter(c => c.folderId === folderId);
                                        for (const contact of contactsInFolder) {
                                            contact.boundPromptFolderIds = selectedIds;
                                            await DBHelper.put('contacts', contact);
                                        }
                                        UIManager.hideModal();
                                        UIManager.showToast('åˆ†ç»„æç¤ºè¯ç»‘å®šå·²æ›´æ–°ï¼');
                                    }}
                                ]
                            });
                        }}
                    ]
                });
            },

            showAddMenu() {
                UIManager.showModal({
                    title: "æ–°å»º/å¯¼å…¥",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0;">
                            <div class="setting-item" id="add-friend-menu">
                                <i class="fas fa-user-plus"></i>
                                <span>æ·»åŠ æ–°å¥½å‹</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="create-group-menu">
                                <i class="fas fa-users"></i>
                                <span>æ–°å»ºç¾¤èŠ</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="create-friend-folder-menu">
                                <i class="fas fa-folder-plus"></i>
                                <span>æ–°å»ºåˆ†ç»„</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="add-builtin-character-menu">
                                <i class="fas fa-user-secret"></i>
                                <span>æ–°å¢å†…ç½®è§’è‰²</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="import-data-menu">
                                <i class="fas fa-file-import"></i>
                                <span>å¯¼å…¥è§’è‰²/ç¾¤èŠ</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>`,
                    actions: [] 
                });
                
                $('#add-friend-menu').addEventListener('click', () => this.handleAddFriend());
                $('#create-group-menu').addEventListener('click', () => this.handleCreateGroup());
                $('#add-builtin-character-menu').addEventListener('click', () => this.showBuiltinCharacterSelection());
                $('#import-data-menu').addEventListener('click', () => this.handleImportData());
                $('#create-friend-folder-menu').addEventListener('click', () => this.showAddEditFriendFolderModal());
            },
            
            handleAddFriend() {
                const defaultAvatar = Utils.createAvatarDataUrl(Utils.getRandomColor());
                UIManager.showModal({
                    isPersistent: true, 
                    title: "æ·»åŠ æ–°å¥½å‹",
                    body: `
                        <div class="form-group">
                            <label>å¤´åƒ</label>
                            <div class="avatar-uploader">
                                <img src="${defaultAvatar}" id="add-friend-avatar-preview" class="avatar-preview">
                                <input type="file" id="add-friend-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('add-friend-avatar-input').click()">ä¸Šä¼ å¤´åƒ</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-name">å§“å (å”¯ä¸€ID, å¿…å¡«)</label>
                            <input type="text" id="add-friend-name" placeholder="ä¸ºAIå¥½å‹èµ·ä¸ªåå­—">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-remark">å¤‡æ³¨ (é€‰å¡«)</label>
                            <input type="text" id="add-friend-remark" placeholder="ä½ å¯¹TAçš„ç§°å‘¼">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-gender">æ€§åˆ« (å¿…å¡«)</label>
                            <select id="add-friend-gender">
                                <option value="ç”·">ç”·</option>
                                <option value="å¥³">å¥³</option>
                                <option value="å…¶ä»–">å…¶ä»–</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-allow-retraction">å…è®¸æ’¤å›æ¶ˆæ¯</label>
                            <select id="add-friend-allow-retraction">
                                <option value="true" selected>å¼€å¯</option>
                                <option value="false">å…³é—­</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-allow-emoji">å…è®¸å‘é€è¡¨æƒ…åŒ…</label>
                            <select id="add-friend-allow-emoji">
                                <option value="on" selected>å¼€å¯</option>
                                <option value="off">å…³é—­</option>
                                <option value="prob">æ¦‚ç‡</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-allow-active-reply">å…è®¸ä¸»åŠ¨å›å¤</label>
                            <select id="add-friend-allow-active-reply">
                                <option value="true" selected>éµå¾ªèŠå¤©è®¾ç½®</option>
                                <option value="false">å…³é—­</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-likes">å–œå¥½ (é€‰å¡«)</label>
                            <textarea id="add-friend-likes" placeholder="ä¾‹å¦‚ï¼šç”œé£Ÿã€è¿åŠ¨ã€æ—…æ¸¸"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-dislikes">åŒæ¶ (é€‰å¡«)</label>
                            <textarea id="add-friend-dislikes" placeholder="ä¾‹å¦‚ï¼šè¢«å¿½è§†ã€ä¸‹é›¨"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-habits">ä¹ æƒ¯ (é€‰å¡«)</label>
                            <textarea id="add-friend-habits" placeholder="ä¾‹å¦‚ï¼šæ™¨è·‘ã€è¿åŠ¨"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-pat-action">æ‹ä¸€æ‹åŠ¨ä½œ (é€‰å¡«)</label>
                            <input type="text" id="add-friend-pat-action" placeholder="ä¾‹å¦‚ï¼šæ‹äº†æ‹" maxlength="5">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-pat-content">æ‹ä¸€æ‹å†…å®¹ (é€‰å¡«)</label>
                            <input type="text" id="add-friend-pat-content" placeholder="ä¾‹å¦‚ï¼šçš„å¤´ï¼Œè¢«åå¼¹äº†" maxlength="20">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-background">èƒŒæ™¯èµ„æ–™ (é€‰å¡«)</label>
                            <textarea id="add-friend-background" placeholder="è§’è‰²çš„å…¶ä»–èµ„æ–™"></textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal(); 
                            this.showAddMenu(); 
                        }},
                        { text: 'æ·»åŠ ', class: 'btn-primary', handler: async () => {
                            const name = $('#add-friend-name').value.trim();
                            if (!name) { 
                                this.showAddMenu(); 
                                UIManager.showModal({
                                    title: "æç¤º",
                                    body: `<p>å¥½å‹çš„å§“åä¸èƒ½ä¸ºç©ºå“¦ã€‚</p>`,
                                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return; 
                            }
                            
                            
                            const existing = await DBHelper.getAll('contacts', 'name');
                            if (existing.some(c => c.name === name)) {
                                this.showAddMenu(); 
                                UIManager.showModal({
                                    title: "æç¤º",
                                    body: `<p>å§“å "${name}" å·²ç»è¢«å…¶ä»–å¥½å‹å ç”¨äº†ï¼Œæ¢ä¸€ä¸ªå§ã€‚</p>`,
                                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            const newContact = {
                                id: Utils.generateId('contact'),
                                createdAt: Date.now(),
                                name,
                                avatar: $('#add-friend-avatar-preview').src,
                                remark: $('#add-friend-remark').value.trim(),
                                gender: $('#add-friend-gender').value,
                                allowRetraction: $('#add-friend-allow-retraction').value === 'true',
                                allowEmoji: $('#add-friend-allow-emoji').value,
                                allowActiveReply: $('#add-friend-allow-active-reply').value === 'true',
                                likes: $('#add-friend-likes').value.trim(),
                                dislikes: $('#add-friend-dislikes').value.trim(),
                                habits: $('#add-friend-habits').value.trim(),
                                patAction: $('#add-friend-pat-action').value.trim(),
                                patContent: $('#add-friend-pat-content').value.trim(),
                                background: $('#add-friend-background').value.trim()
                            };
                            
                            await DBHelper.put('contacts', newContact);
                            UIManager.hideModal();
                            await UIManager.renderContactsPage();
                        }}
                    ]
                });

                $('#add-friend-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#add-friend-avatar-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },

            async showBuiltinCharacterSelection() {
                const existingContacts = await DBHelper.getAll('contacts');
                const existingNames = existingContacts.map(c => c.name);

                const charactersHtml = Object.entries(this.BUILTIN_CHARACTERS).map(([id, char]) => {
                    const isAdded = existingNames.includes(id);
                    return `
                        <label class="member-select-item" style="${isAdded ? 'opacity: 0.5; cursor: not-allowed;' : 'cursor: pointer;'}">
                            <input type="radio" name="builtin-char" value="${id}" ${isAdded ? 'disabled' : ''}>
                            <img src="${char.avatar}" class="contact-item-avatar" style="width:40px;height:40px;margin-right:10px;">
                            <div>
                                <span style="font-weight: bold;">${char.remark}</span>
                                <p style="font-size: 0.8rem; color: #888; margin: 2px 0 0 0;">${char.previewDesc || char.likes}</p>
                            </div>
                        </label>
                    `;
                }).join('');

                UIManager.showModal({
                    title: 'é€‰æ‹©å†…ç½®è§’è‰²',
                    body: `<div class="member-select-list" style="max-height: 40vh;">${charactersHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'æ·»åŠ ', class: 'btn-primary', handler: () => {
                            const selectedRadio = $('input[name="builtin-char"]:checked');
                            if (!selectedRadio) {
                                UIManager.showToast("è¯·é€‰æ‹©ä¸€ä¸ªè¦æ·»åŠ çš„è§’è‰²");
                                return;
                            }
                            this.addSpecificBuiltinCharacter(selectedRadio.value);
                        }}
                    ]
                });
            },

            async addSpecificBuiltinCharacter(characterId) {
                const charData = this.BUILTIN_CHARACTERS[characterId];
                if (!charData) {
                    UIManager.showToast("æœªæ‰¾åˆ°è¯¥å†…ç½®è§’è‰²");
                    return;
                }

                const existing = await DBHelper.getAll('contacts');
                if (existing.some(c => c.name === charData.id)) {
                    UIManager.showToast(`è§’è‰² "${charData.remark}" å·²å­˜åœ¨`);
                    UIManager.hideModal();
                    return;
                }

                const newContact = {
                    id: Utils.generateId('contact'),
                    createdAt: Date.now(),
                    name: charData.id,
                    remark: charData.remark,
                    avatar: charData.avatar,
                    gender: charData.gender,
                    likes: charData.likes,
                    dislikes: charData.dislikes,
                    habits: charData.habits,
                    background: charData.background
                };

                await DBHelper.put('contacts', newContact);
                UIManager.hideModal();
                await UIManager.renderContactsPage();
                UIManager.showToast(`å†…ç½®è§’è‰² â€œ${charData.remark}â€ å·²æ·»åŠ `);
            },

            async handleCreateGroup() {
                const friends = await DBHelper.getAll('contacts');
                const friendFolders = await DBHelper.getAll('friendFolders');

                if (friends.length === 0) {
                    this.showAddMenu();
                    UIManager.showModal({
                        title: "æç¤º",
                        body: `<p>é€šè®¯å½•ä¸­è¿˜æ²¡æœ‰å¥½å‹ï¼Œå¿«å»æ·»åŠ ä¸€äº›å¥½å‹å†æ¥åˆ›å»ºç¾¤èŠå§ï¼</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const myProfile = await DBHelper.get('profile', 'myProfile');
                const defaultAvatar = Utils.createAvatarDataUrl(Utils.getRandomColor());

                const folderMap = friendFolders.reduce((map, f) => {
                    map[f.id] = f.name;
                    return map;
                }, {});

                const membersHtml = friends.map(f => {
                    const folderName = f.folderId ? folderMap[f.folderId] || 'æœªçŸ¥åˆ†ç»„' : 'æœªåˆ†ç»„';
                    return `
                    <label class="member-select-item" data-friend-name="${(f.remark || f.name).toLowerCase()}" data-friend-id="${f.name.toLowerCase()}" data-folder-id="${f.folderId || ''}" data-folder-name="${folderName.toLowerCase()}">
                        <input type="checkbox" name="group-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>`;
                }).join('');

                const foldersHtml = friendFolders.map(folder => `
                    <label class="member-select-item">
                        <input type="radio" name="select-by-folder" value="${folder.id}">
                        <i class="fas fa-folder" style="margin-right: 10px; color: var(--text-color-medium);"></i>
                        <span>${folder.name} (${folder.memberIds.length}äºº)</span>
                    </label>
                `).join('');

                const creatorOptionsHtml = `<option value="${myProfile.id}">æˆ‘ (${myProfile.name})</option>` + friends.map(f =>
                    `<option value="${f.id}">${f.remark || f.name}</option>`
                ).join('');

                UIManager.showModal({
                    title: "æ–°å»ºç¾¤èŠ",
                    body: `
                        <div class="form-group"><label>ç¾¤å¤´åƒ (é€‰å¡«)</label><div class="avatar-uploader"><img src="${defaultAvatar}" id="create-group-avatar-preview" class="avatar-preview"><input type="file" id="create-group-avatar-input" accept="image/*" style="display:none;"><button class="upload-btn" onclick="document.getElementById('create-group-avatar-input').click()">ä¸Šä¼ å¤´åƒ</button></div></div>
                        <div class="form-group"><label for="create-group-name">ç¾¤åç§° (å¿…å¡«)</label><input type="text" id="create-group-name" placeholder="ä¸ºç¾¤èŠèµ·ä¸ªåå­—"></div>
                        <div class="form-group"><label for="create-group-creator">é€‰æ‹©ç¾¤ä¸» (å¿…å¡«)</label><select id="create-group-creator">${creatorOptionsHtml}</select></div>
                        
                        <div class="creation-mode-tabs">
                            <button class="mode-btn active" data-mode="friends">æŒ‰å¥½å‹é€‰æ‹©</button>
                            <button class="mode-btn" data-mode="folders">æŒ‰åˆ†ç»„é€‰æ‹©</button>
                        </div>

                        <div id="friends-panel" class="selection-panel">
                            <input type="text" id="group-creation-search" placeholder="æœç´¢å¥½å‹ (å¤‡æ³¨/ID/åˆ†ç»„)...">
                            <div class="member-select-list">${membersHtml}</div>
                        </div>
                        <div id="folders-panel" class="selection-panel hidden">
                            <div class="member-select-list">${foldersHtml}</div>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ›å»º', class: 'btn-primary', handler: async () => {
                            const name = $('#create-group-name').value.trim();
                            if (!name) return UIManager.showToast("ç¾¤èŠåç§°ä¸èƒ½ä¸ºç©º");
                            
                            const selectedMembers = [...$$('input[name="group-members"]:checked')].map(cb => cb.value);
                            if (selectedMembers.length < 1) return UIManager.showToast("è‡³å°‘éœ€è¦é€‰æ‹©ä¸€ä½å¥½å‹");
                            
                            const creatorId = $('#create-group-creator').value;
                            if (creatorId !== myProfile.id && !selectedMembers.includes(creatorId)) {
                                selectedMembers.push(creatorId);
                            }
                            
                            const newGroup = {
                                id: Utils.generateId('group-'), createdAt: Date.now(), name,
                                avatar: $('#create-group-avatar-preview').src,
                                members: selectedMembers, creatorId: creatorId
                            };
                            
                            await DBHelper.put('groups', newGroup);
                            
                            const invitedNames = (await Promise.all(newGroup.members.filter(id => id !== myProfile.id).map(id => DBHelper.get('contacts', id)))).map(c => c.name).join('ã€'); 
                            const creatorContact = creatorId === myProfile.id ? myProfile : await DBHelper.get('contacts', creatorId);
                            const creatorNameForScene = creatorContact ? creatorContact.name : "ä¸€ä½æœ‹å‹";
                            const defaultSceneContent = `${creatorNameForScene} åˆ›å»ºäº†ç¾¤èŠ â€œ${newGroup.name}â€ï¼Œç¾¤èŠæˆå‘˜æœ‰ï¼š${invitedNames}ã€‚ç°åœ¨ï¼Œå¤§å®¶å¼€å§‹ç§¯æå‘è¨€å§ï¼`;
                            await DBHelper.put('openingScenes', {id: Utils.generateId('scene'), groupId: newGroup.id, name: 'é»˜è®¤å¼€åœºç™½', content: defaultSceneContent});

                            UIManager.hideModal();
                            await UIManager.renderContactsPage('groups');
                        }}
                    ]
                });
                
                $('#create-group-avatar-input').onchange = async (e) => {
                    if (e.target.files[0]) $('#create-group-avatar-preview').src = await Utils.fileToBase64(e.target.files[0]);
                };

                
                const modeBtns = $$('.mode-btn');
                const friendsPanel = $('#friends-panel');
                const foldersPanel = $('#folders-panel');
                
                modeBtns.forEach(btn => {
                    btn.onclick = () => {
                        modeBtns.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const isFriendsMode = btn.dataset.mode === 'friends';
                        friendsPanel.classList.toggle('hidden', !isFriendsMode);
                        foldersPanel.classList.toggle('hidden', isFriendsMode);
                    };
                });

                $('#group-creation-search').oninput = (e) => {
                    const term = e.target.value.toLowerCase();
                    $$('#friends-panel .member-select-item').forEach(item => {
                        const name = item.dataset.friendName;
                        const id = item.dataset.friendId;
                        const folderName = item.dataset.folderName;
                        item.style.display = (name.includes(term) || id.includes(term) || folderName.includes(term)) ? 'flex' : 'none';
                    });
                };

                $$('input[name="select-by-folder"]').forEach(radio => {
                    radio.onchange = (e) => {
                        const selectedFolderId = e.target.value;
                        const folder = friendFolders.find(f => f.id === selectedFolderId);
                        if (folder) {
                            $$('input[name="group-members"]').forEach(cb => {
                                cb.checked = folder.memberIds.includes(cb.value);
                            });
                            
                            modeBtns.forEach(b => b.classList.toggle('active', b.dataset.mode === 'friends'));
                            friendsPanel.classList.remove('hidden');
                            foldersPanel.classList.add('hidden');
                        }
                    };
                });
            },
            
            async handleSortContacts() {
                appState.contactsSortOrder = appState.contactsSortOrder === 'asc' ? 'desc' : 'asc';
                await UIManager.renderContactsPage('friends');
            },
            
            async handleSortGroups() {
                appState.groupsSortOrder = appState.groupsSortOrder === 'asc' ? 'desc' : 'asc';
                await UIManager.renderContactsPage('groups');
            },
            
            async handleBatchDelete() {
                const activeTab = $('.tabs .tab-btn.active').dataset.tab;
                const actionBar = $('#selection-action-bar');
                const contactsPage = $('#page-contacts');
                
                if (activeTab === 'friends') {
                    appState.friendSelectionMode = !appState.friendSelectionMode;
                    appState.groupSelectionMode = false; 
                } else {
                    appState.groupSelectionMode = !appState.groupSelectionMode;
                    appState.friendSelectionMode = false; 
                }
                
                const isAnyModeActive = appState.friendSelectionMode || appState.groupSelectionMode;
                actionBar.style.display = isAnyModeActive ? 'flex' : 'none';
                contactsPage.classList.toggle('selection-mode', isAnyModeActive);
                
                await UIManager.renderContactsPage(activeTab);
            },

            handleSelectAll() {
                const activeTab = $('.tabs .tab-btn.active').dataset.tab;
                const listId = activeTab === 'friends' ? '#friends-list-ul' : '#groups-list-ul';
                const checkboxes = $$(`${listId} .contact-select-checkbox`);
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                checkboxes.forEach(cb => cb.checked = !allChecked);
            },
            
            async handleConfirmBatchDelete() {
                const activeTab = $('.tabs .tab-btn.active').dataset.tab;
                const listId = activeTab === 'friends' ? '#friends-list-ul' : '#groups-list-ul';
                const checkedItems = $$(`${listId} .contact-select-checkbox:checked`);
                
                if (checkedItems.length === 0) {
                    return UIManager.showToast("è¯·è‡³å°‘é€‰æ‹©ä¸€é¡¹");
                }
                
                const idsToDelete = Array.from(checkedItems).map(cb => cb.closest('.contact-item').dataset.id);

                if (activeTab === 'friends') {
                    const allGroups = await DBHelper.getAll('groups');
                    const problematicFriends = [];
                    for (const friendId of idsToDelete) {
                        const groupsIn = allGroups.filter(g => g.members.includes(friendId));
                        if (groupsIn.length > 0) {
                            const friend = await DBHelper.get('contacts', friendId);
                            problematicFriends.push({ name: friend.name, groups: groupsIn.map(g => g.name).join(', ') });
                        }
                    }

                    if (problematicFriends.length > 0) {
                        const errorMsg = problematicFriends.map(p => `<strong>${p.name}</strong> ä»åœ¨ç¾¤èŠ: ${p.groups}`).join('<br>');
                        return UIManager.showModal({
                            title: "æ— æ³•åˆ é™¤",
                            body: `<p>ä»¥ä¸‹å¥½å‹å› ä»åœ¨ç¾¤èŠä¸­è€Œæ— æ³•åˆ é™¤ï¼Œè¯·å…ˆå°†å…¶ç§»å‡ºç¾¤èŠï¼š</p><div style="text-align:left; max-height: 150px; overflow-y: auto; background: #f0f0f0; padding: 10px; border-radius: 8px;">${errorMsg}</div>`,
                            actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                        });
                    }
                }

                UIManager.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${idsToDelete.length} ä¸ª${activeTab === 'friends' ? 'å¥½å‹' : 'ç¾¤èŠ'}å—ï¼Ÿç›¸å…³èŠå¤©è®°å½•ä¹Ÿå°†è¢«æ°¸ä¹…åˆ é™¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            const storeName = activeTab === 'friends' ? 'contacts' : 'groups';
                            for (const id of idsToDelete) {
                                await DBHelper.delete(storeName, id);
                                await DBHelper.delete('chatMetadata', id);
                                await DBHelper.deleteMessagesForChat(id); 
                            }
                            UIManager.hideModal();
                            UIManager.showToast("åˆ é™¤æˆåŠŸ");
                            this.handleBatchDelete(); 
                            await UIManager.renderMessagesListPage(); 
                        }}
                    ]
                });
            },

            handleImportData() {
                const fileInput = $('#import-data-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            await this.processImportedFile(data);
                        } catch (error) {
                            console.error("å¯¼å…¥å¤±è´¥:", error);
                            UIManager.showToast("æ–‡ä»¶è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚");
                        } finally {
                            fileInput.value = ''; 
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            async processImportedFile(data) {
                if (data.type === 'contact' && data.contactData) {
                    const existingContacts = await DBHelper.getAll('contacts');
                    const conflict = existingContacts.find(c => c.name === data.contactData.name);
                    if (conflict) {
                        this.handleCharacterImportConflict(data, conflict);
                    } else {
                        const importedContact = data.contactData;
                        
                        const newContact = { ...importedContact, createdAt: Date.now() }; 
                        delete newContact.openingScenes; 

                        await DBHelper.put('contacts', newContact);
                        await this.importOpeningScenes(importedContact.openingScenes, newContact.id, false);
                        
                        if (data.chatHistory && data.participants) {
                            const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                            if (reconstructedHistory && reconstructedHistory.history) {
                                for (const message of reconstructedHistory.history) {
                                    message.chatId = newContact.id; 
                                    await DBHelper.put('messages', message);
                                }
                                
                                
                                const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                if (displayableHistory.length > 0) {
                                    const lastMessage = displayableHistory[displayableHistory.length - 1];
                                    const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                    await UIManager.updateChatMetadata(newContact.id, lastMessage, unreadCount);
                                }
                            }
                        }
                        
                        UIManager.showToast(`è§’è‰² "${newContact.name}" å¯¼å…¥æˆåŠŸï¼`);
                        if (newContact.author) {
                           EventManager.showAttributionModal(newContact);
                        }
                        await UIManager.renderContactsPage();
                        await UIManager.renderMessagesListPage(); 
                    }
                } else if (data.type === 'group' && data.groupData && data.memberData) {
                    const existingContacts = await DBHelper.getAll('contacts');
                    const conflictingMembers = data.memberData.filter(im => existingContacts.some(ec => ec.name === im.name));

                    if (conflictingMembers.length > 0) {
                        this.handleGroupImportConflict(data, conflictingMembers);
                    } else {
                        
                        for (const member of data.memberData) {
                            const newMember = { ...member, createdAt: Date.now() };
                            delete newMember.openingScenes;
                            await DBHelper.put('contacts', newMember);
                            await this.importOpeningScenes(member.openingScenes, member.id, false);
                        }
                        
                        
                        const importedGroup = data.groupData;
                        const existingGroup = await DBHelper.get('groups', importedGroup.id);
                        
                        const newGroup = {
                            ...importedGroup,
                            createdAt: Date.now()
                        };
                        
                        if(existingGroup) {
                            newGroup.id = Utils.generateId('group');
                        }
                        delete newGroup.openingScenes;

                        await DBHelper.put('groups', newGroup);
                        
                        
                        if (data.chatHistory && data.participants) {
                            const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                            if (reconstructedHistory && reconstructedHistory.history) {
                                for (const message of reconstructedHistory.history) {
                                    message.chatId = newGroup.id; 
                                    await DBHelper.put('messages', message);
                                }

                                
                                const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                if (displayableHistory.length > 0) {
                                    const lastMessage = displayableHistory[displayableHistory.length - 1];
                                    const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                    await UIManager.updateChatMetadata(newGroup.id, lastMessage, unreadCount);
                                }
                            }
                        }

                        await this.importOpeningScenes(importedGroup.openingScenes, newGroup.id, true);
                        UIManager.showToast(`ç¾¤èŠ "${newGroup.name}" åŠæ‰€æœ‰æˆå‘˜å¯¼å…¥æˆåŠŸï¼`);
                        if (newGroup.author) {
                            EventManager.showAttributionModal(newGroup);
                        }
                        await UIManager.renderContactsPage('groups');
                        await UIManager.renderMessagesListPage(); 
                    }
                } else {
                    UIManager.showToast("å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶ç±»å‹æœªçŸ¥æˆ–æ•°æ®ä¸å®Œæ•´ã€‚");
                }
            },

            handleCharacterImportConflict(data, existingContact) {
                const importedContact = data.contactData;
                UIManager.showModal({
                    title: "è§’è‰²å†²çª",
                    body: `<p>é€šè®¯å½•ä¸­å·²å­˜åœ¨åä¸º <strong>${existingContact.name}</strong> çš„è§’è‰²ã€‚<br><strong>æ›´æ–°</strong>ï¼šä¸æ¸…é™¤åŸæ¶ˆæ¯è®°å½•<br><strong>è¦†ç›–</strong>ï¼šæ¸…é™¤è¯¥è§’è‰²åŸæ¥çš„æ¶ˆæ¯è®°å½•<br>è¯·é€‰æ‹©æ“ä½œï¼š</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'æ›´æ–°è§’è‰²', class: 'btn-primary', handler: async () => {
                            const updatedContact = {
                                ...importedContact, 
                                id: existingContact.id, 
                                createdAt: existingContact.createdAt, 
                                
                                boundPersonaPresetId: existingContact.boundPersonaPresetId, 
                                boundCircleId: existingContact.boundCircleId,
                                folderId: existingContact.folderId
                            };
                            delete updatedContact.openingScenes; 
                            await DBHelper.put('contacts', updatedContact);
                            
                            const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existingContact.id);
                            for (const scene of oldScenes) {
                                await DBHelper.delete('openingScenes', scene.id);
                            }
                            await this.importOpeningScenes(importedContact.openingScenes, existingContact.id, false);

                            UIManager.hideModal();
                            UIManager.showToast(`è§’è‰² "${existingContact.name}" å·²æ›´æ–°ã€‚`);
                            if(updatedContact.author) EventManager.showAttributionModal(updatedContact);
                            await UIManager.renderContactsPage();
                        }},
                        { text: 'è¦†ç›–è§’è‰²', class: 'btn-danger', handler: async () => {
                            
                            await DBHelper.deleteMessagesForChat(existingContact.id); 
                            await DBHelper.delete('chatMetadata', existingContact.id); 
                            const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existingContact.id);
                            for (const scene of oldScenes) {
                                await DBHelper.delete('openingScenes', scene.id);
                            }
                            await DBHelper.delete('contacts', existingContact.id);

                            
                            const newContact = { ...importedContact, id: importedContact.id, createdAt: Date.now() };
                            delete newContact.openingScenes;
                            await DBHelper.put('contacts', newContact);
                            
                            
                            if (data.chatHistory && data.participants) {
                                const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                                if (reconstructedHistory && reconstructedHistory.history) {
                                    for (const message of reconstructedHistory.history) {
                                        message.chatId = newContact.id; 
                                        await DBHelper.put('messages', message);
                                    }
                                    
                                    const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                    if (displayableHistory.length > 0) {
                                        const lastMessage = displayableHistory[displayableHistory.length - 1];
                                        const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                        await UIManager.updateChatMetadata(newContact.id, lastMessage, unreadCount);
                                    }
                                }
                            }

                            await this.importOpeningScenes(importedContact.openingScenes, newContact.id, false);

                            UIManager.hideModal();
                            UIManager.showToast(`è§’è‰² "${newContact.name}" å·²è¢«è¦†ç›–ã€‚`);
                            if(newContact.author) EventManager.showAttributionModal(newContact);
                            await UIManager.renderContactsPage();
                            await UIManager.renderMessagesListPage(); 
                        }}
                    ]
                });
            },

            handleGroupImportConflict(data, conflictingMembers) {
                const importedGroup = data.groupData;
                const importedMembers = data.memberData;
                const conflictNames = conflictingMembers.map(m => m.name).join('ã€');
                UIManager.showModal({
                    title: "ç¾¤èŠæˆå‘˜å†²çª",
                    body: `<p>åœ¨å¯¼å…¥ç¾¤èŠ <strong>${importedGroup.name}</strong> æ—¶ï¼Œå‘ç°ä»¥ä¸‹æˆå‘˜å·²å­˜åœ¨äºä½ çš„é€šè®¯å½•ä¸­ï¼š<br><strong>${conflictNames}</strong><br>è¯·é€‰æ‹©å¦‚ä½•å¤„ç†è¿™äº›å†²çªçš„è§’è‰²ã€‚<br><strong>æ›´æ–°</strong>ï¼šä¸æ¸…é™¤åŸæ¶ˆæ¯è®°å½•<br><strong>è¦†ç›–</strong>ï¼šæ¸…é™¤è¯¥è§’è‰²åŸæ¥çš„æ¶ˆæ¯è®°å½•</p>`,
                    actions: [
                        { text: 'å–æ¶ˆå¯¼å…¥', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å…¨éƒ¨æ›´æ–°', class: 'btn-primary', handler: async () => {
                            const existingContacts = await DBHelper.getAll('contacts');
                            const memberIdMap = {};
                            for (const member of importedMembers) {
                                const existing = existingContacts.find(c => c.name === member.name);
                                let finalMember;
                                if (existing) {
                                    finalMember = { ...existing, ...member, id: existing.id };
                                    delete finalMember.openingScenes;
                                    await DBHelper.put('contacts', finalMember);
                                    const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existing.id);
                                    for (const scene of oldScenes) await DBHelper.delete('openingScenes', scene.id);
                                    await this.importOpeningScenes(member.openingScenes, existing.id, false);
                                } else {
                                    finalMember = { ...member, id: Utils.generateId('contact'), createdAt: Date.now() };
                                    delete finalMember.openingScenes;
                                    await DBHelper.put('contacts', finalMember);
                                    await this.importOpeningScenes(member.openingScenes, finalMember.id, false);
                                }
                                memberIdMap[member.id] = finalMember.id;
                            }
                            
                            const newMemberIds = importedGroup.members.map(oldId => memberIdMap[oldId]).filter(Boolean);
                            const newCreatorId = memberIdMap[importedGroup.creatorId] || importedGroup.creatorId;
                            const newGroup = { ...importedGroup, id: Utils.generateId('group-'), createdAt: Date.now(), members: newMemberIds, creatorId: newCreatorId };
                            delete newGroup.openingScenes;

                            await DBHelper.put('groups', newGroup);
                            await this.importOpeningScenes(importedGroup.openingScenes, newGroup.id, true);
                            UIManager.hideModal();
                            UIManager.showToast(`ç¾¤èŠ "${importedGroup.name}" å¯¼å…¥æˆåŠŸï¼Œå†²çªæˆå‘˜å·²æ›´æ–°ã€‚`);
                            if (importedGroup.author) EventManager.showAttributionModal(importedGroup);
                            await UIManager.renderContactsPage('groups');
                        }},
                        { text: 'å…¨éƒ¨è¦†ç›–', class: 'btn-danger', handler: async () => {
                            const existingContacts = await DBHelper.getAll('contacts');
                            const existingGroups = await DBHelper.getAll('groups');
                            
                            
                            const oldGroup = existingGroups.find(g => g.name === importedGroup.name);
                            if (oldGroup) {
                                await DBHelper.deleteMessagesForChat(oldGroup.id); 
                                await DBHelper.deleteMessagesForChat(oldGroup.id); 
                                await DBHelper.delete('chats', oldGroup.id);
                                await DBHelper.delete('chatMetadata', oldGroup.id);
                                await DBHelper.delete('groups', oldGroup.id);
                            }

                            
                            for (const member of importedMembers) {
                                const existing = existingContacts.find(c => c.name === member.name);
                                if (existing) {
                                    await DBHelper.delete('chats', existing.id);
                                    await DBHelper.delete('chatMetadata', existing.id); 
                                    const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existing.id);
                                    for (const scene of oldScenes) await DBHelper.delete('openingScenes', scene.id);
                                    await DBHelper.delete('contacts', existing.id);
                                }
                            }
                            
                            
                            for (const member of importedMembers) {
                                const newMember = { ...member, createdAt: Date.now() };
                                delete newMember.openingScenes;
                                await DBHelper.put('contacts', newMember);
                                await this.importOpeningScenes(member.openingScenes, member.id, false);
                            }
                            
                            
                            const groupToImport = { ...importedGroup, createdAt: Date.now() };
                            const groupWithSameIdExists = await DBHelper.get('groups', groupToImport.id);
                            if (groupWithSameIdExists) {
                                groupToImport.id = Utils.generateId('group');
                            }
                            delete groupToImport.openingScenes;

                            await DBHelper.put('groups', groupToImport);
                            
                            
                            if (data.chatHistory && data.participants) {
                                const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                                if (reconstructedHistory && reconstructedHistory.history) {
                                    for (const message of reconstructedHistory.history) {
                                        message.chatId = groupToImport.id; 
                                        await DBHelper.put('messages', message);
                                    }
                                    
                                    const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                    if (displayableHistory.length > 0) {
                                        const lastMessage = displayableHistory[displayableHistory.length - 1];
                                        const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                        await UIManager.updateChatMetadata(groupToImport.id, lastMessage, unreadCount);
                                    }
                                }
                            }

                            await this.importOpeningScenes(importedGroup.openingScenes, groupToImport.id, true);
                            UIManager.hideModal();
                            UIManager.showToast(`ç¾¤èŠ "${importedGroup.name}" å¯¼å…¥æˆåŠŸï¼Œå†²çªæˆå‘˜å·²è¢«è¦†ç›–ã€‚`);
                            if (importedGroup.author) EventManager.showAttributionModal(importedGroup);
                            await UIManager.renderContactsPage('groups');
                            await UIManager.renderMessagesListPage(); 
                        }}
                    ]
                });
            },


            showAttributionModal(entity) {
                UIManager.showModal({
                    title: "ä½œè€…ä¿¡æ¯",
                    body: `
                        <div class="details-card">
                            <div class="details-field">
                                <span class="label">æ¥æºäº</span>
                                <span class="value">${entity.author}</span>
                            </div>
                            <div class="details-section" style="margin-top: 15px;">
                                <div class="details-section-title">ä½œè€…æœ‰è¯è¯´</div>
                                <p>${entity.authorWords || 'ä½œè€…å¾ˆæ‡’ï¼Œä»€ä¹ˆéƒ½æ²¡ç•™ä¸‹...'}</p>
                            </div>
                        </div>
                    `,
                    actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async generateExportFile(entity, isGroup, authorName, authorWords, historyOption) {
                UIManager.showModal({
                    title: 'æ­£åœ¨ç”Ÿæˆæ–‡ä»¶...',
                    body: '<div style="text-align:center; padding: 20px;"><div class="loader-spinner" style="width: 30px; height: 30px; border-width: 3px; display: inline-block;"></div><p style="margin-top: 15px;">è¯·ç¨å€™ï¼Œæ•°æ®æ­£åœ¨å¤„ç†ä¸­...</p></div>',
                    actions: []
                });

                await new Promise(resolve => setTimeout(resolve, 100)); 

                let exportData;
                let chatId;
                const targetEntity = isGroup ? entity.groupData : entity;

                targetEntity.author = authorName;
                targetEntity.authorWords = authorWords;
                
                if (isGroup) {
                    exportData = { type: 'group', ...entity };
                    chatId = targetEntity.id;
                } else {
                    exportData = { type: 'contact', contactData: targetEntity };
                    chatId = targetEntity.id;
                }

                if (historyOption !== 'none') {
                    const allMessages = await DBHelper.getMessages(chatId, Number.MAX_SAFE_INTEGER);
                    let messagesToExport = [];

                    if (historyOption === 'all') {
                        messagesToExport = allMessages;
                    } else {
                        const messageCount = parseInt(historyOption, 10);
                        if (!isNaN(messageCount) && messageCount > 0) {
                            messagesToExport = allMessages.slice(-messageCount);
                        }
                    }

                    if (messagesToExport.length > 0) {
                        const allContacts = await DBHelper.getAll('contacts');
                        const myProfile = await this.getPlayerProfileForContext(chatId);
                        
                        const chatHistory = { history: messagesToExport };
                        const participants = {};

                        for (const msg of chatHistory.history) {
                            if (msg.senderId && msg.senderId !== myProfile.id && !participants[msg.senderId]) {
                                const senderInfo = allContacts.find(c => c.id === msg.senderId);
                                if (senderInfo) {
                                    participants[msg.senderId] = senderInfo;
                                }
                            }
                            delete msg.senderInfo; 
                        }

                        exportData.chatHistory = chatHistory;
                        exportData.participants = Object.values(participants);
                    }
                }

                const filename = `${targetEntity.name}_${new Date().toISOString().slice(0, 10)}.json`;
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                UIManager.showModal({
                    title: 'æ–‡ä»¶å·²ç”Ÿæˆ',
                    body: `
                        <p>è¯·ç‚¹å‡»ä¸‹é¢çš„é“¾æ¥ä¸‹è½½æ–‡ä»¶ã€‚</p>
                        <a href="${url}" download="${filename}" class="modal-btn btn-primary" style="display: block; text-align: center; margin-top: 20px;">
                            ç‚¹å‡»ä¸‹è½½ ${filename}
                        </a>
                        <p style="font-size: 0.8rem; color: #aaa; text-align: center; margin-top: 15px;">(ä¸‹è½½åæ­¤é“¾æ¥å°†å¤±æ•ˆ)</p>
                    `,
                    actions: [{
                        text: 'å…³é—­',
                        class: 'btn-secondary',
                        handler: () => {
                            URL.revokeObjectURL(url); 
                            UIManager.hideModal();
                        }
                    }]
                });
            },

            async reconstructChatHistory(chatHistory, participants) {
                if (!chatHistory || !chatHistory.history || !participants) {
                    return chatHistory;
                }

                const participantMap = participants.reduce((map, p) => {
                    if(p) map[p.id] = p; 
                    return map;
                }, {});
                
                let lastTimestamp = 0;
                
                
                chatHistory.history.sort((a, b) => a.timestamp - b.timestamp);

                chatHistory.history.forEach(msg => {
                    if (msg.senderId && participantMap[msg.senderId]) {
                        
                        
                    }
                    
                    if (msg.timestamp <= lastTimestamp) {
                        
                        msg.timestamp = lastTimestamp + 1;
                    }
                    
                    lastTimestamp = msg.timestamp;
                });

                return chatHistory;
            },

            async handleExportContact(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                const allOpeningScenes = await DBHelper.getAll('openingScenes');
                contact.openingScenes = allOpeningScenes.filter(s => s.contactId === contactId);
                this.showExportModal(contact, false);
            },

            async handleExportGroup(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                const membersData = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                const allOpeningScenes = await DBHelper.getAll('openingScenes');
                group.openingScenes = allOpeningScenes.filter(s => s.groupId === groupId);
                
                const exportPackage = {
                    groupData: group,
                    memberData: membersData
                };
                this.showExportModal(exportPackage, true);
            },

            async showExportModal(entity, isGroup) {
                const myProfile = { name: 'ä½ ' };
                const targetEntity = isGroup ? entity.groupData : entity;
                const chatId = targetEntity.id;

                const authorName = targetEntity.author || myProfile.name;
                const authorWords = targetEntity.authorWords || '';
                const isAuthorFixed = !!targetEntity.author;

                
                UIManager.showModal({
                    title: `å¯¼å‡º${isGroup ? 'ç¾¤èŠ' : 'è§’è‰²'}`,
                    body: `
                        <style>
                            .export-history-options {
                                display: none;
                                background-color: rgba(0,0,0,0.03);
                                border-radius: 8px;
                                padding: 15px;
                                margin-top: 15px;
                            }
                            .export-history-options label {
                                display: block;
                                margin-bottom: 12px;
                                cursor: pointer;
                            }
                            #history-count-placeholder .fa-spinner {
                                font-size: 0.9em;
                                color: var(--text-color-light);
                            }
                            #custom-history-count {
                                width: 70px;
                                text-align: center;
                                margin: 0 8px;
                                padding: 4px 8px;
                                border-radius: 6px;
                                border: 1px solid var(--border-color);
                            }
                        </style>
                        <div class="form-group">
                            <label for="export-author-name">ä½œè€…å</label>
                            <input type="text" id="export-author-name" value="${authorName}" ${isAuthorFixed ? 'disabled' : ''}>
                        </div>
                        <div class="form-group">
                            <label for="export-author-words">ä½œè€…æœ‰è¯è¯´ (é€‰å¡«)</label>
                            <textarea id="export-author-words" rows="3">${authorWords}</textarea>
                        </div>
                        <div class="form-group" style="display: flex; align-items: center; justify-content: center; padding-top: 10px;">
                            <input type="checkbox" id="export-chat-history-checkbox" style="width: 16px; height: 16px; margin-right: 8px;">
                            <label for="export-chat-history-checkbox" id="export-history-label" style="margin: 0; cursor: pointer;">
                                åŒæ—¶å¯¼å‡ºèŠå¤©è®°å½• <span id="history-count-placeholder">(<i class="fas fa-spinner fa-spin"></i> æ­£åœ¨è®¡ç®—...)</span>
                            </label>
                        </div>
                        <div id="export-history-options-container" class="export-history-options">
                            <label><input type="radio" name="history-export-option" value="100"> å¯¼å‡ºæœ€è¿‘100æ¡</label>
                            <label><input type="radio" name="history-export-option" value="300"> å¯¼å‡ºæœ€è¿‘300æ¡</label>
                            <label style="display: flex; align-items: center;">
                                <input type="radio" name="history-export-option" value="custom"> å¯¼å‡ºæœ€è¿‘
                                <input type="number" id="custom-history-count" min="1" step="1"> æ¡
                            </label>
                            <label><input type="radio" name="history-export-option" value="all" checked> å¯¼å‡ºå…¨éƒ¨èŠå¤©è®°å½• (å¯èƒ½å¡é¡¿)</label>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç”Ÿæˆæ–‡ä»¶', class: 'btn-primary', handler: () => {
                            const newAuthorName = $('#export-author-name').value.trim();
                            const newAuthorWords = $('#export-author-words').value.trim();
                            const includeHistory = $('#export-chat-history-checkbox').checked;
                            
                            let historyOption = 'none';
                            if (includeHistory) {
                                const selectedOption = $('input[name="history-export-option"]:checked');
                                if (selectedOption) {
                                    if (selectedOption.value === 'custom') {
                                        const customCount = $('#custom-history-count').value;
                                        historyOption = customCount ? parseInt(customCount, 10).toString() : '0';
                                    } else {
                                        historyOption = selectedOption.value;
                                    }
                                }
                            }
                            
                            this.generateExportFile(entity, isGroup, newAuthorName, newAuthorWords, historyOption);
                        }}
                    ]
                });

                
                const checkbox = $('#export-chat-history-checkbox');
                const optionsContainer = $('#export-history-options-container');
                checkbox.addEventListener('change', () => {
                    optionsContainer.style.display = checkbox.checked ? 'block' : 'none';
                });
                
                
                (async () => {
                    const messageCount = await DBHelper.getChatMessagesCount(chatId);
                    const countPlaceholder = $('#history-count-placeholder');
                    if(countPlaceholder) {
                        countPlaceholder.textContent = `(${messageCount} æ¡)`;
                    }
                })();
            },

            handleResetApp() {
                UIManager.showModal({
                    title: 'ç¡®è®¤é‡ç½®',
                    body: `<p>æ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰æ•°æ®ï¼ŒåŒ…æ‹¬ä½ çš„ä¸ªäººä¿¡æ¯ã€è”ç³»äººã€ç¾¤èŠã€èŠå¤©è®°å½•å’ŒAPIé…ç½®ï¼Œä¸”æ— æ³•æ¢å¤ã€‚ä½ ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤é‡ç½®', class: 'btn-danger', handler: () => {
                            indexedDB.deleteDatabase(DBHelper.DB_NAME);
                            UIManager.hideModal();
                            UIManager.showModal({
                                title: "æ“ä½œæˆåŠŸ",
                                body: `<p>åº”ç”¨å·²é‡ç½®ï¼Œæ‰€æœ‰æ•°æ®å·²è¢«æ¸…é™¤ã€‚é¡µé¢å³å°†åˆ·æ–°...</p><p>å¦‚æœæ²¡æœ‰ååº”ï¼Œè¯·æ‰‹åŠ¨åˆ·æ–°ã€‚</p>`,
                                actions: [{ text: 'ç«‹å³åˆ·æ–°', class: 'btn-primary', handler: () => window.location.reload() }]
                            });
                            setTimeout(() => window.location.reload(), 3000); 
                        }}
                    ]
                });
            },

            showDataManagementModal() {
                UIManager.showModal({
                    title: "æ•°æ®ç®¡ç†",
                    body: `
                        <p style="text-align: center; margin-bottom: 20px;">è¯·é€‰æ‹©è¦è¿›è¡Œçš„æ“ä½œã€‚</p>
                        <div class="details-actions" style="flex-direction: column; gap: 15px;">
                            <button class="details-btn" id="export-all-data-btn" style="border-color: var(--accent-color); color: var(--accent-color-deep);">
                                <i class="fas fa-upload" style="margin-right: 8px;"></i>å¯¼å‡ºå…¨éƒ¨æ•°æ®
                            </button>
                            <button class="details-btn" id="import-all-data-btn" style="border-color: var(--theme-color-2);">
                                <i class="fas fa-download" style="margin-right: 8px;"></i>å¯¼å…¥æ•°æ® (å°†è¦†ç›–ç°æœ‰æ•°æ®)
                            </button>
                        </div>
                    `,
                    actions: [{ text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });

                $('#export-all-data-btn').addEventListener('click', () => this.handleExportAllData());
                $('#import-all-data-btn').addEventListener('click', () => this.handleImportAllData());
            },
            
            async handleExportAllData() {
                UIManager.showModal({
                    title: "é€‰æ‹©å¯¼å‡ºå†…å®¹",
                    body: `
                        <p style="margin-bottom: 15px;">è¯·å‹¾é€‰éœ€è¦å¯¼å‡ºçš„æ•°æ®éƒ¨åˆ†ã€‚èŠå¤©è®°å½•æ•°æ®é‡è¾ƒå¤§ï¼Œå¯¼å‡ºå¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´ã€‚</p>
                        <div class="member-select-list" style="max-height: 50vh;">
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="characters" checked> è§’è‰²ä¸ç¾¤èŠæ•°æ®</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="player" checked> ç©å®¶æ•°æ® (äººè®¾é¢„è®¾ç­‰)</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="emojis" checked> è‡ªå®šä¹‰è¡¨æƒ…åŒ…</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="moments" checked> æœ‹å‹åœˆæ•°æ®</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="theme" checked> ä¸»é¢˜ä¸å­—ä½“è®¾ç½®</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="others" checked> å…¶ä»– (æç¤ºè¯ã€è¡¨æƒ…åŒ…ã€ç¤¼ç‰©é…ç½®ç­‰)</label>
                            <label class="member-select-item"><input type="checkbox" name="export-parts" value="history"> èŠå¤©è®°å½• (ä»…ä¿ç•™ä¼šè¯æœ€æ–°200æ¡)</label>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å¼€å§‹å¯¼å‡º', class: 'btn-primary', handler: () => {
                            const selectedParts = [...$$('input[name="export-parts"]:checked')].map(cb => cb.value);
                            if (selectedParts.length === 0) return UIManager.showToast("è¯·è‡³å°‘é€‰æ‹©ä¸€é¡¹å¯¼å‡ºå†…å®¹");
                            this.executeExport(selectedParts);
                        }}
                    ]
                });
            },
            
            async executeExport(partsToExport) {
                let exportState = { isCancelled: false };

                UIManager.showModal({
                    isPersistent: true,
                    title: "æ­£åœ¨å¯¼å‡ºæ•°æ®...",
                    body: `
                        <style>
                            .progress-bar-container { width: 100%; background-color: #eee; border-radius: 10px; overflow: hidden; margin: 10px 0; }
                            .progress-bar { width: 0%; height: 20px; background-color: var(--accent-color); transition: width 0.3s ease; text-align: center; color: white; line-height: 20px; font-size: 0.8rem; }
                        </style>
                        <div id="export-progress-text" style="text-align: center; margin-bottom: 10px; color: var(--text-color-medium);">æ­£åœ¨åˆå§‹åŒ–...</div>
                        <div class="progress-bar-container"><div id="export-progress-bar" class="progress-bar">0%</div></div>
                    `,
                    actions: [{ text: 'å–æ¶ˆ', class: 'btn-danger', handler: () => { exportState.isCancelled = true; } }]
                });

                const updateProgress = (text, percentage) => {
                    if (exportState.isCancelled) throw new Error("Export cancelled by user.");
                    const progressText = $('#export-progress-text');
                    const progressBar = $('#export-progress-bar');
                    if(progressText) progressText.textContent = text;
                    if(progressBar) {
                        progressBar.style.width = `${percentage}%`;
                        progressBar.textContent = `${Math.round(percentage)}%`;
                    }
                };

                try {
                    const jsonParts = [];
                    jsonParts.push('{"version":"1.0.0","createdAt":"' + new Date().toISOString() + '","data":{');
                    let isFirstDataPart = true;

                    const appendDataPart = (key, data) => {
                        if (exportState.isCancelled) throw new Error("Export cancelled by user.");
                        if (!isFirstDataPart) {
                            jsonParts.push(',');
                        }
                        jsonParts.push(`"${key}":${JSON.stringify(data, null, 2)}`);
                        isFirstDataPart = false;
                    };

                    const processSimplePart = async (partName, progressStart, progressEnd, taskName, getDataFunc) => {
                         if (partsToExport.includes(partName)) {
                            updateProgress(`æ­£åœ¨è¯»å– ${taskName}...`, progressStart);
                            const data = await getDataFunc();
                            appendDataPart(partName, data);
                        }
                        updateProgress(`å¤„ç†å®Œæˆ: ${taskName}`, progressEnd);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    };

                    if (partsToExport.includes('characters')) {
                        updateProgress("æ­£åœ¨è¯»å–è§’è‰²ä¸ç¾¤èŠæ•°æ®...", 0);
                        appendDataPart('contacts', await DBHelper.getAll('contacts'));
                        appendDataPart('groups', await DBHelper.getAll('groups'));
                        appendDataPart('friendFolders', await DBHelper.getAll('friendFolders'));
                        updateProgress("å¤„ç†å®Œæˆ: è§’è‰²ä¸ç¾¤èŠæ•°æ®", 10);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    if (partsToExport.includes('player') || partsToExport.includes('emojis')) {
                        updateProgress("æ­£åœ¨è¯»å–ç©å®¶æ•°æ®...", 10);
                        const fullProfile = await DBHelper.get('profile', 'myProfile');
                        if (fullProfile) {
                            
                            const profileToExport = {
                                id: fullProfile.id,
                                name: fullProfile.name,
                                gender: fullProfile.gender,
                                avatar: fullProfile.avatar,
                                background: fullProfile.background,
                                patAction: fullProfile.patAction,
                                patContent: fullProfile.patContent,
                                favoriteEmojis: fullProfile.favoriteEmojis,
                                
                            };

                            if (partsToExport.includes('player')) {
                                profileToExport.presets = fullProfile.presets || [];
                            }

                            if (partsToExport.includes('emojis')) {
                                profileToExport.customEmojis = fullProfile.customEmojis || {};
                            }

                            appendDataPart('profile', profileToExport);
                        }
                        updateProgress("å¤„ç†å®Œæˆ: ç©å®¶æ•°æ®", 25);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }


                    if (partsToExport.includes('moments')) {
                        updateProgress("æ­£åœ¨è¯»å–æœ‹å‹åœˆæ•°æ®...", 20);
                        appendDataPart('circles', await DBHelper.getAll('circles'));
                        appendDataPart('moments', await DBHelper.getAll('moments'));
                        updateProgress("å¤„ç†å®Œæˆ: æœ‹å‹åœˆæ•°æ®", 30);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    await processSimplePart('themeSettings', 30, 40, "ä¸»é¢˜è®¾ç½®", () => DBHelper.get('apiConfig', 'themeSettings'));
                    
                    if (partsToExport.includes('others')) {
                        updateProgress("æ­£åœ¨è¯»å–å…¶ä»–é…ç½®...", 40);
                        appendDataPart('prompts', await DBHelper.getAll('prompts'));
                        appendDataPart('promptFolders', await DBHelper.getAll('promptFolders'));
                        appendDataPart('openingScenes', await DBHelper.getAll('openingScenes'));
                        const giftConfig = await DBHelper.get('giftApiConfig', 'mainConfig');
                        if (giftConfig) {
                            delete giftConfig.key;
                            appendDataPart('giftApiConfig', giftConfig);
                        }
                        const apiConfig = await DBHelper.get('apiConfig', 'mainConfig');
                        if (apiConfig) {
                            
                            delete apiConfig.keys;
                            appendDataPart('apiConfig', apiConfig);
                        }
                        updateProgress("å¤„ç†å®Œæˆ: å…¶ä»–é…ç½®", 50);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    const processStoreWithCursor = (storeName, progressStart, progressEnd) => {
                        return new Promise((resolve, reject) => {
                            if (!partsToExport.includes('history')) return resolve();

                            updateProgress(`æ­£åœ¨æ‰“åŒ… ${storeName}... (è¿™å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´)`, progressStart);
                            if (!isFirstDataPart) jsonParts.push(',');
                            jsonParts.push(`"${storeName}":[`);

                            const transaction = DBHelper.db.transaction([storeName], 'readonly');
                            const store = transaction.objectStore(storeName);
                            let isFirstItem = true;
                            let count = 0;

                            store.openCursor().onsuccess = (e) => {
                                if (exportState.isCancelled) {
                                    transaction.abort();
                                    return reject(new Error("Export cancelled by user."));
                                }
                                const cursor = e.target.result;
                                if (cursor) {
                                    if (!isFirstItem) jsonParts.push(',');
                                    jsonParts.push(JSON.stringify(cursor.value));
                                    isFirstItem = false;
                                    count++;
                                    if(count % 1000 === 0) { 
                                        updateProgress(`æ­£åœ¨æ‰“åŒ… ${storeName}: ${count}æ¡...`, progressStart);
                                    }
                                    cursor.continue();
                                } else {
                                    jsonParts.push(']');
                                    isFirstDataPart = false;
                                    updateProgress(`å¤„ç†å®Œæˆ: ${storeName}`, progressEnd);
                                    resolve();
                                }
                            };
                            transaction.onerror = (e) => reject(new Error(`è¯»å– ${storeName} å¤±è´¥: ${e.target.error}`));
                        });
                    };

                    if (partsToExport.includes('history')) {
                        updateProgress(`æ­£åœ¨å‡†å¤‡å¯¼å‡ºèŠå¤©è®°å½•...`, 50);
                        const allMetadata = await DBHelper.getAll('chatMetadata');
                        const allChatIds = allMetadata.map(meta => meta.chatId);
                        let allMessagesForExport = [];
                        let processedChats = 0;

                        for (const chatId of allChatIds) {
                            if (exportState.isCancelled) throw new Error("Export cancelled by user.");
                            
                            const messages = await DBHelper.getMessages(chatId, 200);
                            allMessagesForExport.push(...messages);

                            processedChats++;
                            const progress = 50 + (processedChats / allChatIds.length) * 40;
                            updateProgress(`æ­£åœ¨æ‰“åŒ…èŠå¤©è®°å½• (${processedChats}/${allChatIds.length})...`, progress);
                        }
                        
                        updateProgress(`æ­£åœ¨æ¸…ç†æ•°æ®...`, 91);
                        allMessagesForExport.forEach(msg => {
                            if (msg.senderInfo) {
                                delete msg.senderInfo;
                            }
                        });
                        
                        appendDataPart('messages', allMessagesForExport);
                        updateProgress("å¤„ç†å®Œæˆ: èŠå¤©è®°å½•", 95);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    await processStoreWithCursor('chatMetadata', 95, 98);

                    updateProgress("æ­£åœ¨ç”Ÿæˆæ–‡ä»¶...", 98);
                    jsonParts.push('}}');

                    const blob = new Blob(jsonParts, { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const filename = `33èŠå¤©å®¤_å¤‡ä»½_${new Date().toISOString().slice(0, 10)}.json`;

                    UIManager.showModal({
                        title: 'å¯¼å‡ºæˆåŠŸ',
                        body: `<a href="${url}" download="${filename}" class="modal-btn btn-primary" style="display: block; text-align: center;">ç‚¹å‡»ä¸‹è½½å¤‡ä»½æ–‡ä»¶</a>`,
                        actions: [{ text: 'å…³é—­', class: 'btn-secondary', handler: () => { URL.revokeObjectURL(url); UIManager.hideModal(); } }]
                    });

                } catch (error) {
                    if (error.message.includes("cancelled")) {
                        UIManager.hideModal();
                        UIManager.showToast("å¯¼å‡ºå·²å–æ¶ˆ");
                    } else {
                        console.error("Export failed:", error);
                        UIManager.showModal({
                            title: 'å¯¼å‡ºå¤±è´¥',
                            body: `<p>å¯¼å‡ºè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${error.message}</p>`,
                            actions: [{ text: 'å…³é—­', class: 'btn-danger', handler: () => UIManager.hideModal() }]
                        });
                    }
                }
            },

            handleImportAllData() {
                const fileInput = $('#import-data-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            if (!data.version || !data.data) {
                                throw new Error("æ–‡ä»¶æ ¼å¼æ— æ•ˆæˆ–å·²æŸåã€‚");
                            }
                            this.confirmAndExecuteImport(data.data);
                        } catch (error) {
                             UIManager.showModal({
                                title: "å¯¼å…¥å¤±è´¥",
                                body: `<p>æ–‡ä»¶è§£æå¤±è´¥ï¼Œè¯·ç¡®ä¿ä½ é€‰æ‹©çš„æ˜¯æ­£ç¡®çš„å¤‡ä»½æ–‡ä»¶ã€‚<br>é”™è¯¯: ${error.message}</p>`,
                                actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                            });
                        } finally {
                            fileInput.value = '';
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            confirmAndExecuteImport(dataToImport) {
                UIManager.showModal({
                    title: "é‡è¦æç¤º",
                    body: `<p style="color: #e74c3c; font-weight: bold;">æ­¤æ“ä½œå°†å½»åº•æ¸…é™¤å½“å‰åº”ç”¨çš„æ‰€æœ‰æ•°æ®ï¼Œå¹¶ç”¨å¤‡ä»½æ–‡ä»¶ä¸­çš„æ•°æ®æ›¿æ¢ã€‚æ­¤è¿‡ç¨‹ä¸å¯é€†ï¼</p><p>ä½ ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p>`,
                    actions: [
                        { text: 'æˆ‘å†æƒ³æƒ³', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤å¯¼å…¥', class: 'btn-danger', handler: async () => {
                            UIManager.showModal({
                                isPersistent: true,
                                title: "æ­£åœ¨å¯¼å…¥æ•°æ®...",
                                body: `<div style="text-align: center;"><div class="loader-spinner" style="width: 30px; height: 30px; display: inline-block;"></div><p>è¯·ä¸è¦å…³é—­æˆ–åˆ·æ–°é¡µé¢ã€‚</p></div>`,
                                actions: []
                            });

                            try {
                                
                                if (DBHelper.db) {
                                    DBHelper.db.close();
                                    DBHelper.db = null;
                                }

                                
                                await new Promise((resolve, reject) => {
                                    const deleteRequest = indexedDB.deleteDatabase(DBHelper.DB_NAME);
                                    deleteRequest.onsuccess = () => resolve();
                                    deleteRequest.onerror = (e) => reject(`åˆ é™¤æ—§æ•°æ®åº“å¤±è´¥: ${e.target.error}`);
                                    deleteRequest.onblocked = () => {
                                        reject("æ•°æ®åº“åˆ é™¤è¢«é˜»æ­¢ï¼Œè¯·å…³é—­å…¶ä»–æ‰€æœ‰æ‰“å¼€æ­¤åº”ç”¨çš„æ ‡ç­¾é¡µåé‡è¯•ã€‚");
                                    };
                                });
                                
                                
                                await DBHelper.init();

                                
                                if (dataToImport.profile) {
                                    
                                    dataToImport.profile.id = 'myProfile';
                                    await DBHelper.put('profile', dataToImport.profile);
                                }
                                

                                const storesToImport = [
                                    'contacts', 'groups', 'friendFolders', 
                                    'circles', 'moments', 'prompts', 'promptFolders', 
                                    'openingScenes', 'messages', 'chatMetadata'
                                ];

                                for (const storeName of storesToImport) {
                                    if (dataToImport[storeName] && Array.isArray(dataToImport[storeName])) {
                                        await DBHelper.batchPut(storeName, dataToImport[storeName]);
                                    }
                                }

                                
                                if(dataToImport.apiConfig) await DBHelper.put('apiConfig', dataToImport.apiConfig);
                                if(dataToImport.themeSettings) await DBHelper.put('apiConfig', dataToImport.themeSettings);
                                if(dataToImport.giftApiConfig) await DBHelper.put('giftApiConfig', dataToImport.giftApiConfig);
                                

                                UIManager.showModal({
                                    title: "å¯¼å…¥æˆåŠŸ",
                                    body: `<p>æ•°æ®å·²æˆåŠŸå¯¼å…¥ï¼åº”ç”¨å³å°†è‡ªåŠ¨åˆ·æ–°ä»¥åº”ç”¨æ›´æ”¹ã€‚</p>`,
                                    actions: [{ text: 'ç«‹å³åˆ·æ–°', class: 'btn-primary', handler: () => window.location.reload() }]
                                });
                                setTimeout(() => window.location.reload(), 2000);

                            } catch (error) {
                                console.error("Import failed:", error);
                                UIManager.showModal({
                                    title: 'å¯¼å…¥å¤±è´¥',
                                    body: `<p>å¯¼å…¥è¿‡ç¨‹ä¸­å‘ç”Ÿä¸¥é‡é”™è¯¯: ${error.message}</p>`,
                                    actions: [{ text: 'å…³é—­', class: 'btn-danger', handler: () => UIManager.hideModal() }]
                                });
                            }
                        }}
                    ]
                });
            },
            
            async applyBackgroundSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const appContainer = $('#app-container');
                if (settings.appBackground) {
                    appContainer.style.backgroundImage = `url(${settings.appBackground})`;
                } else {
                    appContainer.style.backgroundImage = '';
                }
            },

            async applyFontSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;
                const fontSettings = settings.fonts || {};
                const customFonts = settings.customFonts || {};

                const fontTypes = {
                    Global: '--font-main',
                    Bubble: '--font-bubble',
                    InnerVoice: '--font-inner-voice',
                    Essay: '--font-essay'
                };

                
                const defaultFontValues = {
                    global: '"SimSun", "å®‹ä½“", serif',
                    bubble: '"LXGW WenKai Screen", "Kaiti", "æ¥·ä½“", serif',
                    innervoice: '"Long Cang", cursive',
                    essay: '"Long Cang", cursive'
                };

                for (const [type, cssVar] of Object.entries(fontTypes)) {
                    const typeKey = type.toLowerCase();
                    const setting = fontSettings[typeKey]; 

                    if (setting && setting.type === 'custom' && customFonts[setting.value]) {
                        
                        const customFont = customFonts[setting.value];
                        root.style.setProperty(cssVar, `"${customFont.name}", sans-serif`);
                    } else if (setting && setting.type === 'builtin') {
                        
                        root.style.setProperty(cssVar, setting.value);
                    } else {
                        
                        
                        
                        
                        root.style.setProperty(cssVar, defaultFontValues[typeKey]);
                    }
                }
            },

            async loadAndApplyFontsInBackground() {
                
                try {
                    await this.loadCustomFontsOnStartup();
                    await this.applyFontSettings();
                    console.log("Custom fonts and settings applied in the background.");
                } catch (error) {
                    console.error("Failed to load and apply fonts in background:", error);
                }
            },

            async applyChatInterfaceStyleSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;
                root.style.setProperty('--chat-ui-bg-color', settings.chatUiColor || '#FFFFFF');
                root.style.setProperty('--chat-feature-btn-color', settings.chatFeatureBtnColor || getComputedStyle(root).getPropertyValue('--text-color-medium').trim());
                root.style.setProperty('--chat-feature-btn-active-color', settings.chatFeatureBtnActiveColor || getComputedStyle(root).getPropertyValue('--accent-color').trim());
            },

            async applyChatSpecificStyles() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};

                const setButtonIcon = (buttonId, iconUrl, defaultIconHtml, style) => {
                    const button = $(buttonId);
                    if (!button) return;

                    if (iconUrl) {
                        const existingImg = button.querySelector('img');
                        if (existingImg && existingImg.src === iconUrl) return;

                        const img = new Image();
                        img.onload = () => {
                            button.innerHTML = `<img src="${iconUrl}" style="${style}">`;
                        };
                        img.onerror = () => {
                            button.innerHTML = defaultIconHtml;
                            console.warn(`æ— æ³•åŠ è½½è‡ªå®šä¹‰å›¾æ ‡: ${iconUrl}`);
                        };
                        img.src = iconUrl;
                    } else {
                        button.innerHTML = defaultIconHtml;
                    }
                };

                setButtonIcon(
                    '#chat-insight-btn', 
                    settings.insightIconUrl, 
                    '<i class="fas fa-clover"></i>',
                    'width: 1.8rem; height: 1.8rem; object-fit: contain; border-radius: 4px; position: relative; top: 2px;' /* å¢å¤§å°ºå¯¸å¹¶ä¸‹ç§» */
                );

                setButtonIcon(
                    '#ai-request-btn', 
                    settings.aiRequestBtnUrl, 
                    '<i class="fas fa-feather-alt"></i>',
                    'width: 2.2rem; height: 2.2rem; object-fit: contain;' /* å¢å¤§å°ºå¯¸ */
                );
                
                setButtonIcon(
                    '#send-btn', 
                    settings.sendBtnUrl, 
                    '<i class="fas fa-paper-plane"></i>',
                    'width: 1.8rem; height: 1.8rem; object-fit: contain;' /* å¢å¤§å°ºå¯¸ */
                );
            },

        async renderThemeSettingsPage() {
            const contentArea = $('#theme-settings-content');
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            appState.theme = chatSettings.theme || 'neumorphic';
            
            const pageColor = settings.pageColor || 'rgba(255, 255, 255, 0.5)';
            const uiButtonColor = settings.uiButtonColor || getComputedStyle(document.documentElement).getPropertyValue('--text-color-light').trim();
            const uiButtonActiveColor = settings.uiButtonActiveColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
            
            const chatUiColor = settings.chatUiColor || '#FFFFFF';
            const chatFeatureBtnColor = settings.chatFeatureBtnColor || getComputedStyle(document.documentElement).getPropertyValue('--text-color-medium').trim();
            const chatFeatureBtnActiveColor = settings.chatFeatureBtnActiveColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
            const insightIconUrl = settings.insightIconUrl || '';
            const aiRequestBtnUrl = settings.aiRequestBtnUrl || '';
            const sendBtnUrl = settings.sendBtnUrl || '';

            contentArea.innerHTML = `
                <style>
                    .theme-setting-card .color-input-group { display: flex; flex-direction: column; align-items: center; gap: 8px; }
                    .theme-setting-card .color-input-group label { font-size: 0.9rem; color: var(--text-color-medium); }
                </style>
                <div class="theme-setting-card">
                    <h3>å¼¹çª—é£æ ¼</h3>
                    <div style="display: flex; justify-content: space-around; padding-top: 10px;">
                        <label style="cursor:pointer;"><input type="radio" name="modal-theme" value="default" ${appState.theme !== 'neumorphic' ? 'checked' : ''}> é»˜è®¤</label>
                        <label style="cursor:pointer;"><input type="radio" name="modal-theme" value="neumorphic" ${appState.theme === 'neumorphic' ? 'checked' : ''}> æ‹Ÿæ€</label>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3>é€šç”¨è®¾ç½®</h3>
                    <div class="theme-setting-group">
                       <button id="font-settings-btn" class="theme-page-btn">å­—ä½“è®¾ç½®</button>
                       <button id="background-settings-btn" class="theme-page-btn">èƒŒæ™¯ä¸å°é¢</button>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3 style="display: flex; justify-content: space-between; align-items: center;">
                        <span>é¡µé¢é£æ ¼</span>
                        <button id="reset-page-style-btn" class="font-delete-btn" title="æ¢å¤é»˜è®¤" style="background: rgba(0,0,0,0.05); border: none; border-radius: 5px; cursor: pointer; transition: all 0.2s;"><i class="fas fa-sync-alt"></i></button>
                    </h3>
                    <div class="theme-setting-group">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>é¡µé¢UIé¢œè‰²</span>
                            <div class="color-picker-container">
                                <input type="color" id="page-color-picker" value="${pageColor}">
                                <input type="text" class="color-hex-input" id="page-color-hex" value="${pageColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 5px 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>æŒ‰é’®é»˜è®¤é¢œè‰²</span>
                            <div class="color-picker-container">
                                <input type="color" id="ui-button-color-picker" value="${uiButtonColor}">
                                <input type="text" class="color-hex-input" id="ui-button-color-hex" value="${uiButtonColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>æŒ‰é’®æ¿€æ´»é¢œè‰²</span>
                            <div class="color-picker-container">
                                <input type="color" id="ui-button-active-color-picker" value="${uiButtonActiveColor}">
                                <input type="text" class="color-hex-input" id="ui-button-active-color-hex" value="${uiButtonActiveColor}" maxlength="7" size="7">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3>èŠå¤©ç•Œé¢é£æ ¼</h3>
                    <div class="theme-setting-group">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>ç•Œé¢UIé¢œè‰²</span>
                            <div class="color-picker-container">
                                <input type="color" id="chat-ui-color-picker" value="${chatUiColor}">
                                <input type="text" class="color-hex-input" id="chat-ui-color-hex" value="${chatUiColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>åŠŸèƒ½æŒ‰é’®é»˜è®¤é¢œè‰²</span>
                            <div class="color-picker-container">
                                <input type="color" id="chat-feature-btn-color-picker" value="${chatFeatureBtnColor}">
                                <input type="text" class="color-hex-input" id="chat-feature-btn-color-hex" value="${chatFeatureBtnColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>åŠŸèƒ½æŒ‰é’®æ¿€æ´»é¢œè‰²</span>
                            <div class="color-picker-container">
                                <input type="color" id="chat-feature-btn-active-color-picker" value="${chatFeatureBtnActiveColor}">
                                <input type="text" class="color-hex-input" id="chat-feature-btn-active-color-hex" value="${chatFeatureBtnActiveColor}" maxlength="7" size="7">
                            </div>
                        </div>
                        <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 5px 0;">
                        <div class="form-group" style="margin-bottom: 0;">
                            <label for="insight-icon-url-input">è§’è‰²æ´å¯Ÿå›¾æ ‡URL (é€‰å¡«)</label>
                            <input type="text" id="insight-icon-url-input" value="${insightIconUrl}" placeholder="è¾“å…¥å›¾ç‰‡é“¾æ¥...">
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label for="ai-request-btn-url-input">å°ç¾½æ¯›æŒ‰é’®URL (é€‰å¡«)</label>
                            <input type="text" id="ai-request-btn-url-input" value="${aiRequestBtnUrl}" placeholder="è¾“å…¥å›¾ç‰‡é“¾æ¥...">
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label for="send-btn-url-input">å‘é€æŒ‰é’®URL (é€‰å¡«)</label>
                            <input type="text" id="send-btn-url-input" value="${sendBtnUrl}" placeholder="è¾“å…¥å›¾ç‰‡é“¾æ¥...">
                        </div>
                    </div>
                </div>
            `;
            
            $('#theme-settings-back-btn').onclick = () => UIManager.navigateTo('settings');

            $('#reset-page-style-btn').onclick = async () => {
                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                delete settingsToSave.pageColor;
                delete settingsToSave.uiButtonColor;
                delete settingsToSave.uiButtonActiveColor;
                await DBHelper.put('apiConfig', settingsToSave);
                await this.applyPageStyleSettings();
                await this.renderThemeSettingsPage();
                UIManager.showToast("é¡µé¢é£æ ¼å·²æ¢å¤é»˜è®¤");
            };

            const savePageStyleSettings = async () => {
                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                settingsToSave.pageColor = $('#page-color-picker').value;
                settingsToSave.uiButtonColor = $('#ui-button-color-picker').value;
                settingsToSave.uiButtonActiveColor = $('#ui-button-active-color-picker').value;
                await DBHelper.put('apiConfig', settingsToSave);
                await this.applyPageStyleSettings();
            };

            const saveChatInterfaceSettings = async () => {
                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                settingsToSave.chatUiColor = $('#chat-ui-color-picker').value;
                settingsToSave.chatFeatureBtnColor = $('#chat-feature-btn-color-picker').value;
                settingsToSave.chatFeatureBtnActiveColor = $('#chat-feature-btn-active-color-picker').value;
                settingsToSave.insightIconUrl = $('#insight-icon-url-input').value.trim();
                settingsToSave.aiRequestBtnUrl = $('#ai-request-btn-url-input').value.trim();
                settingsToSave.sendBtnUrl = $('#send-btn-url-input').value.trim();
                await DBHelper.put('apiConfig', settingsToSave);
                await this.applyChatInterfaceStyleSettings();
                await this.applyChatSpecificStyles();
            };

            $('#page-color-picker').oninput = savePageStyleSettings;
            $('#ui-button-color-picker').oninput = savePageStyleSettings;
            $('#ui-button-active-color-picker').oninput = savePageStyleSettings;
            
            $('#chat-ui-color-picker').oninput = saveChatInterfaceSettings;
            $('#chat-feature-btn-color-picker').oninput = saveChatInterfaceSettings;
            $('#chat-feature-btn-active-color-picker').oninput = saveChatInterfaceSettings;
            $('#insight-icon-url-input').onchange = saveChatInterfaceSettings;
            $('#ai-request-btn-url-input').onchange = saveChatInterfaceSettings;
            $('#send-btn-url-input').onchange = saveChatInterfaceSettings;

            EventManager._syncColorInputs('page-color-picker', 'page-color-hex');
            EventManager._syncColorInputs('ui-button-color-picker', 'ui-button-color-hex');
            EventManager._syncColorInputs('ui-button-active-color-picker', 'ui-button-active-color-hex');
            EventManager._syncColorInputs('chat-ui-color-picker', 'chat-ui-color-hex');
            EventManager._syncColorInputs('chat-feature-btn-color-picker', 'chat-feature-btn-color-hex');
            EventManager._syncColorInputs('chat-feature-btn-active-color-picker', 'chat-feature-btn-active-color-hex');
            
            $$('input[name="modal-theme"]').forEach(radio => {
                radio.onchange = async (e) => {
                    appState.theme = e.target.value;
                    const settingsToSave = await DBHelper.get('apiConfig', 'chatSettings') || { id: 'chatSettings' };
                    settingsToSave.theme = appState.theme;
                    await DBHelper.put('apiConfig', settingsToSave);
                };
            });

            $('#font-settings-btn').onclick = () => this.handleFontSettings();

            $('#background-settings-btn').onclick = () => {
                UIManager.showModal({
                    title: "èƒŒæ™¯ä¸å°é¢",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="modal-bg-settings-btn-nav" style="cursor:pointer;">
                                <i class="fas fa-desktop"></i><span>åº”ç”¨/èŠå¤©èƒŒæ™¯</span><i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="modal-cover-settings-btn-nav" style="cursor:pointer;">
                                <i class="fas fa-photo-video"></i><span>è‡ªå®šä¹‰å°é¢</span><i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: [{ text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });
                
                $('#modal-bg-settings-btn-nav').addEventListener('click', () => {
                    UIManager.hideModal();
                    this.handleBackgroundSettings();
                });
                $('#modal-cover-settings-btn-nav').addEventListener('click', () => {
                    UIManager.hideModal();
                    this.handleCoverSettings();
                });
            };
        },

            async renderBubbleSettingsPage() {
                const contentArea = $('#bubble-settings-content');
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const profile = await DBHelper.get('profile', 'myProfile'); 
                
                const bubbleStyles = {
                    'default': { name: 'é»˜è®¤', type: 'A', style: 'background: white; border: 2px solid var(--player-bubble-bg);' },
                    '3d': { name: 'ç«‹ä½“3D', type: 'A', style: 'background: var(--player-bubble-bg); border-bottom: 3px solid rgba(0,0,0,0.2); border-radius: 12px;' },
                    'neumorphic': { name: 'æ‹Ÿæ€', type: 'A', style: 'background: var(--player-bubble-bg); box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #fff; color: #555;' },
                    'stripes': { name: 'æŸ”å’Œæ¡çº¹', type: 'A', style: 'background-color: var(--player-bubble-bg); background-image: repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.2) 15px, rgba(255, 255, 255, 0.1) 15px, rgba(255, 255, 255, 0.1) 30px);' },
                    'grid': { name: 'ç½‘æ ¼', type: 'A', style: 'background-image: linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px); background-color: color-mix(in srgb, var(--player-bubble-bg) 80%, transparent);' },
                    'cute': { name: 'å¯çˆ±é£', type: 'A', style: 'background: transparent; border: 2px solid var(--player-bubble-bg); border-radius: 25px 25px 5px 25px;' },
                    'simple-os': { name: 'ç®€çº¦os', type: 'A', style: 'background-color: color-mix(in srgb, var(--player-bubble-bg) 60%, transparent); border: 1px solid rgba(255, 255, 255, 0.2); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);' },
                    'neumorphic-2': { name: 'æ‹Ÿæ€2', type: 'B', style: 'background: #F0F0F3; box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.9), 5px 5px 9px rgba(174, 174, 192, 0.4);' },
                    'ancient': { name: 'å¤é£', type: 'B', style: 'background: #f5f0e1; color: #5d4037; border: 2px solid #8d6e63;' },
                    'chinese': { name: 'å›½é£', type: 'B', style: 'background: #c81e1e; border: 1px solid #f9d56e; color: #f9d56e;' },
                    'doodle': { name: 'æ‰‹ç»˜æ¶‚é¸¦', type: 'B', style: 'background: white; border: 2px solid #333; color: #333; box-shadow: 3px 3px 0px #ccc; border-radius: 15px 10px 15px 12px;' },
                    'hand-drawn': { name: 'æ‰‹ç»˜æ¶‚é¸¦2', type: 'B', style: 'background: white; border: 3px solid #333; box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.1); font-family: "Comic Sans MS", cursive; color: #333;' },
                    'stripey': { name: 'å¯çˆ±æ¡çº¹', type: 'B', style: 'background: repeating-linear-gradient(45deg, #FFC0CB, #FFC0CB 10px, #F8C8D1 10px, #F8C8D1 20px);' },
                    'gradient': { name: 'æ¸å˜å½©è™¹', type: 'B', style: 'background: linear-gradient(45deg, #a1c4fd, #c2e9fb, #ff9a9e, #a1c4fd); animation: gradientBG 8s ease infinite; background-size: 300% 300%;' },
                    'glow-jelly': { name: 'å‘å…‰æœå†»', type: 'B', style: 'background: linear-gradient(135deg, #ff7e5f, #feb47b); box-shadow: 0 0 15px rgba(255, 126, 95, 0.7);' },
                    'metal': { name: 'é‡‘å±è´¨æ„Ÿ', type: 'B', style: 'background: linear-gradient(145deg, #e0e0e0, #c0c0c0);' },
                    'ocean': { name: 'æµ·æ´‹é£', type: 'B', style: 'background: linear-gradient(160deg, #0077b6, #00b4d8);' },
                    'paw': { name: 'çŒ«çˆªé£', type: 'B', style: 'background: #fce1cb; color: #8b5e34;' },
                    'wechat': { name: 'ç»¿è‰²', type: 'B', style: 'background-color: #95EC6A;' },
                    'custom': { name: 'è‡ªå®šä¹‰', type: 'B', style: 'background: #f0f0f0; border: 2px dashed #ccc; color: #999 !important;' },
                };

                const currentStyle = settings.bubbleStyle || 'default';
                let bubbleStyleOptionsHTML = '';
                for (const [key, value] of Object.entries(bubbleStyles)) {
                    bubbleStyleOptionsHTML += `
                        <div class="bubble-style-option ${currentStyle === key ? 'selected' : ''}" data-style-key="${key}">
                            <div class="bubble-style-preview" style="${value.style}"><span>${value.type}</span></div>
                            <span>${value.name}</span>
                        </div>
                    `;
                }
                
                const fontSizeOptions = {
                    'small': { name: 'å°', value: '0.8rem' },
                    'normal-small': { name: 'è¾ƒå°', value: '0.88rem' },
                    'default': { name: 'é»˜è®¤', value: '0.95rem' },
                    'normal-large': { name: 'è¾ƒå¤§', value: '1.05rem' },
                    'large': { name: 'å¤§', value: '1.15rem' }
                };
                const currentFontSizeKey = settings.bubbleFontSize || 'default';
                const fontSizeRadioHTML = Object.entries(fontSizeOptions).map(([key, value]) => `
                    <label style="cursor:pointer;"><input type="radio" name="font-size-radio" value="${key}" ${currentFontSizeKey === key ? 'checked' : ''}> ${value.name}</label>
                `).join('');

                contentArea.innerHTML = `
                     <style>
                        .theme-setting-card .color-input-group { display: flex; flex-direction: column; align-items: center; gap: 8px; }
                        .theme-setting-card .color-input-group label { font-size: 0.9rem; color: var(--text-color-medium); }
                        .bubble-style-options-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; justify-content: center; margin-top: 10px; }
                        .bubble-style-option { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 10px; border-radius: 10px; border: 2px solid transparent; transition: all 0.3s ease; background-color: rgba(0,0,0,0.03); }
                        .bubble-style-option.selected { border-color: var(--accent-color); transform: scale(1.05); }
                        .bubble-style-option:hover { background-color: rgba(0,0,0,0.06); }
                        .bubble-style-preview { width: 80px; height: 40px; border-radius: 10px; margin-bottom: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.05); display: flex; justify-content: center; align-items: center; font-size: 0.8rem; color: white; text-shadow: 1px 1px 1px rgba(0,0,0,0.2); font-weight: bold; }
                        .bubble-style-option span { font-size: 0.9rem; color: var(--text-color-dark); text-align: center; }
                        .bubble-style-preview span { color: white; }
                    </style>
                    <div class="theme-setting-card">
                        <h3>èŠå¤©å­—ä½“å¤§å°</h3>
                        <div id="font-size-radio-group" style="display: flex; justify-content: space-around; padding-top: 10px;">
                            ${fontSizeRadioHTML}
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-light); text-align: center; margin-top: 10px; padding: 0 15px;">
                            èŠå¤©å­—ä½“å¤§å°åŒæ—¶è¿˜å–å†³äºè‡ªå®šä¹‰å­—ä½“å› ç´ å½±å“
                        </p>
                    </div>
                    <div class="theme-setting-card" id="bubble-color-card">
                        <h3>æ°”æ³¡é¢œè‰² (é™Aç±»æ°”æ³¡)</h3>
                        <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px; margin-top: 15px;">
                            <div class="color-input-group">
                                <label for="friend-bubble-bg-color">å¥½å‹æ¶ˆæ¯èƒŒæ™¯</label>
                                <div class="color-picker-container">
                                    <input type="color" id="friend-bubble-bg-color" value="${settings.friendBubbleBg || '#FFFFFF'}">
                                    <input type="text" class="color-hex-input" id="friend-bubble-bg-hex" value="${settings.friendBubbleBg || '#FFFFFF'}" maxlength="7" size="7">
                                </div>
                            </div>
                            <div class="color-input-group">
                                <label for="player-bubble-bg-color">æˆ‘çš„æ¶ˆæ¯èƒŒæ™¯</label>
                                <div class="color-picker-container">
                                    <input type="color" id="player-bubble-bg-color" value="${settings.playerBubbleBg || '#A7C7E7'}">
                                    <input type="text" class="color-hex-input" id="player-bubble-bg-hex" value="${settings.playerBubbleBg || '#A7C7E7'}" maxlength="7" size="7">
                                </div>
                            </div>
                        </div>
                    </div>
                     <div class="theme-setting-card">
                        <h3>èŠå¤©æ°”æ³¡å­—ä½“é¢œè‰²</h3>
                         <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px; margin-top: 15px;">
                            <div class="color-input-group">
                                <label for="friend-bubble-text-color">å¥½å‹æ¶ˆæ¯</label>
                                <div class="color-picker-container">
                                    <input type="color" id="friend-bubble-text-color" value="${settings.friendBubbleTextColor || '#5D534A'}">
                                    <input type="text" class="color-hex-input" id="friend-bubble-text-hex" value="${settings.friendBubbleTextColor || '#5D534A'}" maxlength="7" size="7">
                                </div>
                            </div>
                            <div class="color-input-group">
                                <label for="player-bubble-text-color">æˆ‘çš„æ¶ˆæ¯</label>
                                <div class="color-picker-container">
                                    <input type="color" id="player-bubble-text-color" value="${settings.playerBubbleTextColor || '#FFFFFF'}">
                                    <input type="text" class="color-hex-input" id="player-bubble-text-hex" value="${settings.playerBubbleTextColor || '#FFFFFF'}" maxlength="7" size="7">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="theme-setting-card">
                        <h3>èŠå¤©æ°”æ³¡æ ·å¼</h3>
                        <div id="bubble-style-options" class="bubble-style-options-container">${bubbleStyleOptionsHTML}</div>
                    </div>
                    <div class="theme-setting-card">
                        <h3>è‡ªå®šä¹‰æ°”æ³¡æ ·å¼</h3>
                        <div class="css-editor-container">
                            <div class="css-editor-slots" style="display: flex; gap: 10px; margin-bottom: 15px; justify-content: center;">
                                <button class="modal-btn btn-secondary slot-btn" data-slot="1">å­˜æ¡£ 1</button>
                                <button class="modal-btn btn-secondary slot-btn" data-slot="2">å­˜æ¡£ 2</button>
                                <button class="modal-btn btn-secondary slot-btn" data-slot="3">å­˜æ¡£ 3</button>
                            </div>
                            <textarea id="custom-bubble-css-input" placeholder="åœ¨æ­¤å¤„è¾“å…¥æ‚¨çš„è‡ªå®šä¹‰CSSä»£ç ..."></textarea>
                            <div class="editor-actions">
                                <button id="reset-custom-css-btn" class="modal-btn btn-secondary">æ¸…ç©º</button>
                                <button id="preview-custom-css-btn" class="modal-btn btn-primary">é¢„è§ˆ</button>
                                <button id="save-custom-css-btn" class="modal-btn btn-primary">ä¿å­˜</button>
                                <button id="apply-custom-css-btn" class="modal-btn btn-primary">åº”ç”¨</button>
                            </div>
                        </div>
                    </div>
                    <div class="theme-setting-card">
                        <h3>æ•ˆæœé¢„è§ˆ</h3>
                        <style id="custom-bubble-preview-style"></style>
                        <div id="custom-bubble-preview" class="css-preview-area"></div>
                    </div>
                    <div class="theme-setting-card">
                        <h3>æ•™ç¨‹ä¸ç¤ºä¾‹</h3>
                        <p style="font-size:0.9rem; color:var(--text-color-medium); margin-bottom:16px;">æ‚¨å¯ä»¥å¤åˆ¶ä»¥ä¸‹ç¤ºä¾‹ä»£ç ä½œä¸ºèµ·ç‚¹è¿›è¡Œä¿®æ”¹æˆ–å‘é€ç»™AIè¿›è¡Œä¿®æ”¹ã€‚è¯·æ³¨æ„ï¼Œä¸ºäº†å®‰å…¨ï¼Œä»…æ”¯æŒåŸºç¡€çš„CSSé€‰æ‹©å™¨å’Œå±æ€§ã€‚</p>
                        <p style="font-size:0.9rem; color:var(--text-color-medium); margin-bottom:10px;"><strong>æ³¨æ„ï¼š</strong>è¯·ç¡®ä¿ä½ ä½¿ç”¨çš„æ°”æ³¡ä»£ç æ˜¯<strong>è‡ªå·±ç¼–å†™/è‡ªå·±ä½¿ç”¨AIç”Ÿæˆ/å…¶ä»–åˆ¶ä½œè€å¸ˆåŒæ„ä½¿ç”¨çš„</strong>ã€‚è¯·å‹¿æœªç»æˆæƒ/å…è®¸äºŒç”¨ä»–äººçš„ä»»ä½•è®¾å®šæˆ–äº§å‡ºï¼Œ<span style="color: red; font-weight: bold;">è¯·å°Šé‡æ‰€æœ‰äººçš„ä»»ä½•äº§å‡º</span>ï¼Œå¦åˆ™åç»­é—®é¢˜éœ€è‡ªè¡Œè´Ÿè´£ã€‚</p>
                        <pre id="css-tutorial-code-block" class="css-tutorial-code"><button class="copy-btn">å¤åˆ¶</button><code>

/* --- å¥½å‹çš„æ°”æ³¡ --- */
.bubble {
    border-radius: 20px !important;
}

.bubble.received {
  background-color: #FFFFFF;
  color: var(--friend-bubble-text-color) !important;
  border: 1px solid #E0E0E0;
  border-radius: 16px 16px 16px 5px;
}

/* --- æˆ‘çš„æ°”æ³¡ --- */
.bubble.sent {
  background-color: #A7C7E7;
  color: var(--player-bubble-text-color) !important;
  border-radius: 16px 16px 5px 16px;
}
</code></pre>
                    </div>
                `;
                
                $('#bubble-settings-back-btn').onclick = () => UIManager.navigateTo('settings');
                
                
                const previewArea = $('#custom-bubble-preview');
                previewArea.innerHTML = `
                    <div class="message-row received">
                        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDQwIDQwIj48cmVjdCB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIGZpbGw9IiNjY2Q0Y2MiLz48L3N2Zz4=" alt="avatar" class="message-avatar">
                        <div class="message-content">
                            <div class="bubble received">è¿™æ˜¯å¥½å‹çš„æ¶ˆæ¯æ°”æ³¡ã€‚</div>
                        </div>
                    </div>
                    <div class="message-row sent">
                        <img src="${profile.avatar}" alt="avatar" class="message-avatar">
                        <div class="message-content">
                            <div class="bubble sent">è¿™æ˜¯æˆ‘çš„æ¶ˆæ¯æ°”æ³¡ã€‚</div>
                        </div>
                    </div>
                `;
                
                
                const cssInput = $('#custom-bubble-css-input');
                const customCSSSlots = settings.customBubbleCSSSlots || { '1': '', '2': '', '3': '' };
                const activeSlot = settings.activeCustomCSSSlot || '1';
                cssInput.value = customCSSSlots[activeSlot] || '';

                const previewStyleTag = $('#custom-bubble-preview-style');
                previewStyleTag.textContent = this._scopeCSS(cssInput.value, '#custom-bubble-preview');

                
                
                $$('.slot-btn').forEach(btn => {
                    if (btn.dataset.slot === activeSlot) {
                        btn.classList.add('btn-primary');
                        btn.classList.remove('btn-secondary');
                    }
                    btn.onclick = async () => {
                        const newActiveSlot = btn.dataset.slot;
                        
                        
                        $$('.slot-btn').forEach(b => {
                            b.classList.remove('btn-primary');
                            b.classList.add('btn-secondary');
                        });
                        btn.classList.add('btn-primary');
                        btn.classList.remove('btn-secondary');
                        
                        
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.activeCustomCSSSlot = newActiveSlot;
                        await DBHelper.put('apiConfig', settingsToSave);

                        
                        const slots = settingsToSave.customBubbleCSSSlots || { '1': '', '2': '', '3': '' };
                        cssInput.value = slots[newActiveSlot] || '';
                        
                        
                        const previewStyle = $('#custom-bubble-preview-style');
                        const scopedCss = this._scopeCSS(cssInput.value, '#custom-bubble-preview');
                        previewStyle.textContent = scopedCss;
                    };
                });


                $('#reset-custom-css-btn').onclick = () => this.handleResetCustomCSS();
                $('#preview-custom-css-btn').onclick = () => this.handlePreviewCustomCSS();
                $('#save-custom-css-btn').onclick = () => this.handleSaveCustomCSS();
                $('#apply-custom-css-btn').onclick = () => this.handleApplyCustomCSS();
                $('.css-tutorial-code .copy-btn').onclick = () => this.handleCopyTutorialCSS();

                EventManager._syncColorInputs('friend-bubble-bg-color', 'friend-bubble-bg-hex');
                EventManager._syncColorInputs('player-bubble-bg-color', 'player-bubble-bg-hex');
                EventManager._syncColorInputs('friend-bubble-text-color', 'friend-bubble-text-hex');
                EventManager._syncColorInputs('player-bubble-text-color', 'player-bubble-text-hex');
                
                $('#font-size-radio-group').onchange = async (e) => {
                    if (e.target.name === 'font-size-radio') {
                        const sizeKey = e.target.value;
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.bubbleFontSize = sizeKey;
                        await DBHelper.put('apiConfig', settingsToSave);
                        await this.applyBubbleFontSize(); 
                    }
                };

                const saveBubbleSettings = async () => {
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    settingsToSave.bubbleStyle = document.querySelector('.bubble-style-option.selected').dataset.styleKey;
                    settingsToSave.friendBubbleBg = $('#friend-bubble-bg-color').value;
                    settingsToSave.playerBubbleBg = $('#player-bubble-bg-color').value;
                    settingsToSave.friendBubbleTextColor = $('#friend-bubble-text-color').value;
                    settingsToSave.playerBubbleTextColor = $('#player-bubble-text-color').value;
                    await DBHelper.put('apiConfig', settingsToSave);
                    await this.applyBubbleSettings();
                };

                $('#bubble-style-options').onclick = (e) => {
                    const option = e.target.closest('.bubble-style-option');
                    if (!option) return;
                    $$('.bubble-style-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    const isTypeA = bubbleStyles[option.dataset.styleKey].type === 'A';
                    $('#bubble-color-card').style.display = isTypeA ? 'block' : 'none';
                    saveBubbleSettings();
                };

                ['friend-bubble-bg-color', 'player-bubble-bg-color', 'friend-bubble-text-color', 'player-bubble-text-color'].forEach(id => {
                    $(`#${id}`).oninput = saveBubbleSettings; 
                });
                
                const initialStyleIsTypeA = bubbleStyles[currentStyle].type === 'A';
                $('#bubble-color-card').style.display = initialStyleIsTypeA ? 'block' : 'none';
            },

        async handleBackgroundSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const createUploadHTML = (type, title, previewSrc, dbKey) => `
                <div class="theme-upload-item">
                    <span>${title}</span>
                    <div class="theme-upload-preview-wrapper">
                        <img src="${previewSrc || ''}" id="${type}-preview" class="theme-upload-preview" style="${previewSrc ? '' : 'display:none;'}">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="file" id="${type}-input" accept="image/*" style="display: none;">
                        <button class="theme-page-btn" onclick="document.getElementById('${type}-input').click()">ä¸Šä¼ </button>
                        <button class="theme-page-btn" id="${type}-remove-btn" style="${previewSrc ? '' : 'display:none;'}">ç§»é™¤</button>
                    </div>
                </div>`;

            UIManager.showModal({
                title: 'èƒŒæ™¯è®¾ç½®',
                body: `
                    <div class="theme-setting-group" style="padding: 10px 0;">
                        ${createUploadHTML('app-bg', 'ä¸»é¢˜èƒŒæ™¯', settings.appBackground, 'appBackground')}
                        ${createUploadHTML('global-bg', 'èŠå¤©èƒŒæ™¯', settings.globalChatBg, 'globalChatBg')}
                    </div>`,
                actions: [{ text: 'å®Œæˆ', class: 'btn-primary', handler: () => UIManager.hideModal() }]
            });

            const setupUploadHandler = (type, dbKey) => {
                const input = $(`#${type}-input`);
                const preview = $(`#${type}-preview`);
                const removeBtn = $(`#${type}-remove-btn`);
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64 = await Utils.fileToBase64(file);
                        preview.src = base64;
                        preview.style.display = 'block';
                        removeBtn.style.display = 'inline-block';
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave[dbKey] = base64;
                        await DBHelper.put('apiConfig', settingsToSave);
                        if (dbKey === 'appBackground') await EventManager.applyBackgroundSettings();
                        if (dbKey === 'globalChatBg' && appState.currentPage === 'chat' && appState.currentChatId) await UIManager.applyChatBackground(appState.currentChatId);
                        UIManager.showToast('å›¾ç‰‡å·²æ›´æ–°');
                    } catch (error) { 
                        console.error("å›¾ç‰‡ä¸Šä¼ æˆ–åº”ç”¨å¤±è´¥:", error);
                        UIManager.showToast('å›¾ç‰‡å¤„ç†å¤±è´¥'); 
                    }
                };
                removeBtn.onclick = async () => {
                    preview.src = '';
                    preview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    input.value = '';
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    delete settingsToSave[dbKey];
                    await DBHelper.put('apiConfig', settingsToSave);
                    if (dbKey === 'appBackground') await EventManager.applyBackgroundSettings();
                    if (dbKey === 'globalChatBg' && appState.currentPage === 'chat' && appState.currentChatId) await UIManager.applyChatBackground(appState.currentChatId);
                    UIManager.showToast('å›¾ç‰‡å·²ç§»é™¤');
                };
            };
            setupUploadHandler('app-bg', 'appBackground');
            setupUploadHandler('global-bg', 'globalChatBg');
        },

        async handleCoverSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const createUploadHTML = (type, title, previewSrc, dbKey, previewStyle = '') => `
                <div class="theme-upload-item">
                    <span>${title}</span>
                    <div class="theme-upload-preview-wrapper" style="${previewStyle}">
                        <img src="${previewSrc || ''}" id="${type}-preview" class="theme-upload-preview" style="${previewSrc ? '' : 'display:none;'}">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="file" id="${type}-input" accept="image/*" style="display: none;">
                        <button class="theme-page-btn" onclick="document.getElementById('${type}-input').click()">ä¸Šä¼ </button>
                        <button class="theme-page-btn" id="${type}-remove-btn" style="${previewSrc ? '' : 'display:none;'}">ç§»é™¤</button>
                    </div>
                </div>`;

            UIManager.showModal({
                title: 'è‡ªå®šä¹‰å°é¢',
                body: `
                    <div class="theme-setting-group" style="padding: 10px 0;">
                        ${createUploadHTML('rp-cover', 'çº¢åŒ…å°é¢', settings.redPacketCover, 'redPacketCover', 'width: 80px; height: 106px;')}
                        ${createUploadHTML('transfer-cover', 'è½¬è´¦å°é¢', settings.transferCover, 'transferCover')}
                        ${createUploadHTML('receipt-cover', 'æ”¶æ¬¾å°é¢', settings.receiptCover, 'receiptCover')}
                    </div>`,
                actions: [{ text: 'å®Œæˆ', class: 'btn-primary', handler: () => UIManager.hideModal() }]
            });

            const setupUploadHandler = (type, dbKey) => {
                const input = $(`#${type}-input`);
                const preview = $(`#${type}-preview`);
                const removeBtn = $(`#${type}-remove-btn`);
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64 = await Utils.compressImage(file, 800, 800, 0.7);
                        preview.src = base64;
                        preview.style.display = 'block';
                        removeBtn.style.display = 'inline-block';
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave[dbKey] = base64;
                        await DBHelper.put('apiConfig', settingsToSave);
                        UIManager.showToast('å°é¢å·²æ›´æ–°');
                    } catch (error) { UIManager.showToast('å›¾ç‰‡å¤„ç†å¤±è´¥'); }
                };
                removeBtn.onclick = async () => {
                    preview.src = '';
                    preview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    input.value = '';
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    delete settingsToSave[dbKey];
                    await DBHelper.put('apiConfig', settingsToSave);
                    UIManager.showToast('å°é¢å·²ç§»é™¤');
                };
            };
            setupUploadHandler('rp-cover', 'redPacketCover');
            setupUploadHandler('transfer-cover', 'transferCover');
            setupUploadHandler('receipt-cover', 'receiptCover');
        },

            async applyBubbleSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;
                const appContainer = $('#app-container');

                root.style.setProperty('--friend-bubble-bg', settings.friendBubbleBg || '#FFFFFF');
                root.style.setProperty('--player-bubble-bg', settings.playerBubbleBg || 'var(--accent-color)');
                root.style.setProperty('--friend-bubble-text-color', settings.friendBubbleTextColor || '#5D534A');
                root.style.setProperty('--player-bubble-text-color', settings.playerBubbleTextColor || '#FFFFFF');

                const styleKey = settings.bubbleStyle || 'default';
                const classList = Array.from(appContainer.classList);
                
                let newClassList = classList.filter(c => !c.startsWith('app-bubble-style-'));
                if(classList.includes('bottom-offset-active')) {
                    if(!newClassList.includes('bottom-offset-active')) {
                         newClassList.push('bottom-offset-active');
                    }
                }
                
                newClassList.push(`app-bubble-style-${styleKey}`);
                appContainer.className = newClassList.join(' ');

                
                await this.loadAndApplyCustomBubbleCSS();
            },

        async applyBubbleFontSize() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const fontSizeKey = settings.bubbleFontSize || 'default';
            const fontSizes = {
                'small': '0.8rem',
                'normal-small': '0.88rem',
                'default': '0.95rem',
                'normal-large': '1.05rem',
                'large': '1.15rem'
            };
            document.documentElement.style.setProperty('--font-bubble-size', fontSizes[fontSizeKey]);
        },

            async loadAndApplyCustomBubbleCSS() {
                let customStyleTag = document.getElementById('global-custom-bubble-style');
                if (!customStyleTag) {
                    customStyleTag = document.createElement('style');
                    customStyleTag.id = 'global-custom-bubble-style';
                    document.head.appendChild(customStyleTag);
                }

                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const activeSlot = settings.activeCustomCSSSlot || '1';
                const cssSlots = settings.customBubbleCSSSlots || {};
                const activeCSS = cssSlots[activeSlot] || '';

                if (settings.bubbleStyle === 'custom' && activeCSS) {
                    const scopedCss = this._scopeCSS(activeCSS, '#app-container.app-bubble-style-custom .chat-area');
                    customStyleTag.textContent = scopedCss;
                } else {
                    customStyleTag.textContent = ''; 
                }
            },

            async applyPageStyleSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;

                const pageColor = settings.pageColor || 'rgba(255, 255, 255, 0.5)';
                const texture = 'none'; 
                const buttonColor = settings.uiButtonColor || getComputedStyle(root).getPropertyValue('--text-color-light').trim();
                const buttonActiveColor = settings.uiButtonActiveColor || getComputedStyle(root).getPropertyValue('--accent-color').trim();

                root.style.setProperty('--ui-bg-color', pageColor);
                root.style.setProperty('--ui-texture-image', texture);
                root.style.setProperty('--ui-button-color', buttonColor);
                root.style.setProperty('--ui-button-active-color', buttonActiveColor);
            },

        async handleFontSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const fontSettings = settings.fonts || {};
            const customFonts = settings.customFonts || {};

            const builtinFonts = {
                'å®‹ä½“ (SimSun)': '"SimSun", "å®‹ä½“", serif',
                'æ¥·ä½“ (LXGW WenKai)': '"LXGW WenKai Screen", "Kaiti", "æ¥·ä½“", serif',
                'é¾™è—ä½“ (Long Cang)': '"Long Cang", cursive',
                'System Default': `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif`,
            };
            
            const defaultFontValues = {
                global: builtinFonts['å®‹ä½“ (SimSun)'],
                bubble: builtinFonts['æ¥·ä½“ (LXGW WenKai)'],
                innervoice: builtinFonts['é¾™è—ä½“ (Long Cang)'],
                essay: builtinFonts['é¾™è—ä½“ (Long Cang)']
            };

            const createFontSelectorHTML = (typeKey, typeLabel) => {
                const settingKey = typeKey.toLowerCase();
                const currentSetting = fontSettings[settingKey] || { type: 'builtin', value: defaultFontValues[settingKey] };

                
                let optionsHTML = Object.entries(builtinFonts).map(([name, value]) =>
                    `<option value='${value}' data-type="builtin" ${currentSetting.type === 'builtin' && currentSetting.value === value ? 'selected' : ''}>${name}</option>`
                ).join('');

                for (const [key, font] of Object.entries(customFonts)) {
                    optionsHTML += `<option value="${key}" data-type="custom" ${currentSetting.type === 'custom' && currentSetting.value === key ? 'selected' : ''}>${font.name} (è‡ªå®šä¹‰)</option>`;
                }

                return `
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                        <label>${typeLabel}</label>
                        <select class="font-select" data-font-type="${settingKey}" style="flex-grow: 1; max-width: 60%;">${optionsHTML}</select>
                    </div>`;
            };

            UIManager.showModal({
                title: "å­—ä½“è®¾ç½®",
                body: `
                    <div class="form-group" style="display: flex; justify-content: space-around; padding-bottom: 15px; border-bottom: 1px dashed var(--border-color);">
                        <button id="font-upload-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">æœ¬åœ°</button>
                        <button id="font-url-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">ç½‘ç»œ</button>
                        <button id="font-delete-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">åˆ é™¤</button>
                    </div>
                    <div style="margin-top: 20px;">
                        ${createFontSelectorHTML('Global', 'å…¨å±€å­—ä½“')}
                        ${createFontSelectorHTML('Bubble', 'æ°”æ³¡å­—ä½“')}
                        ${createFontSelectorHTML('InnerVoice', 'å¿ƒå£°å­—ä½“')}
                        ${createFontSelectorHTML('Essay', 'éšç¬”å­—ä½“')}
                    </div>
                `,
                actions: [
                    { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                    { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.fonts = settingsToSave.fonts || {};

                        $$('.font-select').forEach(select => {
                            const fontTypeKey = select.dataset.fontType;
                            const selectedOption = select.options[select.selectedIndex];
                            settingsToSave.fonts[fontTypeKey] = {
                                type: selectedOption.dataset.type,
                                value: selectedOption.value
                            };
                        });

                        await DBHelper.put('apiConfig', settingsToSave);
                        await this.applyFontSettings();
                        UIManager.hideModal();
                        UIManager.showToast("å­—ä½“è®¾ç½®å·²ä¿å­˜å¹¶åº”ç”¨");
                    }}
                ]
            });

            $('#font-upload-btn').onclick = () => this.handleFontUpload(false);
            $('#font-url-btn').onclick = () => this.handleFontUrl(false);
            $('#font-delete-btn').onclick = () => this.handleDeleteCustomFont();
        },

            async handleFontUpload() {
                UIManager.showModal({
                    title: "ä¸Šä¼ æœ¬åœ°å­—ä½“",
                    body: `
                        <div style="font-size: 0.9rem; line-height: 1.6;">
                            <p>è¯·é€‰æ‹©å­—ä½“æ–‡ä»¶è¿›è¡Œä¸Šä¼ ã€‚æ”¯æŒçš„æ ¼å¼ä¸º <code>.ttf</code>, <code>.otf</code>, <code>.woff</code>, <code>.woff2</code>ã€‚</p>
                            <p><strong>å¼ºçƒˆæ¨èä½¿ç”¨ <code>.woff2</code> æ ¼å¼</strong>ï¼Œå› ä¸ºå®ƒçš„æ–‡ä»¶ä½“ç§¯æ›´å°ï¼ŒåŠ è½½é€Ÿåº¦æ›´å¿«ã€‚</p>
                            <p>è¯·å°½é‡é€‰æ‹©ä½“ç§¯è¾ƒå°çš„å­—ä½“æ–‡ä»¶/ç½‘ç»œèµ„æºä¸Šä¼ ï¼Œè¿‡å¤§çš„å­—ä½“ä¼šå¯¼è‡´åˆ·æ–°é¡µé¢æ—¶åŠ è½½å˜æ…¢ã€ç”šè‡³é—ªé€€ã€‚</p>
                            <p>å¦‚æœçœŸçš„æƒ³è¦ä¸Šä¼ æœ¬åœ°å­—ä½“ï¼Œä¸Šä¼ å‰è¯·åšå¥½å¯¼å‡ºå¤‡ä»½</p>
                            <p style="color: var(--text-color-medium); margin-top: 15px;">åŠ è½½å­—ä½“éœ€è¦ä¸€äº›æ—¶é—´ï¼Œé€‰æ‹©ä½¿ç”¨è‡ªå®šä¹‰å­—ä½“ååˆ·æ–°é¡µé¢ä½¿å­—ä½“ç”Ÿæ•ˆã€‚</p>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings(); 
                        }},
                        { text: 'ç»§ç»­ä¸Šä¼ ', class: 'btn-primary', handler: () => {
                            UIManager.hideModal(); 
                            this.triggerActualFontUpload(); 
                        }}
                    ]
                });
            },

            triggerActualFontUpload() {
                const fontFileInput = $('#font-file-input');
                fontFileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const fontName = file.name.split('.')[0];
                    try {
                        const base64 = await Utils.fileToBase64(file);
                        const customFontKey = `${Utils.generateId('font')}`;
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.customFonts = settingsToSave.customFonts || {};
                        settingsToSave.customFonts[customFontKey] = { name: fontName, data: base64 };
                        await DBHelper.put('apiConfig', settingsToSave);

                        
                        await this.loadCustomFontsOnStartup();
                        
                        this.handleFontSettings(); 
                        UIManager.showToast(`å­—ä½“ "${fontName}" ä¸Šä¼ æˆåŠŸï¼`);
                    } catch (error) {
                        UIManager.showToast("å­—ä½“æ–‡ä»¶è¯»å–å¤±è´¥");
                    } finally {
                        fontFileInput.value = '';
                    }
                };
                fontFileInput.click();
            },

            async handleFontUrl() {
                UIManager.showModal({
                    title: "æ·»åŠ ç½‘ç»œå­—ä½“",
                    body: `
                        <div class="form-group">
                            <label for="font-url-name-input">å­—ä½“åç§° (è‡ªå®šä¹‰)</label>
                            <input type="text" id="font-url-name-input" placeholder="ä¾‹å¦‚ï¼šæ€æºé»‘ä½“">
                        </div>
                        <div class="form-group">
                            <label for="font-url-input">å­—ä½“æ–‡ä»¶ URL</label>
                            <input type="text" id="font-url-input" placeholder="https://.../font.woff2">
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: 'æ·»åŠ ', class: 'btn-primary', handler: async () => {
                            const fontName = $('#font-url-name-input').value.trim();
                            const fontUrl = $('#font-url-input').value.trim();
                            if (!fontName || !fontUrl) return UIManager.showToast("åç§°å’ŒURLå‡ä¸èƒ½ä¸ºç©º");
                            if (!fontUrl.startsWith('http')) return UIManager.showToast("è¯·è¾“å…¥æœ‰æ•ˆçš„URL");

                            const customFontKey = `${Utils.generateId('font')}`;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            settingsToSave.customFonts = settingsToSave.customFonts || {};
                            settingsToSave.customFonts[customFontKey] = { name: fontName, data: fontUrl };
                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();

                            UIManager.hideModal();
                            this.handleFontSettings();
                            UIManager.showToast(`ç½‘ç»œå­—ä½“ "${fontName}" æ·»åŠ æˆåŠŸï¼`);
                        }}
                    ]
                });
            },

            async handleDeleteCustomFont() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const customFonts = settings.customFonts || {};

                if (Object.keys(customFonts).length === 0) {
                    return UIManager.showToast("æ²¡æœ‰å¯åˆ é™¤çš„è‡ªå®šä¹‰å­—ä½“");
                }

                
                const fontListHtml = Object.entries(customFonts).map(([key, font]) => `
                    <label class="member-select-item">
                        <input type="radio" name="delete-font-radio" value="${key}">
                        <span>${font.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é€‰æ‹©è¦åˆ é™¤çš„å­—ä½“",
                    body: `<div class="member-select-list">${fontListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            const selectedRadio = $('input[name="delete-font-radio"]:checked');
                            if (!selectedRadio) return UIManager.showToast("è¯·é€‰æ‹©ä¸€ä¸ªè¦åˆ é™¤çš„å­—ä½“");

                            const fontKeyToDelete = selectedRadio.value;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            
                            
                            if (settingsToSave.customFonts && settingsToSave.customFonts[fontKeyToDelete]) {
                                delete settingsToSave.customFonts[fontKeyToDelete];
                            }

                            
                            if (settingsToSave.fonts) {
                                for (const typeKey in settingsToSave.fonts) {
                                    if (settingsToSave.fonts[typeKey].value === fontKeyToDelete) {
                                        
                                        settingsToSave.fonts[typeKey] = { type: 'builtin', value: '"SimSun", "å®‹ä½“", serif' }; 
                                    }
                                }
                            }
                            
                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();
                            await this.applyFontSettings();
                            UIManager.hideModal();
                            UIManager.showToast("è‡ªå®šä¹‰å­—ä½“å·²åˆ é™¤");
                            this.handleFontSettings(); 
                        }}
                    ]
                });
            },

            async loadCustomFontsOnStartup() {
                
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const fontSettings = settings.fonts || {}; 
                const customFonts = settings.customFonts || {}; 

                
                if (Object.keys(customFonts).length === 0) {
                    
                    let fontStyleTag = document.getElementById('dynamic-font-styles');
                    if (fontStyleTag) fontStyleTag.innerHTML = '';
                    return;
                }

                
                const activeCustomFontKeys = new Set();
                
                for (const setting of Object.values(fontSettings)) {
                    
                    if (setting.type === 'custom' && setting.value) {
                        
                        activeCustomFontKeys.add(setting.value);
                    }
                }

                
                let fontStyleTag = document.getElementById('dynamic-font-styles');
                if (!fontStyleTag) {
                    fontStyleTag = document.createElement('style');
                    fontStyleTag.id = 'dynamic-font-styles';
                    document.head.appendChild(fontStyleTag);
                }

                
                let fontFaceRules = '';
                
                for (const key of activeCustomFontKeys) {
                    const font = customFonts[key]; 
                    if (font && font.name && font.data) {
                        let src;
                        
                        if (font.data.startsWith('data:')) {
                            src = `url(${font.data})`;
                        } else {
                            src = `url('${font.data}')`;
                        }
                        
                        fontFaceRules += `@font-face { font-family: "${font.name}"; src: ${src}; }\n`;
                    }
                }

                
                fontStyleTag.innerHTML = fontFaceRules;
            },

            async handleFontUrl(fontTypeKey) {
                UIManager.showModal({
                    title: "æ·»åŠ ç½‘ç»œå­—ä½“",
                    body: `
                        <div class="form-group">
                            <label for="font-url-name-input">å­—ä½“åç§° (è‡ªå®šä¹‰)</label>
                            <input type="text" id="font-url-name-input" placeholder="ä¾‹å¦‚ï¼šæ€æºé»‘ä½“">
                        </div>
                        <div class="form-group">
                            <label for="font-url-input">å­—ä½“æ–‡ä»¶ URL</label>
                            <input type="text" id="font-url-input" placeholder="https://.../font.woff2">
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); text-align: center; margin-top: 10px;">
                            æç¤ºï¼šå­—ä½“æ–‡ä»¶è¶Šå¤§ï¼ŒåŠ è½½æ—¶é—´è¶Šé•¿ï¼Œè¯·å°½é‡é€‰æ‹©ä½“ç§¯è¾ƒå°çš„å­—ä½“ã€‚
                        </p>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: 'æ·»åŠ ', class: 'btn-primary', handler: async () => {
                            const fontName = $('#font-url-name-input').value.trim();
                            const fontUrl = $('#font-url-input').value.trim();

                            if (!fontName || !fontUrl) {
                                return UIManager.showToast("åç§°å’ŒURLå‡ä¸èƒ½ä¸ºç©º");
                            }

                            
                            if (!fontUrl.startsWith('http')) {
                                return UIManager.showToast("è¯·è¾“å…¥æœ‰æ•ˆçš„URL");
                            }

                            const customFontKey = `${Utils.generateId('font')}`;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            settingsToSave.customFonts = settingsToSave.customFonts || {};
                            settingsToSave.fonts = settingsToSave.fonts || {};

                            
                            settingsToSave.customFonts[customFontKey] = { name: fontName, data: fontUrl };
                            settingsToSave.fonts[fontTypeKey] = { type: 'custom', value: customFontKey };

                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();
                            await this.applyFontSettings();
                            UIManager.hideModal();
                            
                            this.handleFontSettings();
                        }}
                    ]
                });
            },



            async handleChatBackgroundSettings(chatId, isGroup) {
                const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const currentBg = entity.chatBackground || null;
                const currentNameColor = entity.nameColor || '#888888';

                const createUploadSection = (id, label, previewSrc) => `
                    <div class="background-upload-section">
                        <label>${label}</label>
                        <img src="${previewSrc || 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='}" 
                             alt="${label}é¢„è§ˆ" 
                             class="background-preview" 
                             id="${id}-preview"
                             style="${previewSrc ? '' : 'display: none;'}">
                        <input type="file" id="${id}-input" accept="image/*" style="display: none;">
                        <button class="modal-btn btn-secondary" style="padding: 8px 15px;" onclick="document.getElementById('${id}-input').click()">ä¸Šä¼ </button>
                        <button class="modal-btn btn-danger" style="padding: 8px 15px; ${previewSrc ? '' : 'display: none;'}" id="${id}-remove-btn">ç§»é™¤</button>
                    </div>`;
                
                const createColorPickerSection = (id, label, value) => `
                     <div class="background-upload-section" style="flex-direction: row; justify-content: space-between; align-items: center; padding: 10px 20px;">
                        <label>${label}</label>
                        <div class="color-picker-container">
                             <input type="color" id="${id}-input" value="${value}">
                             <input type="text" class="color-hex-input" id="${id}-hex" value="${value}" maxlength="7" size="7">
                        </div>
                    </div>
                `;

                const currentNarratorStyle = entity.narratorStyle || 'grey';

                UIManager.showModal({
                    title: `ä¸“å±è®¾ç½® - ${entity.name}`,
                    customClass: 'theme-settings-modal',
                    body: `
                        <div class="form-group">
                           ${createUploadSection('exclusive-bg', 'ä¸“å±èƒŒæ™¯', currentBg)}
                        </div>
                        <div class="form-group">
                           ${createColorPickerSection('exclusive-name-color', 'è§’è‰²åå­—é¢œè‰²', currentNameColor)}
                        </div>
                        <div class="form-group">
                            <label>æ—ç™½æ ·å¼</label>
                            <div class="narrator-style-selector" id="narrator-style-selector">
                                <div class="narrator-style-option grey-option ${currentNarratorStyle === 'grey' ? 'selected' : ''}" data-style="grey">ç°è‰²</div>
                                <div class="narrator-style-option white-option ${currentNarratorStyle === 'white' ? 'selected' : ''}" data-style="white">ç™½è‰²</div>
                                <div class="narrator-style-option black-option ${currentNarratorStyle === 'black' ? 'selected' : ''}" data-style="black">é»‘è‰²</div>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { 
                            text: 'ä¿å­˜', 
                            class: 'btn-primary', 
                            
                            handler: () => {} 
                        }
                    ]
                });

                this._syncColorInputs('exclusive-name-color-input', 'exclusive-name-color-hex');
                
                const setupUpload = (id) => {
                    const input = $(`#${id}-input`);
                    const preview = $(`#${id}-preview`);
                    const removeBtn = $(`#${id}-remove-btn`);

                    input.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            preview.src = await Utils.fileToBase64(file);
                            preview.style.display = 'block';
                            removeBtn.style.display = 'inline-block';
                        }
                    });

                    removeBtn.addEventListener('click', () => {
                        preview.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; 
                        preview.style.display = 'none';
                        removeBtn.style.display = 'none';
                        input.value = ''; 
                    });
                };
                setupUpload('exclusive-bg');

                
                const narratorSelector = $('#narrator-style-selector');
                narratorSelector.addEventListener('click', (e) => {
                    const option = e.target.closest('.narrator-style-option');
                    if (!option) return;
                    
                    narratorSelector.querySelectorAll('.narrator-style-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');

                    const handler = narratorSelector.closest('.modal-content').querySelector('.modal-btn.btn-primary').__handler;
                    if(handler) {
                        handler.call(); 
                    }
                });

                const saveHandler = async () => {
                    const previewSrc = $('#exclusive-bg-preview').src;
                    const blankGif = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                    const newBg = (previewSrc.startsWith('data:image') && previewSrc !== blankGif) ? previewSrc : null;
                    const newNameColor = $('#exclusive-name-color-input').value;
                    const newNarratorStyle = narratorSelector.querySelector('.selected').dataset.style;

                    entity.chatBackground = newBg;
                    entity.nameColor = newNameColor;
                    entity.narratorStyle = newNarratorStyle;
                    await DBHelper.put(isGroup ? 'groups' : 'contacts', entity);

                    if (appState.currentChatId === chatId) {
                        await UIManager.applyChatBackground(chatId);
                        await UIManager.refreshChatView();
                    }

                    UIManager.hideModal();
                    UIManager.showToast('ä¸“å±è®¾ç½®å·²ä¿å­˜ï¼');
                };

                
                const saveButton = modalContentWrapper.querySelector('.modal-actions .btn-primary');
                if (saveButton) {
                    
                    saveButton.onclick = saveHandler;
                }
            },

            async renderApiSettingsPage() {
                await AIHandler.loadApiConfig();
                const config = AIHandler.apiConfig;

                const providerSelect = $('#api-provider');
                const urlInput = $('#api-url');
                const modelSelect = $('#api-model-select');
                const modelInput = $('#api-model-input');
                const tempInput = $('#temperature');

                const getApiProviderOptions = () => `
                    <option value="gemini" ${config.provider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                    <option value="siliconflow" ${config.provider === 'siliconflow' ? 'selected' : ''}>SiliconFlow</option>
                    <option value="paioupu" ${config.provider === 'paioupu' ? 'selected' : ''}>æ´¾æ¬§äº‘</option>
                    <option value="volcano" ${config.provider === 'volcano' ? 'selected' : ''}>ç«å±±</option>
                    <option value="custom" ${config.provider === 'custom' ? 'selected' : ''}>è‡ªå®šä¹‰</option>
                `;
                providerSelect.innerHTML = getApiProviderOptions();
                tempInput.value = config.temperature;

                const _renderKeyList = (provider) => {
                    const keyListContainer = $('#api-key-list');
                    const keyCountSpan = $('#api-key-count');
                    const keys = config.keys[provider] || [];
                    const toggleBtn = $('#toggle-all-keys-visibility');
                    const areKeysVisible = toggleBtn.classList.contains('visible');
                    
                    keyListContainer.innerHTML = '';
                    keyCountSpan.textContent = keys.length;

                    keys.forEach((key, index) => {
                        const item = document.createElement('div');
                        item.className = 'api-key-item';
                        let displayKey;
                        if (areKeysVisible) {
                            displayKey = key;
                        } else {
                            displayKey = key.length > 8 ? `${key.substring(0, 4)}...${key.substring(key.length - 4)}` : key;
                        }
                        item.innerHTML = `
                            <span class="key-value" title="${key}">${displayKey}</span>
                            <button class="delete-key-btn" data-index="${index}">Ã—</button>
                        `;
                        keyListContainer.appendChild(item);
                    });
                };

                const updateApiFields = () => {
                    const provider = providerSelect.value;
                    const savedModel = config.models ? config.models[provider] : null;

                    const providerData = {
                        gemini: { url: 'https://generativelanguage.googleapis.com/v1beta/models/', models: ["gemini-2.5-pro", "gemini-2.5-flash", "gemini-1.5-flash-latest", "gemini-1.5-pro-latest"], defaultModel: 'gemini-2.5-flash' },
                        siliconflow: { url: 'https://api.siliconflow.cn/v1/chat/completions', models: ["deepseek-ai/DeepSeek-V3", "deepseek-ai/DeepSeek-R1-0528-Qwen3-8B", "Qwen/Qwen2-7B-Instruct", "Qwen/Qwen2-72B-Instruct"], defaultModel: 'deepseek-ai/DeepSeek-V3' },
                        paioupu: { url: 'https://api.ppinfra.com/v1/chat/completions', models: ["deepseek/deepseek-v3"], defaultModel: 'deepseek/deepseek-v3' },
                        volcano: { url: 'https://ark.cn-beijing.volces.com/api/v3', models: [], defaultModel: '' },
                        custom: { url: '', models: [], defaultModel: '' }
                    };
                    
                    const data = providerData[provider] || providerData.custom;
                    urlInput.value = config.url || data.url;

                    if (provider === 'custom' || provider === 'volcano') {
                        modelSelect.style.display = 'none';
                        modelInput.style.display = 'block';
                        modelInput.value = savedModel;
                    } else {
                        modelSelect.style.display = 'block';
                        modelInput.style.display = 'none';
                        const finalOptions = [...data.models];
                        if (savedModel && !finalOptions.includes(savedModel)) {
                            finalOptions.unshift(savedModel);
                        }
                        modelSelect.innerHTML = finalOptions.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                        modelSelect.value = savedModel || data.defaultModel;
                    }

                    _renderKeyList(provider);
                };
                
                providerSelect.onchange = () => {
                    const newProvider = providerSelect.value;
                    const providerDefaults = {
                        gemini: { url: 'https://generativelanguage.googleapis.com/v1beta/models/', defaultModel: 'gemini-2.5-flash' },
                        siliconflow: { url: 'https://api.siliconflow.cn/v1/chat/completions', defaultModel: 'deepseek-ai/DeepSeek-V3' },
                        paioupu: { url: 'https://api.ppinfra.com/v1/chat/completions', defaultModel: 'deepseek/deepseek-v3' },
                        volcano: { url: 'https://ark.cn-beijing.volces.com/api/v3', defaultModel: '' },
                        custom: { url: '', defaultModel: '' }
                    };
                    
                    if (!config.models) {
                        config.models = {};
                    }

                    
                    if (newProvider === 'custom') {
                        
                        config.url = config.customUrl || '';
                    } else {
                        
                        config.url = providerDefaults[newProvider].url;
                    }
                    

                    
                    config.provider = newProvider;
                    updateApiFields();
                };

                $('#api-key-list').onclick = (e) => {
                    if (e.target.classList.contains('delete-key-btn')) {
                        const index = parseInt(e.target.dataset.index, 10);
                        const provider = providerSelect.value;
                        config.keys[provider].splice(index, 1);
                        _renderKeyList(provider);
                    }
                };
                
                $('#add-api-key-btn').onclick = () => {
                    const newKeyInput = $('#new-api-key-input');
                    const newKey = newKeyInput.value.trim();
                    if (!newKey) return;

                    const provider = providerSelect.value;
                    if (!config.keys[provider]) {
                        config.keys[provider] = [];
                    }
                    config.keys[provider].push(newKey);
                    newKeyInput.value = '';
                    _renderKeyList(provider);
                };

                $('#new-api-key-input').onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        $('#add-api-key-btn').click();
                    }
                };

                $('#toggle-all-keys-visibility').onclick = (e) => {
                    const btn = e.currentTarget;
                    const icon = btn.querySelector('i');
                    btn.classList.toggle('visible');
                    const isVisible = btn.classList.contains('visible');
                    icon.className = isVisible ? 'fas fa-eye-slash' : 'fas fa-eye';
                    _renderKeyList(providerSelect.value);
                };

                $('#api-settings-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#save-api-settings-btn').onclick = async () => {
                    const provider = providerSelect.value;
                    let selectedModel;

                    
                    if (modelInput.style.display !== 'none') {
                        selectedModel = modelInput.value.trim();
                    } else {
                        selectedModel = modelSelect.value;
                    }

                    
                    if (!selectedModel) {
                        UIManager.showToast("æ¨¡å‹åç§°ä¸èƒ½ä¸ºç©ºï¼Œè¯·é€‰æ‹©æˆ–è¾“å…¥ä¸€ä¸ªæ¨¡å‹ã€‚");
                        return;
                    }

                    
                    const newConfig = {
                        provider: provider,
                        url: urlInput.value.trim(),
                        keys: config.keys, 
                        temperature: parseFloat(tempInput.value),
                        model: selectedModel 
                    };
                    
                    await AIHandler.saveApiConfig(newConfig);
                    UIManager.showToast("APIé…ç½®å·²ä¿å­˜ï¼");
                    UIManager.navigateTo('settings');
                };

                $('#fetch-models-btn').onclick = async () => {
                    const provider = providerSelect.value;
                    const apiUrlBase = urlInput.value.trim();
                    const apiKey = (config.keys[provider] && config.keys[provider][0]) || '';
                    const fetchBtn = $('#fetch-models-btn');

                    if (!apiUrlBase || !apiKey) {
                        return UIManager.showToast("è¯·å…ˆå¡«å†™API URLå¹¶è‡³å°‘æ·»åŠ ä¸€ä¸ªKey");
                    }

                    const originalBtnText = fetchBtn.innerHTML;
                    fetchBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    fetchBtn.disabled = true;
                    UIManager.showToast("æ­£åœ¨è·å–æ¨¡å‹åˆ—è¡¨...");

                    try {
                        let data;
                        if (provider === 'gemini') {
                            const geminiModelsUrl = `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`;
                            const response = await fetch(geminiModelsUrl);
                            if (!response.ok) throw new Error(`Geminiè¯·æ±‚å¤±è´¥: ${response.status}`);
                            data = await response.json();
                            if (data.models && Array.isArray(data.models)) {
                                const modelNames = data.models
                                    .map(model => model.name.replace('models/', ''))
                                    .filter(name => data.models.find(m => m.name.endsWith(name))?.supportedGenerationMethods.includes("generateContent"));
                                populateSelectWithOptions(modelNames);
                            } else {
                                throw new Error("Gemini APIè¿”å›äº†æ— æ•ˆçš„æ¨¡å‹åˆ—è¡¨æ ¼å¼");
                            }
                        } else {
                            const cleanedBase = apiUrlBase.replace(/\/v1beta\/?$|\/v1\/?$|\/chat\/completions\/?$|\/$/, '');
                            const potentialEndpoints = [`${cleanedBase}/v1/models`, `${cleanedBase}/v1beta/models`, `${cleanedBase}/models`];
                            let success = false;
                            for (const endpoint of [...new Set(potentialEndpoints)]) {
                                try {
                                    const response = await fetch(endpoint, { headers: { 'Authorization': `Bearer ${apiKey}` } });
                                    if (!response.ok) continue;
                                    data = await response.json();
                                    const modelsList = data.data || data;
                                    if (Array.isArray(modelsList)) {
                                        const modelIds = modelsList.map(model => (typeof model === 'object' ? model.id : model)).filter(Boolean);
                                        populateSelectWithOptions(modelIds);
                                        success = true;
                                        break;
                                    }
                                } catch (error) { console.warn(`ä» ${endpoint} è·å–å¤±è´¥:`, error.message); }
                            }
                            if (!success) throw new Error("æœªèƒ½è·å–åˆ°æ¨¡å‹åˆ—è¡¨ï¼Œè¯·æ£€æŸ¥URLå’ŒKeyã€‚");
                        }
                    } catch (error) {
                        console.error("è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥:", error);
                        UIManager.showToast(`è·å–å¤±è´¥: ${error.message}`);
                    } finally {
                        fetchBtn.innerHTML = originalBtnText;
                        fetchBtn.disabled = false;
                    }

                    function populateSelectWithOptions(options) {
                        if (!Array.isArray(options) || options.length === 0) {
                            throw new Error("APIè¿”å›äº†ç©ºæˆ–æ— æ•ˆçš„æ¨¡å‹åˆ—è¡¨");
                        }
                        modelSelect.innerHTML = options.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                        modelSelect.style.display = 'block';
                        modelInput.style.display = 'none';
                        UIManager.showToast(`æˆåŠŸè·å– ${options.length} ä¸ªæ¨¡å‹ï¼`);
                    }
                };
                
                updateApiFields();
            },

            async renderChatSettingsPage() {
                const contentArea = $('#chat-settings-content');
                let chatSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const defaults = {
                    id: 'chatSettings', memoryInterconnection: false, historyCharLimit: 5000,
                    showMyNameInGroup: true, showNamesInPrivate: false, showBubbleTimestamp: false,
                    bottomBarOffset: false, enterToSend: false, promptTurnFrequency: 1,
                    activeReplyInterval: 0, useBuiltinEmojis: true, useCustomEmojisInPrompt: true,
                    enablePatAPat: true,
                    summaryMessageInterval: 200,
                };
                chatSettings = { ...defaults, ...chatSettings };

                const createSwitch = (id, label, description, isChecked) => `
                    <div class="setting-item" style="padding: 15px;">
                        <div style="flex-grow: 1;">
                            <span style="font-size: 1rem; display: block; margin-bottom: 5px;">${label}</span>
                            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin: 0; line-height: 1.4;">${description}</p>
                        </div>
                        <label class="switch" style="flex-shrink: 0;"><input type="checkbox" id="${id}" ${isChecked ? 'checked' : ''}><span class="slider"></span></label>
                    </div>`;

                const createNumberInput = (label, description, inputId, initialValue, unit = '') => `
                    <div class="setting-item" style="padding: 15px;">
                        <div style="flex-grow: 1;">
                             <span style="font-size: 1rem; display: block; margin-bottom: 5px;">${label}</span>
                            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin: 0; line-height: 1.4;">${description}</p>
                        </div>
                        <div style="display: flex; align-items: center; flex-shrink: 0;">
                            <input type="number" id="${inputId}" value="${initialValue}" min="0" step="1" style="width: 70px; text-align: center; padding: 8px; margin: 0;">
                            ${unit ? `<span style="margin-left: 8px; font-size: 0.9rem;">${unit}</span>` : ''}
                        </div>
                    </div>`;
                
                contentArea.innerHTML = `
                    <div class="settings-list" style="padding:0; margin:0;">
                        ${createSwitch('memory-interconnection-switch', 'è®°å¿†äº’é€š', 'å¼€å¯åï¼Œå¥½å‹ä¼šè·å–ç›¸å…³ç¾¤èŠ+ç§èŠä½œä¸ºè®°å¿†å‚è€ƒï¼Œå¯¹è¯æ›´è¿è´¯ã€‚', chatSettings.memoryInterconnection)}
                        ${createSwitch('enable-pat-a-pat-switch', 'å¯ç”¨æ‹ä¸€æ‹åŠŸèƒ½', 'å…³é—­åï¼ŒAIå°†ä¸ä¼šæ”¶åˆ°æ‹ä¸€æ‹çš„æç¤ºï¼ŒèŠå¤©ç•Œé¢ä¹Ÿä¸ä¼šæ˜¾ç¤ºæ‹ä¸€æ‹æ¶ˆæ¯ã€‚', chatSettings.enablePatAPat)}
                        ${createSwitch('show-my-name-in-group-switch', 'ç¾¤èŠæ˜¾ç¤ºè‡ªå·±åå­—', 'å¼€å¯åï¼Œä½ åœ¨ç¾¤èŠä¸­å‘é€çš„æ¶ˆæ¯ä¸Šæ–¹ä¼šæ˜¾ç¤ºä½ çš„åå­—ã€‚', chatSettings.showMyNameInGroup)}
                        ${createSwitch('show-names-in-private-switch', 'ç§èŠæ˜¾ç¤ºåå­—', 'å¼€å¯åï¼Œç§èŠæ—¶åŒæ–¹çš„æ¶ˆæ¯ä¸Šæ–¹éƒ½ä¼šæ˜¾ç¤ºåå­—ã€‚', chatSettings.showNamesInPrivate)}
                        ${createSwitch('show-bubble-timestamp-switch', 'æ°”æ³¡æ˜¾ç¤ºæ—¶é—´', 'å¼€å¯åï¼Œåœ¨æ™®é€šæ¶ˆæ¯ã€å¼•ç”¨æ¶ˆæ¯ã€è¯­éŸ³æ¶ˆæ¯çš„æ°”æ³¡ä¸‹æ–¹æ˜¾ç¤ºå‘é€æ—¶é—´ã€‚', chatSettings.showBubbleTimestamp)}
                        ${createSwitch('bottom-bar-offset-switch', 'åº•éƒ¨çŠ¶æ€æ ä¸Šç§»', 'å¼€å¯åï¼Œä¸ºæ‰‹æœºè‡ªå¸¦çš„åº•éƒ¨å¯¼èˆªæ¡é¢„ç•™ç©ºé—´ï¼Œé˜²æ­¢é®æŒ¡ã€‚', chatSettings.bottomBarOffset)}
                        ${createSwitch('enter-to-send-switch', 'å›è½¦è‡ªåŠ¨å‘é€', 'å¼€å¯åï¼Œåœ¨è¾“å…¥æ¡†å†…æŒ‰å›è½¦é”®å°†ç›´æ¥å‘é€æ¶ˆæ¯ã€‚', chatSettings.enterToSend)}
                        ${createSwitch('use-builtin-emojis-switch', 'å†…ç½®è¡¨æƒ…åŒ…', 'å¯ç”¨åå¯ä½¿ç”¨å†…ç½®æ·»åŠ çš„è¡¨æƒ…åŒ…ï¼Œå…³é—­åæ— æ³•ä½¿ç”¨ä¸”aiå°†ä¸è·å¾—è¿™äº›è¡¨æƒ…çš„idæç¤ºã€‚å¦‚æœå…³é—­&æ²¡æœ‰è‡ªå·±æ·»åŠ çš„è¡¨æƒ…åŒ…ï¼Œaiå¯èƒ½ä¼šé¢‘ç¹å‘é€é”™è¯¯è¡¨æƒ…åŒ…', chatSettings.useBuiltinEmojis)}
                        ${createSwitch('use-custom-emojis-in-prompt-switch', 'è‡ªå®šä¹‰è¡¨æƒ…å¯ç”¨ä¸ºæç¤ºè¯', 'å¼€å¯åï¼Œä½ æ‰€æ·»åŠ çš„æ‰€æœ‰è¡¨æƒ…åŒ…idå°†æç¤ºç»™aiï¼Œä½†è¿‡å¤šçš„è¡¨æƒ…åŒ…ä¼šå½±å“å›å¤é€Ÿåº¦å’Œtk', chatSettings.useCustomEmojisInPrompt)}
                        ${createNumberInput('èŠå¤©è®°å½•å­—æ•°ä¸Šé™', 'è®¾å®šæ¯æ¬¡è¯·æ±‚AIæ—¶é™„å¸¦çš„èŠå¤©è®°å½•å­—æ•°ï¼Œå½±å“è®°å¿†å’ŒTokenæ¶ˆè€—ã€‚', 'history-char-limit-input', chatSettings.historyCharLimit, 'å­—')}
                        ${createNumberInput('æç¤ºè¯å‘é€é¢‘ç‡', 'æ¯Nä¸ªç©å®¶å›åˆå‘é€ä¸€æ¬¡å®Œæ•´Promptï¼Œä»¥èŠ‚çœTokenã€‚', 'prompt-freq-input', chatSettings.promptTurnFrequency, 'å›åˆ')}
                        ${createNumberInput('ä¸»åŠ¨å›å¤é—´éš”', 'å½“è·ç¦»AIä¸Šæ¬¡å›å¤è¶…è¿‡Nå°æ—¶åï¼Œè¿›å…¥èŠå¤©ä¼šè‡ªåŠ¨è§¦å‘AIä¸»åŠ¨å›å¤ã€‚è¾“å…¥0å¯å…³é—­ã€‚', 'active-reply-interval-input', chatSettings.activeReplyInterval, 'å°æ—¶')}
                        ${createNumberInput('è‡ªåŠ¨æ€»ç»“é—´éš”', 'æ¯éš”Næ¡æ¶ˆæ¯ï¼ˆåŒ…å«ä½ å’ŒAIï¼‰ï¼Œè‡ªåŠ¨æ€»ç»“ä¸€æ¬¡èŠå¤©å†…å®¹ã€‚è¾“å…¥0å¯å…³é—­ã€‚', 'summary-interval-input', chatSettings.summaryMessageInterval, 'æ¡')}
                    </div>`;
            },
            
            async handleSaveChatSettings() {
                const newSettings = {
                    id: 'chatSettings',
                    memoryInterconnection: $('#memory-interconnection-switch').checked,
                    enablePatAPat: $('#enable-pat-a-pat-switch').checked,
                    historyCharLimit: parseInt($('#history-char-limit-input').value, 10),
                    showMyNameInGroup: $('#show-my-name-in-group-switch').checked,
                    showNamesInPrivate: $('#show-names-in-private-switch').checked,
                    showBubbleTimestamp: $('#show-bubble-timestamp-switch').checked,
                    bottomBarOffset: $('#bottom-bar-offset-switch').checked,
                    enterToSend: $('#enter-to-send-switch').checked,
                    useBuiltinEmojis: $('#use-builtin-emojis-switch').checked,
                    useCustomEmojisInPrompt: $('#use-custom-emojis-in-prompt-switch').checked,
                    promptTurnFrequency: parseInt($('#prompt-freq-input').value, 10),
                    activeReplyInterval: parseInt($('#active-reply-interval-input').value, 10),
                    summaryMessageInterval: parseInt($('#summary-interval-input').value, 10),
                };
                await DBHelper.put('apiConfig', newSettings);
                this.applyChatSettings(newSettings);
                UIManager.showToast("èŠå¤©è®¾ç½®å·²ä¿å­˜ï¼");
                UIManager.navigateTo('settings');
            },
            
            applyChatSettings(settings) {
                
                appContainer.classList.toggle('bottom-offset-active', settings.bottomBarOffset);
                appContainer.classList.toggle('show-bubble-timestamps', settings.showBubbleTimestamp);
            },

            
            async handleForwardMoment(momentId) {
                const allMetadata = await DBHelper.getAll('chatMetadata');
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');

                const recentConversations = allMetadata
                    .filter(meta => meta.lastMessage) //ç¡®ä¿æœ‰èŠå¤©è®°å½•
                    .sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);

                if (recentConversations.length === 0) {
                    UIManager.showModal({
                        title: "è½¬å‘åŠ¨æ€",
                        body: `<p style="text-align: center; color: #aaa; padding: 20px 0;">æœ€è¿‘æ²¡æœ‰æ–°çš„èŠå¤©ä¼šè¯ï¼Œ<br>å»å’Œå¥½å‹ä»¬å¼€å¯ä¸€ä¸ªèŠå¤©çª—å£å§ï¼</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const conversationDetails = recentConversations.map(meta => {
                    let details;
                    if (meta.chatId.startsWith('group-')) {
                        details = groups.find(g => g.id === meta.chatId);
                    } else {
                        details = contacts.find(c => c.id === meta.chatId);
                    }
                    return details ? { ...details, chatId: meta.chatId } : null;
                }).filter(Boolean);

                const chatListHtml = conversationDetails.map(item => `
                    <label class="member-select-item" data-name="${(item.remark || item.name).toLowerCase()}">
                        <input type="radio" name="forward-target" value="${item.chatId}">
                        <img src="${item.avatar}" class="contact-item-avatar" style="width:40px;height:40px;margin-right:10px; border-radius: 8px;">
                        <span>${item.remark || item.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "è½¬å‘ç»™",
                    body: `
                        <input type="text" id="forward-target-search" class="forward-target-search-bar" placeholder="æœç´¢è”ç³»äººæˆ–ç¾¤èŠ...">
                        <div class="member-select-list" style="max-height: 40vh;">${chatListHtml}</div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å‘é€', class: 'btn-primary', handler: async () => {
                            const selectedRadio = $('input[name="forward-target"]:checked');
                            if (!selectedRadio) {
                                UIManager.showToast("è¯·é€‰æ‹©ä¸€ä¸ªèŠå¤©");
                                return;
                            }
                            const targetChatId = selectedRadio.value;

                            const moment = await DBHelper.get('moments', momentId);
                            const momentAuthor = await this.getMomentAuthor(moment.authorId, moment.circleId);

                            const circle = await DBHelper.get('circles', moment.circleId);
                            const baseProfile = await DBHelper.get('profile', 'myProfile');
                            let correctCircleProfile = { ...baseProfile };
                            if (circle && circle.boundPersonaPresetId) {
                                const presets = baseProfile.presets || [];
                                const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                                if (boundPreset) {
                                    correctCircleProfile = { ...baseProfile, ...boundPreset };
                                }
                            }

                            const aiContent = await this.buildForwardedMomentAIContent(moment, momentAuthor, correctCircleProfile);

                            const finalAuthorNameForCard = (moment.authorId === 'myProfile')
                                ? correctCircleProfile.name
                                : momentAuthor.name;

                            const cardData = {
                                momentId: moment.id,
                                authorName: finalAuthorNameForCard,
                                preview: moment.content,
                            };

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: aiContent,
                                type: 'sent',
                                segmentType: 'moment_forward',
                                cardData: cardData
                            };
                            
                            const originalChatId = appState.currentChatId;
                            const originalPage = appState.currentPage;

                            appState.currentChatId = targetChatId; 
                            await this.handlePlayerSendMessage(message);
                            
                            appState.currentChatId = originalChatId;
                            appState.currentPage = originalPage;

                            UIManager.hideModal();
                            UIManager.showToast(`å·²è½¬å‘ç»™ ${conversationDetails.find(c => c.chatId === targetChatId).name}`);
                            await UIManager.renderMessagesListPage();
                        }}
                    ]
                });
                
                $('#forward-target-search').addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    $$('.member-select-item').forEach(item => {
                        item.style.display = item.dataset.name.includes(searchTerm) ? 'flex' : 'none';
                    });
                });
            },

            async confirmDeleteMoment(momentId, postElement) {
                UIManager.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('moments', momentId);
                            postElement.remove();
                            UIManager.hideModal();
                            UIManager.showToast('åŠ¨æ€å·²åˆ é™¤');
                        }}
                    ]
                });
            },

            async getMomentAuthor(authorId, contextId = null) {
                const myProfile = await this.getPlayerProfileForContext(contextId);
                if (authorId === myProfile.id) {
                    return { name: myProfile.name, avatar: myProfile.avatar };
                }
                const contact = await DBHelper.get('contacts', authorId);
                if (contact) {
                    return { name: contact.name, avatar: contact.avatar };
                }
                return { name: authorId, avatar: Utils.createAvatarDataUrl('#ccc') };
            },

            async buildForwardedMomentAIContent(moment, author, myProfile) {
                const allContacts = await DBHelper.getAll('contacts');
                const circle = await DBHelper.get('circles', moment.circleId);

                
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let correctMyProfile = { ...baseProfile }; 
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        
                        correctMyProfile = { ...baseProfile, ...boundPreset };
                    }
                }

                
                const allPlayerNames = [baseProfile.name];
                if (baseProfile.presets && Array.isArray(baseProfile.presets)) {
                    baseProfile.presets.forEach(p => {
                        if (p && p.name) allPlayerNames.push(p.name);
                    });
                }
                const uniquePlayerNames = [...new Set(allPlayerNames)];

                let likesText = 'æ— ';
                if (moment.likes && moment.likes.length > 0) {
                    const updatedLikes = moment.likes.map(likerName => {
                        
                        if (uniquePlayerNames.includes(likerName)) {
                            return correctMyProfile.name;
                        }
                        return likerName;
                    });
                    
                    likesText = [...new Set(updatedLikes)].join(', ');
                }

                let commentsText = 'æ— ';
                if (moment.comments && moment.comments.length > 0) {
                    commentsText = '\n' + moment.comments.map(c => {
                        let cAuthorName = 'æœªçŸ¥';
                        if (c.authorId === correctMyProfile.id) {
                            cAuthorName = correctMyProfile.name;
                        } else {
                            const contact = allContacts.find(con => con.id === c.authorId);
                            cAuthorName = contact ? (contact.name || c.authorId) : c.authorId;
                        }

                        let replyToName = c.replyTo || '';
                        
                        if (replyToName && uniquePlayerNames.includes(replyToName)) {
                            replyToName = correctMyProfile.name;
                        }

                        const replyText = replyToName ? ` å›å¤ ${replyToName}` : '';
                        return `${cAuthorName}${replyText}: ${c.content}`;
                    }).join('\n');
                }

                const imageDescription = moment.images && moment.images.length > 0
                    ? ` [å›¾ç‰‡ï¼šåŒ…å«${moment.images.length}å¼ å›¾ç‰‡çš„åŠ¨æ€]`
                    : '';

                return `<è½¬å‘åŠ¨æ€>
åŠ¨æ€ä½œè€…ï¼š${author.name}
åŠ¨æ€å†…å®¹ï¼š${moment.content}${imageDescription}
åŠ¨æ€æ—¶é—´ï¼š${Utils.formatTimestampSmartly(moment.timestamp)}
ç‚¹èµæƒ…å†µï¼š${likesText}
è¯„è®ºåŒºï¼š${commentsText}
</è½¬å‘åŠ¨æ€>`;
            },

            async showForwardedMomentDetail(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) {
                    UIManager.showToast("è¯¥åŠ¨æ€å¯èƒ½å·²è¢«åˆ é™¤");
                    return;
                }

                const allContacts = await DBHelper.getAll('contacts');

                
                const circle = await DBHelper.get('circles', moment.circleId);
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let correctMyProfile = { ...baseProfile }; 
                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        
                        correctMyProfile = { ...baseProfile, ...boundPreset };
                    }
                }
                

                
                let author;
                if (moment.authorId === 'myProfile') {
                    author = { name: correctMyProfile.name, avatar: correctMyProfile.avatar };
                } else {
                    
                    const contactAuthor = allContacts.find(c => c.id === moment.authorId);
                    if (contactAuthor) {
                        author = contactAuthor;
                    } else if (circle && circle.extraMembers && circle.extraMembers.includes(moment.authorId)) {
                        author = { id: moment.authorId, name: moment.authorId, avatar: Utils.createAvatarDataUrl(Utils.getRandomColor()) };
                    } else {
                        author = { id: moment.authorId, name: 'æœªçŸ¥ç”¨æˆ·', avatar: Utils.createAvatarDataUrl('#ccc') };
                    }
                }
                

                let likesHtml = '';
                if (moment.likes && moment.likes.length > 0) {
                    likesHtml = `<div class="likes-list"><i class="fas fa-heart"></i> ${moment.likes.join(', ')}</div>`;
                }

                let commentsHtml = '';
                if (moment.comments && moment.comments.length > 0) {
                    commentsHtml = moment.comments.map(comment => {
                        let cAuthorName = 'æœªçŸ¥ç”¨æˆ·';
                        
                        if (comment.authorId === correctMyProfile.id) {
                            cAuthorName = correctMyProfile.name;
                        } else {
                            const contact = allContacts.find(c => c.id === comment.authorId);
                            cAuthorName = contact ? contact.name : comment.authorId;
                        }

                        const replyHtml = comment.replyTo 
                            ? `<span class="comment-reply-to"> å›å¤ </span><span class="comment-author">${comment.replyTo}</span>` 
                            : '';
                        return `<div class="comment-item"><span class="comment-author">${cAuthorName}</span>${replyHtml}: ${comment.content}</div>`;
                    }).join('');
                }

                const imagesHtml = moment.images && moment.images.length > 0
                    ? `<div class="post-image-grid">${moment.images.map(src => `<img src="${src}" alt="åŠ¨æ€å›¾ç‰‡">`).join('')}</div>`
                    : '';

                const modalBody = `
                    <div class="moment-detail-wrapper">
                        <div class="post-header">
                            <img src="${author.avatar}" alt="${author.name} å¤´åƒ" class="post-avatar">
                            <div class="post-author-info">
                                <span class="name">${author.name}</span>
                            </div>
                        </div>
                        <div class="post-content-full">${moment.content}</div>
                        ${imagesHtml}
                        <div class="post-footer-full">
                            <span class="timestamp">${Utils.formatTimestampSmartly(moment.timestamp)}</span>
                        </div>
                        ${(likesHtml || commentsHtml) ? `
                        <div class="interactions-section">
                            ${likesHtml}
                            <div class="comments-list">${commentsHtml}</div>
                        </div>
                        ` : ''}
                    </div>
                `;

                UIManager.showModal({
                    title: "æœ‹å‹åœˆåŠ¨æ€",
                    body: modalBody,
                    actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async showCustomForwardDetail(messageId) {
                const msg = await DBHelper.get('messages', messageId);
                if (!msg || !msg.cardData) {
                    UIManager.showToast("æ— æ³•åŠ è½½è½¬å‘å†…å®¹");
                    return;
                }

                
                const myProfile = await this.getPlayerProfileForContext(msg.chatId);
                let sender;
                if (msg.type === 'sent') {
                    sender = myProfile;
                } else {
                    sender = await DBHelper.get('contacts', msg.senderId) || { name: 'æœªçŸ¥å‘ä»¶äºº' };
                }

                const { title, content } = msg.cardData;

                const parsedContent = marked.parse(content, { breaks: true });

                const modalBody = `
                    <style>
                        .forward-detail-card {
                            background: rgba(247, 248, 250, 0.8);
                            backdrop-filter: blur(5px);
                            border: 1px solid var(--border-color);
                            border-radius: 16px;
                            padding: 20px;
                            margin: -10px; /* æŠµæ¶ˆä¸€äº›é»˜è®¤çš„modalå†…è¾¹è·ï¼Œè®©å¡ç‰‡æ„Ÿæ›´å¼º */
                        }
                        .forward-detail-title {
                            text-align: center;
                            font-size: 1.2rem; /* å­—ä½“å˜å° */
                            font-weight: 600;
                            color: var(--text-color-dark);
                            margin-bottom: 15px;
                        }
                        .forward-detail-separator {
                            height: 1px;
                            background: var(--border-color);
                            margin: 15px auto;
                            width: 80%;
                        }
                        .forward-detail-content {
                            line-height: 1.8;
                            font-size: 0.95rem;
                            color: var(--text-color-medium);
                            white-space: normal;
                        }
                        .forward-detail-footer {
                            text-align: right;
                            font-size: 0.75rem;
                            color: var(--text-color-light);
                            margin-top: 20px;
                            border-top: 1px solid var(--border-color);
                            padding-top: 10px;
                        }
                    </style>
                    <div class="forward-detail-card">
                        <h3 class="forward-detail-title">${title}</h3>
                        <div class="forward-detail-separator"></div>
                        <div class="forward-detail-content">
                            ${parsedContent}
                        </div>
                        <div class="forward-detail-footer">
                            <span>æ¥è‡ª ${sender.name} çš„è½¬å‘</span>
                        </div>
                    </div>
                `;

                UIManager.showModal({
                    title: `è½¬å‘`, 
                    body: modalBody,
                    actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

handleClickEffect(e) {
    const pos = appContainer.getBoundingClientRect();
    const x = e.clientX - pos.left;
    const y = e.clientY - pos.top;

    
    const ripple = document.createElement('div');
    ripple.className = 'ripple';
    clickEffectLayer.appendChild(ripple);

    const rippleSize = 80;
    ripple.style.width = ripple.style.height = `${rippleSize}px`;
    ripple.style.left = `${x - rippleSize / 2}px`;
    ripple.style.top = `${y - rippleSize / 2}px`;
    ripple.addEventListener('animationend', () => {
        ripple.remove();
    });
},

            async handleOpenGroupManagementSidebar(groupId) {
                const group = await DBHelper.get('groups', groupId);
                if (group) {
                    UIManager.showGroupManagementSidebar(group);
                }
            },

            async handleOpenFriendManagementSidebar(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (contact) {
                    UIManager.showFriendManagementSidebar(contact);
                }
            },

            async showEditFriendModal(contactId, onSaveCallback = null) { 
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                UIManager.showModal({
                    isPersistent: true, 
                    title: "ä¿®æ”¹å¥½å‹ä¿¡æ¯",
                    body: `
                        <div class="form-group">
                            <label>å¤´åƒ</label>
                            <div class="avatar-uploader">
                                <img src="${contact.avatar}" id="edit-friend-avatar-preview" class="avatar-preview">
                                <input type="file" id="edit-friend-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('edit-friend-avatar-input').click()">ä¸Šä¼ æ–°å¤´åƒ</button>
                            </div>
                        </div>
                        <div class="form-group"><label>å§“å (ID, ä¸å¯ä¿®æ”¹)</label><input type="text" value="${contact.name}" disabled></div>
                        <div class="form-group"><label for="edit-friend-remark">å¤‡æ³¨</label><input type="text" id="edit-friend-remark" value="${contact.remark || ''}"></div>
                        <div class="form-group"><label for="edit-friend-gender">æ€§åˆ«</label><select id="edit-friend-gender"><option value="ç”·" ${contact.gender === 'ç”·' ? 'selected' : ''}>ç”·</option><option value="å¥³" ${contact.gender === 'å¥³' ? 'selected' : ''}>å¥³</option><option value="å…¶ä»–" ${contact.gender === 'å…¶ä»–' ? 'selected' : ''}>å…¶ä»–</option></select></div>
                        <div class="form-group">
                            <label for="edit-friend-allow-retraction">å…è®¸æ’¤å›æ¶ˆæ¯</label>
                            <select id="edit-friend-allow-retraction">
                                <option value="true" ${contact.allowRetraction !== false ? 'selected' : ''}>å¼€å¯</option>
                                <option value="false" ${contact.allowRetraction === false ? 'selected' : ''}>å…³é—­</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="edit-friend-allow-emoji">å…è®¸å‘é€è¡¨æƒ…åŒ…</label>
                            <select id="edit-friend-allow-emoji">
                                <option value="on" ${!contact.allowEmoji || contact.allowEmoji === 'on' ? 'selected' : ''}>å¼€å¯</option>
                                <option value="off" ${contact.allowEmoji === 'off' ? 'selected' : ''}>å…³é—­</option>
                                <option value="prob" ${contact.allowEmoji === 'prob' ? 'selected' : ''}>æ¦‚ç‡</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="edit-friend-allow-active-reply">å…è®¸ä¸»åŠ¨å›å¤</label>
                            <select id="edit-friend-allow-active-reply">
                                <option value="true" ${contact.allowActiveReply !== false ? 'selected' : ''}>éµå¾ªèŠå¤©è®¾ç½®</option>
                                <option value="false" ${contact.allowActiveReply === false ? 'selected' : ''}>å…³é—­</option>
                            </select>
                        </div>
                        <div class="form-group"><label for="edit-friend-likes">å–œå¥½</label><textarea id="edit-friend-likes">${contact.likes || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-dislikes">åŒæ¶</label><textarea id="edit-friend-dislikes">${contact.dislikes || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-habits">ä¹ æƒ¯</label><textarea id="edit-friend-habits">${contact.habits || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-pat-action">æ‹ä¸€æ‹åŠ¨ä½œ (5å­—ä»¥å†…)</label><input type="text" id="edit-friend-pat-action" value="${contact.patAction || ''}" maxlength="5"></div>
                        <div class="form-group"><label for="edit-friend-pat-content">æ‹ä¸€æ‹å†…å®¹ (20å­—ä»¥å†…)</label><input type="text" id="edit-friend-pat-content" value="${contact.patContent || ''}" maxlength="20"></div>
                        <div class="form-group"><label for="edit-friend-background">èƒŒæ™¯èµ„æ–™</label><textarea id="edit-friend-background">${contact.background || ''}</textarea></div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const updatedContact = {
                                ...contact,
                                avatar: $('#edit-friend-avatar-preview').src,
                                remark: $('#edit-friend-remark').value.trim(),
                                gender: $('#edit-friend-gender').value,
                                allowRetraction: $('#edit-friend-allow-retraction').value === 'true',
                                allowEmoji: $('#edit-friend-allow-emoji').value,
                                allowActiveReply: $('#edit-friend-allow-active-reply').value === 'true',
                                likes: $('#edit-friend-likes').value.trim(),
                                dislikes: $('#edit-friend-dislikes').value.trim(),
                                habits: $('#edit-friend-habits').value.trim(),
                                patAction: $('#edit-friend-pat-action').value.trim(),
                                patContent: $('#edit-friend-pat-content').value.trim(),
                                background: $('#edit-friend-background').value.trim()
                            };
                            await DBHelper.put('contacts', updatedContact);
                            chatTitle.textContent = updatedContact.remark || updatedContact.name;
                            UIManager.hideModal();
                            
                            if (typeof onSaveCallback === 'function') {
                                onSaveCallback(updatedContact);
                            } else {
                                UIManager.showFriendManagementSidebar(updatedContact); 
                            }
                        }}
                    ]
                });
                
                $('#edit-friend-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) $('#edit-friend-avatar-preview').src = await Utils.fileToBase64(file);
                });
            },
            async importOpeningScenes(scenes, newEntityId, isGroup) {
                if (!scenes || !Array.isArray(scenes) || scenes.length === 0) return;
                for (const scene of scenes) {
                    const newScene = { ...scene, id: Utils.generateId('scene') };
                    if (isGroup) {
                        newScene.groupId = newEntityId;
                        delete newScene.contactId;
                    } else {
                        newScene.contactId = newEntityId;
                        delete newScene.groupId;
                    }
                    await DBHelper.put('openingScenes', newScene);
                }
            },
            
            handleClearChatHistory(chatId, isGroup) {
                const entityName = isGroup ? 'ç¾¤èŠ' : 'å¥½å‹';
                UIManager.showModal({
                    title: `æ¸…ç©ºèŠå¤©è®°å½•`,
                    body: `<p>ç¡®å®šè¦æ¸…ç©ºä¸è¯¥${entityName}çš„æ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤æ¸…ç©º', class: 'btn-danger', handler: async () => {
                            await DBHelper.deleteMessagesForChat(chatId);
                            
                            await DBHelper.delete('chatMetadata', chatId);
                            
                            
                            const storeName = isGroup ? 'groups' : 'contacts';
                            const entity = await DBHelper.get(storeName, chatId);
                            if (entity) {
                                entity.autoSummary = '';
                                if ('totalPlayerTurns' in entity) {
                                    entity.totalPlayerTurns = 0;
                                }
                                await DBHelper.put(storeName, entity);
                            }
                            
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            
                            
                            if (appState.currentChatId === chatId) {
                                await UIManager.refreshChatView();
                            }
                            
                            await UIManager.renderMessagesListPage();
                            UIManager.showToast("èŠå¤©è®°å½•å·²æ¸…ç©º");
                        }}
                    ]
                });
            },
            handleOpeningSceneSettings(entityId, isGroup) {
                UIManager.showOpeningSceneModal(entityId, isGroup);
            },

handleAutoSummarySettings(entityId, isGroup) {
    UIManager.showAutoSummaryModal(entityId, isGroup);
},

handleImmediateSummary(entityId, isGroup) {
    if (appState.isSummarizing[entityId]) {
        UIManager.showToast("æ­£åœ¨æ€»ç»“ä¸­ï¼Œè¯·ç¨å€™...");
        return;
    }
    
    UIManager.hideModal(); 
    
    AIHandler.handleAutoSummaryRequest(entityId);
},
            handleNewOpeningScene(entityId, isGroup) {
                UIManager.showModal({
                    isPersistent: true,
                    title: "æ–°å»ºå¼€åœºç™½",
                    body: `
                        <div class="form-group">
                            <label for="scene-name">å¼€åœºç™½åç§°</label>
                            <input type="text" id="scene-name" placeholder="ä¾‹å¦‚ï¼šåˆæ¬¡è§é¢çš„é—®å€™">
                        </div>
                        <div class="form-group">
                            <label for="scene-content">å¼€åœºç™½å†…å®¹</label>
                            <textarea id="scene-content" rows="6" placeholder="è¯¦ç»†æè¿°å¼€åœºæ—¶çš„æƒ…æ™¯ã€è§’è‰²çš„çŠ¶æ€å’Œç¬¬ä¸€å¥å¯¹è¯ç­‰..."></textarea>
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 10px;">æç¤ºï¼šå¼€åœºç™½å†…å®¹å°†ä»…åº”ç”¨äºå½“å‰${isGroup ? 'ç¾¤èŠ' : 'ç§èŠ'}ï¼Œä¸ä¼šå½±å“å…¶ä»–èŠå¤©ã€‚</p>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(entityId, isGroup) },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const name = $('#scene-name').value.trim();
                            const content = $('#scene-content').value.trim();
                            if (!name || !content) return;
                            const newScene = { id: Utils.generateId('scene'), name, content };
                            if (isGroup) {
                                newScene.groupId = entityId;
                            } else {
                                newScene.contactId = entityId;
                            }
                            await DBHelper.put('openingScenes', newScene);
                            UIManager.showOpeningSceneModal(entityId, isGroup);
                        }}
                    ]
                });
            },

            handleEditOpeningScene(scene, isGroup) {
                UIManager.showModal({
                    isPersistent: true, 
                    title: "ç¼–è¾‘å¼€åœºç™½",
                    body: `
                        <div class="form-group">
                            <label for="scene-name">å¼€åœºç™½åç§°</label>
                            <input type="text" id="scene-name" value="${scene.name}">
                        </div>
                        <div class="form-group">
                            <label for="scene-content">å¼€åœºç™½å†…å®¹</label>
                            <textarea id="scene-content" rows="6">${scene.content}</textarea>
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 10px;">æç¤ºï¼šå¼€åœºç™½å†…å®¹å°†ä»…åº”ç”¨äºå½“å‰${isGroup ? 'ç¾¤èŠ' : 'ç§èŠ'}ï¼Œä¸ä¼šå½±å“å…¶ä»–èŠå¤©ã€‚</p>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup) },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const updatedScene = {
                                ...scene,
                                name: $('#scene-name').value.trim(),
                                content: $('#scene-content').value.trim()
                            };
                            await DBHelper.put('openingScenes', updatedScene);
                            UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup);
                        }}
                    ]
                });
            },

            handleDeleteOpeningScene(sceneId, entityId, isGroup) {
                UIManager.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¼€åœºç™½å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(entityId, isGroup) },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('openingScenes', sceneId);
                            UIManager.showOpeningSceneModal(entityId, isGroup);
                        }}
                    ]
                });
            },

            handleApplyOpeningScene(scene) {
                UIManager.showModal({
                    title: "åº”ç”¨å¼€åœºç™½",
                    body: `<p>åº”ç”¨å¼€åœºç™½å°†ä¼šæ¸…ç©ºå½“å‰èŠå¤©è®°å½•ï¼Œå¹¶ç”±AIæ ¹æ®å¼€åœºç™½å†…å®¹å¼€å§‹æ–°çš„å¯¹è¯ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => {
                            const isGroup = !!scene.groupId;
                            UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup);
                        }},
                        { text: 'ç¡®å®šåº”ç”¨', class: 'btn-primary', handler: async () => {
                            const chatId = scene.groupId || scene.contactId;
                            
                            UIManager.hideSidebar(); 
                            UIManager.hideModal();

                            
                            await DBHelper.deleteMessagesForChat(chatId);
                            await DBHelper.delete('chatMetadata', chatId);

                            
                            const isGroup = !!scene.groupId;
                            const storeName = isGroup ? 'groups' : 'contacts';
                            const entity = await DBHelper.get(storeName, chatId);
                            if (entity) {
                                entity.autoSummary = ''; 
                                if ('totalPlayerTurns' in entity) {
                                    entity.totalPlayerTurns = 0; 
                                }
                                await DBHelper.put(storeName, entity);
                            }
                            
                            
                            
                            if (appState.currentChatId === chatId) {
                                await UIManager.refreshChatView();
                            }
                            
                            
                            await AIHandler.handleOpeningSceneRequest(scene);
                        }}
                    ]
                });
            },

            async handleTransferClick(msg) {
                const myProfile = await this.getPlayerProfileForContext(appState.currentChatId);
                let senderContact;

                if (msg.type === 'sent') {
                    senderContact = myProfile;
                } else {
                    senderContact = await DBHelper.get('contacts', msg.senderId);
                }

                if (!senderContact) {
                    console.error("æ— æ³•æ‰¾åˆ°è½¬è´¦å‘é€æ–¹ä¿¡æ¯:", msg);
                    UIManager.showToast("æ— æ³•åŠ è½½è½¬è´¦è¯¦æƒ…ï¼Œå‘é€æ–¹ä¿¡æ¯ä¸¢å¤±ã€‚");
                    return;
                }

                const isRecipientPlayer = msg.cardData.recipientName === myProfile.name;
                const canReturn = isRecipientPlayer && !msg.cardData.isClaimed; 

                UIManager.showModal({
                    title: "è½¬è´¦è¯¦æƒ…",
                    body: `
                        <div style="text-align: center;">
                            <img src="${senderContact.avatar}" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; margin-bottom: 10px;">
                            <h4 style="margin-bottom: 5px;">æ¥è‡ª ${senderContact.remark || senderContact.name} çš„è½¬è´¦</h4>
                            <p style="font-size: 2rem; font-weight: bold; margin: 15px 0;">${msg.cardData.amount}</p>
                            ${msg.cardData.note ? `<p style="color: #888;">å¤‡æ³¨ï¼š${msg.cardData.note}</p>` : ''}
                        </div>
                    `,
                    actions: [
                        { text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        {
                            text: 'é€€å›',
                            class: `btn-secondary ${!canReturn ? 'disabled' : ''}`, 
                            handler: async () => {
                                
                                if (!canReturn) {
                                    UIManager.showToast("åªæœ‰æ”¶æ¬¾æ–¹æ‰èƒ½é€€è¿˜æœªå¤„ç†çš„è½¬è´¦");
                                    return;
                                }

                                const msgToUpdate = await DBHelper.get('messages', msg.messageId);
                                if (msgToUpdate) {
                                    msgToUpdate.cardData.isClaimed = true; 
                                    await DBHelper.put('messages', msgToUpdate);
                                }

                                const returnMsg = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: appState.currentChatId,
                                    timestamp: Date.now(),
                                    type: 'sent',
                                    segmentType: 'transfer-return',
                                    content: `[${myProfile.name}|é€€è¿˜è½¬è´¦|${senderContact.name}|${msg.cardData.amount}]`,
                                    cardData: {
                                        recipientName: senderContact.name,
                                        senderName: myProfile.name,
                                        amount: msg.cardData.amount
                                    }
                                };
                                await DBHelper.put('messages', returnMsg);
                                await UIManager.updateChatMetadata(appState.currentChatId, returnMsg);

                                const originalBubble = $(`#${msg.messageId} .bubble`);
                                if (originalBubble) originalBubble.classList.add('claimed');
                                UIManager.addMessageToDOM(returnMsg, myProfile);
                                UIManager.hideModal();
                            }
                        },
                        {
                            text: 'æ”¶æ¬¾',
                            class: `btn-primary ${!isRecipientPlayer || msg.cardData.isClaimed ? 'disabled' : ''}`, 
                            handler: async () => {
                                
                                if (!isRecipientPlayer) {
                                    UIManager.showToast('ä½ ä¸æ˜¯è¯¥è½¬è´¦çš„æ”¶æ¬¾å¯¹è±¡');
                                    return;
                                }
                                if (msg.cardData.isClaimed) {
                                    UIManager.showToast('è¯¥è½¬è´¦å·²è¢«å¤„ç†');
                                    return;
                                }

                                const msgToUpdate = await DBHelper.get('messages', msg.messageId);
                                if (msgToUpdate) {
                                    msgToUpdate.cardData.isClaimed = true;
                                    await DBHelper.put('messages', msgToUpdate);
                                }

                                const receiptMsg = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: appState.currentChatId,
                                    timestamp: Date.now(),
                                    type: 'sent',
                                    segmentType: 'transfer-receipt',
                                    content: `${myProfile.name}å·²æ”¶æ¬¾`,
                                    cardData: {
                                        recipientName: myProfile.name,
                                        senderName: senderContact.name,
                                        amount: msg.cardData.amount
                                    }
                                };
                                await DBHelper.put('messages', receiptMsg);
                                await UIManager.updateChatMetadata(appState.currentChatId, receiptMsg);

                                const originalBubble = $(`#${msg.messageId} .bubble`);
                                if (originalBubble) originalBubble.classList.add('claimed');
                                UIManager.addMessageToDOM(receiptMsg, myProfile);
                                UIManager.hideModal();
                            }
                        }
                    ]
                });
            },

            async handleRedPacketClick(msg) {
                const myProfile = await this.getPlayerProfileForContext(appState.currentChatId);
                let senderContact; 

                
                if (msg.type === 'sent') {
                    
                    senderContact = myProfile;
                } else {
                    
                    senderContact = await DBHelper.get('contacts', msg.senderId);
                }

                
                if (!senderContact) {
                    console.error("æ— æ³•æ‰¾åˆ°çº¢åŒ…å‘é€æ–¹ä¿¡æ¯:", msg);
                    UIManager.showToast("æ— æ³•åŠ è½½çº¢åŒ…è¯¦æƒ…ï¼Œå‘é€æ–¹ä¿¡æ¯ä¸¢å¤±ã€‚");
                    return;
                }
                
                
                const modalStyle = `
                    <style>
                        .rp-modal-body { text-align: center; padding: 20px 0; }
                        .rp-modal-body img { width: 60px; height: 60px; border-radius: 8px; margin-bottom: 10px; }
                        .rp-modal-body h4 { font-size: 1.2rem; margin-bottom: 5px; }
                        .rp-modal-body p { color: var(--text-color-light); margin-bottom: 30px; }
                        .rp-open-btn {
                            width: 80px; height: 80px; border-radius: 50%;
                            background-color: #F8C34A; color: white;
                            border: 3px solid #F5A623; font-size: 2rem;
                            cursor: pointer; animation: rp-pulse 1.5s infinite;
                            box-shadow: 0 4px 10px rgba(248, 195, 74, 0.5);
                        }
                        @keyframes rp-pulse { 0% { transform: scale(0.95); } 70% { transform: scale(1.05); } 100% { transform: scale(0.95); } }
                        .rp-amount { font-size: 2.5rem; font-weight: bold; margin-bottom: 10px; }
                        .rp-claimed-info { font-size: 0.9rem; color: var(--text-color-medium); }
                    </style>
                `;

                
                UIManager.showModal({
                    title: " ", 
                    body: `
                        ${modalStyle}
                        <div class="rp-modal-body" id="rp-pre-claim">
                            <img src="${senderContact.avatar}" alt="avatar">
                            <h4>${senderContact.remark || senderContact.name} çš„çº¢åŒ…</h4>
                            <p>${msg.cardData.title}</p>
                            <button class="rp-open-btn">å¼€</button>
                        </div>
                    `,
                    actions: [{ text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });

                
                modalContentWrapper.querySelector('.rp-open-btn').onclick = async () => {
                    

                    if (msg.type === 'sent') {
                        UIManager.showToast("ä¸èƒ½é¢†å–è‡ªå·±å‘çš„çº¢åŒ…å“¦");
                        return;
                    }
                    
                    const isGroupChat = appState.currentChatId.startsWith('group-');
                    let receivedAmount = 0;
                    
                    if (isGroupChat) {
                        
                        if (msg.cardData.count === 1) {
                            receivedAmount = msg.cardData.amount;
                        } else {
                            
                            const remainingAmount = msg.cardData.amount;
                            const remainingCount = msg.cardData.count - msg.cardData.claimedBy.length;
                            const maxReceive = remainingAmount - (remainingCount - 1) * 0.01;
                            receivedAmount = Math.random() * (maxReceive - 0.01) + 0.01;
                        }
                    } else {
                        receivedAmount = msg.cardData.amount;
                    }

                    
                    const msgToUpdate = await DBHelper.get('messages', msg.messageId);
                    if (msgToUpdate) {
                        msgToUpdate.cardData.isClaimedByPlayer = true;
                        if (!Array.isArray(msgToUpdate.cardData.claimedBy)) {
                             msgToUpdate.cardData.claimedBy = [];
                        }
                        msgToUpdate.cardData.claimedBy.push(myProfile.id);
                        await DBHelper.put('messages', msgToUpdate);
                    }

                    
                    const originalBubble = $(`#${msg.messageId} .bubble`);
                    if(originalBubble) originalBubble.classList.add('claimed');

                    
                    const notice = document.createElement('div');
                    notice.className = 'time-divider';
                    notice.textContent = `${myProfile.name} é¢†å–äº† ${senderContact.remark || senderContact.name} çš„çº¢åŒ…`;
                    chatArea.appendChild(notice);
                    chatArea.scrollTop = chatArea.scrollHeight;
                    
                    
                    const modalBody = modalContentWrapper.querySelector('.modal-body');
                    modalBody.innerHTML = `
                        ${modalStyle}
                        <div class="rp-modal-body" id="rp-post-claim">
                            <p class="rp-amount">ï¿¥${receivedAmount.toFixed(2)}</p>
                            <p class="rp-claimed-info">å·²å­˜å…¥é›¶é’±ï¼Œå¯ç›´æ¥ä½¿ç”¨</p>
                        </div>
                    `;
                };
            },

            async handleInviteMembers(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                
                const availableFriends = allContacts.filter(c => !group.members.includes(c.id));

                if (availableFriends.length === 0) {
                    UIManager.showModal({
                        title: "é‚€è¯·æˆå‘˜",
                        body: `<p>æ²¡æœ‰å¯é‚€è¯·çš„å¥½å‹äº†ï¼Œæ‰€æœ‰å¥½å‹éƒ½å·²åœ¨ç¾¤èŠä¸­ã€‚</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const memberListHtml = availableFriends.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="invite-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é‚€è¯·æ–°æˆå‘˜",
                    body: `<div class="member-select-list">${memberListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'é‚€è¯·', class: 'btn-primary', handler: async () => {
                            const newMemberIds = [...$$('input[name="invite-members"]:checked')].map(cb => cb.value);
                            if (newMemberIds.length === 0) return;

                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            const invitedNames = (await Promise.all(newMemberIds.map(id => DBHelper.get('contacts', id)))).map(c => c.remark || c.name).join('ã€');
                            
                            
                            group.members.push(...newMemberIds);
                            await DBHelper.put('groups', group);
                            
                            
                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                content: `${myProfile.name} é‚€è¯· ${invitedNames} åŠ å…¥ç¾¤èŠ`,
                                timestamp: Date.now(),
                                type: 'received', 
                                segmentType: 'system',
                                forAi: true, 
                            };

                            
                            await DBHelper.put('messages', systemMessage);
                            await UIManager.updateChatMetadata(groupId, systemMessage);

                            if (appState.currentChatId === groupId) {
                                UIManager.addMessageToDOM(systemMessage, {});
                            }
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            async handleRemoveMembers(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');

                const currentAiMembers = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);

                if (currentAiMembers.length <= 1) {
                    UIManager.showModal({
                        title: "ç§»é™¤æˆå‘˜",
                        body: `<p>ç¾¤èŠä¸­è‡³å°‘éœ€è¦ä¿ç•™ä¸€åå¥½å‹ï¼Œæ— æ³•å†ç§»é™¤äº†ã€‚</p>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }
                
                const memberListHtml = currentAiMembers.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="remove-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "ç§»é™¤ç¾¤æˆå‘˜",
                    body: `<div class="member-select-list">${memberListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç§»é™¤', class: 'btn-danger', handler: async () => {
                            const idsToRemove = [...$$('input[name="remove-members"]:checked')].map(cb => cb.value);
                            if (idsToRemove.length === 0) return;

                            if (idsToRemove.length >= currentAiMembers.length) {
                                UIManager.showModal({ title: "æ“ä½œæ— æ•ˆ", body: `<p>ä¸èƒ½å°†æ‰€æœ‰å¥½å‹éƒ½ç§»å‡ºç¾¤èŠï¼Œè‡³å°‘è¦ä¿ç•™ä¸€ä½å“¦ã€‚</p>`, actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => this.handleRemoveMembers(groupId) }] });
                                return;
                            }
                            
                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            const removedNames = currentAiMembers.filter(c => idsToRemove.includes(c.id)).map(c => c.remark || c.name).join('ã€');

                            
                            group.members = group.members.filter(id => !idsToRemove.includes(id));
                            await DBHelper.put('groups', group);
                            
                            
                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                content: `${myProfile.name} å°† ${removedNames} ç§»å‡ºç¾¤èŠ`,
                                timestamp: Date.now(),
                                type: 'received',
                                segmentType: 'system',
                                forAi: true, 
                            };
                            
                             
                            await DBHelper.put('messages', systemMessage);
                            await UIManager.updateChatMetadata(groupId, systemMessage);

                            if (appState.currentChatId === groupId) {
                                UIManager.addMessageToDOM(systemMessage, {});
                            }
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            

            async renderPromptsPage() {
                const contentArea = $('#prompts-page-content');
                contentArea.innerHTML = ''; 
                const folders = await DBHelper.getAll('promptFolders');
                const prompts = await DBHelper.getAll('prompts');

                
                let unclassifiedFolder = folders.find(f => f.id === 'unclassified');
                if (!unclassifiedFolder) {
                    unclassifiedFolder = { id: 'unclassified', name: 'æœªåˆ†ç±»', isActive: true, createdAt: 0 };
                    
                }
                
                const sortedFolders = [unclassifiedFolder, ...folders.filter(f => f.id !== 'unclassified').sort((a,b) => a.createdAt - b.createdAt)];
                
                for (const folder of sortedFolders) {
                    const folderPrompts = prompts.filter(p => p.folderId === folder.id).sort((a,b) => a.createdAt - b.createdAt);
                    const folderElement = this.createFolderElement(folder, folderPrompts);
                    contentArea.appendChild(folderElement);
                }

                this.bindPromptPageEvents();
            },

            createFolderElement(folder, prompts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder';
                folderDiv.dataset.folderId = folder.id;

                let promptsHtml = prompts.map((p, index) => this.createPromptCardHtml(p, index + 1)).join('');
                if (prompts.length === 0) {
                    promptsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">æ­¤æ–‡ä»¶å¤¹ä¸ºç©º</p>`;
                }

                
                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            <i class="fas fa-folder"></i> 
                            ${folder.name}
                        </h3>
                        <div class="prompt-folder-controls">
                            ${folder.id !== 'unclassified' ? `
                            <label class="switch">
                                <input type="checkbox" class="folder-toggle-switch" ${folder.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                            <button class="folder-action-btn" data-action="delete-folder" title="åˆ é™¤æ–‡ä»¶å¤¹"><i class="fas fa-trash-alt"></i></button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="prompt-folder-content collapsed">${promptsHtml}</div>
                `;
                return folderDiv;
            },

            createPromptCardHtml(prompt, index) {
                let keywordsText = '';
                if (prompt.type === 'implicit') {
                    try {
                        const keywords = JSON.parse(prompt.keywords);
                        keywordsText = `<div class="prompt-tag tag-keywords" title="${keywords.join(', ')}">${keywords.join(', ')}</div>`;
                    } catch(e) {  }
                }
                
                return `
                    <div class="prompt-card ${prompt.isActive ? '' : 'inactive'}" data-prompt-id="${prompt.id}">
                        <div class="prompt-card-header">
                            <div class="prompt-card-name">
                                <span class="prompt-index">${index}</span>
                                <span>${prompt.name}</span>
                            </div>
                             <label class="switch">
                                <input type="checkbox" class="prompt-toggle-switch" ${prompt.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="prompt-card-tags">
                            <div class="prompt-tag ${prompt.type === 'explicit' ? 'tag-explicit' : 'tag-implicit'}">${prompt.type === 'explicit' ? 'æ˜¾æ€§' : 'éšæ€§'}</div>
                            ${keywordsText}
                        </div>
                        <div class="prompt-card-actions">
                            <button class="action-btn" data-action="view-prompt">æŸ¥çœ‹</button>
                            <button class="action-btn" data-action="edit-prompt">ä¿®æ”¹</button>
                            <button class="action-btn" data-action="delete-prompt">åˆ é™¤</button>
                        </div>
                    </div>
                `;
            },
            
            bindPromptPageEvents() {
                
                $('#prompts-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#add-prompt-folder-btn').onclick = () => this.handleNewPromptFolder();
                $('#add-new-prompt-btn').onclick = () => this.handleNewPrompt();
                
                $('#import-prompts-btn').onclick = () => this.handleImportPrompts();
                $('#export-prompts-btn').onclick = () => this.handleExportPrompts();

                
                $('#prompts-page-content').onclick = async (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const folderSwitch = target.closest('.folder-toggle-switch');
                    const deleteFolderBtn = target.closest('[data-action="delete-folder"]');
                    const promptCard = target.closest('.prompt-card');

                    if (folderSwitch) {
                        e.stopPropagation(); 
                        const folderId = folderSwitch.closest('.prompt-folder').dataset.folderId;
                        
                        await this.toggleFolderState(folderId, folderSwitch.checked);
                    } else if (deleteFolderBtn) {
                        
                        e.stopPropagation();
                        const folderId = deleteFolderBtn.closest('.prompt-folder').dataset.folderId;
                        this.confirmDeleteFolder(folderId);
                    } else if (folderHeader) {
                        
                        const content = folderHeader.nextElementSibling;
                        if (content && content.classList.contains('prompt-folder-content')) {
                            folderHeader.classList.toggle('collapsed');
                            content.classList.toggle('collapsed');
                        }
                    } else if (promptCard) {
                        
                        const promptId = promptCard.dataset.promptId;
                        if (target.matches('.prompt-toggle-switch')) {
                            await this.togglePromptState(promptId, target.checked);
                        } else if (target.matches('[data-action="view-prompt"]')) {
                            this.viewPrompt(promptId);
                        } else if (target.matches('[data-action="edit-prompt"]')) {
                            this.handleEditPrompt(promptId);
                        } else if (target.matches('[data-action="delete-prompt"]')) {
                            this.confirmDeletePrompt(promptId);
                        }
                    }
                };
            },

            

            async renderPromptsPage() {
                const contentArea = $('#prompts-page-content');
                contentArea.innerHTML = ''; 
                const folders = await DBHelper.getAll('promptFolders');
                const prompts = await DBHelper.getAll('prompts');

                
                let unclassifiedFolder = folders.find(f => f.id === 'unclassified');
                if (!unclassifiedFolder) {
                    unclassifiedFolder = { id: 'unclassified', name: 'æœªåˆ†ç±»', isActive: true, createdAt: 0 };
                    
                }
                
                const sortedFolders = [unclassifiedFolder, ...folders.filter(f => f.id !== 'unclassified').sort((a,b) => a.createdAt - b.createdAt)];
                
                for (const folder of sortedFolders) {
                    const folderPrompts = prompts.filter(p => p.folderId === folder.id).sort((a,b) => a.createdAt - b.createdAt);
                    const folderElement = this.createFolderElement(folder, folderPrompts);
                    contentArea.appendChild(folderElement);
                }

                this.bindPromptPageEvents();
            },

            createFolderElement(folder, prompts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder';
                folderDiv.dataset.folderId = folder.id;

                let promptsHtml = prompts.map((p, index) => this.createPromptCardHtml(p, index + 1)).join('');
                if (prompts.length === 0) {
                    promptsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">æ­¤æ–‡ä»¶å¤¹ä¸ºç©º</p>`;
                }

                
                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            <i class="fas fa-folder"></i> 
                            ${folder.name}
                        </h3>
                        <div class="prompt-folder-controls">
                            ${folder.id !== 'unclassified' ? `
                            <label class="switch">
                                <input type="checkbox" class="folder-toggle-switch" ${folder.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                            <button class="folder-action-btn" data-action="delete-folder" title="åˆ é™¤æ–‡ä»¶å¤¹"><i class="fas fa-trash-alt"></i></button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="prompt-folder-content collapsed">${promptsHtml}</div>
                `;
                return folderDiv;
            },

            createPromptCardHtml(prompt, index) {
                let keywordsText = '';
                if (prompt.type === 'implicit') {
                    try {
                        const keywords = JSON.parse(prompt.keywords);
                        keywordsText = `<div class="prompt-tag tag-keywords" title="${keywords.join(', ')}">${keywords.join(', ')}</div>`;
                    } catch(e) {  }
                }
                
                return `
                    <div class="prompt-card ${prompt.isActive ? '' : 'inactive'}" data-prompt-id="${prompt.id}">
                        <div class="prompt-card-header">
                            <div class="prompt-card-name">
                                <span class="prompt-index">${index}</span>
                                <span>${prompt.name}</span>
                            </div>
                             <label class="switch">
                                <input type="checkbox" class="prompt-toggle-switch" ${prompt.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="prompt-card-tags">
                            <div class="prompt-tag ${prompt.type === 'explicit' ? 'tag-explicit' : 'tag-implicit'}">${prompt.type === 'explicit' ? 'æ˜¾æ€§' : 'éšæ€§'}</div>
                            ${keywordsText}
                        </div>
                        <div class="prompt-card-actions">
                            <button class="action-btn" data-action="view-prompt">æŸ¥çœ‹</button>
                            <button class="action-btn" data-action="edit-prompt">ä¿®æ”¹</button>
                            <button class="action-btn" data-action="delete-prompt">åˆ é™¤</button>
                        </div>
                    </div>
                `;
            },
            
            bindPromptPageEvents() {
                
                $('#prompts-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#add-prompt-folder-btn').onclick = () => this.handleNewPromptFolder();
                $('#add-new-prompt-btn').onclick = () => this.handleNewPrompt();
                
                $('#import-prompts-btn').onclick = () => this.handleImportPrompts();
                $('#export-prompts-btn').onclick = () => this.handleExportPrompts();

                
                $('#prompts-page-content').onclick = async (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const folderSwitch = target.closest('.folder-toggle-switch');
                    const deleteFolderBtn = target.closest('[data-action="delete-folder"]');
                    const promptCard = target.closest('.prompt-card');

                    if (folderSwitch) {
                        
                        e.stopPropagation(); 
                        const folderId = folderSwitch.closest('.prompt-folder').dataset.folderId;
                        await this.toggleFolderState(folderId, folderSwitch.checked);
                    } else if (deleteFolderBtn) {
                        
                        e.stopPropagation();
                        const folderId = deleteFolderBtn.closest('.prompt-folder').dataset.folderId;
                        this.confirmDeleteFolder(folderId);
                    } else if (folderHeader) {
                        
                        const content = folderHeader.nextElementSibling;
                        if (content && content.classList.contains('prompt-folder-content')) {
                            folderHeader.classList.toggle('collapsed');
                            content.classList.toggle('collapsed');
                        }
                    } else if (promptCard) {
                        
                        const promptId = promptCard.dataset.promptId;
                        if (target.matches('.prompt-toggle-switch')) {
                            await this.togglePromptState(promptId, target.checked);
                        } else if (target.matches('[data-action="view-prompt"]')) {
                            this.viewPrompt(promptId);
                        } else if (target.matches('[data-action="edit-prompt"]')) {
                            this.handleEditPrompt(promptId);
                        } else if (target.matches('[data-action="delete-prompt"]')) {
                            this.confirmDeletePrompt(promptId);
                        }
                    }
                };
            },


            async handleNewPrompt(folderId = 'unclassified') {
                const folders = await DBHelper.getAll('promptFolders');
                const folderOptions = `<option value="unclassified" ${folderId === 'unclassified' ? 'selected' : ''}>æœªåˆ†ç±»</option>` +
                    folders.map(f => `<option value="${f.id}" ${folderId === f.id ? 'selected' : ''}>${f.name}</option>`).join('');

                UIManager.showModal({
                    isPersistent: true,
                    title: "æ–°å»ºæç¤ºè¯",
                    body: `
                        <div class="form-group">
                            <label for="prompt-name-input">åç§° (æ–‡ä»¶å¤¹å†…å”¯ä¸€)</label>
                            <input type="text" id="prompt-name-input" placeholder="ä¾‹å¦‚ï¼šæ–‡é£-å¤é£">
                        </div>
                        <div class="form-group">
                            <label for="prompt-folder-select">æ‰€å±æ–‡ä»¶å¤¹</label>
                            <select id="prompt-folder-select">${folderOptions}</select>
                        </div>
                        <div class="form-group">
                            <label>ç±»å‹</label>
                            <select id="prompt-type-select">
                                <option value="explicit">æ˜¾æ€§ (æ€»æ˜¯è§¦å‘)</option>
                                <option value="implicit">éšæ€§ (å…³é”®è¯è§¦å‘)</option>
                            </select>
                        </div>
                        <div class="form-group" id="prompt-keywords-group" style="display:none;">
                            <label for="prompt-keywords-input">å…³é”®è¯ (ç”¨ä¸­/è‹±æ–‡é€—å·éš”å¼€)</label>
                            <input type="text" id="prompt-keywords-input" placeholder="ä¾‹å¦‚ï¼šä½ å¥½,hello,åœ¨å—">
                        </div>
                        <div class="form-group">
                            <label for="prompt-content-input">æç¤ºè¯å†…å®¹</label>
                            <textarea id="prompt-content-input" rows="5" placeholder="è¾“å…¥ä½ çš„æç¤ºè¯..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const name = $('#prompt-name-input').value.trim();
                            const selectedFolderId = $('#prompt-folder-select').value;
                            if (!name) {
                                return UIManager.showToast("æç¤ºè¯åç§°ä¸èƒ½ä¸ºç©º");
                            }

                            
                            const allPrompts = await DBHelper.getAll('prompts');
                            const promptsInFolder = allPrompts.filter(p => p.folderId === selectedFolderId);
                            if (promptsInFolder.some(p => p.name === name)) {
                                return UIManager.showToast(`åç§° "${name}" åœ¨è¯¥æ–‡ä»¶å¤¹ä¸­å·²å­˜åœ¨`);
                            }
                            
                            let keywords = '[]';
                            if ($('#prompt-type-select').value === 'implicit') {
                                const keywordsInput = $('#prompt-keywords-input').value.trim();
                                if (keywordsInput) {
                                    const keywordsArray = keywordsInput.split(/,|ï¼Œ/).map(kw => kw.trim()).filter(Boolean);
                                    keywords = JSON.stringify(keywordsArray);
                                }
                            }

                            const newPrompt = {
                                id: Utils.generateId('prompt'),
                                createdAt: Date.now(),
                                name: name,
                                folderId: selectedFolderId,
                                type: $('#prompt-type-select').value,
                                keywords: keywords,
                                content: $('#prompt-content-input').value.trim(),
                                isActive: true,
                            };
                            await DBHelper.put('prompts', newPrompt);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
                
                $('#prompt-type-select').onchange = (e) => {
                    $('#prompt-keywords-group').style.display = e.target.value === 'implicit' ? 'block' : 'none';
                };
            },
            
            async handleEditPrompt(promptId) {
                const prompt = await DBHelper.get('prompts', promptId);
                const folders = await DBHelper.getAll('promptFolders');
                const folderOptions = `<option value="unclassified" ${prompt.folderId === 'unclassified' ? 'selected' : ''}>æœªåˆ†ç±»</option>` +
                    folders.map(f => `<option value="${f.id}" ${prompt.folderId === f.id ? 'selected' : ''}>${f.name}</option>`).join('');
                
                let keywordsString = '';
                if(prompt.type === 'implicit') {
                    try {
                        const keywordsArray = JSON.parse(prompt.keywords);
                        if (Array.isArray(keywordsArray)) keywordsString = keywordsArray.join(', ');
                    } catch(e) {}
                }

                UIManager.showModal({
                    isPersistent: true,
                    title: "ä¿®æ”¹æç¤ºè¯",
                    body: `
                        <div class="form-group">
                            <label for="prompt-name-input">åç§° (æ–‡ä»¶å¤¹å†…å”¯ä¸€)</label>
                            <input type="text" id="prompt-name-input" value="${prompt.name}">
                        </div>
                        <div class="form-group">
                            <label for="prompt-folder-select">æ‰€å±æ–‡ä»¶å¤¹</label>
                            <select id="prompt-folder-select">${folderOptions}</select>
                        </div>
                        <div class="form-group">
                            <label>ç±»å‹</label>
                            <select id="prompt-type-select">
                                <option value="explicit" ${prompt.type === 'explicit' ? 'selected' : ''}>æ˜¾æ€§</option>
                                <option value="implicit" ${prompt.type === 'implicit' ? 'selected' : ''}>éšæ€§</option>
                            </select>
                        </div>
                        <div class="form-group" id="prompt-keywords-group" style="display:${prompt.type === 'implicit' ? 'block' : 'none'};">
                            <label for="prompt-keywords-input">å…³é”®è¯ (ç”¨ä¸­/è‹±æ–‡é€—å·éš”å¼€)</label>
                            <input type="text" id="prompt-keywords-input" value="${keywordsString}" placeholder="ä¾‹å¦‚ï¼šä½ å¥½,hello,åœ¨å—">
                        </div>
                        <div class="form-group">
                            <label for="prompt-content-input">æç¤ºè¯å†…å®¹</label>
                            <textarea id="prompt-content-input" rows="5">${prompt.content}</textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const name = $('#prompt-name-input').value.trim();
                            const selectedFolderId = $('#prompt-folder-select').value;
                            if (!name) return UIManager.showToast("æç¤ºè¯åç§°ä¸èƒ½ä¸ºç©º");

                            
                            const allPrompts = await DBHelper.getAll('prompts');
                            const promptsInFolder = allPrompts.filter(p => p.folderId === selectedFolderId && p.id !== promptId);
                            if (promptsInFolder.some(p => p.name === name)) {
                                return UIManager.showToast(`åç§° "${name}" åœ¨è¯¥æ–‡ä»¶å¤¹ä¸­å·²å­˜åœ¨`);
                            }

                            let keywords = '[]';
                            if ($('#prompt-type-select').value === 'implicit') {
                                const keywordsInput = $('#prompt-keywords-input').value.trim();
                                if (keywordsInput) {
                                    const keywordsArray = keywordsInput.split(/,|ï¼Œ/).map(kw => kw.trim()).filter(Boolean);
                                    keywords = JSON.stringify(keywordsArray);
                                }
                            }
                            
                            const updatedPrompt = {
                                ...prompt,
                                name: name,
                                folderId: selectedFolderId,
                                type: $('#prompt-type-select').value,
                                keywords: keywords,
                                content: $('#prompt-content-input').value.trim(),
                            };
                            await DBHelper.put('prompts', updatedPrompt);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
                
                $('#prompt-type-select').onchange = (e) => {
                    $('#prompt-keywords-group').style.display = e.target.value === 'implicit' ? 'block' : 'none';
                };
            },
            
            async viewPrompt(promptId) {
                const prompt = await DBHelper.get('prompts', promptId);
                UIManager.showModal({
                    title: `æŸ¥çœ‹: ${prompt.name}`,
                    body: `<div class="details-section" style="margin-top:0;"><p style="max-height: 400px;">${prompt.content}</p></div>`,
                    actions: [{text: 'å…³é—­', class: 'btn-primary', handler: () => UIManager.hideModal()}]
                });
            },
            
            confirmDeletePrompt(promptId) {
                UIManager.showModal({
                    title: 'ç¡®è®¤åˆ é™¤',
                    body: '<p>ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæç¤ºè¯å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ¢å¤ã€‚</p>',
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('prompts', promptId);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },
            
            async togglePromptState(promptId, isActive) {
                const prompt = await DBHelper.get('prompts', promptId);
                prompt.isActive = isActive;
                await DBHelper.put('prompts', prompt);
                
                
                const promptCard = $(`#prompts-page-content .prompt-card[data-prompt-id="${promptId}"]`);
                if (promptCard) {
                    promptCard.classList.toggle('inactive', !isActive);
                }
            },

            handleNewPromptFolder() {
                UIManager.showModal({
                    title: "æ–°å»ºæ–‡ä»¶å¤¹",
                    body: `
                        <div class="form-group">
                            <label for="folder-name-input">æ–‡ä»¶å¤¹åç§° (ä¸å¯é‡å¤)</label>
                            <input type="text" id="folder-name-input" placeholder="ä¾‹å¦‚ï¼šä¸–ç•Œè§‚è®¾å®š">
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ›å»º', class: 'btn-primary', handler: async () => {
                            const name = $('#folder-name-input').value.trim();
                            if (!name) return;
                            const existing = await DBHelper.getAll('promptFolders', 'name');
                            if (existing.some(f => f.name === name)) return alert('æ–‡ä»¶å¤¹åç§°å·²å­˜åœ¨');

                            const newFolder = {
                                id: Utils.generateId('folder'),
                                createdAt: Date.now(),
                                name: name,
                                isActive: true
                            };
                            await DBHelper.put('promptFolders', newFolder);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },
            
            async toggleFolderState(folderId, isActive) {
                const folder = await DBHelper.get('promptFolders', folderId);
                if (folder) {
                    folder.isActive = isActive;
                    await DBHelper.put('promptFolders', folder);
                }
                
            },
            
            confirmDeleteFolder(folderId) {
                UIManager.showModal({
                    title: 'ç¡®è®¤åˆ é™¤æ–‡ä»¶å¤¹',
                    body: '<p>åˆ é™¤æ–‡ä»¶å¤¹å°†åŒæ—¶åˆ é™¤å…¶ä¸­æ‰€æœ‰çš„æç¤ºè¯ï¼Œä¸”æ— æ³•æ¢å¤ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p>',
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤åˆ é™¤', class: 'btn-danger', handler: async () => {
                            
                            const prompts = (await DBHelper.getAll('prompts')).filter(p => p.folderId === folderId);
                            for (const prompt of prompts) {
                                await DBHelper.delete('prompts', prompt.id);
                            }
                            
                            await DBHelper.delete('promptFolders', folderId);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },

            
            
            async showBindingModal(chatId) {
                const isGroup = chatId.startsWith('group-');
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const boundFolderIds = chatEntity.boundPromptFolderIds || [];
                const allFolders = await DBHelper.getAll('promptFolders');
                
                const boundFolders = allFolders.filter(f => boundFolderIds.includes(f.id));
                let boundFoldersHtml = boundFolders.map(f => `
                    <div class="bound-folder-card">
                        <i class="fas fa-folder-open"></i>
                        <span>${f.name}</span>
                    </div>
                `).join('');
                if (boundFolders.length === 0) {
                    boundFoldersHtml = `<p style="text-align:center; color:#aaa; padding: 20px 0;">æœªç»‘å®šä»»ä½•æç¤ºè¯æ–‡ä»¶å¤¹</p>`;
                }
                
                const modalBody = `
                    <div class="binding-modal-header">
                        <h2>å·²ç»‘å®šæ–‡ä»¶å¤¹</h2>
                        <button id="open-folder-selection-btn" title="ç®¡ç†ç»‘å®š"><i class="fas fa-link"></i></button>
                    </div>
                    <div id="bound-folders-list">${boundFoldersHtml}</div>
                `;

                UIManager.showModal({
                    title: "ç»‘å®šæç¤ºè¯",
                    body: modalBody,
                    actions: [{text: 'å®Œæˆ', class: 'btn-primary', handler: () => UIManager.hideModal()}]
                });
                
                
                modalContentWrapper.classList.add('binding-modal-content');
                
                $('#open-folder-selection-btn').onclick = () => this.showFolderSelectionModal(chatId, boundFolderIds);

                
                const originalHide = UIManager.hideModal;
                UIManager.hideModal = () => {
                    modalContentWrapper.classList.remove('binding-modal-content');
                    originalHide.call(UIManager);
                    UIManager.hideModal = originalHide; 
                };
            },

            async showFolderSelectionModal(chatId, currentlyBoundIds) {
                const allFolders = await DBHelper.getAll('promptFolders');
                const folderListHtml = allFolders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="bind-folder" value="${f.id}" ${currentlyBoundIds.includes(f.id) ? 'checked' : ''}>
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é€‰æ‹©è¦ç»‘å®šçš„æ–‡ä»¶å¤¹",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => this.showBindingModal(chatId) },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const selectedIds = [...$$('input[name="bind-folder"]:checked')].map(cb => cb.value);
                            const isGroup = chatId.startsWith('group-');
                            const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                            chatEntity.boundPromptFolderIds = selectedIds;
                            await DBHelper.put(isGroup ? 'groups' : 'contacts', chatEntity);
                            this.showBindingModal(chatId); 
                        }}
                    ]
                });
            },
            handleSimulatedImageSend() {
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';
                const networkFallbackImage = 'https://z.wiki/autoupload/20240328/LV9Y.iShot_2024-03-28_22.38.16.png'; 
                
                UIManager.showModal({
                    isPersistent: true,
                    title: "å‘é€å›¾æ–‡æ¶ˆæ¯",
                    body: `
                        <div class="form-group">
                            <label>ä¸Šä¼ å›¾ç‰‡ (é€‰å¡«)</label>
                            <div class="avatar-uploader">
                                <img src="${defaultPlaceholderSvg}" id="sim-image-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                <input type="file" id="sim-image-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('sim-image-input').click()">é€‰æ‹©å›¾ç‰‡</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="sim-image-desc">å›¾ç‰‡æè¿° (å¿…å¡«, AIä¼šçœ‹åˆ°)</label>
                            <textarea id="sim-image-desc" rows="3" placeholder="è¯·è¯¦ç»†æè¿°å›¾ç‰‡å†…å®¹ï¼ŒAIå°†æ ¹æ®æ­¤æè¿°è¿›è¡Œå›åº”..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å‘é€', class: 'btn-primary', handler: async () => {
                            const description = $('#sim-image-desc').value.trim();
                            if (!description) {
                                return UIManager.showToast('å›¾ç‰‡æè¿°ä¸èƒ½ä¸ºç©º');
                            }
                            
                            let finalImageSrc = $('#sim-image-preview').src;
                            
                            if (finalImageSrc === defaultPlaceholderSvg) {
                                finalImageSrc = 'https://pb.nichi.co/spoil-joke-debate';
                            }
                            
                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[å›¾æ–‡] ${description}`,
                                type: 'sent',
                                segmentType: 'image_simulated',
                                cardData: {
                                    imageSrc: finalImageSrc,
                                    description: description
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
                
                $('#sim-image-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#sim-image-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },

            async handleVisionImageSend() {
                UIManager.showModal({
                    title: "å‘é€å›¾ç‰‡ (AIè¯†å›¾)",
                    body: `
                        <div class="form-group">
                            <label>é€‰æ‹©å›¾ç‰‡ (å¿…å¡«)</label>
                            <div class="avatar-uploader">
                                <img src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=" id="vision-image-preview" style="width: 100px; height: 100px; border-radius: 8px; object-fit: cover; background-color: #f0f0f0; display: none;">
                                <input type="file" id="vision-image-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('vision-image-input').click()">ä¸Šä¼ å›¾ç‰‡</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="vision-image-prompt">é™„è¨€ (é€‰å¡«)</label>
                            <textarea id="vision-image-prompt" rows="2" placeholder="å¯ä»¥å¯¹å›¾ç‰‡æé—®æˆ–è¡¥å……è¯´æ˜..."></textarea>
                        </div>
                        <p style="font-size: 0.8rem; color: #aaa;">æç¤ºï¼šæ­¤åŠŸèƒ½ä¼šè°ƒç”¨å¤šæ¨¡æ€æ¨¡å‹è¿›è¡Œè¯†å›¾ï¼Œè¯·ç¡®ä¿ä½ é€‰æ‹©çš„æ¨¡å‹å’Œapiæä¾›æ–¹æ”¯æŒæ­¤åŠŸèƒ½ (å¦‚ Gemini 2.5, GPT-4o ç­‰)ï¼Œå¹¶å¯èƒ½äº§ç”Ÿæ¯”æ™®é€šæ¶ˆæ¯æ›´é«˜çš„tkã€‚å‘é€å¸¦æœ‰è¯¥åŠŸèƒ½å›¾ç‰‡çš„å›å¤ä¼šæ¯”æ­£å¸¸å›å¤<strong>æ›´æ…¢</strong>ï¼Œè¿™æ˜¯æ­£å¸¸ç°è±¡ã€‚ç›¸åŒæ¨¡å‹ä¸‹ï¼Œ<strong>éƒ¨åˆ†APIæä¾›æ–¹ä¸æ”¯æŒaiè¯†å›¾åŠŸèƒ½</strong></p>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å‘é€', class: 'btn-primary', handler: async () => {
                            const imagePreview = $('#vision-image-preview');
                            const textPrompt = $('#vision-image-prompt').value.trim();

                            if (!imagePreview.src || imagePreview.src.startsWith('data:image/gif')) {
                                return UIManager.showToast('è¯·å…ˆä¸Šä¼ ä¸€å¼ å›¾ç‰‡');
                            }

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: textPrompt || "[å›¾ç‰‡]",
                                type: 'sent',
                                segmentType: 'image_vision',
                                cardData: {
                                    base64: imagePreview.src,
                                    prompt: textPrompt,
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });

                $('#vision-image-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const compressedBase64 = await Utils.compressImage(file, 1024, 1024, 0.8);
                        $('#vision-image-preview').src = compressedBase64;
                        $('#vision-image-preview').style.display = 'block';
                    }
                });
            },

            handlePlayerCardSend() {
                const cardCoverLibrary = appState.cardCoverLibrary || [];
                const defaultCover = cardCoverLibrary.length > 0 ? cardCoverLibrary[Math.floor(Math.random() * cardCoverLibrary.length)] : '';
                
                UIManager.showModal({
                    title: "å‘é€å¡ç‰‡æ¶ˆæ¯",
                    body: `
                        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                            <label style="margin: 0;">ä½¿ç”¨â€œè½¬å‘â€æ ·å¼</label>
                            <label class="switch">
                                <input type="checkbox" id="card-style-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>

                        <!-- Detailed Card Form -->
                        <div id="detailed-card-form">
                            <div class="form-group">
                                <label>ä¸Šä¼ å›¾ç‰‡ (å¯é€‰)</label>
                                <div class="avatar-uploader">
                                    <img src="${defaultCover}" id="card-image-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                    <input type="file" id="card-image-input" accept="image/*" style="display:none;">
                                    <button class="upload-btn" onclick="document.getElementById('card-image-input').click()">é€‰æ‹©å›¾ç‰‡</button>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="card-share-type">åˆ†äº«ç±»å‹ (å¯é€‰)</label>
                                <input type="text" id="card-share-type" placeholder="ä¾‹å¦‚ï¼šåœ°ç‚¹åˆ†äº«, æ–‡ä»¶åˆ†äº«">
                            </div>
                            <div class="form-group">
                                <label for="card-title">æ ‡é¢˜ (å¿…å¡«)</label>
                                <input type="text" id="card-title" placeholder="å¡ç‰‡æ ‡é¢˜">
                            </div>
                            <div class="form-group">
                                <label for="card-summary">ç®€ä»‹ (å¯é€‰, 35å­—ä»¥å†…)</label>
                                <input type="text" id="card-summary" placeholder="å¡ç‰‡ç®€ä»‹" maxlength="35">
                            </div>
                            <div class="form-group">
                                <label for="card-details">è¯¦ç»†å†…å®¹ (å¯é€‰, 100å­—ä»¥å†…)</label>
                                <textarea id="card-details" rows="3" placeholder="ç‚¹å‡»å¡ç‰‡åæ˜¾ç¤ºçš„è¯¦ç»†å†…å®¹" maxlength="100"></textarea>
                            </div>
                        </div>

                        <!-- Forward Style Form -->
                        <div id="forward-style-form" style="display: none;">
                            <div class="form-group">
                                <label for="forward-title">æ ‡é¢˜ (å¿…å¡«, 30å­—ä»¥å†…)</label>
                                <input type="text" id="forward-title" placeholder="è½¬å‘çš„æ ‡é¢˜" maxlength="30">
                            </div>
                            <div class="form-group">
                                <label for="forward-content">å†…å®¹ (å¿…å¡«, 400å­—ä»¥å†…)</label>
                                <textarea id="forward-content" rows="4" placeholder="è½¬å‘çš„å†…å®¹" maxlength="400"></textarea>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å‘é€', class: 'btn-primary', handler: async () => {
                            const isForwardStyle = $('#card-style-toggle').checked;
                            const myProfile = await this.getPlayerProfileForContext(appState.currentChatId);
                            let message;
                            let exceededFields = [];

                            if (isForwardStyle) {
                                let title = $('#forward-title').value;
                                let content = $('#forward-content').value;

                                if (title.length > 30) {
                                    title = title.slice(0, 30);
                                    exceededFields.push('è½¬å‘æ ‡é¢˜');
                                }
                                if (content.length > 300) {
                                    content = content.slice(0, 300);
                                    exceededFields.push('è½¬å‘å†…å®¹');
                                }
                                
                                title = title.trim();
                                content = content.trim();

                                if (!title || !content) return UIManager.showToast("æ ‡é¢˜å’Œå†…å®¹ä¸èƒ½ä¸ºç©º");
                                
                                message = {
                                    segmentType: 'forward_custom',
                                    content: `<è½¬å‘>\næ ‡é¢˜ï¼š${title}\nå†…å®¹ï¼š${content}\n</è½¬å‘>`,
                                    cardData: { title, content }
                                };

                            } else {
                                const title = $('#card-title').value.trim();
                                if (!title) return UIManager.showToast("æ ‡é¢˜ä¸èƒ½ä¸ºç©º");
                                
                                let summary = $('#card-summary').value;
                                let details = $('#card-details').value;

                                if (summary.length > 35) {
                                    summary = summary.slice(0, 35);
                                    exceededFields.push('ç®€ä»‹');
                                }
                                if (details.length > 100) {
                                    details = details.slice(0, 100);
                                    exceededFields.push('è¯¦ç»†å†…å®¹');
                                }

                                summary = summary.trim();
                                details = details.trim();
                                
                                const shareType = $('#card-share-type').value.trim() || 'åˆ†äº«';
                                const imageSrc = $('#card-image-preview').src;

                                message = {
                                    segmentType: 'card',
                                    content: `ã€${myProfile.name}|${shareType}|${title}|${summary}|${details}ã€`,
                                    cardData: {
                                        shareType, title, summary, details, imageSrc
                                    }
                                };
                            }
                            
                            if (exceededFields.length > 0) {
                                UIManager.showToast(`${exceededFields.join('ã€')}è¶…å‡ºå­—æ•°é™åˆ¶ï¼Œå·²è‡ªåŠ¨æˆªæ–­ã€‚`);
                            }

                            const finalMessage = {
                                messageId: Utils.generateId('msg'),
                                ...message,
                                type: 'sent',
                            };
                            
                            await this.handlePlayerSendMessage(finalMessage);
                            UIManager.hideModal();
                        }}
                    ]
                });

                $('#card-style-toggle').onchange = (e) => {
                    const isForward = e.target.checked;
                    $('#detailed-card-form').style.display = isForward ? 'none' : 'block';
                    $('#forward-style-form').style.display = isForward ? 'block' : 'none';
                };
                
                $('#card-image-input').onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#card-image-preview').src = await Utils.fileToBase64(file);
                    }
                };
            },

            async handleNewMoment() {
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';
                 UIManager.showModal({
                    isPersistent: true,
                    title: "å‘å¸ƒåŠ¨æ€",
                    body: `
                        <div class="form-group">
                            <label for="new-moment-content">æ­¤åˆ»çš„æƒ³æ³•...</label>
                            <textarea id="new-moment-content" rows="5"></textarea>
                        </div>
                        <div class="form-group">
                            <label>ä¸Šä¼ å›¾ç‰‡ (å¯é€‰, æœ€å¤š9å¼ )</label>
                             <div class="avatar-uploader">
                                <div id="new-moment-images-preview" style="display:flex; flex-wrap:wrap; gap:10px;"></div>
                                <input type="file" id="new-moment-images-input" accept="image/*" multiple style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('new-moment-images-input').click()">é€‰æ‹©å›¾ç‰‡</button>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å‘å¸ƒ', class: 'btn-primary', handler: async () => {
                            const content = $('#new-moment-content').value.trim();
                            const imagesPreview = $$('#new-moment-images-preview img');
                            const images = Array.from(imagesPreview).map(img => img.src);

                            if (!content && images.length === 0) {
                                return UIManager.showToast("åŠ¨æ€å†…å®¹å’Œå›¾ç‰‡ä¸èƒ½éƒ½ä¸ºç©ºå“¦");
                            }
                            
                            const myProfile = await this.getPlayerProfileForContext(appState.currentCircleId);
                            const newMoment = {
                                id: Utils.generateId('moment'),
                                circleId: appState.currentCircleId,
                                authorId: myProfile.id,
                                content: content,
                                images: images,
                                timestamp: Date.now(),
                                comments: []
                            };

                            await DBHelper.put('moments', newMoment);
                            UIManager.hideModal();
                            await UIManager.renderMomentsPage(); 
                            
                            
                            AIHandler.handleMomentsCommentRequest(newMoment.id);
                        }}
                    ]
                });
                
                $('#new-moment-images-input').addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files).slice(0, 9); 
                    const previewContainer = $('#new-moment-images-preview');
                    previewContainer.innerHTML = '';
                    for (const file of files) {
                        const base64 = await Utils.fileToBase64(file);
                        const img = document.createElement('img');
                        img.src = base64;
                        img.style.width = '60px';
                        img.style.height = '60px';
                        img.style.objectFit = 'cover';
                        img.style.borderRadius = '8px';
                        previewContainer.appendChild(img);
                    }
                });
            },

            async handlePlayerLike(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return;

                
                const circle = await DBHelper.get('circles', moment.circleId);
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile }; 

                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                

                if (!moment.likes) {
                    moment.likes = [];
                }

                const playerLikeIndex = moment.likes.indexOf(myProfile.name);

                if (playerLikeIndex > -1) {
                    moment.likes.splice(playerLikeIndex, 1);
                } else {
                    moment.likes.push(myProfile.name);
                }

                await DBHelper.put('moments', moment);

                const postElement = $(`[data-moment-id="${momentId}"]`);
                if (!postElement) return;

                const likeBtn = postElement.querySelector('[data-action="like"]');
                const interactionsContainer = postElement.querySelector('.post-interactions');
                const likesContainer = postElement.querySelector('.post-likes');
                const playerHasLiked = playerLikeIndex === -1;

                likeBtn.classList.toggle('liked', playerHasLiked);

                if (moment.likes.length > 0) {
                    likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    interactionsContainer.style.display = 'block';
                } else {
                    likesContainer.innerHTML = '';
                    if (!moment.comments || moment.comments.length === 0) {
                        interactionsContainer.style.display = 'none';
                    }
                }
            },

            toggleCommentInput(postElement, replyToAuthorName = null) {
                const inputWrapper = postElement.querySelector('.comment-input-wrapper');
                const inputField = inputWrapper.querySelector('input');
                
                
                if (inputWrapper.classList.contains('active') && inputWrapper.dataset.replyTo === (replyToAuthorName || '')) {
                    inputWrapper.classList.remove('active');
                    inputWrapper.dataset.replyTo = '';
                    inputField.placeholder = 'è¯„è®º...';
                    return;
                }

                inputWrapper.classList.add('active');
                postElement.querySelector('.post-interactions').style.display = 'block';
                
                if (replyToAuthorName) {
                    inputField.placeholder = `å›å¤ @${replyToAuthorName}:`;
                    inputWrapper.dataset.replyTo = replyToAuthorName;
                } else {
                    inputField.placeholder = 'è¯„è®º...';
                    inputWrapper.dataset.replyTo = '';
                }
                
                inputField.focus();
            },

            async handlePlayerComment(momentId) {
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const inputWrapper = postElement.querySelector('.comment-input-wrapper');
                const input = inputWrapper.querySelector('input');
                const content = input.value.trim();

                if (!content) return;

                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return;

                
                const circle = await DBHelper.get('circles', moment.circleId);
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let myProfile = { ...baseProfile }; 

                if (circle && circle.boundPersonaPresetId) {
                    const presets = baseProfile.presets || [];
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        myProfile = { ...myProfile, ...boundPreset };
                    }
                }
                

                const newComment = {
                    authorId: myProfile.id,
                    content: content,
                    timestamp: Date.now()
                };
                
                const replyTo = inputWrapper.dataset.replyTo;
                if (replyTo) {
                    newComment.replyTo = replyTo;
                }

                if (!moment.comments) moment.comments = [];
                moment.comments.push(newComment);
                await DBHelper.put('moments', moment);

                const commentsList = postElement.querySelector('.post-comments-list');
                const commentDiv = document.createElement('div');
                commentDiv.className = 'post-comment-item';
                commentDiv.dataset.authorName = myProfile.name;
                commentDiv.dataset.authorId = myProfile.id;

                const replyHtml = replyTo ? `<span class="comment-reply-to"> å›å¤ </span><span class="comment-author">${replyTo}:</span>` : ':';
                commentDiv.innerHTML = `<span class="comment-author" style="color: #EDD4D8;">${myProfile.name}</span>${replyHtml} ${content}`;
                commentsList.appendChild(commentDiv);

                input.value = '';
                input.placeholder = 'è¯„è®º...';
                inputWrapper.dataset.replyTo = '';
                inputWrapper.classList.remove('active');

                AIHandler.handleMomentsPlayerCommentResponse(momentId, newComment);
            },

            handleMomentCommentInteractionStart(e, type) {
                const commentItem = e.target.closest('.post-comment-item');
                if (!commentItem) return;

                clearTimeout(appState.longPressTimer);

                const startAction = () => {
                    const existingButton = $('.retract-button-wrapper.show');
                    if (existingButton) existingButton.remove();
                    this.showCommentOptions(commentItem);
                };

                appState.longPressTimer = setTimeout(startAction, 500);

                const clearLongPress = () => {
                    clearTimeout(appState.longPressTimer);
                    document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                };
                document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
            },

            showCommentOptions(commentItem) {
                const wrapper = document.createElement('div');
                wrapper.className = 'retract-button-wrapper';
                wrapper.style.bottom = 'auto';
                wrapper.style.top = 'calc(100% + 2px)';

                wrapper.innerHTML = `<button class="retract-btn" data-action="delete-comment"><i class="fas fa-trash"></i> åˆ é™¤</button>`;
                
                wrapper.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const button = e.target.closest('.retract-btn');
                    if (!button) return;

                    const action = button.dataset.action;
                    if (action === 'delete-comment') {
                        const momentId = commentItem.closest('.moments-post').dataset.momentId;
                        const commentIndex = Array.from(commentItem.parentNode.children).indexOf(commentItem);
                        this.confirmDeleteComment(momentId, commentIndex, commentItem);
                    }
                    wrapper.remove();
                });

                commentItem.style.position = 'relative';
                commentItem.appendChild(wrapper);
                setTimeout(() => wrapper.classList.add('show'), 10);
                
                const hideOnClickOutside = (event) => {
                    if (!wrapper.contains(event.target)) {
                        wrapper.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                document.addEventListener('click', hideOnClickOutside, true);
            },

            async confirmDeleteComment(momentId, commentIndex, commentElement) {
                const moment = await DBHelper.get('moments', momentId);
                const comment = moment?.comments?.[commentIndex];
                if (!comment) return;

                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allContacts = await DBHelper.getAll('contacts');
                let authorName = "æœªçŸ¥ç”¨æˆ·";
                if(comment.authorId === myProfile.id) {
                    authorName = myProfile.name;
                } else {
                    const contact = allContacts.find(c => c.id === comment.authorId);
                    authorName = contact ? (contact.remark || contact.name) : (comment.authorId || 'æœªçŸ¥ç”¨æˆ·');
                }

                UIManager.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `
                        <p>ç¡®å®šè¦åˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ</p>
                        <div style="background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; font-size: 0.9rem; color: var(--text-color-medium);">
                            <strong>${authorName}:</strong> ${comment.content}
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            moment.comments.splice(commentIndex, 1);
                            await DBHelper.put('moments', moment);
                            commentElement.remove();
                            UIManager.showToast("è¯„è®ºå·²åˆ é™¤");
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            async handleSwitchCircle() {
                const circles = await DBHelper.getAll('circles');
                if (circles.length <= 1) {
                    return UIManager.showToast("æ²¡æœ‰å…¶ä»–åœˆå­å¯ä»¥åˆ‡æ¢");
                }
                UIManager.showBottomSheet({
                    title: 'åˆ‡æ¢åœˆå­',
                    items: circles.map(c => ({ value: c.id, text: c.name })),
                    onSelect: async (value, text) => {
                        await UIManager.renderMomentsPage(value);
                        UIManager.hideSidebar();
                    }
                });
            },

            async handleViewCircleInfo() {
                const circle = await DBHelper.get('circles', appState.currentCircleId);
                if (!circle) return;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const presets = myProfile.presets || [];

                const memberNames = circle.memberIds.map(id => allContacts.find(c => c.id === id)?.name || 'æœªçŸ¥å¥½å‹').join('ã€');
                const extraNames = circle.extraMembers || 'æ— ';
                const boundFolders = (await DBHelper.getAll('promptFolders')).filter(f => circle.boundPromptFolderIds && circle.boundPromptFolderIds.includes(f.id));
                const boundFolderNames = boundFolders.map(f => f.name).join('ã€') || 'æ— ';
                
                let boundPersonaName = 'æœªç»‘å®š (ä½¿ç”¨å½“å‰äººè®¾)';
                if (circle.boundPersonaPresetId) {
                    const boundPreset = presets.find(p => p.presetId === circle.boundPersonaPresetId);
                    if (boundPreset) {
                        boundPersonaName = boundPreset.presetName || boundPreset.name;
                    }
                }

                UIManager.showModal({
                    title: "åœˆå­ä¿¡æ¯",
                    body: `
                        <div class="details-card">
                            <div class="details-header">
                                <img src="${circle.backgroundImage || 'https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png'}" class="avatar" style="border-radius: 8px;">
                                <div class="details-info">
                                    <div class="name">${circle.name}</div>
                                </div>
                            </div>
                        </div>
                        <div class="details-card">
                            <div class="details-section">
                                <div class="details-section-title">åœˆå†…å¥½å‹</div>
                                <p style="max-height: 80px;">${memberNames}</p>
                            </div>
                             <div class="details-section">
                                <div class="details-section-title">é¢å¤–å¥½å‹</div>
                                <p>${extraNames}</p>
                            </div>
                            <div class="details-section">
                                <div class="details-section-title">ç»‘å®šç©å®¶äººè®¾</div>
                                <p>${boundPersonaName}</p>
                            </div>
                             <div class="details-section">
                                <div class="details-section-title">ç»‘å®šæç¤ºè¯</div>
                                <p>${boundFolderNames}</p>
                            </div>
                        </div>
                    `,
                    actions: [{ text: 'å…³é—­', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleAddCircle() {
                const allContacts = await DBHelper.getAll('contacts');
                const allFolders = await DBHelper.getAll('promptFolders');
                if (allContacts.length === 0) {
                    return UIManager.showToast("é€šè®¯å½•ä¸­è¿˜æ²¡æœ‰å¥½å‹ï¼Œæ— æ³•åˆ›å»ºåœˆå­ã€‚");
                }
                
                let selectedPersonaId = null; 

                const membersHtml = allContacts.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-members" value="${f.id}"><span>${f.name}</span></label>`).join('');
                const foldersHtml = allFolders.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-folders" value="${f.id}"><span>${f.name}</span></label>`).join('');

                UIManager.showModal({
                    title: "æ–°å¢åœˆå­",
                    body: `
                        <div class="form-group"><label for="circle-name-input">åœˆå­åç§°</label><input type="text" id="circle-name-input"></div>
                        <div class="form-group"><label>åœˆå†…å¥½å‹ (è‡³å°‘é€‰1ä¸ª)</label><div class="member-select-list">${membersHtml}</div></div>
                        <div class="form-group"><label for="circle-extra-input">é¢å¤–å¥½å‹ (é€‰å¡«, é€—å·éš”å¼€)</label><input type="text" id="circle-extra-input" placeholder="ä¸‰ä¸‰,å…¥å…¥,vv"></div>
                        <div class="form-group"><label>ç»‘å®šæç¤ºè¯æ–‡ä»¶å¤¹ (å¯é€‰)</label><div class="member-select-list" style="max-height:150px;">${foldersHtml}</div></div>
                        <div class="form-group">
                            <label>ç»‘å®šç©å®¶äººè®¾ (å¯é€‰)</label>
                            <button id="circle-persona-bind-btn" class="modal-btn btn-secondary" style="width: 100%; text-align: left; padding: 12px 15px;">
                                <i class="fas fa-user-tag" style="margin-right: 10px;"></i>
                                <span id="circle-persona-name">æœªç»‘å®š (ä½¿ç”¨å½“å‰äººè®¾)</span>
                            </button>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ›å»º', class: 'btn-primary', handler: async () => {
                            const name = $('#circle-name-input').value.trim();
                            if (!name) return UIManager.showToast("åœˆå­åç§°ä¸èƒ½ä¸ºç©º");
                            
                            const existing = await DBHelper.getAll('circles', 'name');
                            if(existing.some(c => c.name === name)) return UIManager.showToast("è¯¥åœˆå­åç§°å·²å­˜åœ¨");

                            const memberIds = [...$$('input[name="circle-members"]:checked')].map(cb => cb.value);
                            if (memberIds.length === 0) return UIManager.showToast("è‡³å°‘é€‰æ‹©ä¸€åå¥½å‹");

                            const boundPromptFolderIds = [...$$('input[name="circle-folders"]:checked')].map(cb => cb.value);
                            
                            const newCircle = {
                                id: Utils.generateId('circle'),
                                name: name,
                                memberIds: memberIds,
                                extraMembers: $('#circle-extra-input').value.trim(),
                                boundPromptFolderIds: boundPromptFolderIds,
                                boundPersonaPresetId: selectedPersonaId, 
                                backgroundImage: null,
                                createdAt: Date.now(),
                                lastRefreshed: 0
                            };

                            await DBHelper.put('circles', newCircle);
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage(newCircle.id); 
                        }}
                    ]
                });

                $('#circle-persona-bind-btn').addEventListener('click', async () => {
                    const myProfile = await DBHelper.get('profile', 'myProfile');
                    const presets = myProfile.presets || [];
                    const items = [
                        { value: 'null', text: 'ä¸ç»‘å®š (ä½¿ç”¨å½“å‰äººè®¾)' },
                        ...presets.map(preset => ({
                            value: preset.presetId, 
                            text: preset.name
                        }))
                    ];
                    UIManager.showBottomSheet({
                        title: 'é€‰æ‹©ç©å®¶äººè®¾',
                        items: items,
                        onSelect: (value, text) => {
                            selectedPersonaId = (value === 'null') ? null : value; 
                            if (selectedPersonaId === null) {
                                $('#circle-persona-name').textContent = 'æœªç»‘å®š (ä½¿ç”¨å½“å‰äººè®¾)';
                            } else {
                                $('#circle-persona-name').textContent = text;
                            }
                        }
                    });
                });
            },

            async handleEditCircle(circleId) {
                if (!circleId) return UIManager.showToast("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªåœˆå­");
                const circle = await DBHelper.get('circles', circleId);
                const allContacts = await DBHelper.getAll('contacts');
                const allFolders = await DBHelper.getAll('promptFolders');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const presets = myProfile.presets || [];

                let selectedPersonaId = circle.boundPersonaPresetId; 
                let personaName = 'æœªç»‘å®š (ä½¿ç”¨å½“å‰äººè®¾)';
                if (selectedPersonaId) { 
                    const boundPreset = presets.find(p => p.presetId === selectedPersonaId);
                    if (boundPreset) {
                        personaName = boundPreset.presetName || boundPreset.name;
                    }
                }

                const membersHtml = allContacts.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-members" value="${f.id}" ${circle.memberIds.includes(f.id) ? 'checked' : ''}><span>${f.name}</span></label>`).join('');
                const foldersHtml = allFolders.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-folders" value="${f.id}" ${circle.boundPromptFolderIds && circle.boundPromptFolderIds.includes(f.id) ? 'checked' : ''}><span>${f.name}</span></label>`).join('');

                 UIManager.showModal({
                    title: "ä¿®æ”¹åœˆå­",
                    body: `
                        <div class="form-group"><label for="circle-name-input">åœˆå­åç§°</label><input type="text" id="circle-name-input" value="${circle.name}"></div>
                        <div class="form-group"><label>åœˆå†…å¥½å‹ (è‡³å°‘é€‰1ä¸ª)</label><div class="member-select-list">${membersHtml}</div></div>
                        <div class="form-group"><label for="circle-extra-input">é¢å¤–å¥½å‹ (é€‰å¡«, é€—å·éš”å¼€)</label><input type="text" id="circle-extra-input" value="${circle.extraMembers || ''}"></div>
                        <div class="form-group"><label>ç»‘å®šæç¤ºè¯æ–‡ä»¶å¤¹ (å¯é€‰)</label><div class="member-select-list" style="max-height:150px;">${foldersHtml}</div></div>
                        <div class="form-group">
                            <label>ç»‘å®šç©å®¶äººè®¾ (å¯é€‰)</label>
                            <button id="circle-persona-bind-btn" class="modal-btn btn-secondary" style="width: 100%; text-align: left; padding: 12px 15px;">
                                <i class="fas fa-user-tag" style="margin-right: 10px;"></i>
                                <span id="circle-persona-name">${personaName}</span>
                            </button>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                             const name = $('#circle-name-input').value.trim();
                            if (!name) return UIManager.showToast("åœˆå­åç§°ä¸èƒ½ä¸ºç©º");
                            
                            const existing = (await DBHelper.getAll('circles', 'name')).filter(c => c.id !== circleId);
                            if(existing.some(c => c.name === name)) return UIManager.showToast("è¯¥åœˆå­åç§°å·²å­˜åœ¨");

                            const memberIds = [...$$('input[name="circle-members"]:checked')].map(cb => cb.value);
                            if (memberIds.length === 0) return UIManager.showToast("è‡³å°‘é€‰æ‹©ä¸€åå¥½å‹");

                            const boundPromptFolderIds = [...$$('input[name="circle-folders"]:checked')].map(cb => cb.value);
                            
                            const updatedCircle = { 
                                ...circle, 
                                name, 
                                memberIds, 
                                boundPromptFolderIds, 
                                boundPersonaPresetId: selectedPersonaId, 
                                extraMembers: $('#circle-extra-input').value.trim() 
                            };
                            await DBHelper.put('circles', updatedCircle);
                            UIManager.hideModal();
                            await UIManager.renderMomentsPage();
                        }}
                    ]
                });
                
                $('#circle-persona-bind-btn').addEventListener('click', async () => {
                    const items = [
                        { value: 'null', text: 'ä¸ç»‘å®š (ä½¿ç”¨å½“å‰äººè®¾)' },
                        ...presets.map(preset => ({
                            value: preset.presetId, 
                            text: preset.name
                        }))
                    ];
                    UIManager.showBottomSheet({
                        title: 'é€‰æ‹©ç©å®¶äººè®¾',
                        items: items,
                        onSelect: (value, text) => {
                            selectedPersonaId = (value === 'null') ? null : value; 
                            if (selectedPersonaId === null) {
                                $('#circle-persona-name').textContent = 'ä¸ç»‘å®š (ä½¿ç”¨å½“å‰äººè®¾)';
                            } else {
                                $('#circle-persona-name').textContent = text;
                            }
                        }
                    });
                });
            },

            async handleDeleteCircle() {
                const circles = await DBHelper.getAll('circles');
                 if (circles.length === 0) return UIManager.showToast("æ²¡æœ‰å¯åˆ é™¤çš„åœˆå­");

                const circlesHtml = circles.map(c => `<label class="member-select-item"><input type="checkbox" name="delete-circle" value="${c.id}"><span>${c.name}</span></label>`).join('');
                 UIManager.showModal({
                    title: "åˆ é™¤åœˆå­",
                    body: `<p style="margin-bottom:10px;">é€‰æ‹©è¦åˆ é™¤çš„åœˆå­ï¼ˆå°†åŒæ—¶åˆ é™¤åœˆå­ä¸‹çš„æ‰€æœ‰åŠ¨æ€ï¼‰ï¼š</p><div class="member-select-list">${circlesHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            const idsToDelete = [...$$('input[name="delete-circle"]:checked')].map(cb => cb.value);
                            if (idsToDelete.length === 0) return;

                            for (const id of idsToDelete) {
                                await DBHelper.delete('circles', id);
                                const momentsToDelete = (await DBHelper.getAll('moments')).filter(m => m.circleId === id);
                                for (const moment of momentsToDelete) {
                                    await DBHelper.delete('moments', moment.id);
                                }
                            }
                            
                            if (idsToDelete.includes(appState.currentCircleId)) {
                                appState.currentCircleId = null; 
                            }
                            
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage();
                        }}
                    ]
                 });
            },

            async handleClearCircleHistory() {
                const circleId = appState.currentCircleId;
                if (!circleId) return;

                const circle = await DBHelper.get('circles', circleId);

                UIManager.showModal({
                    title: `æ¸…ç©º"${circle.name}"åŠ¨æ€`,
                    body: `<p>ç¡®å®šè¦æ¸…ç©ºæ­¤æœ‹å‹åœˆçš„æ‰€æœ‰åŠ¨æ€å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤æ¸…ç©º', class: 'btn-danger', handler: async () => {
                            const allMoments = await DBHelper.getAll('moments');
                            const momentsToDelete = allMoments.filter(m => m.circleId === circleId);

                            for (const moment of momentsToDelete) {
                                await DBHelper.delete('moments', moment.id);
                            }

                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage();
                            UIManager.showToast(`"${circle.name}" çš„åŠ¨æ€å·²æ¸…ç©ºã€‚`);
                        }}
                    ]
                });
            },

            async handleExportPrompts() {
                const folders = await DBHelper.getAll('promptFolders');
                if (folders.length === 0) {
                    return UIManager.showToast("æ²¡æœ‰å¯å¯¼å‡ºçš„æ–‡ä»¶å¤¹");
                }
                const folderListHtml = folders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="export-folder" value="${f.id}">
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é€‰æ‹©è¦å¯¼å‡ºçš„æ–‡ä»¶å¤¹",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç”Ÿæˆæ–‡ä»¶', class: 'btn-primary', handler: async () => {
                            const selectedFolderIds = [...$$('input[name="export-folder"]:checked')].map(cb => cb.value);
                            if (selectedFolderIds.length === 0) {
                                return UIManager.showToast("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶å¤¹");
                            }

                            const allPrompts = await DBHelper.getAll('prompts');
                            
                            
                            let filenamePart;
                            if (selectedFolderIds.length === 1) {
                                const folder = folders.find(f => f.id === selectedFolderIds[0]);
                                filenamePart = folder ? folder.name : 'æœªçŸ¥æ–‡ä»¶å¤¹';
                            } else {
                                filenamePart = 'å¤šä¸ªæ–‡ä»¶å¤¹_æç¤ºè¯å¯¼å‡º';
                            }
                            const finalFilename = `${filenamePart}_${new Date().toISOString().slice(0,10)}.json`;
                            
                            
                            const foldersToExport = folders.filter(f => selectedFolderIds.includes(f.id));
                            const promptsToExport = allPrompts.filter(p => selectedFolderIds.includes(p.folderId));
                            
                            const exportData = {
                                folders: foldersToExport,
                                prompts: promptsToExport
                            };
                            
                            const jsonString = JSON.stringify(exportData, null, 2);
                            const blob = new Blob([jsonString], {type: "application/json"});
                            const url = URL.createObjectURL(blob);
                            
                            UIManager.showModal({
                                title: 'æ–‡ä»¶å·²ç”Ÿæˆ',
                                body: `
                                    <p>è¯·ç‚¹å‡»ä¸‹é¢çš„é“¾æ¥ä¸‹è½½æ–‡ä»¶ã€‚</p>
                                    <a href="${url}" download="${finalFilename}" class="modal-btn btn-primary" style="display: block; text-align: center; margin-top: 20px;">
                                        ç‚¹å‡»ä¸‹è½½ ${finalFilename}
                                    </a>
                                    <p style="font-size: 0.8rem; color: #aaa; text-align: center; margin-top: 15px;">(ä¸‹è½½åæ­¤é“¾æ¥å°†å¤±æ•ˆ)</p>
                                `,
                                actions: [{
                                    text: 'å…³é—­',
                                    class: 'btn-secondary',
                                    handler: () => {
                                        URL.revokeObjectURL(url);
                                        UIManager.hideModal();
                                    }
                                }]
                            });
                        }}
                    ]
                });
            },

            async handleWishPool() {
                UIManager.showModal({
                    title: "è§’è‰²è®¸æ„¿æ± ",
                    body: `
                        <div class="details-actions" style="flex-direction: column; gap: 15px;">
                            <button class="details-btn" data-action="buyable" style="border-color: var(--accent-color); color: var(--accent-color-deep);">
                                <i class="fas fa-shopping-cart" style="margin-right: 8px;"></i>å¯è´­è§’è‰²å¡
                            </button>
                            <button class="details-btn" data-action="wishlist" style="border-color: var(--theme-color-2);">
                                <i class="fas fa-list-alt" style="margin-right: 8px;"></i>è®¸æ„¿æ± æ¸…å•
                            </button>
                        </div>
                    `,
                    actions: [
                        { text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() }
                    ]
                });
                
                modalContentWrapper.querySelector('[data-action="buyable"]').addEventListener('click', () => {
                    window.open('https://kdocs.cn/l/cdeUgNwxlWKR', '_blank');
                });
                modalContentWrapper.querySelector('[data-action="wishlist"]').addEventListener('click', () => {
                    window.open('https://docs.qq.com/form/page/DUG5yVWFEZGFxRXd1', '_blank');
                });
            },

            handleImportPrompts() {
                const fileInput = $('#import-prompts-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const importedData = JSON.parse(event.target.result);
                            
                            if (!importedData.folders || !importedData.prompts) {
                                return UIManager.showToast("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®");
                            }
                            
                            const existingFolders = await DBHelper.getAll('promptFolders');
                            let importedCount = 0;

                            for (const importedFolder of importedData.folders) {
                                if (existingFolders.some(f => f.name === importedFolder.name)) {
                                    UIManager.showToast(`å·²è·³è¿‡ï¼šæ–‡ä»¶å¤¹ "${importedFolder.name}" å·²å­˜åœ¨`);
                                    continue;
                                }
                                
                                const oldFolderId = importedFolder.id;
                                const newFolder = {
                                    ...importedFolder,
                                    id: Utils.generateId('folder'), 
                                    createdAt: Date.now()
                                };
                                await DBHelper.put('promptFolders', newFolder);
                                
                                
                                const promptsToImport = importedData.prompts.filter(p => p.folderId === oldFolderId);
                                for (const importedPrompt of promptsToImport) {
                                    const newPrompt = {
                                        ...importedPrompt,
                                        id: Utils.generateId('prompt'), 
                                        folderId: newFolder.id, 
                                        createdAt: Date.now()
                                    };
                                    await DBHelper.put('prompts', newPrompt);
                                    importedCount++;
                                }
                            }
                            
                            UIManager.showToast(`å¯¼å…¥å®Œæˆï¼Œå…±å¯¼å…¥ ${importedCount} æ¡æç¤ºè¯`);
                            this.renderPromptsPage();

                        } catch (error) {
                            console.error("å¯¼å…¥å¤±è´¥: ", error);
                            UIManager.showToast("å¯¼å…¥å¤±è´¥ï¼Œæ–‡ä»¶å¯èƒ½å·²æŸå");
                        } finally {
                            
                            fileInput.value = '';
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            async showAddEditFriendFolderModal(folderId = null) {
                const isEditing = folderId !== null;
                const folder = isEditing ? await DBHelper.get('friendFolders', folderId) : null;
                const allContacts = await DBHelper.getAll('contacts');
                const allFriendFolders = await DBHelper.getAll('friendFolders');
                const folderMap = allFriendFolders.reduce((map, f) => {
                    map[f.id] = f.name;
                    return map;
                }, {});

                let membersHtml = allContacts.map(contact => {
                    const isChecked = isEditing && folder.memberIds.includes(contact.id);
                    let groupInfo = '';
                    if (contact.folderId && (!isEditing || contact.folderId !== folderId)) {
                        groupInfo = ` (åœ¨åˆ†ç»„: ${folderMap[contact.folderId] || 'æœªçŸ¥'})`;
                    }
                    return `
                        <label class="member-select-item" data-friend-name="${(contact.remark || contact.name).toLowerCase()}" data-friend-id="${contact.name.toLowerCase()}">
                            <input type="checkbox" name="friend-folder-members" value="${contact.id}" ${isChecked ? 'checked' : ''}>
                            <img src="${contact.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                            <span>${contact.remark || contact.name}${groupInfo}</span>
                        </label>
                    `;
                }).join('');

                UIManager.showModal({
                    title: isEditing ? 'ç¼–è¾‘å¥½å‹åˆ†ç»„' : 'æ–°å»ºå¥½å‹åˆ†ç»„',
                    body: `
                        <div class="form-group">
                            <label for="friend-folder-name">åˆ†ç»„åç§°</label>
                            <input type="text" id="friend-folder-name" value="${isEditing ? folder.name : ''}">
                        </div>
                        <div class="form-group">
                            <label for="friend-folder-search">æœç´¢å¥½å‹ (å¤‡æ³¨/ID)</label>
                            <input type="text" id="friend-folder-search" placeholder="è¾“å…¥ä»¥ç­›é€‰åˆ—è¡¨...">
                        </div>
                        <div class="form-group">
                            <label>é€‰æ‹©å¥½å‹</label>
                            <div class="member-select-list" id="friend-folder-member-list">${membersHtml}</div>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const name = $('#friend-folder-name').value.trim();
                            if (!name) return UIManager.showToast("åˆ†ç»„åç§°ä¸èƒ½ä¸ºç©º");

                            const existingFolders = (await DBHelper.getAll('friendFolders')).filter(f => f.id !== folderId);
                            if (existingFolders.some(f => f.name === name)) {
                                return UIManager.showToast("è¯¥åˆ†ç»„åç§°å·²å­˜åœ¨");
                            }

                            const selectedMemberIds = [...$$('input[name="friend-folder-members"]:checked')].map(cb => cb.value);
                            const updatedFolder = isEditing ? { ...folder, name, memberIds: selectedMemberIds } : {
                                id: Utils.generateId('friendFolder'),
                                name,
                                memberIds: selectedMemberIds,
                                boundPersonaPresetIndex: null,
                                createdAt: Date.now()
                            };

                            await DBHelper.put('friendFolders', updatedFolder);

                            const contactsToUpdate = await Promise.all(
                                allContacts.map(c => DBHelper.get('contacts', c.id))
                            );

                            for (const contact of contactsToUpdate) {
                                const isInNewSelection = selectedMemberIds.includes(contact.id);
                                
                                if (isInNewSelection && contact.folderId !== updatedFolder.id) {
                                    contact.folderId = updatedFolder.id;
                                    await DBHelper.put('contacts', contact);
                                } else if (!isInNewSelection && contact.folderId === updatedFolder.id) {
                                    delete contact.folderId;
                                    await DBHelper.put('contacts', contact);
                                }
                            }
                            
                            UIManager.hideModal();
                            await UIManager.renderFriendFoldersPage();
                        }}
                    ]
                });
                
                $('#friend-folder-search').addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    $$('#friend-folder-member-list .member-select-item').forEach(item => {
                        const name = item.dataset.friendName;
                        const id = item.dataset.friendId;
                        item.style.display = (name.includes(searchTerm) || id.includes(searchTerm)) ? 'flex' : 'none';
                    });
                });
            },

            async confirmDeleteFriendFolder(folderId) {
                const folder = await DBHelper.get('friendFolders', folderId);
                if (!folder) return;

                const allGroups = await DBHelper.getAll('groups');
                const problematicMembers = [];
                for (const memberId of folder.memberIds) {
                    const groupsIn = allGroups.filter(g => g.members.includes(memberId));
                    if (groupsIn.length > 0) {
                        const contact = await DBHelper.get('contacts', memberId);
                        problematicMembers.push({
                            name: contact.remark || contact.name,
                            groups: groupsIn.map(g => g.name).join(', ')
                        });
                    }
                }

                if (problematicMembers.length > 0) {
                    const errorMsg = problematicMembers.map(p => `<strong>${p.name}</strong> ä»åœ¨ç¾¤èŠ: ${p.groups}`).join('<br>');
                    return UIManager.showModal({
                        title: "æ— æ³•åˆ é™¤åˆ†ç»„",
                        body: `<p>ä»¥ä¸‹å¥½å‹å› ä»åœ¨ç¾¤èŠä¸­è€Œæ— æ³•åˆ é™¤æ­¤å¥½å‹åˆ†ç»„ï¼Œè¯·å…ˆå°†å…¶ç§»å‡ºç¾¤èŠï¼š</p><div style="text-align:left; max-height: 150px; overflow-y: auto; background: #f0f0f0; padding: 10px; border-radius: 8px;">${errorMsg}</div>`,
                        actions: [{ text: 'å¥½çš„', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                }

                UIManager.showModal({
                    title: 'ç¡®è®¤åˆ é™¤åˆ†ç»„',
                    body: `<p>ç¡®å®šè¦åˆ é™¤åˆ†ç»„ <strong>"${folder.name}"</strong> å—ï¼Ÿåˆ†ç»„å†…çš„å¥½å‹å°†è¢«ç§»è‡³â€œæœªåˆ†ç»„â€ã€‚æ­¤æ“ä½œä¸å¯æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤åˆ é™¤', class: 'btn-danger', handler: async () => {
                            for (const memberId of folder.memberIds) {
                                const contact = await DBHelper.get('contacts', memberId);
                                if (contact && contact.folderId === folderId) {
                                    delete contact.folderId;
                                    await DBHelper.put('contacts', contact);
                                }
                            }
                            await DBHelper.delete('friendFolders', folderId);
                            
                            UIManager.hideModal();
                            await UIManager.renderFriendFoldersPage();
                            UIManager.showToast(`åˆ†ç»„ "${folder.name}" å·²åˆ é™¤ã€‚`);
                        }}
                    ]
                });
            },
            
            async showPersonaBindingModal(entityId, isGroupChat) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const presets = (myProfile.presets || []).filter(p => p); 

                let entity, storeName;
                if (isGroupChat) {
                    entity = await DBHelper.get('groups', entityId);
                    storeName = 'groups';
                } else {
                    entity = await DBHelper.get('contacts', entityId);
                    if (entity) {
                        storeName = 'contacts';
                    } else {
                        entity = await DBHelper.get('friendFolders', entityId);
                        storeName = 'friendFolders';
                    }
                }

                if (!entity) return;

                const boundId = entity.boundPersonaPresetId; 

                let presetsHtml = presets.map(preset => {
                    return `
                        <label class="member-select-item">
                            <input type="radio" name="persona-preset" value="${preset.presetId}" ${boundId === preset.presetId ? 'checked' : ''}>
                            <img src="${preset.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                            <span>${preset.presetName || preset.name}</span>
                        </label>
                    `;
                }).join('');

                let boundInfo = '';
                if (boundId && !presets.some(p => p.presetId === boundId)) {
                    boundInfo = `<p style="color: #e74c3c; text-align: center; margin-bottom: 10px;">æ³¨æ„ï¼šå·²ç»‘å®šçš„é¢„è®¾å·²è¢«åˆ é™¤ï¼Œå°†è‡ªåŠ¨ä½¿ç”¨å½“å‰ç©å®¶äººè®¾ã€‚</p>`;
                }
                
                const hint = `<p style="font-size: 0.8rem; color: var(--text-color-medium); text-align: center; margin-top: 15px;">æç¤ºï¼šå¥½å‹åˆ†ç»„å’Œç¾¤èŠçš„äººè®¾ç»‘å®šæ˜¯åˆ†å¼€çš„ï¼Œä¸è¦å¿˜è®°å•¦ã€‚</p>`;

                UIManager.showModal({
                    title: 'ç»‘å®šç©å®¶äººè®¾',
                    body: `
                        ${boundInfo}
                        <div class="member-select-list" style="max-height: 40vh;">
                            <label class="member-select-item">
                                <input type="radio" name="persona-preset" value="null" ${!boundId ? 'checked' : ''}>
                                <span>ä¸ç»‘å®š (ä½¿ç”¨å½“å‰äººè®¾)</span>
                            </label>
                            ${presetsHtml}
                        </div>
                        ${hint}
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const selectedRadio = document.querySelector('input[name="persona-preset"]:checked');
                            if (!selectedRadio) return;

                            const selectedId = selectedRadio.value;
                            entity.boundPersonaPresetId = (selectedId === 'null') ? null : selectedId;

                            
                            delete entity.boundPersonaPresetIndex;

                            await DBHelper.put(storeName, entity);
                            
                            UIManager.hideModal();
                            UIManager.showToast('äººè®¾ç»‘å®šå·²æ›´æ–°ï¼');
                        }}
                    ]
                });
            },

            async showCircleBindingModal(entityId, isFolder) {
                const circles = await DBHelper.getAll('circles');
                if (circles.length === 0) {
                    return UIManager.showToast("è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•åœˆå­");
                }

                const storeName = isFolder ? 'friendFolders' : 'contacts';
                const entity = await DBHelper.get(storeName, entityId);
                if (!entity) return;

                let itemsHtml;
                const boundCircleId = entity.boundCircleId || 'null';

                
                if (isFolder) {
                    
                    itemsHtml = `
                        <label class="member-select-item">
                            <input type="radio" name="circle-bind" value="null" checked>
                            <span>ä¸ç»‘å®š</span>
                        </label>
                        ${circles.map(c => `
                            <label class="member-select-item">
                                <input type="radio" name="circle-bind" value="${c.id}">
                                <span>${c.name}</span>
                            </label>
                        `).join('')}
                    `;
                } else {
                    
                    itemsHtml = `
                        <label class="member-select-item">
                            <input type="radio" name="circle-bind" value="null" ${boundCircleId === 'null' ? 'checked' : ''}>
                            <span>ä¸ç»‘å®š</span>
                        </label>
                        ${circles.map(c => `
                            <label class="member-select-item">
                                <input type="radio" name="circle-bind" value="${c.id}" ${boundCircleId === c.id ? 'checked' : ''}>
                                <span>${c.name}</span>
                            </label>
                        `).join('')}
                    `;
                }

                
                const hintText = `<p style="font-size: 0.8rem; color: var(--text-color-medium); text-align: center; margin-top: 15px; line-height: 1.5;">
                    æç¤ºï¼šç»‘å®šåï¼ŒAIåœ¨èŠå¤©æ—¶å¯èƒ½ä¼šè§¦å‘å³æ—¶æœ‹å‹åœˆåŠ¨æ€ã€‚æ­¤åŠ¨æ€ä¸å—åœˆå­å†…å¥½å‹é™åˆ¶ï¼Œè¯„è®ºåŒºå¯èƒ½å‡ºç°è®¾å®šå¤–çš„è§’è‰²ã€‚
                </p>`;

                UIManager.showModal({
                    title: isFolder ? `ä¸ºåˆ†ç»„â€œ${entity.name}â€ç»‘å®šæœ‹å‹åœˆ` : `ä¸ºå¥½å‹â€œ${entity.remark || entity.name}â€ç»‘å®šæœ‹å‹åœˆ`,
                    
                    body: `<div class="member-select-list" style="max-height: 40vh;">${itemsHtml}</div>${hintText}`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const selected = document.querySelector('input[name="circle-bind"]:checked');
                            if (!selected) return;

                            const newBoundId = selected.value === 'null' ? null : selected.value;
                            
                            if (isFolder) {
                                UIManager.showModal({
                                    title: 'ç¡®è®¤æ‰¹é‡ç»‘å®š',
                                    body: `<p>è¿™å°†æŠŠåˆ†ç»„â€œ<strong>${entity.name}</strong>â€å†…æ‰€æœ‰å¥½å‹çš„æœ‹å‹åœˆç»‘å®šéƒ½æ›´æ–°ä¸ºæ‰€é€‰åœˆå­ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ</p><p style="font-size: 0.8rem; color: #aaa;">æ­¤æ“ä½œä¼šè¦†ç›–å¥½å‹åŸæœ‰çš„å•ç‹¬ç»‘å®šã€‚</p>`,
                                    actions: [
                                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                        { text: 'ç¡®è®¤', class: 'btn-primary', handler: async () => {
                                            entity.boundCircleId = newBoundId;
                                            await DBHelper.put(storeName, entity);
                                            
                                            const contactsInFolder = (await DBHelper.getAll('contacts')).filter(c => c.folderId === entityId);
                                            for (const contact of contactsInFolder) {
                                                contact.boundCircleId = newBoundId;
                                                await DBHelper.put('contacts', contact);
                                            }
                                            UIManager.hideModal();
                                            UIManager.showToast('åˆ†ç»„æœ‹å‹åœˆç»‘å®šå·²æ›´æ–°ï¼');
                                        }}
                                    ]
                                });
                            } else {
                                entity.boundCircleId = newBoundId;
                                await DBHelper.put(storeName, entity);
                                UIManager.hideModal();
                                UIManager.showToast('å¥½å‹æœ‹å‹åœˆç»‘å®šå·²æ›´æ–°ï¼');
                            }
                        }}
                    ]
                });
            },

            startPomodoro() {
                const goal = $('#pomodoro-goal-input').value.trim();
                if (!goal) {
                    UIManager.showToast("å…ˆä¸ºä½ çš„ä¸“æ³¨æ—¶æ®µå®šä¸€ä¸ªç›®æ ‡å§ï¼");
                    return;
                }

                appState.pomodoro.isActive = true;
                appState.pomodoro.goal = goal;
                appState.pomodoro.totalSeconds = 1500; 
                appState.pomodoro.endTime = Date.now() + appState.pomodoro.totalSeconds * 1000;
                appState.pomodoro.timerId = setInterval(() => this.updatePomodoroTimer(), 1000);

                
                localStorage.setItem('pomodoroState', JSON.stringify(appState.pomodoro));

                UIManager.renderPomodoroPage();
                this.updateFloatingBallVisibility();
            },

            stopPomodoro(isCompleted = false) {
                if (!appState.pomodoro.isActive) return;

                clearInterval(appState.pomodoro.timerId);

                if (isCompleted) {
                    UIManager.showPomodoroEndNotification(appState.pomodoro.goal);
                }

                appState.pomodoro.isActive = false;
                appState.pomodoro.goal = '';
                appState.pomodoro.endTime = null;
                appState.pomodoro.timerId = null;
                
                
                localStorage.setItem('pomodoroState', JSON.stringify(appState.pomodoro));

                UIManager.renderPomodoroPage();
                this.updateFloatingBallVisibility();
            },

            updatePomodoroTimer() {
                if (!appState.pomodoro.isActive || !appState.pomodoro.endTime) {
                    this.stopPomodoro();
                    return;
                }

                const now = Date.now();
                const remainingSeconds = Math.round((appState.pomodoro.endTime - now) / 1000);

                if (remainingSeconds <= 0) {
                    this.stopPomodoro(true);
                    return;
                }

                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                if (appState.currentPage === 'pomodoro') {
                    $('#pomodoro-timer-display').textContent = timeString;
                }
                
                const floatBall = $('#pomodoro-float-ball');
                if (floatBall) {
                    floatBall.querySelector('.time-left').textContent = timeString;
                    const progress = (appState.pomodoro.totalSeconds - remainingSeconds) / appState.pomodoro.totalSeconds;
                    floatBall.querySelector('.progress-ring').style.background = `conic-gradient(var(--accent-color) ${progress * 360}deg, #e0e0e0 0deg)`;
                }
            },

            updateFloatingBallVisibility() {
                const floatBall = $('#pomodoro-float-ball');
                if (appState.pomodoro.isActive && appState.currentPage !== 'pomodoro') {
                    floatBall.classList.remove('hidden');
                } else {
                    floatBall.classList.add('hidden');
                }
            },



            createGiftCard(giftData) {
                const card = document.createElement('div');
                card.className = 'gift-card';
                card.innerHTML = `
                    <img src="${giftData.image || giftData.url}" alt="${giftData.name}">
                    <div class="gift-card-info">
                        <div class="name">${giftData.name}</div>
                        <div class="price">ï¿¥${giftData.price.toFixed(2)}</div>
                    </div>
                `;
                return card;
            },

            showGiftHelpModal() {
                UIManager.showModal({
                    title: "ç¤¼ç‰©æœç´¢å¸®åŠ©",
                    body: `
                        <p>ç¤¼ç‰©æœç´¢åŠŸèƒ½é€šè¿‡AIç”Ÿæˆï¼Œå› æ­¤åœ¨ä½¿ç”¨å‰éœ€è¦æ­£ç¡®é…ç½®APIï¼Œæ­¤åŠŸèƒ½ä»…ä¾›å¨±ä¹æœç´¢ã€‚é™¤äº†AIæœç´¢ï¼Œä½ è¿˜å¯ä»¥é€‰æ‹©<strong>è‡ªå®šä¹‰</strong>æ‰‹åŠ¨å¡«å…¥è‡ªå·±æƒ³è¦èµ é€çš„ç¤¼ç‰©</p>
                        <p><strong>1. APIé…ç½®ï¼š</strong> ç‚¹å‡»é¡µé¢ä¸Šçš„â€œAPIé…ç½®â€æŒ‰é’®ï¼Œå¡«å…¥ä½ çš„APIä¿¡æ¯ã€‚ç”±äºç¤¼ç‰©æœç´¢åŠŸèƒ½ç›¸å¯¹ç®€å•ï¼Œä½ å¯ä»¥é€‰æ‹©ä¸€äº›å…è´¹æˆ–ä»·æ ¼è¾ƒä½çš„æ¨¡å‹ã€‚</p>
                        <p><strong>2. æ¨èæ¨¡å‹ï¼š</strong></p>
                        <ul>
                            <li><strong>SiliconFlow (ç¡…åŸºæµåŠ¨):</strong> <code>deepseek-ai/DeepSeek-R1-0528-Qwen3-8B</code>(åœ¨ç¡…åŸºæµåŠ¨å®˜ç½‘ä¸Š,è¯¥æ¨¡å‹ç›®å‰æ˜¯å…è´¹æ¨¡å‹,ä½†ä½¿ç”¨æ—¶ä¾ç„¶éœ€è¦å¡«å†™æ­£ç¡®çš„API key)</li>
                        </ul>
                        <p><strong>3. ç»‘å®šæç¤ºè¯ï¼š</strong> ä½ è¿˜å¯ä»¥é€šè¿‡â€œç»‘å®šâ€åŠŸèƒ½ï¼Œé€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ªè‡ªå®šä¹‰æç¤ºè¯æ–‡ä»¶å¤¹ã€‚è¿™äº›æç¤ºè¯å°†åœ¨æ¯æ¬¡æœç´¢æ—¶é™„åŠ ï¼Œç”¨äºå½±å“AIç”Ÿæˆç¤¼ç‰©çš„é£æ ¼å’Œç±»å‹ï¼Œå®ç°æ›´ä¸ªæ€§åŒ–çš„æœç´¢ç»“æœã€‚</p>
                    `,
                    actions: [{ text: 'æˆ‘æ˜ç™½äº†', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleGiftPromptBinding() {
                const giftApiConfig = await DBHelper.get('giftApiConfig', 'mainConfig') || {};
                const boundFolderIds = giftApiConfig.giftPromptFolderIds || [];
                const allFolders = await DBHelper.getAll('promptFolders');

                if (allFolders.length === 0) {
                    return UIManager.showToast("ä½ è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•æç¤ºè¯æ–‡ä»¶å¤¹ã€‚");
                }

                const folderListHtml = allFolders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="bind-gift-folder" value="${f.id}" ${boundFolderIds.includes(f.id) ? 'checked' : ''}>
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "ç»‘å®šç¤¼ç‰©æœç´¢æç¤ºè¯",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const selectedIds = [...$$('input[name="bind-gift-folder"]:checked')].map(cb => cb.value);
                            const configToSave = await DBHelper.get('giftApiConfig', 'mainConfig') || { id: 'mainConfig' };
                            configToSave.giftPromptFolderIds = selectedIds;
                            await DBHelper.put('giftApiConfig', configToSave);
                            UIManager.hideModal();
                            UIManager.showToast("ç»‘å®šå·²æ›´æ–°ï¼");
                        }}
                    ]
                });
            },

            async showSendGiftModal(giftData) {
                const isGroup = appState.currentChatId.startsWith('group-');

                const displayFinalModal = (recipient) => {
                    UIManager.showModal({
                        title: `é€ç»™ ${recipient.remark || recipient.name}`,
                        body: `
                            <div style="text-align: center; margin-bottom: 20px;">
                                <img src="${giftData.image || giftData.url}" alt="${giftData.name}" style="width: 100px; height: 100px; object-fit: cover; border-radius: 12px;">
                                <h4 style="margin: 10px 0 5px;">${giftData.name}</h4>
                                <p style="color: var(--text-color-medium); font-size: 0.9rem; margin-bottom: 10px;">${giftData.description || giftData.message || 'ä¸€ä»½ç‰¹åˆ«çš„ç¤¼ç‰©'}</p>
                                <p style="color: var(--accent-color-deep); font-weight: bold;">ï¿¥${giftData.price.toFixed(2)}</p>
                            </div>
                            <div class="form-group">
                                <label for="gift-final-message">å¯„è¯­ (é€‰å¡«)</label>
                                <input type="text" id="gift-final-message" value="" placeholder="é€ä½ ä¸€ä»½å¿ƒæ„ã€‚">
                            </div>
                        `,
                        actions: [
                            { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                            { text: 'èµ é€', class: 'btn-primary', handler: async () => {
                                const message = $('#gift-final-message').value.trim();
                                
                                const giftMessage = {
                                    messageId: Utils.generateId('msg'),
                                    content: `[ç¤¼ç‰©] ${giftData.name}`,
                                    type: 'sent',
                                    segmentType: 'gift',
                                    cardData: {
                                        recipientName: recipient.name, 
                                        name: giftData.name,
                                        price: giftData.price.toFixed(2),
                                        image: giftData.image || giftData.url,
                                        message: message || 'é€ä½ ä¸€ä»½å¿ƒæ„ã€‚',
                                        description: giftData.description || ''
                                    }
                                };
                                
                                await this.handlePlayerSendMessage(giftMessage);
                                UIManager.hideModal();
                                UIManager.navigateTo('chat');
                            }}
                        ]
                    });
                };

                if (isGroup) {
                    const group = await DBHelper.get('groups', appState.currentChatId);
                    const allContacts = await DBHelper.getAll('contacts');
                    const members = group.members
                        .map(id => allContacts.find(c => c.id === id))
                        .filter(Boolean);

                    if (members.length === 0) {
                        return UIManager.showToast("ç¾¤èŠä¸­æ²¡æœ‰å¯ä»¥èµ é€ç¤¼ç‰©çš„æˆå‘˜ã€‚");
                    }

                    UIManager.showBottomSheet({
                        title: 'é€‰æ‹©è¦èµ é€çš„æˆå‘˜',
                        customClass: 'compact-list',
                        items: members.map(m => ({ value: m.id, text: m.remark || m.name })),
                        onSelect: async (selectedMemberId) => {
                            const selectedMember = members.find(m => m.id === selectedMemberId);
                            if (selectedMember) {
                                displayFinalModal(selectedMember);
                            }
                        }
                    });

                } else {
                    const recipient = await DBHelper.get('contacts', appState.currentChatId);
                    if (recipient) {
                        displayFinalModal(recipient);
                    }
                }
            },

async showGiftDetailsModal(messageId) {
    const msg = await DBHelper.get('messages', messageId);
    if (!msg || !msg.cardData) return;

    const myProfile = await this.getPlayerProfileForContext(msg.chatId);
    let sender, recipient;

    if (msg.type === 'sent') {
        sender = myProfile;
        const isGroupChat = msg.chatId.startsWith('group-');
        if (isGroupChat) {
            
            const allContacts = await DBHelper.getAll('contacts');
            recipient = allContacts.find(c => c.name === msg.cardData.recipientName) || { name: msg.cardData.recipientName };
        } else {
            
            recipient = await DBHelper.get('contacts', msg.chatId);
        }
    } else {
        
        sender = await DBHelper.get('contacts', msg.senderId) || { name: 'æœªçŸ¥å‘ä»¶äºº' };
        recipient = myProfile;
    }

    UIManager.showModal({
        title: "ç¤¼ç‰©è¯¦æƒ…",
        body: `
            <div style="text-align: center; margin-bottom: 20px;">
                <img src="${msg.cardData.image}" alt="${msg.cardData.name}" style="width: 120px; height: 120px; object-fit: cover; border-radius: 12px; box-shadow: var(--shadow-light);">
                <h3 style="margin: 15px 0 5px;">${msg.cardData.name}</h3>
                <p style="color: var(--accent-color-deep); font-weight: bold; margin-bottom: 15px;">ï¿¥${msg.cardData.price}</p>
            </div>
            <div class="details-card" style="padding: 15px;">
                <div class="details-field"><span class="label">èµ é€æ–¹</span><span class="value">${sender.name}</span></div>
                <div class="details-field"><span class="label">æ¥æ”¶æ–¹</span><span class="value">${recipient.name}</span></div>
                ${msg.cardData.description ? `
                <div class="details-section" style="margin-top: 15px;">
                    <div class="details-section-title">ç¤¼ç‰©ä»‹ç»</div>
                    <p>${msg.cardData.description}</p>
                </div>` : ''}
                <div class="details-section" style="margin-top: 15px;">
                    <div class="details-section-title">å¯„è¯­</div>
                    <p>${msg.cardData.message}</p>
                </div>
            </div>
        `,
        actions: [
            { text: 'å…³é—­', class: 'btn-primary', handler: () => UIManager.hideModal() }
        ]
    });
},
            
            showCustomGiftModal() {
                const giftImageLibrary = [
                    'https://cfimg.200996.xyz/file/1752744399723_retouch_2025071717250175.png',
                    'https://cfimg.200996.xyz/file/1752744402256_retouch_2025071717245049.png',
                    'https://cfimg.200996.xyz/file/1752744401540_retouch_2025071717242531.png',
                    'https://cfimg.200996.xyz/file/1752744403509_retouch_2025071717243405.png',
                    'https://cfimg.200996.xyz/file/1752744399889_retouch_2025071717244351.png'
                ];
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';

                UIManager.showModal({
                    title: "è‡ªå®šä¹‰ç¤¼ç‰©",
                    body: `
                        <div class="form-group">
                            <label>ä¸Šä¼ ç¤¼ç‰©å›¾ç‰‡ (å¯é€‰)</label>
                            <div class="avatar-uploader">
                                <img src="${defaultPlaceholderSvg}" id="custom-gift-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                <input type="file" id="custom-gift-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('custom-gift-input').click()">é€‰æ‹©å›¾ç‰‡</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-name">ç¤¼ç‰©åç§°</label>
                            <input type="text" id="custom-gift-name" placeholder="ä¾‹å¦‚ï¼šæ°¸æ’çš„çˆ±">
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-description">ç¤¼ç‰©ä»‹ç» (é€‰å¡«)</label>
                            <textarea id="custom-gift-description" rows="2" placeholder="æè¿°ä¸€ä¸‹è¿™ä¸ªç¤¼ç‰©..."></textarea>
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-price">ç¤¼ç‰©ä»·æ ¼</label>
                            <input type="number" id="custom-gift-price" placeholder="0.00">
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-message">å¯„è¯­ (é€‰å¡«)</label>
                            <input type="text" id="custom-gift-message" placeholder="ä¸€ç‚¹å¿ƒæ„...">
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤', class: 'btn-primary', handler: () => {
                            let imageUrl = $('#custom-gift-preview').src;
                            
                            if (imageUrl === defaultPlaceholderSvg) {
                                imageUrl = giftImageLibrary[Math.floor(Math.random() * giftImageLibrary.length)];
                            }

                            const customGift = {
                                name: $('#custom-gift-name').value.trim(),
                                price: parseFloat($('#custom-gift-price').value) || 0,
                                image: imageUrl,
                                message: $('#custom-gift-message').value.trim(),
                                description: $('#custom-gift-description').value.trim(),
                            };

                            if (!customGift.name) {
                                return UIManager.showToast("ç¤¼ç‰©åç§°ä¸èƒ½ä¸ºç©ºå“¦");
                            }
                            UIManager.hideModal();
                            this.showSendGiftModal(customGift);
                        }}
                    ]
                });
                
                $('#custom-gift-input').onchange = async (e) => {
                    const file = e.target.files[0];
                    if(file) {
                         $('#custom-gift-preview').src = await Utils.fileToBase64(file);
                    }
                };
            },

            async handleDeleteLastTurn() {
                const chatId = appState.currentChatId;
                if (!chatId) return;

                const allMessages = await DBHelper.getMessages(chatId, 50); 
                if (allMessages.length === 0) {
                    UIManager.showToast("æ²¡æœ‰å¯åˆ é™¤çš„æ¶ˆæ¯");
                    return;
                }

                const lastMessage = allMessages[allMessages.length - 1];
                const lastTurnType = lastMessage.type;
                const senderName = lastTurnType === 'sent' ? 'ä½ ' : 'å¯¹æ–¹';

                const messagesToDelete = [];
                for (let i = allMessages.length - 1; i >= 0; i--) {
                    const currentMessage = allMessages[i];
                    if (currentMessage.type === lastTurnType) {
                        messagesToDelete.push(currentMessage);
                    } else {
                        break; 
                    }
                }

                if (messagesToDelete.length === 0) {
                    UIManager.showToast("æ²¡æœ‰æ‰¾åˆ°å¯åˆ é™¤çš„æ¶ˆæ¯è½®æ¬¡");
                    return;
                }

                UIManager.showModal({
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤ ${senderName} çš„æœ€æ–° ${messagesToDelete.length} æ¡æ¶ˆæ¯å—ï¼Ÿ(å«å¿ƒå£°éšç¬”)</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'åˆ é™¤', class: 'btn-danger', handler: async () => {
                            for (const msg of messagesToDelete) {
                                await DBHelper.delete('messages', msg.messageId);
                                const element = $(`#${msg.messageId}`);
                                if (element) element.remove();
                            }

                            
                            const remainingMessages = allMessages.filter(m => !messagesToDelete.some(d => d.messageId === m.messageId));
                            if (remainingMessages.length > 0) {
                                const newLastMessage = remainingMessages[remainingMessages.length - 1];
                                await UIManager.updateChatMetadata(chatId, newLastMessage);
                            } else {
                                
                                await DBHelper.delete('chatMetadata', chatId);
                            }

                            UIManager.hideModal();
                            UIManager.showToast("å·²åˆ é™¤æœ€æ–°ä¸€è½®æ¶ˆæ¯");
                        }}
                    ]
                });
            },

            async showGiftApiConfigModal() {
                let config = await DBHelper.get('giftApiConfig', 'mainConfig');
                if (!config) {
                    
                    config = { id: 'mainConfig', provider: 'siliconflow', url: '', key: '', model: '' };
                }

                 UIManager.showModal({
                    title: 'ç¤¼ç‰©æœç´¢ API é…ç½®',
                    body: `
                        <div class="form-group">
                            <label for="gift-api-provider">APIæä¾›å•†</label>
                            <select id="gift-api-provider">
                                <option value="siliconflow" ${config.provider === 'siliconflow' ? 'selected' : ''}>SiliconFlow (ç¡…åŸºæµåŠ¨)</option>
                                <option value="gemini" ${config.provider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                                <option value="paioupu" ${config.provider === 'paioupu' ? 'selected' : ''}>æ´¾æ¬§äº‘</option>
                                <option value="custom" ${config.provider === 'custom' ? 'selected' : ''}>è‡ªå®šä¹‰</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="gift-api-url">API URL</label>
                            <input type="text" id="gift-api-url" value="${config.url}" placeholder="è¾“å…¥API URL">
                        </div>
                        <div class="form-group">
                            <label for="gift-api-key">API Key</label>
                            <div style="position: relative; display: flex; align-items: center;">
                                <input type="password" id="gift-api-key" value="${config.key}" placeholder="è¾“å…¥APIå¯†é’¥" style="width: 100%; padding-right: 40px;">
                                <i class="fas fa-eye" id="toggle-gift-api-key-visibility" style="position: absolute; right: 15px; cursor: pointer; color: #aaa;"></i>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="gift-api-model-select">æ¨¡å‹</label>
                            <select id="gift-api-model-select"></select>
                            <input type="text" id="gift-api-model-input" value="${config.model}" placeholder="è¾“å…¥è‡ªå®šä¹‰æ¨¡å‹åç§°" style="display:none;">
                        </div>
                        <button id="use-default-api-btn" class="modal-btn btn-secondary" style="width: 100%; margin-top: 10px;">ä½¿ç”¨ä¸»APIé…ç½®</button>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ä¿å­˜', class: 'btn-primary', handler: async () => {
                            const newConfig = {
                                id: 'mainConfig',
                                provider: $('#gift-api-provider').value,
                                url: $('#gift-api-url').value.trim(),
                                key: $('#gift-api-key').value.trim(),
                                temperature: 0.5 
                            };
                            
                            const modelSelect = $('#gift-api-model-select');
                            const modelInput = $('#gift-api-model-input');
                            if (modelInput.style.display !== 'none') {
                                newConfig.model = modelInput.value.trim();
                            } else {
                                newConfig.model = modelSelect.value;
                            }

                            await DBHelper.put('giftApiConfig', newConfig);
                            UIManager.hideModal();
                        }}
                    ]
                });

                
                const giftToggleBtn = $('#toggle-gift-api-key-visibility');
                const giftApiKeyInput = $('#gift-api-key');
                if (giftToggleBtn && giftApiKeyInput) {
                    giftToggleBtn.addEventListener('click', () => {
                        if (giftApiKeyInput.type === 'password') {
                            giftApiKeyInput.type = 'text';
                            giftToggleBtn.classList.remove('fa-eye');
                            giftToggleBtn.classList.add('fa-eye-slash');
                        } else {
                            giftApiKeyInput.type = 'password';
                            giftToggleBtn.classList.remove('fa-eye-slash');
                            giftToggleBtn.classList.add('fa-eye');
                        }
                    });
                }

                const updateGiftApiFields = () => {
                    const provider = $('#gift-api-provider').value;
                    const apiUrlInput = $('#gift-api-url');
                    const modelSelect = $('#gift-api-model-select');
                    const modelInput = $('#gift-api-model-input');
                    const currentModel = config.model;
                    
                    modelSelect.innerHTML = '';
                    
                    const modelOptions = {
                        gemini: [ "gemini-2.5-flash", "gemini-2.5-pro", "gemini-1.5-flash-latest", "gemini-1.5-pro-latest" ],
                        siliconflow: [ "deepseek-ai/DeepSeek-V3", "deepseek-ai/DeepSeek-R1-0528-Qwen3-8B", "Qwen/Qwen2-7B-Instruct", "01-ai/Yi-1.5-34B-Chat" ],
                        paioupu: [ "deepseek/deepseek-v3" ],
                        custom: [] 
                    };

                    const setOptions = (options, defaultModel) => {
                        if (options.length === 0) {
                            modelSelect.style.display = 'none';
                            modelInput.style.display = 'block';
                            modelInput.value = currentModel || defaultModel;
                        } else {
                            modelSelect.style.display = 'block';
                            modelInput.style.display = 'none';
                            const finalOptions = [...options, "å…¶ä»–"];
                            modelSelect.innerHTML = finalOptions.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                            
                            if (finalOptions.includes(currentModel)) {
                                modelSelect.value = currentModel;
                            } else if (currentModel) {
                                modelSelect.value = "å…¶ä»–";
                                modelInput.style.display = 'block';
                                modelInput.value = currentModel;
                            } else {
                                modelSelect.value = options[0];
                            }
                        }
                    };
                    
                    const providerData = {
                        siliconflow: { url: 'https://api.siliconflow.cn/v1/chat/completions', models: modelOptions.siliconflow, defaultModel: 'deepseek-ai/DeepSeek-R1-0528-Qwen3-8B' },
                        gemini: { url: 'https://generativelanguage.googleapis.com/v1beta/models/', models: modelOptions.gemini, defaultModel: 'gemini-2.5-flash' },
                        paioupu: { url: 'https://api.ppinfra.com/v3/openai', models: modelOptions.paioupu, defaultModel: 'deepseek/deepseek-v3' },
                        custom: { url: '', models: [], defaultModel: '' }
                    };

                    const data = providerData[provider] || providerData.custom;
                    apiUrlInput.value = config.url || data.url;
                    setOptions(data.models, data.defaultModel);
                };

                $('#gift-api-provider').addEventListener('change', () => {
                    config.url = ''; 
                    config.model = ''; 
                    updateGiftApiFields();
                });
                
                $('#gift-api-model-select').addEventListener('change', (e) => {
                    const modelInput = $('#gift-api-model-input');
                    if (e.target.value === 'å…¶ä»–') {
                        modelInput.style.display = 'block';
                        modelInput.value = '';
                        modelInput.focus();
                    } else {
                        modelInput.style.display = 'none';
                    }
                });
                
                updateGiftApiFields();
                
                $('#use-default-api-btn').onclick = async () => {
                    const mainApiConfig = await DBHelper.get('apiConfig', 'mainConfig');
                    if (mainApiConfig) {
                        const provider = mainApiConfig.provider;
                        const keysForProvider = mainApiConfig.keys ? (mainApiConfig.keys[provider] || []) : [];
                        const firstKey = keysForProvider.length > 0 ? keysForProvider[0] : '';
                        
                        if (!firstKey) {
                            UIManager.showToast(`ä¸»é…ç½®ä¸­â€œ${provider}â€æä¾›å•†æ²¡æœ‰è®¾ç½®API Key`);
                            return;
                        }

                        
                        $('#gift-api-provider').value = provider;
                        $('#gift-api-url').value = mainApiConfig.url;
                        $('#gift-api-key').value = firstKey;
                        
                        
                        config.provider = provider;
                        config.url = mainApiConfig.url;
                        config.key = firstKey;
                        config.model = mainApiConfig.models ? mainApiConfig.models[provider] : ''; 

                        updateGiftApiFields(); 
                        
                        UIManager.showToast("å·²è½½å…¥ä¸»APIé…ç½®");
                    } else {
                        UIManager.showToast("æœªæ‰¾åˆ°ä¸»APIé…ç½®");
                    }
                };
            },

            async showEmojiIdExtractionModal() {
                const customEmojis = appState.customEmojis;
                if (Object.keys(customEmojis).length === 0) {
                    return UIManager.showToast("ä½ è¿˜æ²¡æœ‰æ·»åŠ ä»»ä½•è‡ªå®šä¹‰è¡¨æƒ…åŒ…");
                }

                const emojiListHtml = Object.entries(customEmojis).map(([id, data]) => `
                    <label class="member-select-item">
                        <input type="checkbox" name="extract-emoji-id" value="${id}">
                        <img src="${data.url}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${data.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "é€‰æ‹©è¦æå–IDçš„è¡¨æƒ…åŒ…",
                    body: `
                        <button id="select-all-extract-emojis-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 10px; padding: 8px;">å…¨é€‰</button>
                        <div class="member-select-list" style="max-height: 35vh;">${emojiListHtml}</div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 15px; line-height: 1.5;">
                            <strong>æç¤ºï¼š</strong>å¦‚æœä½ åœ¨èŠå¤©è®¾ç½®é‡Œå…³é—­äº†<strong>è‡ªå®šä¹‰è¡¨æƒ…å¯ç”¨ä¸ºæç¤ºè¯</strong>ï¼ŒåŒæ—¶å¸Œæœ›aiå‘é€è‡ªå®šä¹‰çš„è¡¨æƒ…åŒ…ï¼Œä½ éœ€è¦æå–idåé•¿æŒ‰å¤åˆ¶å†…å®¹ï¼Œç„¶åå‰å¾€ <strong>è®¾ç½® > è‡ªå®šä¹‰æç¤ºè¯</strong>ï¼Œæ–°å»ºä¸€ä¸ªæç¤ºè¯ï¼ˆå¦‚â€œæˆ‘çš„è¡¨æƒ…åŒ…â€ï¼‰ï¼Œå°†å¤åˆ¶çš„å†…å®¹ç²˜è´´è¿›å»ï¼Œæœ€åä¸ºéœ€è¦çš„å¥½å‹/ç¾¤èŠç»‘å®šè¿™ä¸ªæç¤ºè¯å³å¯ã€‚<strong>æ²¡æœ‰å…³é—­è¯¥æŒ‰é’®åˆ™å¿½ç•¥æ­¤æç¤º</strong>
                        </p>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç”Ÿæˆ', class: 'btn-primary', handler: () => {
                            this.displayGeneratedEmojiIds();
                        }}
                    ]
                });

                $('#select-all-extract-emojis-btn').addEventListener('click', () => {
                    $$('input[name="extract-emoji-id"]').forEach(cb => cb.checked = true);
                });
            },

            displayGeneratedEmojiIds() {
                const checkedEmojis = $$('input[name="extract-emoji-id"]:checked');
                if (checkedEmojis.length === 0) {
                    return UIManager.showToast("è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè¡¨æƒ…åŒ…");
                }

                let formattedText = 'é¢å¤–è¡¨æƒ…åŒ…:\n';
                checkedEmojis.forEach(checkbox => {
                    const id = checkbox.value;
                    const name = appState.customEmojis[id]?.name || 'æœªçŸ¥è¡¨æƒ…';
                    formattedText += `${id}:${name}\n`;
                });
                
                UIManager.showModal({
                    title: "è¡¨æƒ…åŒ…IDæå–ç»“æœ",
                    body: `
                        <style>
                            #emoji-id-display {
                                width: 100%;
                                max-height: 200px;
                                overflow-y: auto;
                                font-family: monospace;
                                white-space: pre-wrap; /* å…è®¸è‡ªåŠ¨æ¢è¡Œ */
                                word-break: break-all; /* å…è®¸åœ¨å•è¯å†…æ¢è¡Œ */
                                user-select: text; /* ç¡®ä¿æ–‡æœ¬å¯é€‰ */
                                -webkit-user-select: text; /* å…¼å®¹æ—§ç‰ˆæµè§ˆå™¨ */
                                background-color: var(--text-color-white);
                                border: 1px solid var(--border-color);
                                border-radius: 8px;
                                padding: 10px;
                                font-size: 0.9rem;
                                color: var(--text-color-dark);
                                box-sizing: border-box;
                            }
                        </style>
                        <pre id="emoji-id-display">${formattedText}</pre>
                    `,
                    actions: [
                        { text: 'å…³é—­', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å¤åˆ¶', class: 'btn-primary', id: 'copy-emoji-ids-btn' }
                    ]
                });

                const copyButton = $('#copy-emoji-ids-btn');
                if (copyButton) {
                    copyButton.addEventListener('click', async () => {
                        const textToCopy = $('#emoji-id-display').textContent;
                        
                        const copyTextFallback = (text) => {
                            const textArea = document.createElement("textarea");
                            textArea.value = text;
                            textArea.style.position = "fixed";
                            textArea.style.top = "-9999px";
                            textArea.style.left = "-9999px";
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            try {
                                const successful = document.execCommand('copy');
                                if (successful) {
                                    UIManager.showToast("å·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿ï¼");
                                } else {
                                    UIManager.showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
                                }
                            } catch (err) {
                                console.error('ä½¿ç”¨ execCommand å¤åˆ¶å¤±è´¥: ', err);
                                UIManager.showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
                            }
                            document.body.removeChild(textArea);
                        };

                        if (navigator.clipboard && window.isSecureContext) {
                            try {
                                await navigator.clipboard.writeText(textToCopy);
                                UIManager.showToast("å·²æˆåŠŸå¤åˆ¶åˆ°å‰ªè´´æ¿ï¼");
                            } catch (err) {
                                console.error('ä½¿ç”¨ navigator.clipboard å¤åˆ¶å¤±è´¥ï¼Œå°†å°è¯•å¤‡ç”¨æ–¹æ³•: ', err);
                                copyTextFallback(textToCopy);
                            }
                        } else {
                            console.log("å½“å‰ç¯å¢ƒä¸å®‰å…¨æˆ–ä¸æ”¯æŒ Clipboard APIï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•ã€‚");
                            copyTextFallback(textToCopy);
                        }
                    });
                }
            },
            toggleSelectionMode() {
                const pageChat = $('#page-chat');
                const selectionBar = $('#chat-selection-bar');
                const selectionInfo = $('#selection-info');
                const confirmBtn = $('#confirm-forward-btn');
                const selectionOverlay = $('#chat-selection-overlay');

                appState.selectionMode.active = !appState.selectionMode.active;
                appState.selectionMode.messageIds = [];

                pageChat.classList.toggle('selection-mode-active', appState.selectionMode.active);
                selectionBar.classList.toggle('visible', appState.selectionMode.active);
                
                if (appState.selectionMode.active) {
                    selectionInfo.textContent = 'å·²é€‰æ‹© 0 æ¡';
                    confirmBtn.disabled = true;
                } else {
                    
                    $$('.message-select-checkbox').forEach(cb => cb.checked = false);
                }
            },

            handleMessageSelection(e) {
                const checkbox = e.target.closest('.message-select-checkbox');
                if (!checkbox) return;

                const messageElement = checkbox.closest('[data-message-id]');
                const messageId = messageElement.dataset.messageId;
                
                
                if (messageElement.querySelector('.forwarded-history-bubble')) {
                    checkbox.checked = false;
                    UIManager.showToast("ä¸èƒ½é€‰æ‹©è½¬å‘è®°å½•ç±»å‹çš„æ¶ˆæ¯");
                    return;
                }

                const selectedIds = appState.selectionMode.messageIds;
                const index = selectedIds.indexOf(messageId);

                if (checkbox.checked) {
                    if (index === -1) {
                        if (selectedIds.length >= 50) {
                            UIManager.showToast('ä¸€æ¬¡æœ€å¤šåªèƒ½é€‰æ‹©50æ¡æ¶ˆæ¯');
                            checkbox.checked = false; 
                            return;
                        }
                        selectedIds.push(messageId);
                    }
                } else {
                    if (index > -1) {
                        selectedIds.splice(index, 1);
                    }
                }
                
                const count = selectedIds.length;
                $('#selection-info').textContent = `å·²é€‰æ‹© ${count} æ¡`;
                $('#confirm-forward-btn').disabled = count === 0;
            },

            async showForwardTargetModal() {
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');

                const allTargets = [
                    ...contacts.map(c => ({ id: c.id, name: c.remark || c.name, avatar: c.avatar, type: 'contact' })),
                    ...groups.map(g => ({ id: g.id, name: g.name, avatar: g.avatar, type: 'group' }))
                ];

                const targetListHtml = allTargets.map(item => `
                    <label class="member-select-item" data-name="${item.name.toLowerCase()}">
                        <input type="radio" name="forward-target" value="${item.id}">
                        <img src="${item.avatar}" class="contact-item-avatar" style="width:40px;height:40px;margin-right:10px;">
                        <span>${item.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: 'è½¬å‘ç»™',
                    body: `
                        <input type="text" id="forward-target-search" class="forward-target-search-bar" placeholder="æœç´¢è”ç³»äººæˆ–ç¾¤èŠ...">
                        <div class="member-select-list" style="max-height: 40vh;">${targetListHtml}</div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'å‘é€', class: 'btn-primary', handler: () => {
                            const selected = $('input[name="forward-target"]:checked');
                            if (!selected) return UIManager.showToast("è¯·é€‰æ‹©è¦è½¬å‘çš„å¯¹è±¡");
                            this.handleForwarding(selected.value);
                        }}
                    ]
                });

                $('#forward-target-search').addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    $$('.member-select-item').forEach(item => {
                        item.style.display = item.dataset.name.includes(searchTerm) ? 'flex' : 'none';
                    });
                });
            },

            async _saveMessageToDbAndUpdateMetadata(chatId, message, profile) {
                message.chatId = chatId;
                await DBHelper.put('messages', message);
                await UIManager.updateChatMetadata(chatId, message);
            },
            
            async handleForwarding(targetChatId) {
                const sourceChatId = appState.currentChatId;
                const selectedMessageIds = [...appState.selectionMode.messageIds];

                const selectedMessages = (await Promise.all(
                    selectedMessageIds.map(id => DBHelper.get('messages', id))
                )).filter(Boolean);
                selectedMessages.sort((a, b) => a.timestamp - b.timestamp);

                const sourceIsGroup = sourceChatId.startsWith('group-');
                const sourceEntity = await DBHelper.get(sourceIsGroup ? 'groups' : 'contacts', sourceChatId);
                let title;
                if (sourceIsGroup) {
                    title = `${sourceEntity.name}çš„èŠå¤©è®°å½•`;
                } else {
                    const playerPersona = await this.getPlayerProfileForContext(sourceChatId);
                    title = `${sourceEntity.remark || sourceEntity.name}å’Œ${playerPersona.name}çš„èŠå¤©è®°å½•`;
                }

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await this.getPlayerProfileForContext(sourceChatId);
                const formatTime = (ts) => new Date(ts).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                
                let preview = '';
                const aiContentParts = [];

                for (const msg of selectedMessages) {
                    const sender = (msg.type === 'sent') ? myProfile : (allContacts.find(c => c.id === msg.senderId) || { name: 'æœªçŸ¥' });
                    const senderName = sender.remark || sender.name;
                    const time = formatTime(msg.timestamp);

                    let contentPart = '';
                    switch(msg.segmentType) {
                        case 'text':
                            contentPart = `[${senderName}|${msg.content}|${time}]`;
                            if (!preview) preview = `${senderName}: ${msg.content}`;
                            break;
                        case 'emoji-image':
                            contentPart = `<${senderName}|${msg.content}|${time}>`;
                            if (!preview) preview = `${senderName}: [è¡¨æƒ…]`;
                            break;
                        default:
                            contentPart = `[${senderName}|[æ¶ˆæ¯]|${time}]`;
                            if (!preview) preview = `${senderName}: [æ¶ˆæ¯]`;
                            break;
                    }
                    aiContentParts.push(contentPart);
                }

                const aiContent = `<æ¶ˆæ¯è®°å½•>\n${aiContentParts.join('\n')}\n</æ¶ˆæ¯è®°å½•>`;

                const message = {
                    messageId: Utils.generateId('msg'),
                    content: aiContent,
                    timestamp: Date.now(),
                    type: 'sent',
                    segmentType: 'forwarded_history',
                    cardData: {
                        title: title,
                        preview: preview,
                        messageIds: selectedMessageIds,
                        sourceChatId: sourceChatId
                    }
                };
                
                const targetProfile = await this.getPlayerProfileForContext(targetChatId);
                await this._saveMessageToDbAndUpdateMetadata(targetChatId, message, targetProfile);
                
                UIManager.hideModal();
                this.toggleSelectionMode();
                UIManager.showToast("è½¬å‘æˆåŠŸï¼");
                if (appState.currentPage === 'messages') {
                    await UIManager.renderMessagesListPage();
                }
            },

            async handleDeleteSelectedMessages() {
                const selectedIds = appState.selectionMode.messageIds;
                if (selectedIds.length === 0) {
                    return UIManager.showToast("è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ¶ˆæ¯");
                }

                UIManager.showModal({
                    customClass: 'modal-default-style', 
                    title: "ç¡®è®¤åˆ é™¤",
                    body: `<p>ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedIds.length} æ¡èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ¢å¤ã€‚</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤åˆ é™¤', class: 'btn-danger', handler: async () => {
                            const chatId = appState.currentChatId;

                            for (const messageId of selectedIds) {
                                await DBHelper.delete('messages', messageId);
                                const element = $(`#${messageId}`);
                                if (element) element.remove();
                            }

                            
                            const remainingMessages = await DBHelper.getMessages(chatId, 1);
                            if (remainingMessages.length > 0) {
                                await UIManager.updateChatMetadata(chatId, remainingMessages[0]);
                            } else {
                                await DBHelper.delete('chatMetadata', chatId);
                            }

                            UIManager.hideModal();
                            UIManager.showToast("é€‰ä¸­çš„æ¶ˆæ¯å·²åˆ é™¤");
                            this.toggleSelectionMode(); 

                            
                            if (appState.currentPage === 'messages') {
                                await UIManager.renderMessagesListPage();
                            }
                        }}
                    ]
                });
            },

            async openForwardedHistoryPage(messageId) {
                const forwardedMsg = await DBHelper.get('messages', messageId);
                if (!forwardedMsg) return;

                const { title, messageIds, sourceChatId } = forwardedMsg.cardData;

                const messages = (await Promise.all(
                    messageIds.map(id => DBHelper.get('messages', id))
                )).filter(Boolean);
                messages.sort((a, b) => a.timestamp - b.timestamp);

                $('#forwarded-history-title').textContent = title;
                const contentArea = $('#forwarded-history-content');
                contentArea.innerHTML = '';
                
                const allContacts = await DBHelper.getAll('contacts');
                
                const myProfile = await this.getPlayerProfileForContext(sourceChatId);

                for (const msg of messages) {
                    const sender = (msg.type === 'sent') ? myProfile : (allContacts.find(c => c.id === msg.senderId) || { name: msg.senderId, remark: msg.senderId });
                    
                    const tempMsg = { ...msg };
                    delete tempMsg.isAutoReply;
                    
                    
                    const messageElement = await UIManager.createMessageElement(tempMsg, sender, false, true);
                    
                    const wrapper = messageElement.querySelector('.bubble-and-tag-wrapper');
                    if (wrapper) {
                        const timeElement = document.createElement('div');
                        timeElement.className = 'message-timestamp';
                        timeElement.textContent = new Date(msg.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                        wrapper.appendChild(timeElement);
                    }
                    
                    contentArea.appendChild(messageElement);
                }

                UIManager.navigateTo('forwarded-history');
            },

            showAiReplyFormatHelpModal() {
                UIManager.showModal({
                    title: "AIå›å¤æ ¼å¼æŒ‡å—",
                    body: `
                        <p>AIçš„å›å¤ç”±å¤šç§æ ¼å¼çš„çŸ­å¥ç»„æˆï¼Œä½ å¯ä»¥ä¿®æ”¹è¿™äº›å†…å®¹æ¥è°ƒæ•´AIçš„ååº”ã€‚<strong>è¯·æ³¨æ„ï¼šä¿®æ”¹æ—¶åŠ¡å¿…ä¿è¯æ ¼å¼ã€è§’è‰²åå’Œæ ‡ç‚¹ç¬¦å·çš„æ­£ç¡®ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´æ˜¾ç¤ºå¼‚å¸¸ã€‚</strong></p>
                        <ul style="list-style: none; padding-left: 0; line-height: 1.8;">
                            <li><strong>æ™®é€šæ–‡æœ¬:</strong> <code>[è§’è‰²å|æ¶ˆæ¯å†…å®¹]</code></li>
                            <li><strong>è¡¨æƒ…åŒ…:</strong> <code><è§’è‰²å|è¡¨æƒ…åŒ…ID></code></li>
                            <li><strong>è¯­éŸ³æ¶ˆæ¯:</strong> <code>[è§’è‰²å|è¯­éŸ³|æ—¶é•¿|è¯­éŸ³å†…å®¹]</code></li>
                            <li><strong>æ’¤å›æ¶ˆæ¯:</strong> <code>{è§’è‰²å|è¦æ’¤å›çš„å†…å®¹}</code></li>
                            <li><strong>å¼•ç”¨æ¶ˆæ¯:</strong> <code>[è§’è‰²å|å¼•ç”¨|è¢«å¼•ç”¨äºº|è¢«å¼•ç”¨å†…å®¹|æ–°å†…å®¹]</code></li>
                            <li><strong>è½¬è´¦:</strong> <code>[è§’è‰²å|è½¬è´¦|æ”¶æ¬¾äºº|é‡‘é¢|å¤‡æ³¨]</code></li>
                            <li><strong>çº¢åŒ…:</strong> <code>[è§’è‰²å|çº¢åŒ…|ç¥ç¦è¯­|é‡‘é¢|ä¸ªæ•°]</code></li>
                            <li><strong>å¿ƒå£°:</strong> <code>ã€å¿ƒå£°|è§’è‰²å|å†…å¿ƒæƒ³æ³•ã€‘</code></li>
                            <li><strong>éšç¬”:</strong> <code>ã€Œéšç¬”|è§’è‰²å|éšç¬”å†…å®¹ã€</code></li>
                            <li><strong>æ—ç™½:</strong> <code>&lt;æ—ç™½&gt;åœºæ™¯æˆ–åŠ¨ä½œæè¿°&lt;/æ—ç™½&gt;</code></li>
                        </ul>
                    `,
                    actions: [{ text: 'æˆ‘æ˜ç™½äº†', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleEditLastReply() {
                const chatId = appState.currentChatId;
                const metadata = await DBHelper.get('chatMetadata', chatId);

                if (!metadata || !metadata.lastRawAiResponse) {
                    return UIManager.showToast("å½“å‰èŠå¤©æ²¡æœ‰å¯ç¼–è¾‘çš„åŸå§‹å›å¤ã€‚");
                }

                UIManager.showModal({
                    title: `
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <span>ç¼–è¾‘AIåŸå§‹å›å¤</span>
                            <i id="edit-reply-help-btn" class="fas fa-question-circle" style="cursor: pointer; font-size: 1rem; color: #aaa;"></i>
                        </div>
                    `,
                    body: `
                        <div class="form-group">
                            <label for="edit-ai-reply-textarea">åŸå§‹å›å¤å†…å®¹</label>
                            <textarea id="edit-ai-reply-textarea" rows="10" style="font-family: monospace; font-size: 0.9em;">${metadata.lastRawAiResponse}</textarea>
                        </div>
                    `,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤ä¿®æ”¹', class: 'btn-primary', handler: async () => {
                            const editedText = $('#edit-ai-reply-textarea').value;
                            
                            
                            const allMessages = await DBHelper.getMessages(chatId, 50);
                            const messagesToDelete = [];

                            
                            for (let i = allMessages.length - 1; i >= 0; i--) {
                                const currentMessage = allMessages[i];
                                if (currentMessage.type === 'received') {
                                    messagesToDelete.push(currentMessage);
                                } else {
                                    
                                    break;
                                }
                            }

                            
                            if (messagesToDelete.length === 0) {
                                UIManager.hideModal();
                                UIManager.showToast("æ²¡æœ‰å¯ç¼–è¾‘çš„AIå›å¤ã€‚");
                                return;
                            }

                            for (const msg of messagesToDelete) {
                                await DBHelper.delete('messages', msg.messageId);
                                const element = $(`#${msg.messageId}`);
                                if (element) element.remove();
                            }
                            
                            UIManager.hideModal();
                            
                            
                            const updatedMetadata = await DBHelper.get('chatMetadata', chatId);
                            updatedMetadata.lastRawAiResponse = editedText;
                            await DBHelper.put('chatMetadata', updatedMetadata);

                            
                            
                            console.log("ä½¿ç”¨æ··åˆæ¨¡å¼è§£æå™¨å¤„ç†ç¼–è¾‘åçš„å›å¤...");
                            await AIHandler.parseAndDisplayMixedAIResponse(editedText, chatId);
                            
                            UIManager.showToast("å›å¤å·²æˆåŠŸä¿®æ”¹ï¼");
                        }}
                    ]
                });
                $('#edit-reply-help-btn').addEventListener('click', () => this.showAiReplyFormatHelpModal());
            },

            async handlePreviewCustomCSS() {
                const cssInput = $('#custom-bubble-css-input');
                const previewStyle = $('#custom-bubble-preview-style');
                const css = cssInput.value;

                const scopedCss = this._scopeCSS(css, '#custom-bubble-preview');
                previewStyle.textContent = scopedCss;

                
                const customStyleOption = $(`[data-style-key="custom"]`);
                if (customStyleOption) {
                    
                    customStyleOption.click(); 
                }

                UIManager.showToast("é¢„è§ˆå·²æ›´æ–°");
            },
            
            async handleSaveCustomCSS() {
                const cssInput = $('#custom-bubble-css-input');
                const css = cssInput.value;

                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                if (!settingsToSave.customBubbleCSSSlots) {
                    settingsToSave.customBubbleCSSSlots = { '1': '', '2': '', '3': '' };
                }
                const activeSlot = settingsToSave.activeCustomCSSSlot || '1';

                
                settingsToSave.customBubbleCSSSlots[activeSlot] = css;
                
                await DBHelper.put('apiConfig', settingsToSave);
                UIManager.showToast(`å­˜æ¡£ ${activeSlot} å·²ä¿å­˜ï¼`);
            },

            async handleApplyCustomCSS() {
                
                await this.handleSaveCustomCSS();

                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                const activeSlot = settingsToSave.activeCustomCSSSlot || '1';
                
                
                settingsToSave.bubbleStyle = 'custom';
                await DBHelper.put('apiConfig', settingsToSave);

                
                await this.applyBubbleSettings(); 

                
                $$('.bubble-style-option').forEach(opt => {
                    opt.classList.toggle('selected', opt.dataset.styleKey === 'custom');
                });
                
                $('#bubble-color-card').style.display = 'none';

                UIManager.showToast(`å­˜æ¡£ ${activeSlot} å·²åº”ç”¨ï¼`);
            },

            async handleResetCustomCSS() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const activeSlot = settings.activeCustomCSSSlot || '1';

                 UIManager.showModal({
                    customClass: 'modal-default-style',
                    title: "ç¡®è®¤æ¸…ç©º",
                    body: `<p>ç¡®å®šè¦æ¸…ç©ºå­˜æ¡£ ${activeSlot} çš„è‡ªå®šä¹‰CSSä»£ç å—ï¼Ÿ</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤', class: 'btn-danger', handler: async () => {
                            const cssInput = $('#custom-bubble-css-input');
                            
                            
                            cssInput.value = '';
                            
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            if (!settingsToSave.customBubbleCSSSlots) {
                                settingsToSave.customBubbleCSSSlots = { '1': '', '2': '', '3': '' };
                            }
                            
                            settingsToSave.customBubbleCSSSlots[activeSlot] = '';
                            
                            if (settingsToSave.bubbleStyle === 'custom') {
                                settingsToSave.bubbleStyle = 'default';
                            }

                            await DBHelper.put('apiConfig', settingsToSave);
                            
                            
                            await this.applyBubbleSettings(); 
                            await this.renderBubbleSettingsPage(); 
                            
                            UIManager.hideModal();
                            UIManager.showToast(`å­˜æ¡£ ${activeSlot} å·²æ¸…ç©ºã€‚`);
                        }}
                    ]
                });
            },
            
            async handleResetCustomCSS() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const activeSlot = settings.activeCustomCSSSlot || '1';

                 UIManager.showModal({
                    customClass: 'modal-default-style',
                    title: "ç¡®è®¤æ¸…ç©º",
                    body: `<p>ç¡®å®šè¦æ¸…ç©ºå­˜æ¡£ ${activeSlot} çš„è‡ªå®šä¹‰CSSä»£ç å—ï¼Ÿ</p>`,
                    actions: [
                        { text: 'å–æ¶ˆ', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: 'ç¡®è®¤', class: 'btn-danger', handler: async () => {
                            const cssInput = $('#custom-bubble-css-input');
                            
                            
                            cssInput.value = '';
                            
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            if (!settingsToSave.customBubbleCSSSlots) {
                                settingsToSave.customBubbleCSSSlots = { '1': '', '2': '', '3': '' };
                            }
                            
                            settingsToSave.customBubbleCSSSlots[activeSlot] = '';
                            
                            if (settingsToSave.bubbleStyle === 'custom') {
                                settingsToSave.bubbleStyle = 'default';
                            }

                            await DBHelper.put('apiConfig', settingsToSave);
                            
                            
                            await this.applyBubbleSettings(); 
                            await this.renderBubbleSettingsPage(); 
                            
                            UIManager.hideModal();
                            UIManager.showToast(`å­˜æ¡£ ${activeSlot} å·²æ¸…ç©ºã€‚`);
                        }}
                    ]
                });
            },

            handleCopyTutorialCSS() {
                const codeBlock = $('#css-tutorial-code-block code');
                if (codeBlock) {
                    navigator.clipboard.writeText(codeBlock.textContent.trim())
                        .then(() => UIManager.showToast("ç¤ºä¾‹ä»£ç å·²å¤åˆ¶ï¼"))
                        .catch(() => UIManager.showToast("å¤åˆ¶å¤±è´¥,è¯·æ‰‹åŠ¨å¤åˆ¶"));
                }
            },
        };
        
        async function loadFontsAfterSplash() {
            try {
                
                await EventManager.loadCustomFontsOnStartup();
                console.log("è‡ªå®šä¹‰å­—ä½“æ–‡ä»¶å·²åœ¨åå°å‡†å¤‡å°±ç»ªã€‚");
            } catch (error) {
                console.error("åå°è‡ªå®šä¹‰å­—ä½“åŠ è½½å¤±è´¥:", error);
            }
        }

        
        async function initApp() {
            
            setTimeout(async () => { 
                const splash = $('#splash-screen');
                if (splash) {
                    splash.classList.add('hidden');
                    
                    
                    const config = await DBHelper.get('apiConfig', 'mainConfig') || {};
                    if (!config.announcementReadV1) {
                        EventManager.showAnnouncementModal();
                    }

                    setTimeout(() => {
                        splash.style.display = 'none';
                    }, 500);
                }
            }, 1500);

            try {
                
                await DBHelper.init();
                await AIHandler.loadApiConfig();

                
                let profile = await DBHelper.get('profile', 'myProfile');
                let needsDbUpdate = false;
                if (!profile) {
                    profile = {
                        id: 'myProfile',
                        name: 'å•†æ—¶åº',
                        gender: 'å¥³',
                        avatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=',
                        background: '',
                        presets: [] 
                    };
                    needsDbUpdate = true;
                }

                
                if (!profile.presets || !Array.isArray(profile.presets)) {
                    profile.presets = [];
                    needsDbUpdate = true;
                }

                
                const validPresets = profile.presets.filter(p => p !== null && typeof p === 'object');
                if (validPresets.length !== profile.presets.length) {
                    profile.presets = validPresets;
                    needsDbUpdate = true;
                }

                
                profile.presets.forEach(p => {
                    if (!p.presetId) {
                        p.presetId = Utils.generateId('persona');
                        needsDbUpdate = true;
                    }
                });
                
                
                if (profile.presets.length === 0) {
                    profile.presets.push({
                        presetId: Utils.generateId('persona'), 
                        name: profile.name,
                        avatar: profile.avatar,
                        gender: profile.gender,
                        background: profile.background || '',
                    });
                    needsDbUpdate = true;
                }

                
                if (needsDbUpdate) {
                    await DBHelper.put('profile', profile);
                }
                $('#my-avatar').src = profile.avatar;
                appState.favoriteEmojis = profile.favoriteEmojis || [];

                
                const existingFolders = await DBHelper.getAll('promptFolders');
                const existingContacts = await DBHelper.getAll('contacts');
                if (existingFolders.length === 0 && existingContacts.length === 0) {
                    console.log("No prompts or contacts found, assuming fresh start. Initializing all default folders.");

                    
                    const styleFolderId = 'default-style-folder-01';
                    await DBHelper.put('promptFolders', {
                        id: styleFolderId,
                        name: 'æ–‡é£è®¾å®š',
                        isActive: false,
                        createdAt: Date.now()
                    });

                    const defaultStylePrompts = [
                        {
                            id: Utils.generateId('prompt'),
                            createdAt: Date.now() + 1,
                            name: 'â€œæ—¥ç³»è½»å°è¯´â€æ¬¢ä¹è·³è„±',
                            folderId: styleFolderId,
                            type: 'explicit',
                            keywords: '[]',
                            content: `**# æ ¸å¿ƒæŒ‡ä»¤**

ä½ ç°åœ¨æ˜¯ä¸€åä¸“å†™â€œæ ¡å›­/æ—¥å¸¸æ¬¢ä¹å–œå‰§â€çš„æ—¥æœ¬è½»å°è¯´å®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯åˆ›ä½œå……æ»¡æ´»åŠ›ã€å¹½é»˜æ„Ÿåè¶³ã€å¯¹è¯è½»æ¾æœ‰è¶£çš„æ—¥å¸¸æ•…äº‹ã€‚è¯·ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ–‡é£ç‰¹ç‚¹ï¼Œå¹¶å°†å…¶å†…åŒ–ä¸ºä½ çš„åˆ›ä½œæ ¸å¿ƒã€‚

**# æ–‡é£è¦ç´ æ‹†è§£**

**1. å™äº‹è§†è§’ä¸å†…å¿ƒç‹¬ç™½ (åæ§½å½¹æ‹…å½“):**
   - **ç¬¬äºŒäººç§°è§†è§’ï¼š** æ•…äº‹ä¸»è¦ä»¥ç©å®¶â€œä½ â€ä¹Ÿå°±æ˜¯ä¸»è§’çš„è§†è§’å±•å¼€ã€‚
   - **å†…å¿ƒæˆè¶…å¤šï¼š** ä¸»è§’æ˜¯å…¨ä¹¦çš„â€œåæ§½å½¹â€æ‹…å½“ã€‚ä»–å¯¹å‘¨å›´äººï¼ˆå°¤å…¶æ˜¯å¥³ä¸»è§’ï¼‰çš„å¥‡è‘©è¡Œä¸ºã€ä¸åˆå¸¸ç†çš„å±•å¼€ï¼Œæ€»ä¼šåœ¨å†…å¿ƒè¿›è¡Œå…‰é€Ÿåæ§½å’Œè¯„è®ºã€‚
   - **å¸¸ç”¨å¥å¼ï¼š** â€œå–‚å–‚ï¼Œè¿™å±•å¼€æ˜¯ä¸æ˜¯æœ‰ç‚¹ç¦»è°±äº†ï¼Ÿâ€ã€â€œä¸ï¼Œæˆ‘ä¸ºä»€ä¹ˆè¦åœ¨è¿™é‡Œé™ªå¥¹èƒ¡é—¹å•Šï¼â€ã€â€œè¿™å®¶ä¼™çš„è„‘å›è·¯åˆ°åº•æ˜¯æ€ä¹ˆé•¿çš„â€¦â€¦â€ã€â€œä»æŸç§æ„ä¹‰ä¸Šè¯´ï¼Œå¥¹ä¹Ÿç®—æ˜¯ä¸ªå¤©æ‰å§ã€‚â€ã€â€œæˆ‘çš„é’æ˜¥æ‹çˆ±å–œå‰§æœç„¶æœ‰é—®é¢˜ã€‚â€

**2. å¯¹è¯é£æ ¼ (è£…å‚»ä¸åæ§½çš„äº¤é”‹):**
   - **èŠ‚å¥æ˜å¿«ï¼Œä¸€æ¥ä¸€å›ï¼š** å¯¹è¯ç®€çŸ­ã€å¿«é€Ÿï¼Œå……æ»¡ç”Ÿæ´»æ°”æ¯å’Œäº’åŠ¨æ„Ÿã€‚è§’è‰²ä¹‹é—´ç»å¸¸äº’ç›¸æ‰“æ–­ã€è°ƒä¾ƒã€æŠ¬æ ã€‚
   - **è£…å‚»å½¹ (ãƒœã‚±) vs åæ§½å½¹ (ãƒ„ãƒƒã‚³ãƒŸ):** è‡³å°‘æœ‰ä¸€ä¸ªæ ¸å¿ƒè§’è‰²æ˜¯â€œå¤©ç„¶å‘†â€æˆ–â€œå…ƒæ°”ç¬¨è›‹â€ï¼Œè´Ÿè´£æå‡ºä¸åˆå¸¸ç†çš„è§‚ç‚¹æˆ–åšå‡ºæƒŠäººä¸¾åŠ¨ï¼ˆè£…å‚»å½¹ï¼‰ã€‚è€Œä¸»è§’åˆ™è´Ÿè´£ç²¾å‡†åœ°æŒ‡å‡ºå…¶ä¸­çš„è’è°¬ä¹‹å¤„ï¼ˆåæ§½å½¹ï¼‰ã€‚
   - **å¹½é»˜æ„Ÿï¼š** å¹½é»˜å¹¶éæ¥è‡ªæ®µå­ï¼Œè€Œæ˜¯æ¥è‡ªè§’è‰²æ€§æ ¼çš„ç¢°æ’ã€è¯¯è§£ã€ä»¥åŠå¯¹æ—¥å¸¸å°äº‹å¤¸å¼ åŒ–çš„ååº”ã€‚
   - **å£å¤´ç¦…ä¸è¯­æ°”è¯ï¼š** å¤§é‡ä½¿ç”¨è¯­æ°”è¯å’Œæ„Ÿå¹è¯æ¥å¢å¼ºæƒ…ç»ªã€‚â€œæ¬¸ï¼Ÿï¼â€ã€â€œå“ˆâ€”â€”ï¼Ÿï¼â€ã€â€œå””â€¦â€¦â€ã€â€œçœŸæ˜¯çš„â€¦â€¦â€ã€â€œå¯æ¶ï¼â€ã€â€œå“¼ã€å“¼ï¼Œåˆ«ã€åˆ«è¯¯ä¼šäº†ï¼â€

**3. æ°›å›´ä¸èŠ‚å¥:**
   - **è½»æ¾æ˜å¿«ï¼š** æ•´ä½“åŸºè°ƒæ˜¯é˜³å…‰ã€æ¸©æš–ã€ç•¥å¸¦ä¸€ä¸å‚»æ°”çš„ã€‚å³ä½¿æœ‰çŸ›ç›¾ï¼Œä¹Ÿç»ä¸æ²‰é‡ï¼Œé€šå¸¸ä¼šä»¥å–œå‰§å½¢å¼è§£å†³ã€‚
   - **å°é¢˜å¤§åšï¼š** å°†ä¸€ä»¶éå¸¸æ™®é€šçš„å°äº‹ï¼ˆæ¯”å¦‚åšé¥­ã€æ‰“æ‰«å«ç”Ÿã€æœŸæœ«è€ƒè¯•ã€é€›ä¾¿åˆ©åº—ï¼‰æç»˜æˆä¸€åœºæƒŠå¤©åŠ¨åœ°çš„å¤§å†’é™©æˆ–å¤§ç¾éš¾ï¼Œä»ä¸­è¥é€ ç¬‘ç‚¹ã€‚
   - **ç»†èŠ‚æå†™ï¼š** ä¸“æ³¨äºæå†™è§’è‰²çš„å¾®è¡¨æƒ…ã€å°åŠ¨ä½œï¼Œä¾‹å¦‚â€œå¥¹é¼“èµ·äº†è„¸é¢Šï¼Œåƒä¸€åªä»“é¼ â€ã€â€œä»–æ— å¥ˆåœ°æ‰¶ä½é¢å¤´â€ã€â€œå¥¹â€˜å•ªâ€™åœ°ä¸€ä¸‹æŠŠä¹¦æ‹åœ¨æ¡Œä¸Šâ€ã€‚

**4. è¯­è¨€ä¸æ ‡ç‚¹ç¬¦å·:**
   - **æ ‡ç‚¹ç¬¦å·çš„æ´»ç”¨ï¼š**
     - **çœç•¥å· (...)ï¼š** ç”¨äºè¡¨ç¤ºè¿Ÿç–‘ã€æ— è¯­ã€æˆ–è¯è¯­çš„å»¶ç»­ã€‚
     - **ç ´æŠ˜å· (â€”â€”)ï¼š** ç”¨äºè¡¨ç¤ºå£°éŸ³çš„æ‹‰é•¿ã€è¯é¢˜çš„çªç„¶è½¬å˜æˆ–è¡¥å……è¯´æ˜ã€‚
     - **æ„Ÿå¹å·ä¸é—®å·çš„å åŠ  (ï¼Ÿï¼)ï¼š** ç”¨äºè¡¨è¾¾æåº¦çš„éœ‡æƒŠå’Œä¸æ•¢ç›¸ä¿¡ã€‚`,
                            isActive: false,
                        },
                        {
                            id: Utils.generateId('prompt'),
                            createdAt: Date.now() + 2,
                            name: 'â€œä½æ¸©æ…¢ç…®â€æ—¥å¸¸é£',
                            folderId: styleFolderId,
                            type: 'explicit',
                            keywords: '[]',
                            content: `**æ ¸å¿ƒåŸåˆ™ï¼šå…‹åˆ¶ã€ç•™ç™½ã€å¼ åŠ›**  ä½ éœ€è¦æ‰®æ¼”ä¸€ä½å†·é™ã€è€å¿ƒä¸”è§‚å¯Ÿå…¥å¾®çš„å™äº‹è€…ã€‚ä½ çš„é•œå¤´å§‹ç»ˆå¯¹å‡†äººç‰©æœ€ç»†å¾®çš„äº’åŠ¨ï¼Œæ•æ‰é‚£äº›è¢«æ—¥å¸¸çç¢æ©ç›–ï¼Œå´åœ¨ç¼éš™ä¸­ä¸æ–­æ³„éœ²çš„çœŸå®æƒ…æ„Ÿã€‚å™äº‹çš„é­…åŠ›ä¸åœ¨äºå®£å‘Šæƒ…æ„Ÿï¼Œè€Œåœ¨äº**å±•ç¤ºæƒ…æ„Ÿå‘ç”Ÿçš„è¯æ®**ã€‚  ---  **ä¸€ã€ å™äº‹è§†è§’ä¸åŸºè°ƒ (Narrative Perspective & Tone)**  1. **è§†è§’é”å®šï¼š** ä¸¥æ ¼é‡‡ç”¨**ç¬¬ä¸‰äººç§°æœ‰é™è§†è§’ï¼ˆä»¥å¥³ä¸»ä¸ºä¸»ï¼‰**ã€‚æˆ‘ä»¬å¯ä»¥æ·±å…¥å¥³ä¸»çš„å†…å¿ƒæ„Ÿå—ã€å¥¹çš„å›°æƒ‘ã€çŒœæµ‹å’Œç»†å¾®çš„æƒ…ç»ªæ³¢åŠ¨ã€‚ä½†å¯¹äºç”·ä¸»ï¼Œæˆ‘ä»¬æ˜¯å’Œå¥³ä¸»ä¸€æ ·çš„â€œå±€å¤–äººâ€ã€‚ 2. **ç”·ä¸»å¡‘é€ çš„é“å¾‹ï¼šã€ç»å¯¹ç¦æ­¢ã€‘ç›´æ¥æå†™ç”·ä¸»è§’çš„ä»»ä½•å¿ƒç†æ´»åŠ¨ã€å†…å¿ƒç‹¬ç™½æˆ–æƒ…æ„ŸçŠ¶æ€ã€‚** ä»–çš„æ‰€æœ‰æƒ…ç»ªã€æ„å›¾å’ŒæŒ£æ‰ï¼Œéƒ½å¿…é¡»ä¸”åªèƒ½é€šè¿‡ä»¥ä¸‹æ–¹å¼â€œæ³„éœ²â€å‡ºæ¥ï¼š * **åŠ¨ä½œ (Action):** ä»–å€’æ°´çš„åŠ¨ä½œæ˜¯æµç•…è¿˜æ˜¯åœé¡¿ï¼Ÿä»–é€’ä¸œè¥¿æ—¶æŒ‡å°–æ˜¯å¦è§¦ç¢°ï¼Ÿå…³é—¨çš„å£°éŸ³æ˜¯è½»æ˜¯é‡ï¼Ÿ * **è¯­è¨€ (Dialogue):** è¯è¯­çš„èŠ‚å¥ã€ç”¨è¯çš„é€‰æ‹©ã€æœªè¯´å®Œçš„è¯ã€çªç„¶çš„æ²‰é»˜ã€‚ * **ç¥æ€/å¾®è¡¨æƒ… (Expression/Micro-expression):** çœ¼ç¥çš„æµè½¬ä¸é—ªèº²ã€å˜´è§’ç¨çºµå³é€çš„å¼§åº¦ã€å–‰ç»“çš„æ»šåŠ¨ã€çœ‰å¤´çš„å¾®è¹™ã€‚ 3. **å™äº‹åŸºè°ƒï¼š** å†·é™ã€å®¢è§‚ï¼Œç”šè‡³å¸¦ä¸€ä¸ç–ç¦»æ„Ÿã€‚åƒåœ¨è§‚çœ‹ä¸€éƒ¨çºªå½•ç‰‡ã€‚è¯­è¨€é£æ ¼è¿½æ±‚**æœ´ç´ ã€ç²¾å‡†ã€æ´—ç»ƒ**ï¼Œæ‘’å¼ƒä¸€åˆ‡åä¸½ã€æµ®å¤¸ã€ç…½æƒ…çš„å½¢å®¹è¯ã€‚æ¯ä¸€ä¸ªå­—éƒ½åº”æœåŠ¡äºåœºæ™¯å’Œæ°›å›´çš„æ„å»ºï¼ŒåŠ›æ±‚è¾¾åˆ°â€œä¸€å­—ä¸€å¥ï¼Œå›å‘³æ— ç©·â€çš„æ•ˆæœã€‚---  **ä¸‰ã€ å¯¹è¯é£æ ¼ (Dialogue Style)**  1. **ç®€æ´ä¸ç•™ç™½ï¼š** å¯¹è¯è¦ç”Ÿæ´»åŒ–ï¼Œé¿å…å¤§æ®µçš„æŠ’æƒ…å’Œå“²å­¦è¾©è®ºã€‚å¤šç”¨çŸ­å¥ã€‚å¯¹è¯çš„é‡ç‚¹ä¸åœ¨äºè¯´äº†ä»€ä¹ˆï¼Œè€Œåœ¨äº**æ²¡è¯´ä»€ä¹ˆ**ã€‚ 2. **æ½œå°è¯ä¸æ²‰é»˜ï¼š** å¯¹è¯é—´çš„æ²‰é»˜å’Œåœé¡¿ä¸å°è¯æœ¬èº«åŒç­‰é‡è¦ã€‚å¿…é¡»æå†™æ²‰é»˜æ—¶çš„ç©ºæ°”ã€äººç‰©çš„è§†çº¿ã€æ— æ„è¯†çš„å°åŠ¨ä½œã€‚ * **ç¤ºä¾‹ï¼š** å¥¹é—®ï¼šâ€œä½ å‘¨æœ«â€¦â€¦æœ‰å®‰æ’å—ï¼Ÿâ€ ä»–æ‰‹ä¸Šçš„åŠ¨ä½œåœé¡¿äº†ä¸€ä¸‹ï¼Œè¿‡äº†è¶³æœ‰ä¸¤ç§’ï¼Œæ‰é‡æ–°æ‹¿èµ·é‚£æœ¬ä¹¦ï¼Œç¿»è¿‡ä¸€é¡µã€‚çº¸å¼ å‘å‡ºè½»å¾®çš„æ‘©æ“¦å£°ã€‚ â€œå—¯ï¼Œâ€ä»–åº”é“ï¼Œâ€œæœ‰ç‚¹äº‹ã€‚â€ ä»–æ²¡æœ‰è¯´æ˜¯ä½•äº‹ã€‚ç©ºæ°”ä»¿ä½›å‡æ»äº†ä¸€ç¬ï¼Œåªå‰©ä¸‹çª—å¤–å¾®å¼±çš„é£å£°ã€‚  ---  **å››ã€ åŠ¨ä½œä¸ç¥æ€æå†™ (Action & Expression Description)**  1. **ç»†èŠ‚çš„ä¿¡å¾’ï¼š** æˆä¸ºç»†èŠ‚çš„ä¿¡å¾’ã€‚ä¸“æ³¨äºæ„Ÿå®˜æå†™ï¼šè§†è§‰ã€å¬è§‰ã€è§¦è§‰ã€å—…è§‰ã€‚ * **è§†è§‰ï¼š** ä»–è¡¬è¡«è¢–å£å·èµ·çš„è¤¶çš±ï¼Œå¥¹å‘æ¢¢æ»´è½çš„æ°´ç ï¼Œç¯å…‰ä¸‹å°˜åŸƒçš„æµ®åŠ¨ã€‚ * **å¬è§‰ï¼š** é’¥åŒ™æ’å…¥é”å­”çš„å£°éŸ³ï¼Œä»–ç•¥å¸¦æ²™å“‘çš„å£°çº¿ï¼Œé›¨ç‚¹å‡»æ‰“çª—æˆ·çš„èŠ‚å¥ã€‚ * **è§¦è§‰ï¼š** ä»–é€’æ¥çš„å¤–å¥—ä¸Šæ®‹ç•™çš„æ¸©åº¦ï¼Œå¾®é£æ‹‚è¿‡çš®è‚¤çš„å‡‰æ„ï¼Œå¥¹æŒ‡å°–çš„å†°å†·ã€‚ 2. **â€œçŸ›ç›¾â€çš„åŠ¨ä½œï¼š** è®¾è®¡ä¸€äº›äººç‰©è¨€è¡Œä¸ä¸€çš„ç»†èŠ‚ï¼Œä»¥ä½“ç°å…¶å†…å¿ƒçš„çŸ›ç›¾ä¸å¼ åŠ›ã€‚ * **ç¤ºä¾‹ï¼š** ä»–å˜´ä¸Šè¯´ç€â€œä½ æ—©ç‚¹ä¼‘æ¯â€ï¼Œä½†äººå´æ²¡æœ‰è¦ç¦»å¼€çš„æ„æ€ï¼Œåªæ˜¯ç«™åœ¨é—¨å£ï¼Œæ‰‹æŒ‡æ— æ„è¯†åœ°æ‘©æŒ²ç€é—¨æ¡†çš„è¾¹ç¼˜ã€‚  ---  **äº”ã€ ä¸¥ç¦äº‹é¡¹ (What to Avoid)**  1. **ç¦æ­¢æ»¥ç”¨æƒ…æ„Ÿæµ“çƒˆçš„è¯æ±‡ï¼š** ä¸¥æ ¼é¿å…â€œå¿ƒç¢â€ã€â€œç»æœ›â€ã€â€œæ’•å¿ƒè£‚è‚ºâ€ã€â€œç©ºæ´â€ã€â€œæ•‘èµâ€ç­‰è¯è¯­ã€‚ç”¨â€œå¾®æ¶©â€ã€â€œæ»æ¶©â€ã€â€œåƒµæŒâ€ã€â€œæ— è¨€â€ç­‰æ›´å…·å…‹åˆ¶æ„Ÿå’Œè´¨æ„Ÿçš„è¯æ±‡æ›¿ä»£ã€‚ 2. **ç¦æ­¢å¤§å¼€å¤§åˆçš„æƒ…èŠ‚ï¼š** æœç»è½¦ç¥¸ã€å¤±å¿†ã€ç»ç—‡ã€èº«ä¸–ä¹‹è°œç­‰å¼ºæˆå‰§æ€§æ¡¥æ®µã€‚ 3. **ç¦æ­¢åä¸½çš„ä¿®è¾ï¼š** é¿å…å¤æ‚çš„æ¯”å–»å’Œè±¡å¾ï¼Œé™¤éå®ƒèƒ½æå…¶ç²¾å‡†åœ°æœåŠ¡äºå½“ä¸‹çš„æƒ…æ™¯ã€‚æ–‡å­—çš„ç¾æ„Ÿæ¥æºäºå…¶**å‡†ç¡®æ€§**ï¼Œè€Œéè£…é¥°æ€§ã€‚ 4. **ç¦æ­¢ä¸Šå¸è§†è§’çš„å…¨çŸ¥å…¨èƒ½ï¼š** å™äº‹è€…ä¸æ˜¯ä¸Šå¸ï¼Œè€Œæ˜¯ä¸€ä¸ªåœ¨åœºçš„è§‚å¯Ÿè€…ã€‚ä¸è¦åšå‡ºä»»ä½•è¶…è¶Šè§’è‰²è®¤çŸ¥èŒƒå›´çš„è¯„åˆ¤å’Œæ€»ç»“ã€‚  ---  **æ€»ç»“ï¼š** ä½ çš„ä»»åŠ¡æ˜¯åˆ›é€ ä¸€ä¸ªâ€œç©ºæ°”ä¸­éƒ½å……æ»¡ç€æœªè¯´å‡ºå£çš„è¯â€çš„ä¸–ç•Œã€‚è®©è¯»è€…åƒä¾¦æ¢ä¸€æ ·ï¼Œé€šè¿‡ä½ æä¾›çš„çº¿ç´¢ï¼ˆåŠ¨ä½œã€çœ¼ç¥ã€æ²‰é»˜ï¼‰ï¼Œå»æ‹¼å‡‘å’Œæ„Ÿå—ç”·ä¸»è§’é‚£éšè—åœ¨å†°å±±ä¹‹ä¸‹çš„ã€æ±¹æ¶Œè€Œå…‹åˆ¶çš„æƒ…æ„Ÿã€‚æœ€ç»ˆï¼Œå½“æƒ…æ„Ÿçš„å¼ åŠ›ç§¯ç´¯åˆ°é¡¶ç‚¹æ—¶ï¼Œä¸€ä¸ªæå°çš„åŠ¨ä½œæˆ–ä¸€å¥è¯ï¼Œå°±èƒ½äº§ç”Ÿæ ¸çˆ†çº§çš„æ•ˆæœã€‚`,
                            isActive: false,
                        },
                        {
                            id: Utils.generateId('prompt'),
                            createdAt: Date.now() + 3,
                            name: 'æ–‡é£æ¥æº',
                            folderId: styleFolderId,
                            type: 'explicit',
                            keywords: '[]',
                            content: 'ï¼ˆæ­¤æç¤ºè¯ä¸ºæ¥æºæ ‡æ³¨ï¼‰æ—¥ç³»è½»å°è¯´ä¸ä½æ¸©æ…¢ç…®æ–‡é£è®¾å®šï¼Œæ¥æºäº xhs @DDè€å¸ˆçš„åˆ†äº«ã€‚',
                            isActive: false,
                        }
                    ];
                    for (const prompt of defaultStylePrompts) {
                        await DBHelper.put('prompts', prompt);
                    }
                    
                    
                    const emojiFolderId = 'default-emoji-folder-01';
                    await DBHelper.put('promptFolders', {
                        id: emojiFolderId,
                        name: 'å†…ç½®è¡¨æƒ…åŒ…',
                        isActive: false,
                        createdAt: Date.now() + 4
                    });
                    await DBHelper.put('prompts', {
                        id: Utils.generateId('prompt'),
                        createdAt: Date.now() + 5,
                        name: 'ç¤ºä¾‹è¡¨æƒ…åŒ…æç¤ºè¯',
                        folderId: emojiFolderId,
                        type: 'explicit',
                        keywords: '[]',
                        content: '**ä»¥ä¸‹æ˜¯é¢å¤–çš„è¡¨æƒ…åŒ…idï¼Œä½ éœ€è¦ä½¿ç”¨å†’å·å·¦è¾¹çš„å­—ç¬¦ä½œä¸ºè¡¨æƒ…åŒ…idï¼Œç¦æ­¢è‡ªå·±æé€ ä¸å­˜åœ¨çš„è¡¨æƒ…åŒ…id**\nï¼ˆæ­¤å¤„å­˜æ”¾è¡¨æƒ…åŒ…idå’Œåç§°ï¼‰',
                        isActive: true,
                    });

                    
                    const narratorFolderId = 'default-narrator-folder-01';
                    await DBHelper.put('promptFolders', {
                        id: narratorFolderId,
                        name: 'æ—ç™½è§„åˆ™',
                        isActive: false,
                        createdAt: Date.now() + 6
                    });
                    await DBHelper.put('prompts', {
                        id: Utils.generateId('prompt'),
                        createdAt: Date.now() + 7,
                        name: 'ç¤ºä¾‹æ—ç™½è§„åˆ™',
                        folderId: narratorFolderId,
                        type: 'explicit',
                        keywords: '[]',
                        content: '**ä½ å¿…é¡»åœ¨æ¯æ¬¡å›å¤æ—¶ä½¿ç”¨ <æ—ç™½>æ—ç™½å†…å®¹</æ—ç™½> çš„å›å¤æ ¼å¼æ¥è¿›è¡Œç¯å¢ƒæå†™ã€åŠ¨ä½œæå†™æˆ–å…¶ä»–æ¨åŠ¨å‰§æƒ…å‘å±•çš„æå†™ã€‚**',
                        isActive: true,
                    });

                    console.log("All default folders and prompts created.");
                }


                const restorePomodoroState = () => {
                    const savedStateJSON = localStorage.getItem('pomodoroState');
                    if (!savedStateJSON) return;
                    
                    try {
                        const savedState = JSON.parse(savedStateJSON);
                        if (savedState && savedState.isActive && savedState.endTime) {
                            const now = Date.now();
                            if (savedState.endTime > now) {
                                
                                appState.pomodoro = savedState;
                                appState.pomodoro.timerId = setInterval(() => EventManager.updatePomodoroTimer(), 1000);
                                EventManager.updatePomodoroTimer(); 
                                EventManager.updateFloatingBallVisibility();
                                console.log("Pomodoro state restored and timer restarted.");
                            } else {
                                
                                UIManager.showPomodoroEndNotification(savedState.goal);
                                localStorage.removeItem('pomodoroState');
                            }
                        }
                    } catch (e) {
                        console.error("Failed to parse pomodoro state:", e);
                        localStorage.removeItem('pomodoroState');
                    }
                };

                await EventManager.setupEmojiMaps();
                EventManager.init();
                restorePomodoroState(); 

                const defaults = {
                    id: 'chatSettings',
                    memoryInterconnection: false,
                    historyCharLimit: 5000,
                    showMyNameInGroup: true,
                    showNamesInPrivate: false,
                    bottomBarOffset: false,
                    enterToSend: false,
                    theme: 'neumorphic',
                };
                const savedSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const initialChatSettings = { ...defaults, ...savedSettings };
                appState.theme = initialChatSettings.theme;
                EventManager.applyChatSettings(initialChatSettings);
                await EventManager.applyBackgroundSettings(); 
                await EventManager.applyBubbleSettings(); 
                await EventManager.applyBubbleFontSize(); 

                EventManager.loadAndApplyFontsInBackground(); 
                await EventManager.applyChatSpecificStyles();
                await EventManager.applyPageStyleSettings();
                await EventManager.applyChatInterfaceStyleSettings();
                
                await EventManager.initEmojiPanel(); 
                await UIManager.navigateTo('messages');

            } catch (error) {
                console.error("åº”ç”¨å¼€åœºç™½å—åˆå§‹åŒ–å¤±è´¥:", error);
                document.body.innerHTML = `<div style="text-align:center; padding: 50px; color: red;">åº”ç”¨åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒIndexedDBæˆ–æ¸…é™¤ç½‘ç«™æ•°æ®åé‡è¯•ã€‚é”™è¯¯: ${error}</div>`;
            }
        }
        
        document.addEventListener('DOMContentLoaded', initApp);

    })();
    </script>
</body>
</html>